---
layout: post
title: C程序编程四步走
categories:
  - TECHNOLOGY
tags:
  - C
  - GCC
  - Compile
  - Assemble
  - Link
comments: true
date: 2017-03-21 10:02:16
permalink: compile-gcc
---

任何一个C程序代码到生成一个可执行文件都需要四步，分别是预处理`Pre-processing`，编译`Compiling`，汇编`Assembling`和链接`Link`，这里借助Gcc工具来探究这四步分别做了什么事，起到什么样的作用。本文使用的测试代码是经典入门程序"Hello World!"。
<!-- more -->

## 测试环境
为探究预处理，编译，汇编和链接的功能，我们在Ubuntu系统中使用Gcc编译器(version=4.8.4)，用简单的也是最经典的入门程序"Hello World!"作为测试代码。源文件{% asset_link hello.c hello.c %}代码如下：
```c
// filename: hello.c
# include <stdio.h>

int man(void){
  printf("Hello World!");
  return 0;
}
```
正常情况我们都会执行命令`gcc hello.c -o hello.out`来生成二进制可执行程序hello.out。

## [预处理][pre-processing]
C预处理器是用在编译器处理程序之前，它预扫描源代码完成包含头文件，宏扩展，条件编译，行控制等功能。对于测试代码中，预处理器只对头文件进行了处理。获取预处理器输出的结果使用该命令`gcc -E hello.c -o hello.i`。
由于{% asset_link hello.i hello.i %}文件内容比较多，这里截取部分进行说明。
```c
// filename: hello.i
# 1 "hello.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "hello.c"

...
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef long unsigned int size_t;

...
# 5 "hello.c" 2

int main(){
    printf("Hello World!");
    return 0;
}
```
> **Tips:**
> hello.i中有很多这样的格式`# line filename flags`，它表示下面行是由文件filename的第line行生成的。其中flags有1，2，3，4四种取值
> * 1 代表新文件的开始
> * 2 代表返回一个文件
> * 3 代表下面的文本来自系统头文件，所以某些警告可以过滤掉
> * 4 代表下面的文本应该包含在extern C块中
按照提示stddef.h文件中第212行有size_t的宏定义。

## [编译][compile]
编译的过程是将某种编程语言写的源代码（这里特指C语言）转换成另一种编程语言（这里特指汇编语言）。前面我们将{% asset_link hello.c hello.c %}预处理成了{% asset_link hello.i hello.i %}文件，现在就要将{% asset_link hello.i hello.i %}文件编译成{% asset_link hello.s hello.s %}汇编文件。获取编译器输出的结果使用命令`gcc -S hello.i -o hello.s`。汇编结果见{% asset_link hello.s hello.s%}。
```c
	.file	"hello.c"
	.section	.rodata
.LC0:
	.string	"Hello World!"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$.LC0, %edi
	movl	$0, %eax
	call	printf
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4"
	.section	.note.GNU-stack,"",@progbits
```

## [汇编][assemble]
汇编的过程是将汇编语言编写的源码转换成可执行的机器代码，通常目标文件中包含至少两个段：代码段和数据段。其中代码段包含程序的指令，一般可读和可执行，不可写；数据段用来存放程序中所用到的各种全局变量或静态数据，一般可读，可写，可执行。获取汇编器输出的结果使用该命令`gcc -S hello.s -o hello.o`，由于{% asset_link hello.o hello.o%}是二进制文件，是无法阅读的。这里我们通过命令`objdump`来对二进制文件进行反汇编，查看里面内容。
```c
// objdump -d hello.o 查看hello.o中代码段信息
hello.o：     文件格式 elf64-x86-64

Disassembly of section .text:

0000000000000000 <main>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	bf 00 00 00 00       	mov    $0x0,%edi
   9:	b8 00 00 00 00       	mov    $0x0,%eax
   e:	e8 00 00 00 00       	callq  13 <main+0x13>
  13:	b8 00 00 00 00       	mov    $0x0,%eax
  18:	5d                   	pop    %rbp
  19:	c3                   	retq
```
hello.o中各段信息如下：
```c
// objdump -h hello.o 显示hello.o中各个段的头部信息
hello.o：     文件格式 elf64-x86-64

节：
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000001a  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  0000005a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  0000005a  2**0
                  ALLOC
  3 .rodata       0000000d  0000000000000000  0000000000000000  0000005a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .comment      0000002c  0000000000000000  0000000000000000  00000067  2**0
                  CONTENTS, READONLY
  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000093  2**0
                  CONTENTS, READONLY
  6 .eh_frame     00000038  0000000000000000  0000000000000000  00000098  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
```

## [链接][linker]
链接的过程是将一个或多个由编译器或汇编器生成的目标文件链接库（静态库或动态库）形成可执行文件。其中静态库会和汇编生成的目标文件一起链接打包到可执行文件中【静态链接】，它对函数库的链接是放在编译时期完成的。而动态库在程序编译时不会被链接到可执行文件中，而是在程序运行时才会被载入【动态链接】。不同的应用程序如果调用相同的库，那么在内存中只需要一份该共享库实例。获取链接器链接后的可执行文件使用命令`gcc hello.o -o hello`。如果想看该可执行文件依赖的库，可以使用命令`ldd hello`。
```bash
# ldd hello 显示hello依赖的库
	linux-vdso.so.1 =>  (0x00007ffc85980000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f06c7a53000)
	/lib64/ld-linux-x86-64.so.2 (0x000055ad7be9e000)
```


## 参考文献
1. [预处理][pre-processing]
2. [预处理-行号标记][linemarker]
3. [编译器][compile]
4. [汇编][assemble]
5. [链接器][linker]

[pre-processing]: https://zh.wikipedia.org/wiki/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8
[linemarker]: https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html
[compiler]: https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8
[assemble]: https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80
[linker]: https://zh.wikipedia.org/wiki/%E9%93%BE%E6%8E%A5%E5%99%A8
