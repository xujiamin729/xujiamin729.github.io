---
layout:	post
title:	ACM算法之Trie树
categories:
- TECHNOLOGY
tags:
- ACM
- Algorithm
permalink:  Solve-trie-ACM
comments:   true
---
Trie树是一种用于快速检索的多叉树结构,经常用于统计和排序大量的字符串（但又不限于字符串），所以经常被搜索引擎系统用于文本词频统计。本文首先介绍Trie树的定义、原理及具体实现，然后结合hihocoder上的题目做一些具体实践。
<!-- more -->


## 定义和原理
[Trie树](http://baike.baidu.com/link?url=ZbVlpuiiV_AoQ96VDfabEG1M_VazTv8HR164QVbQRWmbsXwOwORvSkUfmqAjc3SOVebmK11nUdmIPQRNKq1nuevV1Mvh_EQPGaYn6GqtqT3p6n1hOc0zpXqxV9QKBL09tPeNQm1izNCWvDW3E6cNea)又称字典树，单词查找树，是一种树形结构，是一种哈系树的变种，也是一种用于快速检索的多叉树结构。它有三个基本特征：  

* 根节点不包含字符，除根节点外每个节点都只包含一个字符  
* 从根节点到某个节点，路径上经过的字符连起来就是对应的字符串  
* 每个节点的所有字节点所包含的字符都不相同  

除此之外，Trie树一般包含两个基本操作：

* `InsertTrie`	将字符串记录到Trie树中，顺便统计词频  
* `SearchTrie`	查询Trie树中公共字符串出现的次数   

此外还有个基本方法，`CreateNode`，用于建立Trie树的节点并初始化。有了这些方法，Trie树就可以构建成功。

对于文本词频的统计，也可以对相同长度的词生成hash表，不过此时查找的复杂度要达到$O(n)$，n为词的数目。而Trie树在性能上高于哈希表，其插入和查询的复杂度是$O(N)$，N为词的长度。不过Trie树的内存消耗非常大，达到$26^N$级别（用左儿子右兄弟的方法建树可能会好点），这就是==空间换时间==的思想，换句话说是利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。


## 代码实现
* Trie树节点定义

	```c
	#define MAX 26
	typedef struct Node{
		int count;
		struct Node *next[MAX];
	}TrieNode;
	```
	这里的宏定义MAX代表26个字母表。
* Trie树节点初始化`CreateNode`

	```c
	// 创建新节点
	TrieNode* CreateNode(){
		int i=0;
		TrieNode *p = (TrieNode*)malloc(sizeof(TrieNode));
		p->count=1;
		for(i=0; i<MAX; i++){
			p->next[i]=NULL;
		}
		return p;
	}
	```
	`CreateNode`是Trie树节点的创建初始化函数，并返回节点指针。
* Trie树插入操作[==O(N)==]

	```c
	// 插入字典树
	void InsertTrie(TrieNode** pRoot, char *s){
		TrieNode *p = NULL;
		// 基本不太可能出现*pRoot为NULL，因为Trie树根节点一定存在
		if (*pRoot == NULL){
			*pRoot = CreateNode();
		}
		p = *pRoot;
		int i=0,index;
		while(s[i] != '\0'){
			index = s[i++] - 'a';
			if(p->next[index] == NULL){
				// 新路径要创建新节点
				p->next[index] = CreateNode();
			}else{
				// 旧路径需要统计次数
				p->next[index]->count++;
			}
			p = p->next[index];
		}
	}
	```

* Trie树的查询操作[==O(N)==]

	```c
	// 查找字典树
	int SearchTrie(TrieNode** pRoot, char *s){
		TrieNode *p = NULL;
		// 基本不太可能出现的情况
		if(*pRoot == NULL){
			return 0;
		}
		p = *pRoot;
		int i=0,index;
		while(s[i] != '\0'){
			index = s[i++] - 'a';
			// 未知字符说明不存在
			if (p->next[index] == NULL){
				return 0;
			}else{
				p = p->next[index];
			}
		}
		return p->count;
	}
	```

## 解题报告
* HihoCoder
	1. 第二周：[Trie树](http://hihocoder.com/problemset/problem/1014)	|	[源码]({{ site.baseurl }}/assets/attachs/hiho_1014.c.txt)

		注意点：
		1. Trie树的根节点不包含字符，不能为空的。插入和搜索操作中的判别是为了代码的健壮性。
