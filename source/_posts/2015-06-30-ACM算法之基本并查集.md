---
layout:	post
title:	ACM算法之基本并查集
categories:
- TECHNOLOGY
tags:
- ACM
- Algorithm
permalink:  Explore-unionFind
comments:   true
---
并查集是一种用途广泛的数据结构，能够快速地处理集合的合并和查询问题，并且实现起来非常方便，在很多场合中都有着非常巧妙的应用。本文首先介绍并查集的定义、原理及具体实现，然后结合hihocoder以及poj上的题目做一些具体实践。
<!-- more -->

## 定义和原理
[并查集](https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86)(Union-Find Set)是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个操作用于此数据结构：

* `Find`			确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。  
* `Union`	将两个子集合并成同一个集合。  

因为它支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，`MakeSet`，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。


网络上有两篇帮助理解的博文，博主用通俗易懂的语言，图文并茂的方式将并查集生动形象得阐释了。特附上博文链接：   

* [通俗易懂的诠释并查集](http://www.cnblogs.com/ACShiryu/archive/2011/11/24/unionset.html)
* [图文并茂的解释并查集](http://www.cnblogs.com/cyjb/p/UnionFindSets.html)


## 代码实现
* 并查集的数据存储[==O(n)==]

	```c
	#define LENMAX 1000000
	int father[LENMAX]
	```
	虽然并查集是树型的数据结构，但是实际的存储是用数组，就跟堆排序一样。
* 并查集的初始化`MakeSet`

	```c
	void MakeSet(){
		int i;
		for(i=0;i<LENMAX;i++){
			father[i]=i;
		}
	}
	```
	`MakeSet`是并查集的初始化函数，这里采用`father[i]==i`来判定该i是否是某个集合的代表。
* 并查集的查找操作[==O(alpha(n)) alpha(n)<n==]

	```c
	// 查找操作--未压缩路径
	int Find(int x){
		if(x==father[x])
		  return x;
		else
		  return Find(father[x]);
	}
	```

	```c
	// 查找操作--压缩路径
	int Find(int x){
		if(x==father[x])
		  return x;
		else{
			father[x]=Find(father[x]);
			return father[x];
		}
	}
	```
	压缩路径可以避免重复查找，其实际的意义是将树的深度由n变成1。就是将层层的等级制度变成全部向皇帝/代表负责。
* 并查集的合并操作[==O(alpha(n))  alpha(n)<n==]

	```c
	// 合并操作
	void Union(int x, int y){
		int fatherX = Find(x);
		int fatherY = Find(y);

		// fatherY归fatherX管了
		if(fatherX!=fatherY)
		  father[fatherY]=fatherX;

		/*
		// 合并的时候取小的数值
		if(fatherX<fatherY)
			father[fatherY]=fatherX;
		else
			father[fatherX]=fatherY;
		*/
	}
	```

## 解题报告
* HihoCoder
	1. 第十四周：[无间道之并查集](http://hihocoder.com/contest/hiho14/problem/1)	|	[源码]({{ site.baseurl }}/assets/attachs/hiho_14_main.cpp.txt)

		注意点：
		1. 通过map将名称转化为int标号
		2. 最后一步判定两个名称是否是同一个集合时用`Find(mapName[nameX])==Find(mapName[nameY])`,不能用`father[mapName[nameX]]==father[mapName[nameY]]`。

* POJ
	1. 1611: [The Suspects](http://poj.org/problem?id=1611)	|	[源码]({{ site.baseurl }}/assets/attachs/poj_1611_main.cpp.txt)

		注意点:
		1.  判定i是否和0同一类必须得通过`Find`找到最高的根节点是相同[代码实现可以添加`rank[LENMAX]`来记录同集合的元素个数]
	2. 2524: [Ubiquitous Religions](http://poj.org/problem?id=2524)	|	[源码]({{ site.baseurl }}/assets/attachs/poj_2524_main.cpp.txt)

		注意点：
		1. 通过`i=father[i]`判断是否是根节点,也就是说是否是一个集合
