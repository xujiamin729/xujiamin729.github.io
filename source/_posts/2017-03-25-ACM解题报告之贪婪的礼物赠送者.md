---
layout: post
title: ACM解题报告之贪婪的礼物赠送者
categories:
  - TECHNOLOGY
tags:
  - ACM
  - USACO
  - Report
comments: true
date: 2017-03-25 11:30:33
permalink: greedy-gift-givers
---
本题属于杂项题，而解题的思路在于存储数据以及排序。本题使用了结构体来存储数据，并使用了快排排序算法和二叉排序树两种方法来解决排序的问题。这两种方法使得空间复杂度为$O(n)$，时间复杂度为$O(nlogn)$。
<!-- more -->

## 题目
题目来自USACO的[Greedy Gift Givers][GreedyGiftGivers]，具体的英文说明见{% asset_link gift1.md.txt 附件%}，这里作一下简单的说明，就是有NP个人准备了一些钱来送礼物，他们会尽可能平方这些钱给收礼者。这些钱不会被分割为小数，而多出来的钱将会留在送礼者身上。第一行输入人数NP，下面NP行输入每个人的名字，接下来是NP组送礼的表示，第一行表示送礼人的名字，第二行表示送的金钱和送的人数n，后面是n个接受礼物的名字。

## 思路
本题要解决两个问题，一个是数据存储，一个是送礼过程中如何快速定位到送礼人和收礼人。
1. 数据存储
这里要存储的数据其实就是人名`char array`和礼物数`int`。这里考虑到后面定位查找，所以采用结构体`struct Person`来存储数据。
```c
typedef strut Person{
  char name[16];
  int gifts;
}Person;
```

2. 查找定位
就现有的知识已知，查找最快的方法是随机存取和哈希算法，这两种方法的时间复杂度为$O(1)$，但本题因为要根据名称来查找定位，所以没有考虑这两种可能，再往上的时间复杂度是$O(logn)$，常见的方法有二分查找或二叉树查找。其中二分查找针对的对象是排序的数组，二叉树查找针对的对象是二叉排序树。下面就用上面两种方法来实现该问题。


## 算法说明
### 排序+二分查找
这里排序查找的对象是结构体数组，由于排序的依据有名称和次序两个变量，所以思路里的结构体要添加order变量。
```c
typedef struct Person{
  char name[16];
  int order;
  int gifts;
}Person;
```

对于排序算法和查找算法，我这里选择快速排序和二分查找算法，并且在c的stdlib库中有已经实现的qsort和bsearch方法来调用，不过需要我们实现比较函数来告诉这两个函数如何排列这些结构体。这里关于快速排序算法请参考{% post_link Explore-quickSort ACM排序算法之快排 %}，而关于二分查找算法请参考{% post_link ACM算法之二分查找法 ACM算法之二分查找法 %}。
这里附上以名称name为依据的升序比较函数：
```c
#include<string.h>
// @brief   按名称进行比较
// @param   a   Person结构体
//          b   Person结构体
// @return  strcmp(a.name, b.name)
int CompByName(const void *a, const void *b){
  return strcmp(((Person *)a)->name, ((Person *)b)->name);
}
```
附：{% asset_link gift1_sort.c gift1_sort.c完整代码 %}

### 二叉排序树
对于二叉树结构的节点必须得有两个子节点，所以结构体需要作一下修改：
```c
typedef struct Node{
  char name[16];
  int gifts;
  struct Person *left;
  struct Person *right;
}tNode;
```

对于二叉排序树的构建和查找，这里要分别实现，构建的过程就是一次插入节点的过程。而这个过程就需要按照左节点名称小于等于父节点名称小于等于右节点名称，所以我构建了一个递归插入函数，它输入当前树的根节点和要插入的新节点名称，并返回新节点插入后二叉树的根节点。至于二叉排序树的查找就通过递归纵向查找是否有该新节点。

* 节点插入代码：
```c
// @brief   向二叉排序树插入节点
// @param   root  二叉排序树的根节点指针
//          str   插入的新节点名称
// @return  二叉排序树的根节点
tNode *InsertOrderTree(tNode *root, char *str){
  int condi;

  if(root == NULL){
    // str为新节点
    tNode *Node = (tNode *)malloc(sizeof(tNode));
    if(Node == NULL)
      // 无法申请节点空间，直接返回NULL
      return NULL;
    strcpy(Node->name, str);
    Node->gifts = 0;
    Node->left = NULL;
    Node->right = NULL;
    root = Node;
  }else if((con
  return root;
}
```

* 查找二叉排序树节点
```c
// @brief   在二叉排序树中查找节点名为str的节点
// @param   root  二叉排序树的根节点指针
//          str   查找新节点的名称
// @return  查找到的节点指针或NULL
tNode *FindOrderTree(tNode *root, char *str){
  int condi;

  if(root == NULL){
    return NULL;
  }else if((condi = strcmp(str, root->name)) == 0){
    // 该节点已经找到
    return root;
  }else if(condi < 0){
    return FindOrderTree(root->left, str);
  }else{
    return FindOrderTree(root->right, str);
  }
}

````

附：{% asset_link gift1_tree.c gift1_tree.c完整代码 %}

## 参考文献
1. [Greedy Gift Givers][GreedyGiftGivers]

[GreedyGiftGivers]: http://train.usaco.org/usacoprob2?a=F3aC6EQx1tA&S=gift1
