{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/static/code/hello.c","path":"static/code/hello.c","modified":0,"renderable":0},{"_id":"themes/hjy/source/css/docs.min.css","path":"css/docs.min.css","modified":0,"renderable":1},{"_id":"themes/hjy/source/img/CSDN.png","path":"img/CSDN.png","modified":0,"renderable":1},{"_id":"themes/hjy/source/img/博客园.png","path":"img/博客园.png","modified":0,"renderable":1},{"_id":"themes/hjy/source/img/网易云音乐.png","path":"img/网易云音乐.png","modified":0,"renderable":1},{"_id":"themes/hjy/source/img/old.png","path":"img/old.png","modified":0,"renderable":1},{"_id":"themes/hjy/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/hjy/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/hjy/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/hjy/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/hjy/source/js/jquery.bootstrap-autohidingnavbar.js","path":"js/jquery.bootstrap-autohidingnavbar.js","modified":0,"renderable":1},{"_id":"themes/hjy/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/hjy/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/hjy/source/img/identity.jpg","path":"img/identity.jpg","modified":0,"renderable":1},{"_id":"themes/hjy/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/hjy/source/css/hjy-bootstrap.css","path":"css/hjy-bootstrap.css","modified":0,"renderable":1},{"_id":"themes/hjy/source/img/avatar2.png","path":"img/avatar2.png","modified":0,"renderable":1},{"_id":"themes/hjy/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hjy/README.md","hash":"82ed960c6af829973f22821d886b04ac19c0efff","modified":1496671554000},{"_id":"themes/hjy/.gitignore","hash":"9009bd7826c1dd5d0d3a236313e14a267d8a444f","modified":1496671554000},{"_id":"themes/hjy/_config.yml","hash":"c2e47893453ea0c92d8766babc7811c1df4da47f","modified":1496671554000},{"_id":"source/_drafts/.2017-03-21-C程序的内存管理.md.swp","hash":"67fab703105b3febf31d712f87a7586d2e016f7d","modified":1496672548000},{"_id":"source/_drafts/2013-06-19-以Gimp为手K天P地之模糊滤镜.md","hash":"7a7f8931146e6573551c6c024d8a4991cfc91ead","modified":1496672548000},{"_id":"source/_drafts/2015-06-13-自定义博客主题.md","hash":"b50e86a88e5aba797dc1fad60fe7863876c5906f","modified":1496672548000},{"_id":"source/_drafts/2015-08-01-宿营黄山.md","hash":"d48cc1810f1ea8fb6676c30b0a4d1685678f01bc","modified":1496672548000},{"_id":"source/_drafts/2017-03-21-C程序的内存管理.md","hash":"a81dc5735c83c0c8f3bd3f3a35ef86e222ef0167","modified":1496672548000},{"_id":"source/_drafts/2015-11-28-VIM配置之终结篇.md","hash":"5bd62706913d18fe8719e6ddc547efcb0cb32216","modified":1496672548000},{"_id":"source/_drafts/2015-11-22-程序中的存储区.md","hash":"074f831bbe0dcc1bfcff90008cd6cca9da6cfa5a","modified":1496672548000},{"_id":"source/_posts/2013-06-18-以Gimp为手K天P地之简介.md","hash":"a1bf91f3adfd49113c3748a491ade768e1581d94","modified":1496672548000},{"_id":"source/_posts/2013-07-20-ubuntu制作usb启动盘.md","hash":"1f0e29996be7137866e0ca6f871ee50419ef9993","modified":1496672548000},{"_id":"source/_posts/.2017-04-14-高效排序之交换.md.swp","hash":"929ad206dee0e651a2e9c9c32f5e7ed0d8ebc4e1","modified":1496672548000},{"_id":"source/_drafts/2017-03-21-C程序编程四步走.md","hash":"3a484bdd6445a64a01587cc908ba59cd05bbc8fa","modified":1496672548000},{"_id":"source/_posts/2013-09-10-简单批处理之常用命令.md","hash":"fe93e84b2827f1123293c27889e809f5d7196f90","modified":1496672548000},{"_id":"source/_posts/2013-09-08-简单批处理之内部命令.md","hash":"820711228360d96669fb1d95363ef27ab02332d5","modified":1496672548000},{"_id":"source/_posts/2013-09-09-简单批处理之符号简介.md","hash":"642e048f0ba642b56b9545ad4f2e9d18a7910d57","modified":1496672548000},{"_id":"source/_posts/2013-09-11-简单批处理之语法结构.md","hash":"2edca23867c1139c1cee22fb5d0da6f9e4c0ba2b","modified":1496672548000},{"_id":"source/_posts/2013-09-12-简单批处理之字符串处理.md","hash":"1414690939fe2611ffa505950203b4413d752e69","modified":1496672548000},{"_id":"source/_posts/2013-09-15-简单批处理之实用脚本片段.md","hash":"895feb808b8c5d9a4058947a772b6ec32d62f546","modified":1496672548000},{"_id":"source/_posts/2013-09-14-简单批处理之众里find它一次度.md","hash":"328c98f1a629d9eaf0c59a8ada9018c8feba8cfd","modified":1496672548000},{"_id":"source/_posts/2013-09-13-简单批处理之一切尽在at中.md","hash":"86e6cd844b2fd4ff93ba3ecbd4bd4fb69caa73d5","modified":1496672548000},{"_id":"source/_posts/2014-02-26-shell编程之基本内容.md","hash":"d397d3edbad47f21da9c7ee354e98bd0a137db4d","modified":1496672548000},{"_id":"source/_posts/2014-02-28-shell编程之常用命令.md","hash":"0aac0943d358bc0115a7ea28c91ea739625225b4","modified":1496672548000},{"_id":"source/_posts/2014-02-27-shell编程之语法结构.md","hash":"11b6e75598c548e55ddf69d022a7b2b99b53c077","modified":1496672548000},{"_id":"source/_posts/2014-02-29-shell编程之实用脚本片段.md","hash":"e464006274b4347755d2cad1c90cfd619933d01f","modified":1496672548000},{"_id":"source/_posts/2014-03-05-ACM编程技巧之代码片段.md","hash":"18f3da2e3275cd25ab47218173d0e8e63daa4c32","modified":1496672548000},{"_id":"source/_posts/2014-03-07-ACM编程技巧之常用字符操作函数.md","hash":"10d6710fd9a5103f9310fa3467fca594c49c070d","modified":1496672548000},{"_id":"source/_posts/2014-12-04-python基础篇之基本概念.md","hash":"308b77f521a9c4bbb18caabb6caed00d14600956","modified":1496672548000},{"_id":"source/_posts/2014-12-03-python基础篇之介绍.md","hash":"62fde2b5ed18f627dd949e75b8b48641e31ddb7e","modified":1496672548000},{"_id":"source/_posts/2014-12-07-python基础篇之元组和字典.md","hash":"c186627bd3ef6c5096481a15086a5929e726bdc8","modified":1496672548000},{"_id":"source/_posts/2014-12-08-python基础篇之基本语法.md","hash":"86b909c3f3aa25df926408e055a04b851f76cb11","modified":1496672548000},{"_id":"source/_posts/2014-12-05-python基础篇之字符串.md","hash":"85774553d9bb48ede8ba2dc5a2e991391bb65d91","modified":1496672548000},{"_id":"source/_posts/2014-12-06-python基础篇之链表.md","hash":"7a8b25b2b8d3fcf8314196aad2da33e3d4bcb09e","modified":1496672548000},{"_id":"source/_posts/2014-12-09-python基础篇之文件操作.md","hash":"d060ae25c8786fc6678aa58f09be6e76fa14255f","modified":1496672548000},{"_id":"source/_posts/2014-12-30-ubuntukylin安装推荐.md","hash":"90d323ba96cf0dfe7bc2acff331397632cc9919b","modified":1496672548000},{"_id":"source/_posts/2014-12-10-python基础篇之正则表达式.md","hash":"0934a0371848063fede4b536a769fbb9b31a32a7","modified":1496672548000},{"_id":"source/_posts/2014-12-11-python基础篇之实用工具.md","hash":"1f6353a68dd15c0fd164fffc5d0ae98b47705fcf","modified":1496672548000},{"_id":"source/_posts/2014-12-31-Linux经久不衰的应用程序.md","hash":"9b1667db8d107d492adcf344530a4e9f949c5742","modified":1496672548000},{"_id":"source/_posts/2015-05-16-shell编程之内容查找grep.md","hash":"5370a358d606568b77b7c2384bd879e3164091b5","modified":1496672548000},{"_id":"source/_posts/2015-05-20-shell编程之文本处理工具sed.md","hash":"dbdf9572e4692ef094886951f2fd1c02d8690f9f","modified":1496672548000},{"_id":"source/_posts/2015-05-18-shell编程之文本处理工具awk.md","hash":"75736e44a2fad1b61808b9fa5948eb9462e341d2","modified":1496672548000},{"_id":"source/_posts/2015-05-22-shell编程之系统进程监控.md","hash":"d0a74797cff0c6d6b293bf8d5c088ffc8d6f9216","modified":1496672548000},{"_id":"source/_posts/2015-05-31-ubuntu下lamp的构建.md","hash":"521077259f88b07f2b7728035b101582a2f8ee40","modified":1496672548000},{"_id":"source/_posts/2015-05-31-版本控制神器git.md","hash":"9d39963dcbc1743769683342a8d4154f94d0c7da","modified":1496672548000},{"_id":"source/_posts/2015-06-04-实用的写博语言markdown.md","hash":"df2cfb690ece6a7ec623a4b81efcba8ad1285092","modified":1496672548000},{"_id":"source/_posts/2015-07-01-shell编程之文件检索find.md","hash":"42cf2aeb512ba5da8cd1fddb771cae4c06ea775a","modified":1496672548000},{"_id":"source/_posts/2015-07-15-ACM算法之约数个数原理.md","hash":"68bf2601d1c5c58575d59c62d2af787387ccc773","modified":1496672548000},{"_id":"source/_posts/2015-07-06-shell编程之软硬链接ln.md","hash":"95ae9b053139fd4c24d1b235c8c7fcd2b5cc7ba9","modified":1496672548000},{"_id":"source/_posts/2015-06-30-ACM算法之基本并查集.md","hash":"6a78346bbba04ea11b7c0c72557c63eeffddf7ae","modified":1496672548000},{"_id":"source/_posts/2015-07-23-ACM解题报告之最大约数个数.md","hash":"c6984194a35f2951ff8f6bea027b007134de0d61","modified":1496672548000},{"_id":"source/_posts/2015-08-21-ACM算法之Trie树.md","hash":"62b45b62da815dbab9609b8b9f2cf6cf4edeb344","modified":1496672548000},{"_id":"source/_posts/2015-08-11-逃离VMWare拥抱docker.md","hash":"69d87195a79afc5c20b843aac26861cd24bf9590","modified":1496672548000},{"_id":"source/_posts/2015-08-04-搭建日志分析系统ELK.md","hash":"e11cc4ce641202c6c694bde6f0970bfab39cc700","modified":1496672548000},{"_id":"source/_posts/2015-08-13-集成开发工具Eclipse的配置.md","hash":"ab4faf2d6d8a745b82f1b7dff03c201d046ff782","modified":1496672548000},{"_id":"source/_posts/2015-08-22-C语言编程之常见错误.md","hash":"582a352c2e5643eab44978e5fe806b331b0ee8e7","modified":1496672548000},{"_id":"source/_posts/2015-08-31-VIM配置之入门篇.md","hash":"5779cd8fc7311d349d020423c0fb79bc4ccf07dd","modified":1496672548000},{"_id":"source/_posts/2015-09-08-shell运行环境之环境变量.md","hash":"a0854d4a885df9f74ba3e32bb2758d96a8f49c62","modified":1496672548000},{"_id":"source/_posts/2015-08-25-ACM解题报告之最长回文子串.md","hash":"834cd0712f558912734a6c845a1305b874323e36","modified":1496672548000},{"_id":"source/_posts/2015-09-07-ACM解题报告之格雷码.md","hash":"3f2facb93e0862fffa940d1e9f77111473edc624","modified":1496672548000},{"_id":"source/_posts/2015-09-08-刨根问底之shell里的运行环境.md","hash":"e53c5ee5c09787582b99f0b4e116fcc9899c3bec","modified":1496672548000},{"_id":"source/_posts/2015-09-09-shell运行环境之环境配置文件.md","hash":"242948730e6e8c5d880a9c7c793c4412c66a6c6c","modified":1496672548000},{"_id":"source/_posts/2015-09-13-shell运行环境之sudo的环境.md","hash":"6b2545ba8044c492f284fd933ac2b707a62eb793","modified":1496672548000},{"_id":"source/_posts/2015-10-10-C语言编程之运算符.md","hash":"8cd61370f372814caa2decb16d741883270681a5","modified":1496672548000},{"_id":"source/_posts/2015-10-08-C语言编程之数据类型.md","hash":"888f3125aff9a3b1b63ab67c0ad43d18775d66fa","modified":1496672548000},{"_id":"source/_posts/2015-10-24-C家族语言之输入输出.md","hash":"29641a308e4428687ceaaf5c91da860fe00205c9","modified":1496672548000},{"_id":"source/_posts/2015-09-25-VIM配置之进阶篇.md","hash":"df50129157d6c8cff4e7903d43a8aa12f056a565","modified":1496672548000},{"_id":"source/_posts/2015-10-19-ML之线性回归.md","hash":"314cd16bbd12941ac73ad7f91aea81c2cf83faf4","modified":1496672548000},{"_id":"source/_posts/2015-10-26-C语言编程之指针.md","hash":"49de4e12f561f0e736be12b01479858a900fd766","modified":1496672548000},{"_id":"source/_posts/2015-12-04-python里的数据科学之Numpy实战.md","hash":"20bdb5c5637e95919d44e895531fb08294d6bfbc","modified":1496672548000},{"_id":"source/_posts/2015-12-09-macbook操作系统OSX初探.md","hash":"e5e7c12682d831a02ea0557ff2d7f0798fa7e709","modified":1496672548000},{"_id":"source/_posts/2015-12-07-python里的数据科学之Matplotlib实战.md","hash":"7add21b22287eb2d16f0cb77d895375462c646b5","modified":1496672548000},{"_id":"source/_posts/2015-12-02-货比三家之MacPro_MF840.md","hash":"237e23d44c469132246eb1319791c143e5ae7439","modified":1496672548000},{"_id":"source/_posts/2015-12-29-更快的构建自己博客.md","hash":"801627a38289869043680b4b23ddf43b5cb16a73","modified":1496672548000},{"_id":"source/_posts/2015-12-10-macbook常用软件及其管理.md","hash":"9536a11950a1ed03620bb6a94f994c318c5e3aee","modified":1496672548000},{"_id":"source/_posts/2016-01-10-程序猿得看的经典好书.md","hash":"d80b3a2a9d5f088afe233b9a45da2e4bd6a0c6cd","modified":1496672548000},{"_id":"source/_posts/2017-01-24-从零开始搭建https服务器.md","hash":"81b7684350d015c8ca7c2c543af24e10a72dc00f","modified":1496672548000},{"_id":"source/_posts/2017-02-03-Nginx部署多应用.md","hash":"821bc4f81bf5333511b0b30208f34ec6959321e1","modified":1496672548000},{"_id":"source/_posts/2017-02-05-使用Python和Flask设计RESTFul接口.md","hash":"c5c926ea434ace0d7743a00978e09d3c34e4bd4f","modified":1496672548000},{"_id":"source/_posts/2017-03-28-ACM排序算法之快排.md","hash":"0859ebdec0cd793adacc08f625ff4b54062c5135","modified":1496672548000},{"_id":"source/_posts/2017-01-30-活用python虚拟环境virtualenv.md","hash":"83ee02497d69a07a4c9832f8b13e72b8d8ddb95f","modified":1496672548000},{"_id":"source/_posts/2017-04-14-高效排序之交换.md","hash":"29630f85c95073493187b8eb640d546e37d3891a","modified":1496672548000},{"_id":"source/_posts/2017-03-25-ACM解题报告之贪婪的礼物赠送者.md","hash":"4c21a8a3cc5fa0f3434cfb077e9e97a33dbb3210","modified":1496672548000},{"_id":"source/_posts/2017-05-02-自搭服务器之网络配置.md","hash":"47a447cb9c293bea1f8ba529f005d033e1436877","modified":1496672548000},{"_id":"themes/hjy/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1496671554000},{"_id":"themes/hjy/.git/config","hash":"2bfe8ec693a2b535b95739f532f78e998ad12c94","modified":1496671554000},{"_id":"themes/hjy/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1496671534000},{"_id":"themes/hjy/.git/index","hash":"7f472e97a766b707db6301cdd08913732bd3f372","modified":1496671554000},{"_id":"themes/hjy/.git/packed-refs","hash":"c01020fd838d287f521310b4230b2fede468ad49","modified":1496671554000},{"_id":"themes/hjy/layout/index.ejs","hash":"781cfe4099167a72ac887941c925e216509961f7","modified":1496671554000},{"_id":"themes/hjy/layout/layout.ejs","hash":"f6d2142085431ad853e96783bffb2a14b03c9213","modified":1496671554000},{"_id":"themes/hjy/layout/post.ejs","hash":"a05fd1a27e1c54c9dbab9e69a257a299b0f549cc","modified":1496671554000},{"_id":"source/_drafts/2017-03-21-C程序编程四步走/hello.c","hash":"5bde60abe6d80bdca14c89709b181ba48275642e","modified":1496672548000},{"_id":"source/_drafts/2017-03-21-C程序编程四步走/hello.s","hash":"ccb335a73031cbf5452f021679ad4d5e4e0409a9","modified":1496672548000},{"_id":"source/static/code/hello.c","hash":"5bde60abe6d80bdca14c89709b181ba48275642e","modified":1496672548000},{"_id":"source/_drafts/2017-03-21-C程序编程四步走/hello.i","hash":"cd23e70c059071066c75ad5494c18debb1c55484","modified":1496672548000},{"_id":"source/_posts/2015-07-23-ACM解题报告之最大约数个数/hiho_divisors_travel.cpp.txt","hash":"a09bce4b4701719d201dd026a90110dba9b4bde0","modified":1496672548000},{"_id":"source/_posts/2015-07-23-ACM解题报告之最大约数个数/hiho_divisors.cpp.txt","hash":"749e4900c9c412080a788539c20195f42ba40c61","modified":1496672548000},{"_id":"source/_posts/2015-07-23-ACM解题报告之最大约数个数/hiho_divisors_depart.cpp.txt","hash":"5926feabe96357d8a9860febe574900d43478951","modified":1496672548000},{"_id":"source/_posts/2017-03-25-ACM解题报告之贪婪的礼物赠送者/gift1.md.txt","hash":"a80027bfab531ca15601b81e25f4ae17db6854e9","modified":1496672548000},{"_id":"source/_posts/2017-03-25-ACM解题报告之贪婪的礼物赠送者/gift1_tree.c","hash":"8970beec66f51734e228f409a2b6119640848976","modified":1496672548000},{"_id":"source/_posts/2017-03-25-ACM解题报告之贪婪的礼物赠送者/gift1_sort.c","hash":"5d7c49c28d35030ee5f0aabde443cf1c7fda1a43","modified":1496672548000},{"_id":"themes/hjy/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1496671534000},{"_id":"themes/hjy/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1496671534000},{"_id":"themes/hjy/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1496671534000},{"_id":"themes/hjy/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1496671534000},{"_id":"themes/hjy/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1496671534000},{"_id":"themes/hjy/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1496671534000},{"_id":"themes/hjy/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1496671534000},{"_id":"themes/hjy/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1496671534000},{"_id":"themes/hjy/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1496671534000},{"_id":"themes/hjy/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1496671534000},{"_id":"themes/hjy/.git/logs/HEAD","hash":"67f01a72a83572acff07f459e374986a6974f49a","modified":1496671554000},{"_id":"themes/hjy/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1496671534000},{"_id":"themes/hjy/layout/_partial/after-footer.ejs","hash":"eea6e1dca98f022c949c7a4784bc6b734807b302","modified":1496671554000},{"_id":"themes/hjy/layout/_partial/archive.ejs","hash":"e5c2c56a9df8243fcc3cfeaafebe230d83444fed","modified":1496671554000},{"_id":"themes/hjy/layout/_partial/article.ejs","hash":"05520876538da5ee8571a3085dbcefee7edf0f05","modified":1496671554000},{"_id":"themes/hjy/layout/_partial/footer.ejs","hash":"8e95cf3448ecc57e979ed4c663c434e311b79e45","modified":1496671554000},{"_id":"themes/hjy/layout/_partial/head.ejs","hash":"c3495a78a266f49e33f16fa7cdc9d40b997a5ddb","modified":1496671554000},{"_id":"themes/hjy/layout/_partial/site-col.ejs","hash":"134babed5870dc1e80731374a5ae0ba9ee1cc067","modified":1496671554000},{"_id":"themes/hjy/layout/_partial/toc.ejs","hash":"72ca653f533ae362b3473285c69c3dc259011c2f","modified":1496671554000},{"_id":"themes/hjy/source/css/docs.min.css","hash":"dd43c18a6b20c3f384fa21b869fd8fc70fcd75d6","modified":1496671554000},{"_id":"themes/hjy/source/img/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1496671554000},{"_id":"themes/hjy/source/img/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1496671554000},{"_id":"themes/hjy/source/img/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1496671554000},{"_id":"themes/hjy/source/img/old.png","hash":"67c50a96e54681db3a202c3b00de037ade442dab","modified":1496671554000},{"_id":"themes/hjy/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1496671554000},{"_id":"themes/hjy/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1496671554000},{"_id":"themes/hjy/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1496671554000},{"_id":"themes/hjy/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1496671554000},{"_id":"themes/hjy/source/js/jquery.bootstrap-autohidingnavbar.js","hash":"6883180781f5332517d0f9cc6c959a0848c1a729","modified":1496671554000},{"_id":"themes/hjy/source/js/main.js","hash":"521bb7333dcfe210fc71311d8718d13e3f791b4f","modified":1496671554000},{"_id":"themes/hjy/source/js/toc.js","hash":"72ba1228fc1a44df45b8f4b562eba78594f13016","modified":1496671554000},{"_id":"themes/hjy/source/img/identity.jpg","hash":"379b209c0919411fa8d700dff8211605e03515fe","modified":1496671554000},{"_id":"themes/hjy/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1496671554000},{"_id":"themes/hjy/.git/objects/pack/pack-b954e91c20e385927fc398a73765167bc2e4a284.idx","hash":"c23032009997ffaa38f4f37e36b7fa35e4e816aa","modified":1496671554000},{"_id":"themes/hjy/layout/_partial/post/tag.ejs","hash":"0a6f684b4fb6a3b0b71d430c8e2e0cf4bf4c7289","modified":1496671554000},{"_id":"themes/hjy/.git/refs/heads/master","hash":"3f124882b5f5339945feae6c1a9f0038eacda55f","modified":1496671554000},{"_id":"themes/hjy/layout/_partial/post/category.ejs","hash":"265bb12f7cfa5e0bcbb74fdd409ba13a6d9d2e22","modified":1496671554000},{"_id":"themes/hjy/layout/_partial/post/data.ejs","hash":"e0775b7ef18c21e6d6f7b281cd67013ee635a6d5","modified":1496671554000},{"_id":"themes/hjy/layout/_partial/post/title.ejs","hash":"2bb24405a6b30aab26939a7e98648aca3eab83bf","modified":1496671554000},{"_id":"themes/hjy/source/css/hjy-bootstrap.css","hash":"f6eb597e35d9ab7442e57a1f062f3cc78b1427b2","modified":1496671554000},{"_id":"themes/hjy/.git/logs/refs/heads/master","hash":"67f01a72a83572acff07f459e374986a6974f49a","modified":1496671554000},{"_id":"themes/hjy/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1496671554000},{"_id":"themes/hjy/.git/logs/refs/remotes/origin/HEAD","hash":"67f01a72a83572acff07f459e374986a6974f49a","modified":1496671554000},{"_id":"themes/hjy/source/img/avatar2.png","hash":"942183956fa95e44245054f77b2e2fc287d4bd58","modified":1496671554000},{"_id":"themes/hjy/source/img/avatar.png","hash":"48115eb75fc7a3626d0abcb4d0d113b18d90fc62","modified":1496671554000},{"_id":"themes/hjy/.git/objects/pack/pack-b954e91c20e385927fc398a73765167bc2e4a284.pack","hash":"51a33cb0f97f71881b4f2fbd672605eb214c29da","modified":1496671554000},{"_id":"public/2017/05/02/自搭服务器之网络配置/index.html","hash":"052cd3714988c11c943a2db8f64b948f43a5df7c","modified":1496677512600},{"_id":"public/2017/04/14/Research-swap/index.html","hash":"98e55d2cfe2d8341ab1108f1b5091ab6d78cc5c4","modified":1496677512600},{"_id":"public/2017/03/28/Explore-quickSort/index.html","hash":"f8d2e0cbc9728cef0560fcb45c589bff2a6c4dd9","modified":1496677512601},{"_id":"public/2017/03/21/manage-memory-c/index.html","hash":"f1b75ab7675fdbcb447d9fe513f22da1e3d02169","modified":1496677512601},{"_id":"public/2017/02/05/design-restful/index.html","hash":"d34f9192b504fd33b42a66c00cb27782aafba0a3","modified":1496677512601},{"_id":"public/2017/02/03/server-multi-apps/index.html","hash":"9b355319315711c75b02d588adaac0a24e5b15a3","modified":1496677512601},{"_id":"public/2017/01/30/virtualenv/index.html","hash":"bfb72d4cc9561c53b517e24b43433ab1eba167e3","modified":1496677512601},{"_id":"public/2015/12/29/Building-blog/index.html","hash":"cbadcfa776eb2d770a1dd9d3b842e874d9e3bff4","modified":1496677512601},{"_id":"public/2015/12/09/Explore-OSX/index.html","hash":"c614a573e200cfa7b145e517b47a411d9ad6db86","modified":1496677512601},{"_id":"public/2015/12/04/Explore-Numpy-Python/index.html","hash":"b6643f596400afef57fc14d0589db7a60fe38a75","modified":1496677512601},{"_id":"public/2015/12/02/Buy-MacPro/index.html","hash":"f0d5effea765d63e3b968f73bf6dc548123e4afc","modified":1496677512601},{"_id":"public/2015/11/28/Explore-ultimate-vim/index.html","hash":"b26fde798118d7a0649e52c2c70e99febd8092d7","modified":1496677512601},{"_id":"public/2015/11/22/Explore-memory-inC/index.html","hash":"e74a63a8966cda97f2387ef95e4b2af5099f8767","modified":1496677512601},{"_id":"public/2015/10/24/Review-input-C/index.html","hash":"c2dccdfa86415538bb82f66f8142df4f8f869b28","modified":1496677512601},{"_id":"public/2015/10/19/Explore-LR-ML/index.html","hash":"d549a49e574134c872ed9e374b2c301d4a6d4545","modified":1496677512602},{"_id":"public/2015/09/13/Explore-sudo-Shell/index.html","hash":"f770fcf7220aa7a2a465bc33a348d7edd1885ba8","modified":1496677512602},{"_id":"public/2015/09/07/Solve-gray-ACM/index.html","hash":"4006d7039a81120b70824f56eaafca895ba91e98","modified":1496677512602},{"_id":"public/2015/08/22/Explore-commonError-C/index.html","hash":"b8114c7aa242a592dd151365af96673316bb2eb1","modified":1496677512602},{"_id":"public/2015/08/21/Solve-trie-ACM/index.html","hash":"e570d21f1ad727d2b9ff5568a21025c8d8364be6","modified":1496677512602},{"_id":"public/2015/08/13/Record-configure-Eclipse/index.html","hash":"20f778782470a193eb757791e6c16d3f3d05c336","modified":1496677512602},{"_id":"public/2015/08/01/Travel-huangshan/index.html","hash":"0b5f4e43478ed65e93a337a6709a671fe0b1699e","modified":1496677512602},{"_id":"public/2015/07/15/Explore-numOfDivisor/index.html","hash":"9c9e33f8d3637fa4c6e2fcbb6753b41215094237","modified":1496677512602},{"_id":"public/2015/07/06/Explore-ln-Shell/index.html","hash":"626723a7c0237613d217b0576ff61b4ee939233f","modified":1496677512602},{"_id":"public/2015/07/01/Explore-find-Shell/index.html","hash":"fbc32df933d588de82e13805545313906604c8de","modified":1496677512602},{"_id":"public/2015/06/30/Explore-unionFind/index.html","hash":"54257e5e8832ac29a5e199e253b958d87081cfc8","modified":1496677512603},{"_id":"public/2015/06/13/Diy-blogTheme/index.html","hash":"2cd81a0209c67115c8298dc0e1c99521c91cd05e","modified":1496677512603},{"_id":"public/2015/06/04/Explore-markdown/index.html","hash":"19d6830baa289a9d06bcdf3999c55a33e2c66155","modified":1496677512603},{"_id":"public/2015/05/31/Build-lamp/index.html","hash":"0b38ae4b5ec38252f3188c8e2ecd2eb0add03328","modified":1496677512603},{"_id":"public/2015/05/22/Explore-systemMonitor-shell/index.html","hash":"44e6f48b947b5244febb62cc92903d05b795a1ff","modified":1496677512603},{"_id":"public/2015/05/20/Explore-sed-Shell/index.html","hash":"0b8b1c2e0086c76e16598d789eabe69de80ef678","modified":1496677512603},{"_id":"public/2015/05/18/Explore-awk-Shell/index.html","hash":"1379b785a64ace4e399371f62ea6fc8ec59b3337","modified":1496677512603},{"_id":"public/2015/05/16/Explore-grep-Shell/index.html","hash":"c60ab2626353c54173bfe33f64a1dd57fb5f78cc","modified":1496677512603},{"_id":"public/2014/12/31/Explore-popularSoftware-Ubuntu/index.html","hash":"49bbc255b3d8f8608636b2c402c5a2862ea230a3","modified":1496677512603},{"_id":"public/2014/12/30/Explore-software-ubuntu/index.html","hash":"9c13cf81ef5cbf528c3ec36f33dbff568e39c37d","modified":1496677512603},{"_id":"public/2014/12/10/Study-reg-Python/index.html","hash":"4971dc5dcedb5ad4ed33ad969f40f2f7c9f66120","modified":1496677512603},{"_id":"public/2014/12/09/Study-file-Python/index.html","hash":"1ad2d449c3f305c4cf3573d1674043c107d00b9b","modified":1496677512603},{"_id":"public/2014/12/08/Study-syntax-Python/index.html","hash":"99ccf973cd81e9a565c37bf939e41a094b946c96","modified":1496677512604},{"_id":"public/2014/12/07/Study-tupleDict-Python/index.html","hash":"f51a77bec9c44272b7af6e25655d6d13f99a2391","modified":1496677512604},{"_id":"public/2014/12/06/Study-list-Python/index.html","hash":"ae1a0734feaa7dd3023b48d155881c919c17f5c7","modified":1496677512604},{"_id":"public/2014/12/05/Study-string-Python/index.html","hash":"2e5b3ef414867d5f48707fadf1caa653507f4727","modified":1496677512605},{"_id":"public/2014/12/04/Study-basicConcept-Python/index.html","hash":"7a5d1639f2532968ec99957e56bdd494d6ea3322","modified":1496677512605},{"_id":"public/2014/12/03/Study-introduce-Python/index.html","hash":"0b9f6ea9c129ba16911b96e7338db38438e88ecd","modified":1496677512605},{"_id":"public/2014/03/07/Summary-string-ACM/index.html","hash":"2df470ad7fbdb9a52f97bdc3fedfb3a23a31ac74","modified":1496677512605},{"_id":"public/2014/03/05/Summary-code-ACM/index.html","hash":"b6d17b803c558cdf9219d1f35fad4e7ead27af58","modified":1496677512605},{"_id":"public/2014/03/01/Summary-snip-Shell/index.html","hash":"bc1a20724bf30b4dd9266addc65058e301fb3d0d","modified":1496677512605},{"_id":"public/2014/02/28/Summary-command-Shell/index.html","hash":"c81557aa398cc68dbf9368be67c883a79067b495","modified":1496677512605},{"_id":"public/2014/02/27/Summary-structure-Shell/index.html","hash":"436f7f38ab809681e9320d42d9c7e4c512a5a23b","modified":1496677512605},{"_id":"public/2014/02/26/Summary-basicConcept-Shell/index.html","hash":"172a52c811888fb5db6e00f1c7e37e78bbd0d69f","modified":1496677512605},{"_id":"public/2013/09/15/Summary-snip-Batch/index.html","hash":"32821a6781568bc3bc420a1f0df09bd4bd65a3e4","modified":1496677512605},{"_id":"public/2013/09/14/Summary-find-Batch/index.html","hash":"1da3ee30529b4889a9e36104a8fd0ee99b6af06c","modified":1496677512605},{"_id":"public/2013/09/13/Summary-at-Batch/index.html","hash":"b147709dd73bbaac9d4ea60b353bee9a7a48587b","modified":1496677512605},{"_id":"public/2013/09/12/Summary-string-Batch/index.html","hash":"fd91eae97fb71a8d320c65c536a2c8ae0d8c7ded","modified":1496677512606},{"_id":"public/2013/09/11/Summary-structure-Batch/index.html","hash":"571f4792177e8c6b0d0dd6d177b1a87d5d2386ec","modified":1496677512606},{"_id":"public/2013/09/10/Summary-command-Batch/index.html","hash":"1535bfdba2a22318ea5f53cbdada9089c427164a","modified":1496677512606},{"_id":"public/2013/09/09/Summary-sign-Batch/index.html","hash":"2d1e5d429c0230780a04cd15332402a14bfb649a","modified":1496677512606},{"_id":"public/2013/09/08/Summary-basicCommand-Batch/index.html","hash":"b0c7b0a5c48ce4a7d2b7848e7423489b7b377c4f","modified":1496677512606},{"_id":"public/2013/07/20/Make-startupDisk/index.html","hash":"eb92751f5635e560579287f6bad6089f4f07d19c","modified":1496677512606},{"_id":"public/2013/06/19/Explore-blur-Gimp/index.html","hash":"3ffe61db031d5628d05c89e0c790c98f5bc3d50b","modified":1496677512606},{"_id":"public/2013/06/18/Explore-introduce-Gimp/index.html","hash":"4bf3d27ca7db626a979c2e2f26f6aeee6ab4a825","modified":1496677512606},{"_id":"public/archives/index.html","hash":"c2eab00a69cf3d3a278a23c3a472fba53fc8f073","modified":1496677512606},{"_id":"public/archives/page/2/index.html","hash":"b41680416cfdfb3b7535c86e5b54024b45916d71","modified":1496677512606},{"_id":"public/archives/page/4/index.html","hash":"ceac61e7388ff6e1ed4b40fba20c747601547759","modified":1496677512606},{"_id":"public/archives/page/8/index.html","hash":"ee5223224f5c9a3f5bb3c678b556c98ab95d1df2","modified":1496677512606},{"_id":"public/archives/page/9/index.html","hash":"6fe143be95e26b80f6ad6c459d759308fb0264ee","modified":1496677512606},{"_id":"public/archives/page/11/index.html","hash":"ca8ce7883e74a7207da658d3659ffb5d62467855","modified":1496677512606},{"_id":"public/archives/page/12/index.html","hash":"e1ab5179a66aa5b0f90513e3a1aaf8eb7ef3e52e","modified":1496677512606},{"_id":"public/archives/page/13/index.html","hash":"17365fc589840251d6d2e0eb57f3d236a34dbcd2","modified":1496677512606},{"_id":"public/archives/page/14/index.html","hash":"579cb34bc486680039dd10127165d5b5b74d704e","modified":1496677512606},{"_id":"public/archives/page/15/index.html","hash":"08e90b588e00910e21d3c25589339700083a0343","modified":1496677512606},{"_id":"public/archives/page/16/index.html","hash":"8b3c21687fd1fe9c744021e95afa7a7e1e2f0c7f","modified":1496677512606},{"_id":"public/archives/2013/index.html","hash":"436bc1c450ac5b4a4bde1c38ac5b5506c42f4e72","modified":1496677512606},{"_id":"public/archives/2013/page/2/index.html","hash":"2ecd19dddf8aa6d70267d7c4b039a50ab4a2a0ef","modified":1496677512606},{"_id":"public/archives/2013/page/3/index.html","hash":"7c0f1b05420be57cac6748a5c0886ef607470d15","modified":1496677512606},{"_id":"public/archives/2013/06/index.html","hash":"2a0b0eec75cbf74b08a00db7d7266eecd51a4b3f","modified":1496677512606},{"_id":"public/archives/2013/07/index.html","hash":"d62ad77f8f7188363297c28fb04eaf48596ac6b4","modified":1496677512606},{"_id":"public/archives/2013/09/index.html","hash":"580048d8226cc8d88d0c448aef99a5d7e901864b","modified":1496677512606},{"_id":"public/archives/2013/09/page/2/index.html","hash":"6ff050858a2fa0b45c4817c82d2c3906a3563fba","modified":1496677512607},{"_id":"public/archives/2014/index.html","hash":"ff5ee56a4428d28fd933923de6bed284804458ad","modified":1496677512607},{"_id":"public/archives/2014/page/2/index.html","hash":"b4444b7f8f866cdf767d8a02cc04463c8f567967","modified":1496677512607},{"_id":"public/archives/2014/page/3/index.html","hash":"0cddf39d6e9c19c3c232cc441b38172d9ee07040","modified":1496677512607},{"_id":"public/archives/2014/page/4/index.html","hash":"dd9474233a11e7852cfa4012aebf61f7faaad0e6","modified":1496677512607},{"_id":"public/archives/2014/02/index.html","hash":"38767fa748d6ef3ded8f966ba5a6c052fd3eacde","modified":1496677512607},{"_id":"public/archives/2014/03/index.html","hash":"aed1ed3ac07e3140b3cc013a8cbc0ae3d6530fe3","modified":1496677512607},{"_id":"public/archives/2014/12/index.html","hash":"2d8816ba805306606a5abfaa3b94cdaf4fe9b372","modified":1496677512607},{"_id":"public/archives/2014/12/page/2/index.html","hash":"6b391db50ccce35e1d3dcd23b5cbed840cad2dba","modified":1496677512607},{"_id":"public/archives/2014/12/page/3/index.html","hash":"91874ae38b22553529bdd7cc77ad7fa6dbdb5322","modified":1496677512607},{"_id":"public/archives/2015/index.html","hash":"7a4f5e2a380f03282389a983484f7cf08d4b4f21","modified":1496677512607},{"_id":"public/archives/2015/page/2/index.html","hash":"d777d232434acd05d421b99a167ba28b1a180399","modified":1496677512607},{"_id":"public/archives/2015/page/6/index.html","hash":"c74eed0004310ea289da1d08985e2a84e6832493","modified":1496677512607},{"_id":"public/archives/2015/page/7/index.html","hash":"eaef11a408f5a52d4194f61c05fe6e6d4695af9f","modified":1496677512607},{"_id":"public/archives/2015/05/page/2/index.html","hash":"4e74186e9733efcd04ddbee8b6064f33f86a7c9c","modified":1496677512607},{"_id":"public/archives/2015/06/index.html","hash":"88a91078ada91d926d2b020bdbade7e69331e72c","modified":1496677512607},{"_id":"public/archives/2015/07/index.html","hash":"a168a25bf1691e0c89afcaa490d57a296711d9e5","modified":1496677512607},{"_id":"public/archives/2015/08/page/2/index.html","hash":"9823c8d8a0a0cccfefd7e140fd4f539c17620e3e","modified":1496677512608},{"_id":"public/archives/2015/09/page/2/index.html","hash":"288544d691d68f0e1850b12564449129c3d0ef26","modified":1496677512608},{"_id":"public/archives/2015/10/index.html","hash":"c1653e2da9e1c5475e74144c187d3a0433cb6c96","modified":1496677512608},{"_id":"public/archives/2015/11/index.html","hash":"35abb70fff303a38636f52a425a77ac2f412ff84","modified":1496677512608},{"_id":"public/archives/2015/12/index.html","hash":"7f9f8180e4b0b2b1ca102b6265143d002d9865e6","modified":1496677512608},{"_id":"public/archives/2015/12/page/2/index.html","hash":"2c25b0fcbf4d04edeaba9939354928adba2fc732","modified":1496677512608},{"_id":"public/archives/2016/index.html","hash":"3b00e4795eb625e24bd4e023559602ccebcc6720","modified":1496677512609},{"_id":"public/archives/2016/01/index.html","hash":"b3547ce9a393d21913f735044ce32afc236884d3","modified":1496677512609},{"_id":"public/archives/2017/index.html","hash":"99172b51fb152d3cf5aad5803be3e28f0dc9ecab","modified":1496677512609},{"_id":"public/archives/2017/page/2/index.html","hash":"bc6d84f95e23fc7c175495bc09dda4b7df20d629","modified":1496677512609},{"_id":"public/archives/2017/01/index.html","hash":"bb675fd3a1cbb630bc0e59b75876907471b5c881","modified":1496677512609},{"_id":"public/archives/2017/02/index.html","hash":"9831a65414fbf6beb0fdb16323766b62149d9b2c","modified":1496677512610},{"_id":"public/archives/2017/03/index.html","hash":"9281594757b319d6625bb7ba69f1b2ad7f933e10","modified":1496677512613},{"_id":"public/archives/2017/04/index.html","hash":"107ac98644dedae7b0ab8f1a9d4f3d911949e3f0","modified":1496677512613},{"_id":"public/archives/2017/05/index.html","hash":"e1c51c42038568aca275832ce38609a93f714868","modified":1496677512613},{"_id":"public/categories/TECHNOLOGY/index.html","hash":"b4473655fb40b5147b28cf501b03b2c013df392f","modified":1496677512613},{"_id":"public/categories/TECHNOLOGY/page/3/index.html","hash":"0eb7dae86b1446bdb684f71dd79e142246980ce5","modified":1496677512613},{"_id":"public/categories/TECHNOLOGY/page/7/index.html","hash":"c8a97aa2153dc5e114636a4b706ada01af05d9c7","modified":1496677512613},{"_id":"public/categories/TECHNOLOGY/page/8/index.html","hash":"cab9bf0d6ee88356191747313eea511c74bc03a9","modified":1496677512613},{"_id":"public/categories/TECHNOLOGY/page/10/index.html","hash":"2731c8f931cce843ecc9977dffd6ea9a457ee6b7","modified":1496677512613},{"_id":"public/categories/TECHNOLOGY/page/11/index.html","hash":"2f9418bac5969386b79efdf703d70c97ce0708c9","modified":1496677512614},{"_id":"public/categories/TECHNOLOGY/page/12/index.html","hash":"a6775f5ce21a54408ef34e292c3e95be67c3083c","modified":1496677512614},{"_id":"public/categories/TECHNOLOGY/page/13/index.html","hash":"b753a387dccc7398dec7117d8564adb9ad2c9fd9","modified":1496677512614},{"_id":"public/categories/TECHNOLOGY/page/14/index.html","hash":"04eac7c18036c423fb755cdaf3f9c09927b99955","modified":1496677512614},{"_id":"public/categories/TECHNOLOGY/page/15/index.html","hash":"7973e7998083bcafd9f509b05cf08de5dc8238da","modified":1496677512614},{"_id":"public/categories/LIFE/index.html","hash":"a51579be5347b1e847a695ec299e4e3505b51480","modified":1496677512614},{"_id":"public/categories/READING/index.html","hash":"ee6004a666dccdf144b487d371be8b3780960e46","modified":1496677512614},{"_id":"public/categories/category/index.html","hash":"71fe4e59a3c669521a67ee22346118e2b0f18923","modified":1496677512614},{"_id":"public/index.html","hash":"270765c1380083106796ffc84744ceb87f6f6498","modified":1496677512614},{"_id":"public/page/2/index.html","hash":"bb6dfcd414cffcda142858ec9375889b09435d51","modified":1496677512614},{"_id":"public/page/4/index.html","hash":"1ab2a3a6512995f02c3272c538ef651ec4d9ff13","modified":1496677512614},{"_id":"public/page/8/index.html","hash":"f0602a073bef55607c651c002de2124b67fddd9f","modified":1496677512614},{"_id":"public/page/9/index.html","hash":"4e00938925e5f5098f2952e7e5cbb74c20dd743c","modified":1496677512614},{"_id":"public/page/11/index.html","hash":"b66776cd72c8cbbaa831cee411b5d15dce2de7eb","modified":1496677512614},{"_id":"public/page/12/index.html","hash":"0e25831b87f6c4a419fb81c0278a47fecbeaebbc","modified":1496677512614},{"_id":"public/page/13/index.html","hash":"f28730dcdba37e9c0faf6ec096673e8e7abfdcac","modified":1496677512614},{"_id":"public/page/14/index.html","hash":"2bc7aa42d626dcc5085266b0658549558180b712","modified":1496677512614},{"_id":"public/page/15/index.html","hash":"ebb04c6f1dd9bb1a54c4dc2e7c6a90d01df320c5","modified":1496677512614},{"_id":"public/page/16/index.html","hash":"03eb787eb8c625bd9cdb1071f51cc83d836cb47e","modified":1496677512614},{"_id":"public/tags/Gimp/index.html","hash":"133c079c896e69f857d993edaae041baa45d7a3f","modified":1496677512615},{"_id":"public/tags/Blog/index.html","hash":"65e26bbf7db61c91ab00fd116d444d4ae70de619","modified":1496677512616},{"_id":"public/tags/Hexo/index.html","hash":"df7f19293d89ffb1e12de6bc33f4d461e1810128","modified":1496677512616},{"_id":"public/tags/Travel/index.html","hash":"310fc821d5761dd30030318421afa3ee1d85db87","modified":1496677512616},{"_id":"public/tags/C/index.html","hash":"ff6217a0d473d1c8a5537957c16e9c0ea33ccec3","modified":1496677512616},{"_id":"public/tags/C/page/2/index.html","hash":"267be62ba607e8f48fe6c778093f8b138548eeed","modified":1496677512616},{"_id":"public/tags/Memory/index.html","hash":"eca895fdb5e1158a2f98f508a6a945995a903cca","modified":1496677512616},{"_id":"public/tags/Vim/index.html","hash":"b13bf9438ffb1ae3923646858688f289b37160a4","modified":1496677512616},{"_id":"public/tags/Plugin/index.html","hash":"2a14a6d647dd7668830679854496d450bf6867ac","modified":1496677512616},{"_id":"public/tags/OS/index.html","hash":"7fb105f90bcd74a9145212ede5618b5c0ba02a05","modified":1496677512617},{"_id":"public/tags/Ubuntu/page/2/index.html","hash":"0b5b9fd9907dd39121732cf5a7df7bffb705bb89","modified":1496677512617},{"_id":"public/tags/Ubuntu/page/3/index.html","hash":"86f54ef023dd83e52493514464804615fccbb6ed","modified":1496677512617},{"_id":"public/tags/Software/index.html","hash":"fc7fff19c481171adc5ac3cc50ca38c93545df3a","modified":1496677512617},{"_id":"public/tags/GCC/index.html","hash":"51a68cc233b542a02c595dc9b8271a4934c73f79","modified":1496677512617},{"_id":"public/tags/Compile/index.html","hash":"30241d9a796ad00c85c5f5c72fa99bca3622e32d","modified":1496677512617},{"_id":"public/tags/Assemble/index.html","hash":"248ac361595dbab20d3b3735a7bbad4f3047455a","modified":1496677512617},{"_id":"public/tags/Link/index.html","hash":"969ec658e467d593da0b7bbda7a5a7b4a59ecce9","modified":1496677512617},{"_id":"public/tags/Batch/index.html","hash":"3358c51bad636adee35204d8be5b74d8abe3ee8e","modified":1496677512617},{"_id":"public/tags/Batch/page/2/index.html","hash":"a11137913949060ed08f61da05c6c645fbc1661e","modified":1496677512617},{"_id":"public/tags/Shell/index.html","hash":"3bd0275828ad65afc9b754e4281e6be6dafe89b7","modified":1496677512617},{"_id":"public/tags/Shell/page/3/index.html","hash":"2acf432d2d666bbc8cd326ecacb2d94b6cda2d27","modified":1496677512617},{"_id":"public/tags/ACM/index.html","hash":"04f12a08ebb3f9a0f3fecb82467dabf9f9f90a19","modified":1496677512617},{"_id":"public/tags/ACM/page/2/index.html","hash":"4a5813697937212c5b39070a6af061176f0e09da","modified":1496677512617},{"_id":"public/tags/Coding/page/2/index.html","hash":"137901af77719e2530c02e023bb3b30513c4fbf3","modified":1496677512617},{"_id":"public/tags/Python/index.html","hash":"f12156f5be8717ac797a64de9d22f33a86563470","modified":1496677512617},{"_id":"public/tags/Python/page/2/index.html","hash":"10acef38d7c54b0371139216c4ea427a8ee1ae22","modified":1496677512617},{"_id":"public/tags/Python/page/3/index.html","hash":"af81d606c651707aab120432a88014f77a83d6d1","modified":1496677512617},{"_id":"public/tags/Google/index.html","hash":"099265d078b58b1a4406c5342d666217371c3f4f","modified":1496677512617},{"_id":"public/tags/Google/page/2/index.html","hash":"ffbb8db3ea96976182b26de69dcf74dacd9955ba","modified":1496677512617},{"_id":"public/tags/OPS/index.html","hash":"ba8702a5ab196f81f81cdeffbce73e596ee9d654","modified":1496677512618},{"_id":"public/tags/Git/index.html","hash":"919c1d20291d561a9d332407b35fc42ff0524272","modified":1496677512618},{"_id":"public/tags/Markdown/index.html","hash":"0d5bbb1bd8cc91df2222fddc632cccbdf110ffbc","modified":1496677512618},{"_id":"public/tags/Algorithm/page/2/index.html","hash":"397a05f043a6a3546f3fe7cdd2bfd67282b18d2a","modified":1496677512618},{"_id":"public/tags/HiHoCoder/index.html","hash":"71398522b1b408618ba40ca0db67f683dbe78736","modified":1496677512618},{"_id":"public/tags/Report/index.html","hash":"b47777524b2757c673a1e35ddab43ae019275416","modified":1496677512618},{"_id":"public/tags/LeetCode/index.html","hash":"4dce06e1671c3c1c4aa90993d2c66feda5071d71","modified":1496677512618},{"_id":"public/tags/Interview/index.html","hash":"aab868ad8b5e0da54ec70010cd37b66f3ee70511","modified":1496677512618},{"_id":"public/tags/ML/index.html","hash":"f1af4c276e0114c4b313c857217594f9b9e1ed6b","modified":1496677512618},{"_id":"public/tags/Numpy/index.html","hash":"55ab6b29721e12409dd73fcd8608c6f99efe12b0","modified":1496677512618},{"_id":"public/tags/Mac/index.html","hash":"77263fffb676caec8c85cc4b12134fb73a655d99","modified":1496677512618},{"_id":"public/tags/OSX/index.html","hash":"eb17a2eaf848d3c916d11365b33a95e0331cd310","modified":1496677512618},{"_id":"public/tags/Plt/index.html","hash":"6e271e65ff8457063b40fbe8e053b00316c12279","modified":1496677512618},{"_id":"public/tags/Java/index.html","hash":"76a6ef006b44c5d908431540641202527a2144fb","modified":1496677512618},{"_id":"public/tags/Network/index.html","hash":"b2c8b5292a00f7b8e20c2e230f065b7762cd0d2b","modified":1496677512619},{"_id":"public/tags/Linux/index.html","hash":"31f5b0eaa36760ed039b1df4141747ebcf711a96","modified":1496677512619},{"_id":"public/tags/Cloud/index.html","hash":"c6d218a930324ff524ee8e46a926528fe323190d","modified":1496677512619},{"_id":"public/tags/Nginx/index.html","hash":"28236549dd9235d4876702a700b85e518988a779","modified":1496677512619},{"_id":"public/tags/Django/index.html","hash":"b3ca0fe6b08300bf69c358066fbcfb9470a87a38","modified":1496677512619},{"_id":"public/tags/Flask/index.html","hash":"a923693a14d825eebad4e04c910055120a027896","modified":1496677512619},{"_id":"public/tags/restful/index.html","hash":"5ace70f5ddc3c408d375dd0a602c1700fddce97c","modified":1496677512619},{"_id":"public/tags/Web/index.html","hash":"5168fda1c4c7b105f5f5a4be34fac47e82309021","modified":1496677512619},{"_id":"public/tags/Research/index.html","hash":"6c0203d7fc4cc1dcb7a2734ef8d0e4fef4a5dec1","modified":1496677512619},{"_id":"public/tags/USACO/index.html","hash":"0e6ecb06fce46e719fad7219d2f8de8401e61596","modified":1496677512619},{"_id":"public/tags/tag/index.html","hash":"525521a3c83a052ad19b04385afa02ad04848b6e","modified":1496677512619},{"_id":"public/2017/03/25/greedy-gift-givers/index.html","hash":"3844886fb02a9e5ce627fb8179082ed00549028a","modified":1496677512619},{"_id":"public/2017/03/21/compile-gcc/index.html","hash":"9073e802fdec71c4be506e5c1e0f6248fdc10aaa","modified":1496677512619},{"_id":"public/2017/01/24/https-server/index.html","hash":"ba122353850977b52fdf44572ab1ba65dbb7f70f","modified":1496677512619},{"_id":"public/2016/01/08/IT-books/index.html","hash":"f4180516ba9f692626acf313d32ec19a3a49f449","modified":1496677512619},{"_id":"public/2015/12/10/Manage-software-Mac/index.html","hash":"a792feb9509b7d5b6d5ddccc1fb536a6f007a0f8","modified":1496677512619},{"_id":"public/2015/12/07/Explore-matplotlib-Python/index.html","hash":"601e350580a5e2f1dfa86ce6d6676890e39e051e","modified":1496677512619},{"_id":"public/2015/10/26/Review-pointer-C/index.html","hash":"463a7662338296f03f5b6eeb5608bf3da8f06c2a","modified":1496677512619},{"_id":"public/2015/10/10/Review-operator-C/index.html","hash":"902999f4e3d715f1eb08f0564af90502fd94c6cc","modified":1496677512619},{"_id":"public/2015/10/08/Review-datetype-C/index.html","hash":"4f954ad604812389c88430b8df535c4897714ee6","modified":1496677512619},{"_id":"public/2015/09/25/Explore-advanced-vim/index.html","hash":"bfe4ddfd47d94d4194354a58d8b1dfee5ff00601","modified":1496677512619},{"_id":"public/2015/09/09/Explore-configure-Shell/index.html","hash":"f16feb8dbc9edf2ee5b9039c22878638f4f4b464","modified":1496677512619},{"_id":"public/2015/09/08/Explore-environment-Shell/index.html","hash":"6f042cbd2b9ce0a13e18c9fe6a18be2151e62e33","modified":1496677512619},{"_id":"public/2015/09/08/Explore-runtime-Shell/index.html","hash":"f04d59c29c120f367b1744989e78827613df7026","modified":1496677512619},{"_id":"public/2015/08/31/Explore-primary-vim/index.html","hash":"6bbcd915a8145becab7f6fd74c86a3c7dea549f1","modified":1496677512619},{"_id":"public/2015/08/25/Solve-longestPalindrome-ACM/index.html","hash":"fe45225a3b8331601ae32f0eabbd24b8a337a4da","modified":1496677512620},{"_id":"public/2015/08/11/Explore-docker/index.html","hash":"754e1919eb4efa2420b10e3d8560d2fa1b2dba1e","modified":1496677512620},{"_id":"public/2015/08/04/Explore-ELK/index.html","hash":"0f420ed6984ae75c6a91add20b441db04853adf4","modified":1496677512620},{"_id":"public/2015/07/23/Solve-numOfMaxDivisor-ACM/index.html","hash":"9be250a90cc5be71a8fcb6b304f2e42eaa743a71","modified":1496677512620},{"_id":"public/2015/05/31/Explore-git/index.html","hash":"1b97fcba158992f40410c9aee833a0f06c262375","modified":1496677512620},{"_id":"public/2014/12/11/Study-tool-Python/index.html","hash":"5a3e1c997d80941cff8536267bcf2339d82d9eb1","modified":1496677512620},{"_id":"public/archives/page/3/index.html","hash":"daf8f9de9884fc0788337e56e3b6091913963c99","modified":1496677512620},{"_id":"public/archives/page/5/index.html","hash":"72dca0c61a44579aaf45ae479a1798e30a720b1e","modified":1496677512620},{"_id":"public/archives/page/6/index.html","hash":"e18e82e0e9b8fd17e8c91e1b9ac841919c67caf8","modified":1496677512620},{"_id":"public/archives/page/7/index.html","hash":"bb600e5b253b0ee0d7ee17cdb6ba6108f7a86d8d","modified":1496677512620},{"_id":"public/archives/page/10/index.html","hash":"4673063fcf6920bf2bc7fea41d661aa3f0aa127d","modified":1496677512620},{"_id":"public/archives/2015/page/3/index.html","hash":"28e55359aafed268632d0bef2e8b348f3d4d72bb","modified":1496677512620},{"_id":"public/archives/2015/page/4/index.html","hash":"26fca6d621bb17634e5f1e5b2d7130b597e480ff","modified":1496677512620},{"_id":"public/archives/2015/page/5/index.html","hash":"42f11a8ad0f489c9ccf642adb2764c079d32019e","modified":1496677512620},{"_id":"public/archives/2015/page/8/index.html","hash":"400cf02ef4c3951b47027054b3db2ab6358c14e5","modified":1496677512620},{"_id":"public/archives/2015/05/index.html","hash":"eda68434cfac71e769f78bae474d7f58baf8ff09","modified":1496677512620},{"_id":"public/archives/2015/08/index.html","hash":"de3e20848376c1ff05803220d2841206b811ffc5","modified":1496677512620},{"_id":"public/archives/2015/09/index.html","hash":"8b2bca326272838ddb4160b39dc1595bad46fcc6","modified":1496677512620},{"_id":"public/categories/TECHNOLOGY/page/2/index.html","hash":"825c35c01998b8e3a285193ebb12c86925f8bac2","modified":1496677512620},{"_id":"public/categories/TECHNOLOGY/page/4/index.html","hash":"9b0d3aaf954a2cb8bbd96ded6f98f928da7ce2b9","modified":1496677512620},{"_id":"public/categories/TECHNOLOGY/page/5/index.html","hash":"bbc8d22c5e3cdfb91f5400c93eee6a201c53bbe5","modified":1496677512620},{"_id":"public/categories/TECHNOLOGY/page/6/index.html","hash":"f5c2b4da64b030a7fee0bdc0b8d39ab5cc239626","modified":1496677512620},{"_id":"public/categories/TECHNOLOGY/page/9/index.html","hash":"13b5d6d30a29705a7ae37629352c500254a5ffbe","modified":1496677512621},{"_id":"public/page/3/index.html","hash":"e7c93672f5855472bb2950cfc3f5544987f4477e","modified":1496677512621},{"_id":"public/page/5/index.html","hash":"f6ac319b324db80c4f04fbd67e617b7d524383e1","modified":1496677512621},{"_id":"public/page/6/index.html","hash":"09bc0573bb63aaa5ec9753d72e792db3c14ef7f5","modified":1496677512621},{"_id":"public/page/7/index.html","hash":"08c5ca2740308cd02329fdb9f3c1127eab2e17d3","modified":1496677512621},{"_id":"public/page/10/index.html","hash":"7df3201f3675c79a39322db5bdf2a237a79afec5","modified":1496677512621},{"_id":"public/tags/Ubuntu/index.html","hash":"e2c8f4d5ce25b1da94e78c4281406175f498c1a5","modified":1496677512621},{"_id":"public/tags/Shell/page/2/index.html","hash":"2d2065a70486fe702076a645b057a89e36f476c2","modified":1496677512621},{"_id":"public/tags/Coding/index.html","hash":"d637b60d95f9ba96450e8dceb029aff94d439000","modified":1496677512621},{"_id":"public/tags/Algorithm/index.html","hash":"b9bf9805d9f00b86d3b627201c4e469d19903e9c","modified":1496677512621},{"_id":"public/static/code/hello.c","hash":"5bde60abe6d80bdca14c89709b181ba48275642e","modified":1496677512630},{"_id":"public/img/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1496677512630},{"_id":"public/img/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1496677512630},{"_id":"public/img/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1496677512630},{"_id":"public/img/old.png","hash":"67c50a96e54681db3a202c3b00de037ade442dab","modified":1496677512630},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1496677512630},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1496677512630},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1496677512630},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1496677512630},{"_id":"public/2017/03/21/compile-gcc/hello.c","hash":"5bde60abe6d80bdca14c89709b181ba48275642e","modified":1496677512630},{"_id":"public/2017/03/21/compile-gcc/hello.i","hash":"cd23e70c059071066c75ad5494c18debb1c55484","modified":1496677512630},{"_id":"public/2017/03/21/compile-gcc/hello.s","hash":"ccb335a73031cbf5452f021679ad4d5e4e0409a9","modified":1496677512630},{"_id":"public/2015/07/23/Solve-numOfMaxDivisor-ACM/hiho_divisors.cpp.txt","hash":"749e4900c9c412080a788539c20195f42ba40c61","modified":1496677512630},{"_id":"public/2015/07/23/Solve-numOfMaxDivisor-ACM/hiho_divisors_depart.cpp.txt","hash":"5926feabe96357d8a9860febe574900d43478951","modified":1496677512630},{"_id":"public/2015/07/23/Solve-numOfMaxDivisor-ACM/hiho_divisors_travel.cpp.txt","hash":"a09bce4b4701719d201dd026a90110dba9b4bde0","modified":1496677512630},{"_id":"public/2017/03/25/greedy-gift-givers/gift1.md.txt","hash":"a80027bfab531ca15601b81e25f4ae17db6854e9","modified":1496677512630},{"_id":"public/2017/03/25/greedy-gift-givers/gift1_sort.c","hash":"5d7c49c28d35030ee5f0aabde443cf1c7fda1a43","modified":1496677512630},{"_id":"public/2017/03/25/greedy-gift-givers/gift1_tree.c","hash":"8970beec66f51734e228f409a2b6119640848976","modified":1496677512630},{"_id":"public/img/identity.jpg","hash":"379b209c0919411fa8d700dff8211605e03515fe","modified":1496677512640},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1496677512640},{"_id":"public/js/jquery.bootstrap-autohidingnavbar.js","hash":"6883180781f5332517d0f9cc6c959a0848c1a729","modified":1496677512646},{"_id":"public/js/main.js","hash":"7c2028de4f158a7a024bd5bf3f7a8e3900502539","modified":1496677512646},{"_id":"public/js/toc.js","hash":"72ba1228fc1a44df45b8f4b562eba78594f13016","modified":1496677512646},{"_id":"public/css/docs.min.css","hash":"dd43c18a6b20c3f384fa21b869fd8fc70fcd75d6","modified":1496677512646},{"_id":"public/css/hjy-bootstrap.css","hash":"f6eb597e35d9ab7442e57a1f062f3cc78b1427b2","modified":1496677512646},{"_id":"public/img/avatar2.png","hash":"942183956fa95e44245054f77b2e2fc287d4bd58","modified":1496677512725},{"_id":"public/img/avatar.png","hash":"48115eb75fc7a3626d0abcb4d0d113b18d90fc62","modified":1496677512729}],"Category":[{"name":"TECHNOLOGY","_id":"cj3kb1j2h0027l73yt1k74jbx"},{"name":"LIFE","_id":"cj3kb1j2y002bl73yqf9o55fa"},{"name":"READING","_id":"cj3kb1j4h0061l73yl5mllsx2"},{"name":"category","_id":"cj3kb1j4n006gl73y7luv8ol4"}],"Data":[],"Page":[],"Post":[{"layout":"draft","title":"以Gimp为手K天P地之模糊滤镜","comments":1,"_content":"最近有点忙,等事情忙定了再将这些以前写的东西整理出来.\n<!-- more -->\n","source":"_drafts/2013-06-19-以Gimp为手K天P地之模糊滤镜.md","raw":"---\nlayout:\tdraft\ntitle:\t以Gimp为手K天P地之模糊滤镜\ncategories:\n- TECHNOLOGY\ntags:\n- Gimp\npermalink:  Explore-blur-Gimp\ncomments:\ttrue\n---\n最近有点忙,等事情忙定了再将这些以前写的东西整理出来.\n<!-- more -->\n","slug":"Explore-blur-Gimp","published":0,"date":"2013-06-18T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j090000l73y8r8g3yh2","content":"<p>最近有点忙,等事情忙定了再将这些以前写的东西整理出来. <a id=\"more\"></a></p>\n","site":{"data":{}},"excerpt":"<p>最近有点忙,等事情忙定了再将这些以前写的东西整理出来.","more":"</p>"},{"layout":"draft","title":"自定义博客主题","comment":true,"_content":"房子需要装修,博客也需要装修.而通过**markdown**+**jekyll**+**github**搭建的博客是支持自定义自己的主题的.不过这需要对**html**,**javascript**,**css**有一定的了解.当然,要想自己的博客漂亮美观,自己的审美要好,显然我不具备(嘻嘻).\n<!-- more -->\n\n\n## jekyll的工作流程\n\nsdfsd\nlkdk\n","source":"_drafts/2015-06-13-自定义博客主题.md","raw":"---\nlayout:\tdraft\ntitle:\t自定义博客主题\ncategories:\n- TECHNOLOGY\ntags:\n- Blog\n- Hexo\npermalink:  Diy-blogTheme\ncomment: true\n---\n房子需要装修,博客也需要装修.而通过**markdown**+**jekyll**+**github**搭建的博客是支持自定义自己的主题的.不过这需要对**html**,**javascript**,**css**有一定的了解.当然,要想自己的博客漂亮美观,自己的审美要好,显然我不具备(嘻嘻).\n<!-- more -->\n\n\n## jekyll的工作流程\n\nsdfsd\nlkdk\n","slug":"Diy-blogTheme","published":0,"date":"2015-06-12T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","comments":1,"photos":[],"link":"","_id":"cj3kb1j0d0001l73yveqqgfeu","content":"<p>房子需要装修,博客也需要装修.而通过<strong>markdown</strong>+<strong>jekyll</strong>+<strong>github</strong>搭建的博客是支持自定义自己的主题的.不过这需要对<strong>html</strong>,<strong>javascript</strong>,<strong>css</strong>有一定的了解.当然,要想自己的博客漂亮美观,自己的审美要好,显然我不具备(嘻嘻). <a id=\"more\"></a></p>\n<h2 id=\"jekyll的工作流程\">jekyll的工作流程</h2>\n<p>sdfsd lkdk</p>\n","site":{"data":{}},"excerpt":"<p>房子需要装修,博客也需要装修.而通过<strong>markdown</strong>+<strong>jekyll</strong>+<strong>github</strong>搭建的博客是支持自定义自己的主题的.不过这需要对<strong>html</strong>,<strong>javascript</strong>,<strong>css</strong>有一定的了解.当然,要想自己的博客漂亮美观,自己的审美要好,显然我不具备(嘻嘻).","more":"</p>\n<h2 id=\"jekyll的工作流程\">jekyll的工作流程</h2>\n<p>sdfsd lkdk</p>"},{"layout":"draft","title":"宿营黄山","comments":1,"_content":"hulksdfjalk\n<!-- more -->\n","source":"_drafts/2015-08-01-宿营黄山.md","raw":"---\nlayout:\tdraft\ntitle:\t宿营黄山\ncategories:\n- LIFE\ntags:\n- Travel\npermalink:  Travel-huangshan\ncomments:\ttrue\n---\nhulksdfjalk\n<!-- more -->\n","slug":"Travel-huangshan","published":0,"date":"2015-07-31T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0e0002l73yw0xrvvgv","content":"<p>hulksdfjalk <a id=\"more\"></a></p>\n","site":{"data":{}},"excerpt":"<p>hulksdfjalk","more":"</p>"},{"layout":"post","title":"C程序的内存管理","comments":1,"date":"2017-03-21T01:49:07.000Z","_content":"\n\n","source":"_drafts/2017-03-21-C程序的内存管理.md","raw":"---\nlayout: post\ntitle: C程序的内存管理\ncategories:\n  - TECHNOLOGY\ntags:\n  - C\n  - Memory\ncomments: true\ndate: 2017-03-21 09:49:07\npermalink: manage-memory-c\n---\n\n\n","slug":"manage-memory-c","published":0,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0g0003l73yfd3bud71","content":"\n","site":{"data":{}},"excerpt":"","more":"\n"},{"layout":"draft","title":"VIM配置之终结篇","comments":1,"_content":"details\n<!-- more -->\n\n\n## section\n\n\n\n## 参考文献\n1. [Vimer的程序世界][vimer_world]\n2. [面向前段开发者和TextMate粉丝的vim配置][vim_fronter]\n\n[vimer_world]:  http://www.vimer.cn/\n[vim_fronter]:  http://www.limboy.com/2009/05/30/vim-setting/\n","source":"_drafts/2015-11-28-VIM配置之终结篇.md","raw":"---\nlayout:\tdraft\ntitle:\tVIM配置之终结篇\ncategories:\n- TECHNOLOGY\ntags:\n- Vim\n- Plugin\npermalink:  Explore-ultimate-vim\ncomments:\ttrue\n---\ndetails\n<!-- more -->\n\n\n## section\n\n\n\n## 参考文献\n1. [Vimer的程序世界][vimer_world]\n2. [面向前段开发者和TextMate粉丝的vim配置][vim_fronter]\n\n[vimer_world]:  http://www.vimer.cn/\n[vim_fronter]:  http://www.limboy.com/2009/05/30/vim-setting/\n","slug":"Explore-ultimate-vim","published":0,"date":"2015-11-27T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0g0004l73yg7zwwwe5","content":"<p>details <a id=\"more\"></a></p>\n<h2 id=\"section\">section</h2>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://www.vimer.cn/\" target=\"_blank\" rel=\"external\">Vimer的程序世界</a></li>\n<li><a href=\"http://www.limboy.com/2009/05/30/vim-setting/\" target=\"_blank\" rel=\"external\">面向前段开发者和TextMate粉丝的vim配置</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>details","more":"</p>\n<h2 id=\"section\">section</h2>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://www.vimer.cn/\" target=\"_blank\" rel=\"external\">Vimer的程序世界</a></li>\n<li><a href=\"http://www.limboy.com/2009/05/30/vim-setting/\" target=\"_blank\" rel=\"external\">面向前段开发者和TextMate粉丝的vim配置</a></li>\n</ol>"},{"layout":"draft","title":"程序中的存储区","comments":1,"_content":"details\n<!-- more -->\n\nlet me see see\n## section\n\n\n\n## 参考文献\n1. [C/C++堆、栈、自由存储区、全局/静态存储区和常量存储区][c_mem1]\n2. [C语言的存储区][c_mem2]\n3. [C/C++堆、栈及静态数据区详解][c_mem3]\n4. [内存区划分、内存分配、常量存储区、堆、栈、自由存储区、全局区][c_mem4]\n5. [字符串常量到底存放在哪个存储区][c_mem5]\n\n[c_mem1]:   http://my.oschina.net/liangtee/blog/126728?fromerr=g4g4n4aW\n[c_mem2]:   http://www.cnblogs.com/shiney/archive/2011/10/12/2208626.html\n[c_mem3]:   http://www.cnblogs.com/hanyonglu/archive/2011/04/12/2014212.html\n[c_mem4]:   http://www.cnblogs.com/JCSU/articles/1051579.html\n[c_mem5]:   http://blog.csdn.net/daiyutage/article/details/8605580\n","source":"_drafts/2015-11-22-程序中的存储区.md","raw":"---\nlayout:\tdraft\ntitle:  程序中的存储区\ncategories:\n- TECHNOLOGY\ntags:\n- OS\n- C\n- C++\npermalink:  Explore-memory-inC\ncomments:\ttrue\n---\ndetails\n<!-- more -->\n\nlet me see see\n## section\n\n\n\n## 参考文献\n1. [C/C++堆、栈、自由存储区、全局/静态存储区和常量存储区][c_mem1]\n2. [C语言的存储区][c_mem2]\n3. [C/C++堆、栈及静态数据区详解][c_mem3]\n4. [内存区划分、内存分配、常量存储区、堆、栈、自由存储区、全局区][c_mem4]\n5. [字符串常量到底存放在哪个存储区][c_mem5]\n\n[c_mem1]:   http://my.oschina.net/liangtee/blog/126728?fromerr=g4g4n4aW\n[c_mem2]:   http://www.cnblogs.com/shiney/archive/2011/10/12/2208626.html\n[c_mem3]:   http://www.cnblogs.com/hanyonglu/archive/2011/04/12/2014212.html\n[c_mem4]:   http://www.cnblogs.com/JCSU/articles/1051579.html\n[c_mem5]:   http://blog.csdn.net/daiyutage/article/details/8605580\n","slug":"Explore-memory-inC","published":0,"date":"2015-11-21T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0i0005l73yh176v40r","content":"<p>details <a id=\"more\"></a></p>\n<p>let me see see ## section</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://my.oschina.net/liangtee/blog/126728?fromerr=g4g4n4aW\" target=\"_blank\" rel=\"external\">C/C++堆、栈、自由存储区、全局/静态存储区和常量存储区</a></li>\n<li><a href=\"http://www.cnblogs.com/shiney/archive/2011/10/12/2208626.html\" target=\"_blank\" rel=\"external\">C语言的存储区</a></li>\n<li><a href=\"http://www.cnblogs.com/hanyonglu/archive/2011/04/12/2014212.html\" target=\"_blank\" rel=\"external\">C/C++堆、栈及静态数据区详解</a></li>\n<li><a href=\"http://www.cnblogs.com/JCSU/articles/1051579.html\" target=\"_blank\" rel=\"external\">内存区划分、内存分配、常量存储区、堆、栈、自由存储区、全局区</a></li>\n<li><a href=\"http://blog.csdn.net/daiyutage/article/details/8605580\" target=\"_blank\" rel=\"external\">字符串常量到底存放在哪个存储区</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>details","more":"</p>\n<p>let me see see ## section</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://my.oschina.net/liangtee/blog/126728?fromerr=g4g4n4aW\" target=\"_blank\" rel=\"external\">C/C++堆、栈、自由存储区、全局/静态存储区和常量存储区</a></li>\n<li><a href=\"http://www.cnblogs.com/shiney/archive/2011/10/12/2208626.html\" target=\"_blank\" rel=\"external\">C语言的存储区</a></li>\n<li><a href=\"http://www.cnblogs.com/hanyonglu/archive/2011/04/12/2014212.html\" target=\"_blank\" rel=\"external\">C/C++堆、栈及静态数据区详解</a></li>\n<li><a href=\"http://www.cnblogs.com/JCSU/articles/1051579.html\" target=\"_blank\" rel=\"external\">内存区划分、内存分配、常量存储区、堆、栈、自由存储区、全局区</a></li>\n<li><a href=\"http://blog.csdn.net/daiyutage/article/details/8605580\" target=\"_blank\" rel=\"external\">字符串常量到底存放在哪个存储区</a></li>\n</ol>"},{"layout":"post","title":"以Gimp为手K天P地之简介","comments":1,"_content":"随着大学生活的告一段落,新的征途已经开始了.由于比较喜欢旅游,比较喜欢拍照,比较喜欢处理图片,所以打算在照片处理上下点功夫.在windows里面,提到专业的图像处理软件当属Photoshop了,而另外一款强大的专业的跨平台的位图处理软件Gimp知道的并不多,而且其性能不下于Photoshop.\n<!-- more -->\n\n\n## 简介\nGimp是The GNU Image Manipulation Program的简称,是一套跨平台开发原始码图像处理软件，是遵循GNU授权条款发布的自由软件，可以在GNU/Linux、MS Windows、Mac OS X等平台下运行，能够实现多种图像处理方面的要求，包括照片润饰、图像合成和创建图像等.\n\n## 比较\n相比较于Photoshop,Gimp有如下优点:  \n\n* 安装文件大小  \n\tGimp只有13.4m(ubuntu12.04lts软件中心),而即使是精简版的ps最起码的上百m.  \n* 处理图片能力  \n\t不能说Gimp比Photoshop高明多少,但是最起码可以各有特色来形容吧.关键是Gimp的脚本批处理功能相当强悍.  \n* 跨平台性　　\n\t显然Gimp完胜.\n\n## 选择缘由\n我之所以选Gimp,一方面因为想要将自己的工作环境换到Linux下,另一方面是Photoshop学过点,想要学些新东西,趁机通过Gimp来回顾下Photoshop.\n\n## 计划\n* 熟悉Gimp的工具箱\n* 熟悉Gimp的常用滤镜\n* 熟悉Gimp的编程处理\n","source":"_posts/2013-06-18-以Gimp为手K天P地之简介.md","raw":"---\nlayout:\tpost\ntitle:\t以Gimp为手K天P地之简介\ncategories:\n- TECHNOLOGY\ntags:\n- Gimp\npermalink:  Explore-introduce-Gimp\ncomments:\ttrue\n---\n随着大学生活的告一段落,新的征途已经开始了.由于比较喜欢旅游,比较喜欢拍照,比较喜欢处理图片,所以打算在照片处理上下点功夫.在windows里面,提到专业的图像处理软件当属Photoshop了,而另外一款强大的专业的跨平台的位图处理软件Gimp知道的并不多,而且其性能不下于Photoshop.\n<!-- more -->\n\n\n## 简介\nGimp是The GNU Image Manipulation Program的简称,是一套跨平台开发原始码图像处理软件，是遵循GNU授权条款发布的自由软件，可以在GNU/Linux、MS Windows、Mac OS X等平台下运行，能够实现多种图像处理方面的要求，包括照片润饰、图像合成和创建图像等.\n\n## 比较\n相比较于Photoshop,Gimp有如下优点:  \n\n* 安装文件大小  \n\tGimp只有13.4m(ubuntu12.04lts软件中心),而即使是精简版的ps最起码的上百m.  \n* 处理图片能力  \n\t不能说Gimp比Photoshop高明多少,但是最起码可以各有特色来形容吧.关键是Gimp的脚本批处理功能相当强悍.  \n* 跨平台性　　\n\t显然Gimp完胜.\n\n## 选择缘由\n我之所以选Gimp,一方面因为想要将自己的工作环境换到Linux下,另一方面是Photoshop学过点,想要学些新东西,趁机通过Gimp来回顾下Photoshop.\n\n## 计划\n* 熟悉Gimp的工具箱\n* 熟悉Gimp的常用滤镜\n* 熟悉Gimp的编程处理\n","slug":"Explore-introduce-Gimp","published":1,"date":"2013-06-17T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0j0006l73ybtfghnyu","content":"<p>随着大学生活的告一段落,新的征途已经开始了.由于比较喜欢旅游,比较喜欢拍照,比较喜欢处理图片,所以打算在照片处理上下点功夫.在windows里面,提到专业的图像处理软件当属Photoshop了,而另外一款强大的专业的跨平台的位图处理软件Gimp知道的并不多,而且其性能不下于Photoshop. <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p>Gimp是The GNU Image Manipulation Program的简称,是一套跨平台开发原始码图像处理软件，是遵循GNU授权条款发布的自由软件，可以在GNU/Linux、MS Windows、Mac OS X等平台下运行，能够实现多种图像处理方面的要求，包括照片润饰、图像合成和创建图像等.</p>\n<h2 id=\"比较\">比较</h2>\n<p>相比较于Photoshop,Gimp有如下优点:</p>\n<ul>\n<li>安装文件大小<br>\nGimp只有13.4m(ubuntu12.04lts软件中心),而即使是精简版的ps最起码的上百m.<br>\n</li>\n<li>处理图片能力<br>\n不能说Gimp比Photoshop高明多少,但是最起码可以各有特色来形容吧.关键是Gimp的脚本批处理功能相当强悍.<br>\n</li>\n<li>跨平台性　　 显然Gimp完胜.</li>\n</ul>\n<h2 id=\"选择缘由\">选择缘由</h2>\n<p>我之所以选Gimp,一方面因为想要将自己的工作环境换到Linux下,另一方面是Photoshop学过点,想要学些新东西,趁机通过Gimp来回顾下Photoshop.</p>\n<h2 id=\"计划\">计划</h2>\n<ul>\n<li>熟悉Gimp的工具箱</li>\n<li>熟悉Gimp的常用滤镜</li>\n<li>熟悉Gimp的编程处理</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>随着大学生活的告一段落,新的征途已经开始了.由于比较喜欢旅游,比较喜欢拍照,比较喜欢处理图片,所以打算在照片处理上下点功夫.在windows里面,提到专业的图像处理软件当属Photoshop了,而另外一款强大的专业的跨平台的位图处理软件Gimp知道的并不多,而且其性能不下于Photoshop.","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p>Gimp是The GNU Image Manipulation Program的简称,是一套跨平台开发原始码图像处理软件，是遵循GNU授权条款发布的自由软件，可以在GNU/Linux、MS Windows、Mac OS X等平台下运行，能够实现多种图像处理方面的要求，包括照片润饰、图像合成和创建图像等.</p>\n<h2 id=\"比较\">比较</h2>\n<p>相比较于Photoshop,Gimp有如下优点:</p>\n<ul>\n<li>安装文件大小<br>\nGimp只有13.4m(ubuntu12.04lts软件中心),而即使是精简版的ps最起码的上百m.<br>\n</li>\n<li>处理图片能力<br>\n不能说Gimp比Photoshop高明多少,但是最起码可以各有特色来形容吧.关键是Gimp的脚本批处理功能相当强悍.<br>\n</li>\n<li>跨平台性　　 显然Gimp完胜.</li>\n</ul>\n<h2 id=\"选择缘由\">选择缘由</h2>\n<p>我之所以选Gimp,一方面因为想要将自己的工作环境换到Linux下,另一方面是Photoshop学过点,想要学些新东西,趁机通过Gimp来回顾下Photoshop.</p>\n<h2 id=\"计划\">计划</h2>\n<ul>\n<li>熟悉Gimp的工具箱</li>\n<li>熟悉Gimp的常用滤镜</li>\n<li>熟悉Gimp的编程处理</li>\n</ul>"},{"layout":"post","title":"ubuntu制作usb启动盘","comments":1,"_content":"常年与计算机为伴,免不了要经常给计算机安装系统.而重装系统当然需要工具.光盘安装,读取太慢;硬盘安装,需要一个大前提:电脑能正常工作,一旦电脑无法正常开机,该方法无效.现在u盘非常普及,所以用usb作系统启动盘能很好的解决上面的两个问题.\n<!-- more -->\n\n\n## 准备工作\n\n* u盘\n* ISO镜像文件 -- [ubuntukylin-14.04.2-desktop-amd64.iso](http://www.ubuntukylin.com/downloads/download.php?id=38)\n* 烧盘软件 -- unetbootin-linux-583\n\n\t```bash\n\tsudo apt-get install unetbootin\n\t```\n\n## 格式化u盘\n\n* 查看u盘信息\n\n\t```bash\n\tmount\n\t```\n\t> u盘信息:  \n\t> /dev/sdb1 on /media/KINGSTON type vfat (rw,nosuid,nodev,uid=1000,gid=1000,shortname=mixed,dmask=0077,utf8=1,showexec,flush,uhelper=udisks)\n* 卸载u盘\n\n\t```bash\n\tumount /media/KINGSTON\n\t```\n* 格式化\n\n\t```bash\n\tmkfs -t vfat /dev/sdb1\n\t```\t \n\n## 启动并设置unetbootin-linux-583参数\n\n* 参数设置\n\n\t![图片]({{ site.baseurl }}/assets/images/ubuntu_unetbootin_set.png)\n\t> **注意：**  \n\t> 软件能够识别u盘--u盘一定要插在电脑上\n","source":"_posts/2013-07-20-ubuntu制作usb启动盘.md","raw":"---\nlayout:\tpost\ntitle:\tubuntu制作usb启动盘\ncategories:\n- TECHNOLOGY\ntags:\n- Ubuntu\n- Software\npermalink:  Make-startupDisk\ncomments:\ttrue\n---\n常年与计算机为伴,免不了要经常给计算机安装系统.而重装系统当然需要工具.光盘安装,读取太慢;硬盘安装,需要一个大前提:电脑能正常工作,一旦电脑无法正常开机,该方法无效.现在u盘非常普及,所以用usb作系统启动盘能很好的解决上面的两个问题.\n<!-- more -->\n\n\n## 准备工作\n\n* u盘\n* ISO镜像文件 -- [ubuntukylin-14.04.2-desktop-amd64.iso](http://www.ubuntukylin.com/downloads/download.php?id=38)\n* 烧盘软件 -- unetbootin-linux-583\n\n\t```bash\n\tsudo apt-get install unetbootin\n\t```\n\n## 格式化u盘\n\n* 查看u盘信息\n\n\t```bash\n\tmount\n\t```\n\t> u盘信息:  \n\t> /dev/sdb1 on /media/KINGSTON type vfat (rw,nosuid,nodev,uid=1000,gid=1000,shortname=mixed,dmask=0077,utf8=1,showexec,flush,uhelper=udisks)\n* 卸载u盘\n\n\t```bash\n\tumount /media/KINGSTON\n\t```\n* 格式化\n\n\t```bash\n\tmkfs -t vfat /dev/sdb1\n\t```\t \n\n## 启动并设置unetbootin-linux-583参数\n\n* 参数设置\n\n\t![图片]({{ site.baseurl }}/assets/images/ubuntu_unetbootin_set.png)\n\t> **注意：**  \n\t> 软件能够识别u盘--u盘一定要插在电脑上\n","slug":"Make-startupDisk","published":1,"date":"2013-07-19T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0k0007l73y7y12gd8y","content":"<p>常年与计算机为伴,免不了要经常给计算机安装系统.而重装系统当然需要工具.光盘安装,读取太慢;硬盘安装,需要一个大前提:电脑能正常工作,一旦电脑无法正常开机,该方法无效.现在u盘非常普及,所以用usb作系统启动盘能很好的解决上面的两个问题. <a id=\"more\"></a></p>\n<h2 id=\"准备工作\">准备工作</h2>\n<ul>\n<li>u盘</li>\n<li>ISO镜像文件 – <a href=\"http://www.ubuntukylin.com/downloads/download.php?id=38\" target=\"_blank\" rel=\"external\">ubuntukylin-14.04.2-desktop-amd64.iso</a></li>\n<li><p>烧盘软件 – unetbootin-linux-583</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install unetbootin</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"格式化u盘\">格式化u盘</h2>\n<ul>\n<li><p>查看u盘信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mount</div></pre></td></tr></table></figure>\n<blockquote>\n<p>u盘信息:<br>\n/dev/sdb1 on /media/KINGSTON type vfat (rw,nosuid,nodev,uid=1000,gid=1000,shortname=mixed,dmask=0077,utf8=1,showexec,flush,uhelper=udisks)</p>\n</blockquote></li>\n<li><p>卸载u盘</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">umount /media/KINGSTON</div></pre></td></tr></table></figure></li>\n<li><p>格式化</p>\n<div class=\"sourceCode\"><pre class=\"sourceCode bash\"><code class=\"sourceCode bash\"><span class=\"ex\">mkfs</span> -t vfat /dev/sdb1</code></pre></div></li>\n</ul>\n<h2 id=\"启动并设置unetbootin-linux-583参数\">启动并设置unetbootin-linux-583参数</h2>\n<ul>\n<li><p>参数设置</p>\n<p>[图片](/assets/images/ubuntu_unetbootin_set.png) &gt; <strong>注意：</strong><br>\n&gt; 软件能够识别u盘–u盘一定要插在电脑上</p></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>常年与计算机为伴,免不了要经常给计算机安装系统.而重装系统当然需要工具.光盘安装,读取太慢;硬盘安装,需要一个大前提:电脑能正常工作,一旦电脑无法正常开机,该方法无效.现在u盘非常普及,所以用usb作系统启动盘能很好的解决上面的两个问题.","more":"</p>\n<h2 id=\"准备工作\">准备工作</h2>\n<ul>\n<li>u盘</li>\n<li>ISO镜像文件 – <a href=\"http://www.ubuntukylin.com/downloads/download.php?id=38\" target=\"_blank\" rel=\"external\">ubuntukylin-14.04.2-desktop-amd64.iso</a></li>\n<li><p>烧盘软件 – unetbootin-linux-583</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install unetbootin</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"格式化u盘\">格式化u盘</h2>\n<ul>\n<li><p>查看u盘信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mount</div></pre></td></tr></table></figure>\n<blockquote>\n<p>u盘信息:<br>\n/dev/sdb1 on /media/KINGSTON type vfat (rw,nosuid,nodev,uid=1000,gid=1000,shortname=mixed,dmask=0077,utf8=1,showexec,flush,uhelper=udisks)</p>\n</blockquote></li>\n<li><p>卸载u盘</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">umount /media/KINGSTON</div></pre></td></tr></table></figure></li>\n<li><p>格式化</p>\n<div class=\"sourceCode\"><pre class=\"sourceCode bash\"><code class=\"sourceCode bash\"><span class=\"ex\">mkfs</span> -t vfat /dev/sdb1</code></pre></div></li>\n</ul>\n<h2 id=\"启动并设置unetbootin-linux-583参数\">启动并设置unetbootin-linux-583参数</h2>\n<ul>\n<li><p>参数设置</p>\n<p>[图片](/assets/images/ubuntu_unetbootin_set.png) &gt; <strong>注意：</strong><br>\n&gt; 软件能够识别u盘–u盘一定要插在电脑上</p></li>\n</ul>"},{"layout":"post","title":"C程序编程四步走","comments":1,"date":"2017-03-21T02:02:16.000Z","_content":"\n任何一个C程序代码到生成一个可执行文件都需要四步，分别是预处理`Pre-processing`，编译`Compiling`，汇编`Assembling`和链接`Link`，这里借助Gcc工具来探究这四步分别做了什么事，起到什么样的作用。本文使用的测试代码是经典入门程序\"Hello World!\"。\n<!-- more -->\n\n## 测试环境\n为探究预处理，编译，汇编和链接的功能，我们在Ubuntu系统中使用Gcc编译器(version=4.8.4)，用简单的也是最经典的入门程序\"Hello World!\"作为测试代码。源文件{% asset_link hello.c hello.c %}代码如下：\n```c\n// filename: hello.c\n# include <stdio.h>\n\nint man(void){\n  printf(\"Hello World!\");\n  return 0;\n}\n```\n正常情况我们都会执行命令`gcc hello.c -o hello.out`来生成二进制可执行程序hello.out。\n\n## [预处理][pre-processing]\nC预处理器是用在编译器处理程序之前，它预扫描源代码完成包含头文件，宏扩展，条件编译，行控制等功能。对于测试代码中，预处理器只对头文件进行了处理。获取预处理器输出的结果使用该命令`gcc -E hello.c -o hello.i`。\n由于{% asset_link hello.i hello.i %}文件内容比较多，这里截取部分进行说明。\n```c\n// filename: hello.i\n# 1 \"hello.c\"\n# 1 \"<built-in>\"\n# 1 \"<command-line>\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"<command-line>\" 2\n# 1 \"hello.c\"\n\n...\n# 1 \"/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h\" 1 3 4\n# 212 \"/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h\" 3 4\ntypedef long unsigned int size_t;\n\n...\n# 5 \"hello.c\" 2\n\nint main(){\n    printf(\"Hello World!\");\n    return 0;\n}\n```\n> **Tips:**\n> hello.i中有很多这样的格式`# line filename flags`，它表示下面行是由文件filename的第line行生成的。其中flags有1，2，3，4四种取值\n> * 1 代表新文件的开始\n> * 2 代表返回一个文件\n> * 3 代表下面的文本来自系统头文件，所以某些警告可以过滤掉\n> * 4 代表下面的文本应该包含在extern C块中\n按照提示stddef.h文件中第212行有size_t的宏定义。\n\n## [编译][compile]\n编译的过程是将某种编程语言写的源代码（这里特指C语言）转换成另一种编程语言（这里特指汇编语言）。前面我们将{% asset_link hello.c hello.c %}预处理成了{% asset_link hello.i hello.i %}文件，现在就要将{% asset_link hello.i hello.i %}文件编译成{% asset_link hello.s hello.s %}汇编文件。获取编译器输出的结果使用命令`gcc -S hello.i -o hello.s`。汇编结果见{% asset_link hello.s hello.s%}。\n```c\n\t.file\t\"hello.c\"\n\t.section\t.rodata\n.LC0:\n\t.string\t\"Hello World!\"\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB0:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tmovl\t$.LC0, %edi\n\tmovl\t$0, %eax\n\tcall\tprintf\n\tmovl\t$0, %eax\n\tpopq\t%rbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE0:\n\t.size\tmain, .-main\n\t.ident\t\"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n```\n\n## [汇编][assemble]\n汇编的过程是将汇编语言编写的源码转换成可执行的机器代码，通常目标文件中包含至少两个段：代码段和数据段。其中代码段包含程序的指令，一般可读和可执行，不可写；数据段用来存放程序中所用到的各种全局变量或静态数据，一般可读，可写，可执行。获取汇编器输出的结果使用该命令`gcc -S hello.s -o hello.o`，由于{% asset_link hello.o hello.o%}是二进制文件，是无法阅读的。这里我们通过命令`objdump`来对二进制文件进行反汇编，查看里面内容。\n```c\n// objdump -d hello.o 查看hello.o中代码段信息\nhello.o：     文件格式 elf64-x86-64\n\nDisassembly of section .text:\n\n0000000000000000 <main>:\n   0:\t55                   \tpush   %rbp\n   1:\t48 89 e5             \tmov    %rsp,%rbp\n   4:\tbf 00 00 00 00       \tmov    $0x0,%edi\n   9:\tb8 00 00 00 00       \tmov    $0x0,%eax\n   e:\te8 00 00 00 00       \tcallq  13 <main+0x13>\n  13:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  18:\t5d                   \tpop    %rbp\n  19:\tc3                   \tretq\n```\nhello.o中各段信息如下：\n```c\n// objdump -h hello.o 显示hello.o中各个段的头部信息\nhello.o：     文件格式 elf64-x86-64\n\n节：\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .text         0000001a  0000000000000000  0000000000000000  00000040  2**0\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n  1 .data         00000000  0000000000000000  0000000000000000  0000005a  2**0\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000000  0000000000000000  0000000000000000  0000005a  2**0\n                  ALLOC\n  3 .rodata       0000000d  0000000000000000  0000000000000000  0000005a  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .comment      0000002c  0000000000000000  0000000000000000  00000067  2**0\n                  CONTENTS, READONLY\n  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000093  2**0\n                  CONTENTS, READONLY\n  6 .eh_frame     00000038  0000000000000000  0000000000000000  00000098  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA\n```\n\n## [链接][linker]\n链接的过程是将一个或多个由编译器或汇编器生成的目标文件链接库（静态库或动态库）形成可执行文件。其中静态库会和汇编生成的目标文件一起链接打包到可执行文件中【静态链接】，它对函数库的链接是放在编译时期完成的。而动态库在程序编译时不会被链接到可执行文件中，而是在程序运行时才会被载入【动态链接】。不同的应用程序如果调用相同的库，那么在内存中只需要一份该共享库实例。获取链接器链接后的可执行文件使用命令`gcc hello.o -o hello`。如果想看该可执行文件依赖的库，可以使用命令`ldd hello`。\n```bash\n# ldd hello 显示hello依赖的库\n\tlinux-vdso.so.1 =>  (0x00007ffc85980000)\n\tlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f06c7a53000)\n\t/lib64/ld-linux-x86-64.so.2 (0x000055ad7be9e000)\n```\n\n\n## 参考文献\n1. [预处理][pre-processing]\n2. [预处理-行号标记][linemarker]\n3. [编译器][compile]\n4. [汇编][assemble]\n5. [链接器][linker]\n\n[pre-processing]: https://zh.wikipedia.org/wiki/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8\n[linemarker]: https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html\n[compiler]: https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8\n[assemble]: https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80\n[linker]: https://zh.wikipedia.org/wiki/%E9%93%BE%E6%8E%A5%E5%99%A8\n","source":"_drafts/2017-03-21-C程序编程四步走.md","raw":"---\nlayout: post\ntitle: C程序编程四步走\ncategories:\n  - TECHNOLOGY\ntags:\n  - C\n  - GCC\n  - Compile\n  - Assemble\n  - Link\ncomments: true\ndate: 2017-03-21 10:02:16\npermalink: compile-gcc\n---\n\n任何一个C程序代码到生成一个可执行文件都需要四步，分别是预处理`Pre-processing`，编译`Compiling`，汇编`Assembling`和链接`Link`，这里借助Gcc工具来探究这四步分别做了什么事，起到什么样的作用。本文使用的测试代码是经典入门程序\"Hello World!\"。\n<!-- more -->\n\n## 测试环境\n为探究预处理，编译，汇编和链接的功能，我们在Ubuntu系统中使用Gcc编译器(version=4.8.4)，用简单的也是最经典的入门程序\"Hello World!\"作为测试代码。源文件{% asset_link hello.c hello.c %}代码如下：\n```c\n// filename: hello.c\n# include <stdio.h>\n\nint man(void){\n  printf(\"Hello World!\");\n  return 0;\n}\n```\n正常情况我们都会执行命令`gcc hello.c -o hello.out`来生成二进制可执行程序hello.out。\n\n## [预处理][pre-processing]\nC预处理器是用在编译器处理程序之前，它预扫描源代码完成包含头文件，宏扩展，条件编译，行控制等功能。对于测试代码中，预处理器只对头文件进行了处理。获取预处理器输出的结果使用该命令`gcc -E hello.c -o hello.i`。\n由于{% asset_link hello.i hello.i %}文件内容比较多，这里截取部分进行说明。\n```c\n// filename: hello.i\n# 1 \"hello.c\"\n# 1 \"<built-in>\"\n# 1 \"<command-line>\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"<command-line>\" 2\n# 1 \"hello.c\"\n\n...\n# 1 \"/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h\" 1 3 4\n# 212 \"/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h\" 3 4\ntypedef long unsigned int size_t;\n\n...\n# 5 \"hello.c\" 2\n\nint main(){\n    printf(\"Hello World!\");\n    return 0;\n}\n```\n> **Tips:**\n> hello.i中有很多这样的格式`# line filename flags`，它表示下面行是由文件filename的第line行生成的。其中flags有1，2，3，4四种取值\n> * 1 代表新文件的开始\n> * 2 代表返回一个文件\n> * 3 代表下面的文本来自系统头文件，所以某些警告可以过滤掉\n> * 4 代表下面的文本应该包含在extern C块中\n按照提示stddef.h文件中第212行有size_t的宏定义。\n\n## [编译][compile]\n编译的过程是将某种编程语言写的源代码（这里特指C语言）转换成另一种编程语言（这里特指汇编语言）。前面我们将{% asset_link hello.c hello.c %}预处理成了{% asset_link hello.i hello.i %}文件，现在就要将{% asset_link hello.i hello.i %}文件编译成{% asset_link hello.s hello.s %}汇编文件。获取编译器输出的结果使用命令`gcc -S hello.i -o hello.s`。汇编结果见{% asset_link hello.s hello.s%}。\n```c\n\t.file\t\"hello.c\"\n\t.section\t.rodata\n.LC0:\n\t.string\t\"Hello World!\"\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB0:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tmovl\t$.LC0, %edi\n\tmovl\t$0, %eax\n\tcall\tprintf\n\tmovl\t$0, %eax\n\tpopq\t%rbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE0:\n\t.size\tmain, .-main\n\t.ident\t\"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n```\n\n## [汇编][assemble]\n汇编的过程是将汇编语言编写的源码转换成可执行的机器代码，通常目标文件中包含至少两个段：代码段和数据段。其中代码段包含程序的指令，一般可读和可执行，不可写；数据段用来存放程序中所用到的各种全局变量或静态数据，一般可读，可写，可执行。获取汇编器输出的结果使用该命令`gcc -S hello.s -o hello.o`，由于{% asset_link hello.o hello.o%}是二进制文件，是无法阅读的。这里我们通过命令`objdump`来对二进制文件进行反汇编，查看里面内容。\n```c\n// objdump -d hello.o 查看hello.o中代码段信息\nhello.o：     文件格式 elf64-x86-64\n\nDisassembly of section .text:\n\n0000000000000000 <main>:\n   0:\t55                   \tpush   %rbp\n   1:\t48 89 e5             \tmov    %rsp,%rbp\n   4:\tbf 00 00 00 00       \tmov    $0x0,%edi\n   9:\tb8 00 00 00 00       \tmov    $0x0,%eax\n   e:\te8 00 00 00 00       \tcallq  13 <main+0x13>\n  13:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  18:\t5d                   \tpop    %rbp\n  19:\tc3                   \tretq\n```\nhello.o中各段信息如下：\n```c\n// objdump -h hello.o 显示hello.o中各个段的头部信息\nhello.o：     文件格式 elf64-x86-64\n\n节：\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .text         0000001a  0000000000000000  0000000000000000  00000040  2**0\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n  1 .data         00000000  0000000000000000  0000000000000000  0000005a  2**0\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000000  0000000000000000  0000000000000000  0000005a  2**0\n                  ALLOC\n  3 .rodata       0000000d  0000000000000000  0000000000000000  0000005a  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .comment      0000002c  0000000000000000  0000000000000000  00000067  2**0\n                  CONTENTS, READONLY\n  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000093  2**0\n                  CONTENTS, READONLY\n  6 .eh_frame     00000038  0000000000000000  0000000000000000  00000098  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA\n```\n\n## [链接][linker]\n链接的过程是将一个或多个由编译器或汇编器生成的目标文件链接库（静态库或动态库）形成可执行文件。其中静态库会和汇编生成的目标文件一起链接打包到可执行文件中【静态链接】，它对函数库的链接是放在编译时期完成的。而动态库在程序编译时不会被链接到可执行文件中，而是在程序运行时才会被载入【动态链接】。不同的应用程序如果调用相同的库，那么在内存中只需要一份该共享库实例。获取链接器链接后的可执行文件使用命令`gcc hello.o -o hello`。如果想看该可执行文件依赖的库，可以使用命令`ldd hello`。\n```bash\n# ldd hello 显示hello依赖的库\n\tlinux-vdso.so.1 =>  (0x00007ffc85980000)\n\tlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f06c7a53000)\n\t/lib64/ld-linux-x86-64.so.2 (0x000055ad7be9e000)\n```\n\n\n## 参考文献\n1. [预处理][pre-processing]\n2. [预处理-行号标记][linemarker]\n3. [编译器][compile]\n4. [汇编][assemble]\n5. [链接器][linker]\n\n[pre-processing]: https://zh.wikipedia.org/wiki/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8\n[linemarker]: https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html\n[compiler]: https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8\n[assemble]: https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80\n[linker]: https://zh.wikipedia.org/wiki/%E9%93%BE%E6%8E%A5%E5%99%A8\n","slug":"compile-gcc","published":0,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0o0008l73yjtb8sq1w","content":"<p>任何一个C程序代码到生成一个可执行文件都需要四步，分别是预处理<code>Pre-processing</code>，编译<code>Compiling</code>，汇编<code>Assembling</code>和链接<code>Link</code>，这里借助Gcc工具来探究这四步分别做了什么事，起到什么样的作用。本文使用的测试代码是经典入门程序“Hello World!”。 <a id=\"more\"></a></p>\n<h2 id=\"测试环境\">测试环境</h2>\n<p>为探究预处理，编译，汇编和链接的功能，我们在Ubuntu系统中使用Gcc编译器(version=4.8.4)，用简单的也是最经典的入门程序“Hello World!”作为测试代码。源文件<a href=\"/2017/03/21/compile-gcc/hello.c\" title=\"hello.c\">hello.c</a>代码如下： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// filename: hello.c</span></div><div class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">man</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>正常情况我们都会执行命令<code>gcc hello.c -o hello.out</code>来生成二进制可执行程序hello.out。</p>\n<h2 id=\"预处理pre-processing\"><a href=\"https://zh.wikipedia.org/wiki/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8\" target=\"_blank\" rel=\"external\">预处理</a></h2>\n<p>C预处理器是用在编译器处理程序之前，它预扫描源代码完成包含头文件，宏扩展，条件编译，行控制等功能。对于测试代码中，预处理器只对头文件进行了处理。获取预处理器输出的结果使用该命令<code>gcc -E hello.c -o hello.i</code>。 由于<a href=\"/2017/03/21/compile-gcc/hello.i\" title=\"hello.i\">hello.i</a>文件内容比较多，这里截取部分进行说明。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// filename: hello.i</span></div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"hello.c\"</span></div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"&lt;built-in&gt;\"</span></div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"&lt;command-line&gt;\"</span></div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"/usr/include/stdc-predef.h\"</span> <span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span></div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"&lt;command-line&gt;\"</span> <span class=\"number\">2</span></div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"hello.c\"</span></div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h\"</span> <span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span></div><div class=\"line\"># <span class=\"number\">212</span> <span class=\"string\">\"/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h\"</span> <span class=\"number\">3</span> <span class=\"number\">4</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"keyword\">size_t</span>;</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"># <span class=\"number\">5</span> <span class=\"string\">\"hello.c\"</span> <span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><strong>Tips:</strong> hello.i中有很多这样的格式<code># line filename flags</code>，它表示下面行是由文件filename的第line行生成的。其中flags有1，2，3，4四种取值 * 1 代表新文件的开始 * 2 代表返回一个文件 * 3 代表下面的文本来自系统头文件，所以某些警告可以过滤掉 * 4 代表下面的文本应该包含在extern C块中 按照提示stddef.h文件中第212行有size_t的宏定义。</p>\n</blockquote>\n<h2 id=\"编译compile\">[编译][compile]</h2>\n<p>编译的过程是将某种编程语言写的源代码（这里特指C语言）转换成另一种编程语言（这里特指汇编语言）。前面我们将<a href=\"/2017/03/21/compile-gcc/hello.c\" title=\"hello.c\">hello.c</a>预处理成了<a href=\"/2017/03/21/compile-gcc/hello.i\" title=\"hello.i\">hello.i</a>文件，现在就要将<a href=\"/2017/03/21/compile-gcc/hello.i\" title=\"hello.i\">hello.i</a>文件编译成<a href=\"/2017/03/21/compile-gcc/hello.s\" title=\"hello.s\">hello.s</a>汇编文件。获取编译器输出的结果使用命令<code>gcc -S hello.i -o hello.s</code>。汇编结果见<a href=\"/2017/03/21/compile-gcc/hello.s\" title=\"hello.s\">hello.s</a>。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t.file\t<span class=\"string\">\"hello.c\"</span></div><div class=\"line\">\t.section\t.rodata</div><div class=\"line\">.LC0:</div><div class=\"line\">\t.<span class=\"built_in\">string</span>\t<span class=\"string\">\"Hello World!\"</span></div><div class=\"line\">\t.text</div><div class=\"line\">\t.globl\tmain</div><div class=\"line\">\t.type\tmain, @function</div><div class=\"line\">main:</div><div class=\"line\">.LFB0:</div><div class=\"line\">\t.cfi_startproc</div><div class=\"line\">\tpushq\t%rbp</div><div class=\"line\">\t.cfi_def_cfa_offset <span class=\"number\">16</span></div><div class=\"line\">\t.cfi_offset <span class=\"number\">6</span>, <span class=\"number\">-16</span></div><div class=\"line\">\tmovq\t%rsp, %rbp</div><div class=\"line\">\t.cfi_def_cfa_register <span class=\"number\">6</span></div><div class=\"line\">\tmovl\t$.LC0, %edi</div><div class=\"line\">\tmovl\t$<span class=\"number\">0</span>, %eax</div><div class=\"line\">\tcall\t<span class=\"built_in\">printf</span></div><div class=\"line\">\tmovl\t$<span class=\"number\">0</span>, %eax</div><div class=\"line\">\tpopq\t%rbp</div><div class=\"line\">\t.cfi_def_cfa <span class=\"number\">7</span>, <span class=\"number\">8</span></div><div class=\"line\">\tret</div><div class=\"line\">\t.cfi_endproc</div><div class=\"line\">.LFE0:</div><div class=\"line\">\t.size\tmain, .-main</div><div class=\"line\">\t.ident\t<span class=\"string\">\"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4\"</span></div><div class=\"line\">\t.section\t.note.GNU-<span class=\"built_in\">stack</span>,<span class=\"string\">\"\"</span>,@progbits</div></pre></td></tr></table></figure></p>\n<h2 id=\"汇编assemble\"><a href=\"https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80\" target=\"_blank\" rel=\"external\">汇编</a></h2>\n<p>汇编的过程是将汇编语言编写的源码转换成可执行的机器代码，通常目标文件中包含至少两个段：代码段和数据段。其中代码段包含程序的指令，一般可读和可执行，不可写；数据段用来存放程序中所用到的各种全局变量或静态数据，一般可读，可写，可执行。获取汇编器输出的结果使用该命令<code>gcc -S hello.s -o hello.o</code>，由于是二进制文件，是无法阅读的。这里我们通过命令<code>objdump</code>来对二进制文件进行反汇编，查看里面内容。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// objdump -d hello.o 查看hello.o中代码段信息</span></div><div class=\"line\">hello.o：     文件格式 elf64-x86<span class=\"number\">-64</span></div><div class=\"line\"></div><div class=\"line\">Disassembly of section .text:</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">0000000000000000</span> &lt;main&gt;:</div><div class=\"line\">   <span class=\"number\">0</span>:\t<span class=\"number\">55</span>                   \tpush   %rbp</div><div class=\"line\">   <span class=\"number\">1</span>:\t<span class=\"number\">48</span> <span class=\"number\">89</span> e5             \tmov    %rsp,%rbp</div><div class=\"line\">   <span class=\"number\">4</span>:\tbf <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>       \tmov    $<span class=\"number\">0x0</span>,%edi</div><div class=\"line\">   <span class=\"number\">9</span>:\tb8 <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>       \tmov    $<span class=\"number\">0x0</span>,%eax</div><div class=\"line\">   e:\te8 <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>       \tcallq  <span class=\"number\">13</span> &lt;main+<span class=\"number\">0x13</span>&gt;</div><div class=\"line\">  <span class=\"number\">13</span>:\tb8 <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>       \tmov    $<span class=\"number\">0x0</span>,%eax</div><div class=\"line\">  <span class=\"number\">18</span>:\t<span class=\"number\">5</span>d                   \tpop    %rbp</div><div class=\"line\">  <span class=\"number\">19</span>:\tc3                   \tretq</div></pre></td></tr></table></figure></p>\n<p>hello.o中各段信息如下： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// objdump -h hello.o 显示hello.o中各个段的头部信息</span></div><div class=\"line\">hello.o：     文件格式 elf64-x86<span class=\"number\">-64</span></div><div class=\"line\"></div><div class=\"line\">节：</div><div class=\"line\">Idx Name          Size      VMA               LMA               File off  Algn</div><div class=\"line\">  <span class=\"number\">0</span> .text         <span class=\"number\">0000001</span>a  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000040</span>  <span class=\"number\">2</span>**<span class=\"number\">0</span></div><div class=\"line\">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</div><div class=\"line\">  <span class=\"number\">1</span> .data         <span class=\"number\">00000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000005</span>a  <span class=\"number\">2</span>**<span class=\"number\">0</span></div><div class=\"line\">                  CONTENTS, ALLOC, LOAD, DATA</div><div class=\"line\">  <span class=\"number\">2</span> .bss          <span class=\"number\">00000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000005</span>a  <span class=\"number\">2</span>**<span class=\"number\">0</span></div><div class=\"line\">                  ALLOC</div><div class=\"line\">  <span class=\"number\">3</span> .rodata       <span class=\"number\">0000000</span>d  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000005</span>a  <span class=\"number\">2</span>**<span class=\"number\">0</span></div><div class=\"line\">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class=\"line\">  <span class=\"number\">4</span> .comment      <span class=\"number\">0000002</span>c  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000067</span>  <span class=\"number\">2</span>**<span class=\"number\">0</span></div><div class=\"line\">                  CONTENTS, READONLY</div><div class=\"line\">  <span class=\"number\">5</span> .note.GNU-<span class=\"built_in\">stack</span> <span class=\"number\">00000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000093</span>  <span class=\"number\">2</span>**<span class=\"number\">0</span></div><div class=\"line\">                  CONTENTS, READONLY</div><div class=\"line\">  <span class=\"number\">6</span> .eh_frame     <span class=\"number\">00000038</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000098</span>  <span class=\"number\">2</span>**<span class=\"number\">3</span></div><div class=\"line\">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</div></pre></td></tr></table></figure></p>\n<h2 id=\"链接linker\"><a href=\"https://zh.wikipedia.org/wiki/%E9%93%BE%E6%8E%A5%E5%99%A8\" target=\"_blank\" rel=\"external\">链接</a></h2>\n<p>链接的过程是将一个或多个由编译器或汇编器生成的目标文件链接库（静态库或动态库）形成可执行文件。其中静态库会和汇编生成的目标文件一起链接打包到可执行文件中【静态链接】，它对函数库的链接是放在编译时期完成的。而动态库在程序编译时不会被链接到可执行文件中，而是在程序运行时才会被载入【动态链接】。不同的应用程序如果调用相同的库，那么在内存中只需要一份该共享库实例。获取链接器链接后的可执行文件使用命令<code>gcc hello.o -o hello</code>。如果想看该可执行文件依赖的库，可以使用命令<code>ldd hello</code>。 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># ldd hello 显示hello依赖的库</span></div><div class=\"line\">\tlinux-vdso.so.1 =&gt;  (0x00007ffc85980000)</div><div class=\"line\">\tlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f06c7a53000)</div><div class=\"line\">\t/lib64/ld-linux-x86-64.so.2 (0x000055ad7be9e000)</div></pre></td></tr></table></figure></p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://zh.wikipedia.org/wiki/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8\" target=\"_blank\" rel=\"external\">预处理</a></li>\n<li><a href=\"https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html\" target=\"_blank\" rel=\"external\">预处理-行号标记</a></li>\n<li>[编译器][compile]</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80\" target=\"_blank\" rel=\"external\">汇编</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E9%93%BE%E6%8E%A5%E5%99%A8\" target=\"_blank\" rel=\"external\">链接器</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>任何一个C程序代码到生成一个可执行文件都需要四步，分别是预处理<code>Pre-processing</code>，编译<code>Compiling</code>，汇编<code>Assembling</code>和链接<code>Link</code>，这里借助Gcc工具来探究这四步分别做了什么事，起到什么样的作用。本文使用的测试代码是经典入门程序“Hello World!”。","more":"</p>\n<h2 id=\"测试环境\">测试环境</h2>\n<p>为探究预处理，编译，汇编和链接的功能，我们在Ubuntu系统中使用Gcc编译器(version=4.8.4)，用简单的也是最经典的入门程序“Hello World!”作为测试代码。源文件<a href=\"/2017/03/21/compile-gcc/hello.c\" title=\"hello.c\">hello.c</a>代码如下： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// filename: hello.c</span></div><div class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">man</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>正常情况我们都会执行命令<code>gcc hello.c -o hello.out</code>来生成二进制可执行程序hello.out。</p>\n<h2 id=\"预处理pre-processing\"><a href=\"https://zh.wikipedia.org/wiki/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8\" target=\"_blank\" rel=\"external\">预处理</a></h2>\n<p>C预处理器是用在编译器处理程序之前，它预扫描源代码完成包含头文件，宏扩展，条件编译，行控制等功能。对于测试代码中，预处理器只对头文件进行了处理。获取预处理器输出的结果使用该命令<code>gcc -E hello.c -o hello.i</code>。 由于<a href=\"/2017/03/21/compile-gcc/hello.i\" title=\"hello.i\">hello.i</a>文件内容比较多，这里截取部分进行说明。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// filename: hello.i</span></div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"hello.c\"</span></div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"&lt;built-in&gt;\"</span></div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"&lt;command-line&gt;\"</span></div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"/usr/include/stdc-predef.h\"</span> <span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span></div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"&lt;command-line&gt;\"</span> <span class=\"number\">2</span></div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"hello.c\"</span></div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">\"/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h\"</span> <span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span></div><div class=\"line\"># <span class=\"number\">212</span> <span class=\"string\">\"/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h\"</span> <span class=\"number\">3</span> <span class=\"number\">4</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"keyword\">size_t</span>;</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"># <span class=\"number\">5</span> <span class=\"string\">\"hello.c\"</span> <span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><strong>Tips:</strong> hello.i中有很多这样的格式<code># line filename flags</code>，它表示下面行是由文件filename的第line行生成的。其中flags有1，2，3，4四种取值 * 1 代表新文件的开始 * 2 代表返回一个文件 * 3 代表下面的文本来自系统头文件，所以某些警告可以过滤掉 * 4 代表下面的文本应该包含在extern C块中 按照提示stddef.h文件中第212行有size_t的宏定义。</p>\n</blockquote>\n<h2 id=\"编译compile\">[编译][compile]</h2>\n<p>编译的过程是将某种编程语言写的源代码（这里特指C语言）转换成另一种编程语言（这里特指汇编语言）。前面我们将<a href=\"/2017/03/21/compile-gcc/hello.c\" title=\"hello.c\">hello.c</a>预处理成了<a href=\"/2017/03/21/compile-gcc/hello.i\" title=\"hello.i\">hello.i</a>文件，现在就要将<a href=\"/2017/03/21/compile-gcc/hello.i\" title=\"hello.i\">hello.i</a>文件编译成<a href=\"/2017/03/21/compile-gcc/hello.s\" title=\"hello.s\">hello.s</a>汇编文件。获取编译器输出的结果使用命令<code>gcc -S hello.i -o hello.s</code>。汇编结果见<a href=\"/2017/03/21/compile-gcc/hello.s\" title=\"hello.s\">hello.s</a>。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t.file\t<span class=\"string\">\"hello.c\"</span></div><div class=\"line\">\t.section\t.rodata</div><div class=\"line\">.LC0:</div><div class=\"line\">\t.<span class=\"built_in\">string</span>\t<span class=\"string\">\"Hello World!\"</span></div><div class=\"line\">\t.text</div><div class=\"line\">\t.globl\tmain</div><div class=\"line\">\t.type\tmain, @function</div><div class=\"line\">main:</div><div class=\"line\">.LFB0:</div><div class=\"line\">\t.cfi_startproc</div><div class=\"line\">\tpushq\t%rbp</div><div class=\"line\">\t.cfi_def_cfa_offset <span class=\"number\">16</span></div><div class=\"line\">\t.cfi_offset <span class=\"number\">6</span>, <span class=\"number\">-16</span></div><div class=\"line\">\tmovq\t%rsp, %rbp</div><div class=\"line\">\t.cfi_def_cfa_register <span class=\"number\">6</span></div><div class=\"line\">\tmovl\t$.LC0, %edi</div><div class=\"line\">\tmovl\t$<span class=\"number\">0</span>, %eax</div><div class=\"line\">\tcall\t<span class=\"built_in\">printf</span></div><div class=\"line\">\tmovl\t$<span class=\"number\">0</span>, %eax</div><div class=\"line\">\tpopq\t%rbp</div><div class=\"line\">\t.cfi_def_cfa <span class=\"number\">7</span>, <span class=\"number\">8</span></div><div class=\"line\">\tret</div><div class=\"line\">\t.cfi_endproc</div><div class=\"line\">.LFE0:</div><div class=\"line\">\t.size\tmain, .-main</div><div class=\"line\">\t.ident\t<span class=\"string\">\"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4\"</span></div><div class=\"line\">\t.section\t.note.GNU-<span class=\"built_in\">stack</span>,<span class=\"string\">\"\"</span>,@progbits</div></pre></td></tr></table></figure></p>\n<h2 id=\"汇编assemble\"><a href=\"https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80\" target=\"_blank\" rel=\"external\">汇编</a></h2>\n<p>汇编的过程是将汇编语言编写的源码转换成可执行的机器代码，通常目标文件中包含至少两个段：代码段和数据段。其中代码段包含程序的指令，一般可读和可执行，不可写；数据段用来存放程序中所用到的各种全局变量或静态数据，一般可读，可写，可执行。获取汇编器输出的结果使用该命令<code>gcc -S hello.s -o hello.o</code>，由于是二进制文件，是无法阅读的。这里我们通过命令<code>objdump</code>来对二进制文件进行反汇编，查看里面内容。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// objdump -d hello.o 查看hello.o中代码段信息</span></div><div class=\"line\">hello.o：     文件格式 elf64-x86<span class=\"number\">-64</span></div><div class=\"line\"></div><div class=\"line\">Disassembly of section .text:</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">0000000000000000</span> &lt;main&gt;:</div><div class=\"line\">   <span class=\"number\">0</span>:\t<span class=\"number\">55</span>                   \tpush   %rbp</div><div class=\"line\">   <span class=\"number\">1</span>:\t<span class=\"number\">48</span> <span class=\"number\">89</span> e5             \tmov    %rsp,%rbp</div><div class=\"line\">   <span class=\"number\">4</span>:\tbf <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>       \tmov    $<span class=\"number\">0x0</span>,%edi</div><div class=\"line\">   <span class=\"number\">9</span>:\tb8 <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>       \tmov    $<span class=\"number\">0x0</span>,%eax</div><div class=\"line\">   e:\te8 <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>       \tcallq  <span class=\"number\">13</span> &lt;main+<span class=\"number\">0x13</span>&gt;</div><div class=\"line\">  <span class=\"number\">13</span>:\tb8 <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>       \tmov    $<span class=\"number\">0x0</span>,%eax</div><div class=\"line\">  <span class=\"number\">18</span>:\t<span class=\"number\">5</span>d                   \tpop    %rbp</div><div class=\"line\">  <span class=\"number\">19</span>:\tc3                   \tretq</div></pre></td></tr></table></figure></p>\n<p>hello.o中各段信息如下： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// objdump -h hello.o 显示hello.o中各个段的头部信息</span></div><div class=\"line\">hello.o：     文件格式 elf64-x86<span class=\"number\">-64</span></div><div class=\"line\"></div><div class=\"line\">节：</div><div class=\"line\">Idx Name          Size      VMA               LMA               File off  Algn</div><div class=\"line\">  <span class=\"number\">0</span> .text         <span class=\"number\">0000001</span>a  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000040</span>  <span class=\"number\">2</span>**<span class=\"number\">0</span></div><div class=\"line\">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</div><div class=\"line\">  <span class=\"number\">1</span> .data         <span class=\"number\">00000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000005</span>a  <span class=\"number\">2</span>**<span class=\"number\">0</span></div><div class=\"line\">                  CONTENTS, ALLOC, LOAD, DATA</div><div class=\"line\">  <span class=\"number\">2</span> .bss          <span class=\"number\">00000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000005</span>a  <span class=\"number\">2</span>**<span class=\"number\">0</span></div><div class=\"line\">                  ALLOC</div><div class=\"line\">  <span class=\"number\">3</span> .rodata       <span class=\"number\">0000000</span>d  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000005</span>a  <span class=\"number\">2</span>**<span class=\"number\">0</span></div><div class=\"line\">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class=\"line\">  <span class=\"number\">4</span> .comment      <span class=\"number\">0000002</span>c  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000067</span>  <span class=\"number\">2</span>**<span class=\"number\">0</span></div><div class=\"line\">                  CONTENTS, READONLY</div><div class=\"line\">  <span class=\"number\">5</span> .note.GNU-<span class=\"built_in\">stack</span> <span class=\"number\">00000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000093</span>  <span class=\"number\">2</span>**<span class=\"number\">0</span></div><div class=\"line\">                  CONTENTS, READONLY</div><div class=\"line\">  <span class=\"number\">6</span> .eh_frame     <span class=\"number\">00000038</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000098</span>  <span class=\"number\">2</span>**<span class=\"number\">3</span></div><div class=\"line\">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</div></pre></td></tr></table></figure></p>\n<h2 id=\"链接linker\"><a href=\"https://zh.wikipedia.org/wiki/%E9%93%BE%E6%8E%A5%E5%99%A8\" target=\"_blank\" rel=\"external\">链接</a></h2>\n<p>链接的过程是将一个或多个由编译器或汇编器生成的目标文件链接库（静态库或动态库）形成可执行文件。其中静态库会和汇编生成的目标文件一起链接打包到可执行文件中【静态链接】，它对函数库的链接是放在编译时期完成的。而动态库在程序编译时不会被链接到可执行文件中，而是在程序运行时才会被载入【动态链接】。不同的应用程序如果调用相同的库，那么在内存中只需要一份该共享库实例。获取链接器链接后的可执行文件使用命令<code>gcc hello.o -o hello</code>。如果想看该可执行文件依赖的库，可以使用命令<code>ldd hello</code>。 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># ldd hello 显示hello依赖的库</span></div><div class=\"line\">\tlinux-vdso.so.1 =&gt;  (0x00007ffc85980000)</div><div class=\"line\">\tlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f06c7a53000)</div><div class=\"line\">\t/lib64/ld-linux-x86-64.so.2 (0x000055ad7be9e000)</div></pre></td></tr></table></figure></p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://zh.wikipedia.org/wiki/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8\" target=\"_blank\" rel=\"external\">预处理</a></li>\n<li><a href=\"https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html\" target=\"_blank\" rel=\"external\">预处理-行号标记</a></li>\n<li>[编译器][compile]</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80\" target=\"_blank\" rel=\"external\">汇编</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E9%93%BE%E6%8E%A5%E5%99%A8\" target=\"_blank\" rel=\"external\">链接器</a></li>\n</ol>"},{"layout":"post","title":"简单批处理之常用命令","comments":1,"_content":"本文主要介绍批处理的常用命令,这里只是简单介绍命令的作用,至于命令的具体用法,可以通过 `command /?` 或 `command --help`查看.\n<!-- more -->\n\n\n## 文件夹管理\n* cd\t显示当前目录名或改变当前目录`cd dir`\n* rd\t删除一个目录`rd dir`\n* dir\t显示目录中的文件和子目录列表[等同ls]\n* tree\t以图形显示驱动器或路径的文件夹结构\n* path\t为可执行文件显示或设置一个搜索路径\n* copy\t复制文件和目录树[等同cp]`cp -r`\n\n\n## 文件管理\n* type\t显示文本文件的内容[等同cat]\n* copy\t将一份或多份文件复制到另一个位置[cp]\n* del\t删除一个或数个文件[rm]\n* move\t移动文件并重命名文件和目录[等同mv]\n* ren\t重命名文件[mv]\n* replace\t替换文件\n* attrib\t显示或更改文件属性[等同chmod]\n* find\t搜索字符串[grep]\n* fc\t比较两个文件或两个文件集并显示它们之间的不同[等同diff]\n\n\n## 系统管理\n* at\t安排在特定日期和时间运行命令和程序[等同crontab]\n* shutdown\t立即或定时关机或重启\n* tskill\t结束进程[等同kill]\n* taskkill\t结束进程（比tskill高级）\n* tasklist\t显示进程列表\n* sc\t系统服务设置与控制\n* reg\t注册表控制台工具\n* powercfg\t控制系统上的电源设置\n\n\t> **注意**   \n\t> 查看命令的帮助信息用 `command /?` 或 `command --help`  \n\t>\n\t> ```batch\n\t> rem 查看at命令的帮助文档\n\t> at /?\n\t> ```\n","source":"_posts/2013-09-10-简单批处理之常用命令.md","raw":"---\nlayout:\tpost\ntitle:\t简单批处理之常用命令\ncategories:\n- TECHNOLOGY\ntags:\n- Batch\npermalink:  Summary-command-Batch\ncomments:\ttrue\n---\n本文主要介绍批处理的常用命令,这里只是简单介绍命令的作用,至于命令的具体用法,可以通过 `command /?` 或 `command --help`查看.\n<!-- more -->\n\n\n## 文件夹管理\n* cd\t显示当前目录名或改变当前目录`cd dir`\n* rd\t删除一个目录`rd dir`\n* dir\t显示目录中的文件和子目录列表[等同ls]\n* tree\t以图形显示驱动器或路径的文件夹结构\n* path\t为可执行文件显示或设置一个搜索路径\n* copy\t复制文件和目录树[等同cp]`cp -r`\n\n\n## 文件管理\n* type\t显示文本文件的内容[等同cat]\n* copy\t将一份或多份文件复制到另一个位置[cp]\n* del\t删除一个或数个文件[rm]\n* move\t移动文件并重命名文件和目录[等同mv]\n* ren\t重命名文件[mv]\n* replace\t替换文件\n* attrib\t显示或更改文件属性[等同chmod]\n* find\t搜索字符串[grep]\n* fc\t比较两个文件或两个文件集并显示它们之间的不同[等同diff]\n\n\n## 系统管理\n* at\t安排在特定日期和时间运行命令和程序[等同crontab]\n* shutdown\t立即或定时关机或重启\n* tskill\t结束进程[等同kill]\n* taskkill\t结束进程（比tskill高级）\n* tasklist\t显示进程列表\n* sc\t系统服务设置与控制\n* reg\t注册表控制台工具\n* powercfg\t控制系统上的电源设置\n\n\t> **注意**   \n\t> 查看命令的帮助信息用 `command /?` 或 `command --help`  \n\t>\n\t> ```batch\n\t> rem 查看at命令的帮助文档\n\t> at /?\n\t> ```\n","slug":"Summary-command-Batch","published":1,"date":"2013-09-09T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0p0009l73ytnr2c1z2","content":"<p>本文主要介绍批处理的常用命令,这里只是简单介绍命令的作用,至于命令的具体用法,可以通过 <code>command /?</code> 或 <code>command --help</code>查看. <a id=\"more\"></a></p>\n<h2 id=\"文件夹管理\">文件夹管理</h2>\n<ul>\n<li>cd 显示当前目录名或改变当前目录<code>cd dir</code></li>\n<li>rd 删除一个目录<code>rd dir</code></li>\n<li>dir 显示目录中的文件和子目录列表[等同ls]</li>\n<li>tree 以图形显示驱动器或路径的文件夹结构</li>\n<li>path 为可执行文件显示或设置一个搜索路径</li>\n<li>copy 复制文件和目录树[等同cp]<code>cp -r</code></li>\n</ul>\n<h2 id=\"文件管理\">文件管理</h2>\n<ul>\n<li>type 显示文本文件的内容[等同cat]</li>\n<li>copy 将一份或多份文件复制到另一个位置[cp]</li>\n<li>del 删除一个或数个文件[rm]</li>\n<li>move 移动文件并重命名文件和目录[等同mv]</li>\n<li>ren 重命名文件[mv]</li>\n<li>replace 替换文件</li>\n<li>attrib 显示或更改文件属性[等同chmod]</li>\n<li>find 搜索字符串[grep]</li>\n<li>fc 比较两个文件或两个文件集并显示它们之间的不同[等同diff]</li>\n</ul>\n<h2 id=\"系统管理\">系统管理</h2>\n<ul>\n<li>at 安排在特定日期和时间运行命令和程序[等同crontab]</li>\n<li>shutdown 立即或定时关机或重启</li>\n<li>tskill 结束进程[等同kill]</li>\n<li>taskkill 结束进程（比tskill高级）</li>\n<li>tasklist 显示进程列表</li>\n<li>sc 系统服务设置与控制</li>\n<li>reg 注册表控制台工具</li>\n<li><p>powercfg 控制系统上的电源设置</p>\n<blockquote>\n<p><strong>注意</strong><br>\n查看命令的帮助信息用 <code>command /?</code> 或 <code>command --help</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; rem 查看at命令的帮助文档</div><div class=\"line\">&gt; at /?</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文主要介绍批处理的常用命令,这里只是简单介绍命令的作用,至于命令的具体用法,可以通过 <code>command /?</code> 或 <code>command --help</code>查看.","more":"</p>\n<h2 id=\"文件夹管理\">文件夹管理</h2>\n<ul>\n<li>cd 显示当前目录名或改变当前目录<code>cd dir</code></li>\n<li>rd 删除一个目录<code>rd dir</code></li>\n<li>dir 显示目录中的文件和子目录列表[等同ls]</li>\n<li>tree 以图形显示驱动器或路径的文件夹结构</li>\n<li>path 为可执行文件显示或设置一个搜索路径</li>\n<li>copy 复制文件和目录树[等同cp]<code>cp -r</code></li>\n</ul>\n<h2 id=\"文件管理\">文件管理</h2>\n<ul>\n<li>type 显示文本文件的内容[等同cat]</li>\n<li>copy 将一份或多份文件复制到另一个位置[cp]</li>\n<li>del 删除一个或数个文件[rm]</li>\n<li>move 移动文件并重命名文件和目录[等同mv]</li>\n<li>ren 重命名文件[mv]</li>\n<li>replace 替换文件</li>\n<li>attrib 显示或更改文件属性[等同chmod]</li>\n<li>find 搜索字符串[grep]</li>\n<li>fc 比较两个文件或两个文件集并显示它们之间的不同[等同diff]</li>\n</ul>\n<h2 id=\"系统管理\">系统管理</h2>\n<ul>\n<li>at 安排在特定日期和时间运行命令和程序[等同crontab]</li>\n<li>shutdown 立即或定时关机或重启</li>\n<li>tskill 结束进程[等同kill]</li>\n<li>taskkill 结束进程（比tskill高级）</li>\n<li>tasklist 显示进程列表</li>\n<li>sc 系统服务设置与控制</li>\n<li>reg 注册表控制台工具</li>\n<li><p>powercfg 控制系统上的电源设置</p>\n<blockquote>\n<p><strong>注意</strong><br>\n查看命令的帮助信息用 <code>command /?</code> 或 <code>command --help</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; rem 查看at命令的帮助文档</div><div class=\"line\">&gt; at /?</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote></li>\n</ul>"},{"layout":"post","title":"简单批处理之内部命令","comments":1,"_content":"批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中。批处理文件的扩展名为bat 。本文主要介绍批处理比较常用的内部命令.\n<!-- more -->\n\n\n## echo 命令\n打开回显或关闭请求回显功能，或显示消息。如果没有任何参数，echo 命令将显示当前回显设置。\n\n* Usage：\n\n\t```batch\n\techo [{on　off}] [message]\n\t```\n* Sample：\n\n\t```batch\n\t@echo off / echo hello world\n\t```\n\n\n## rem命令\n注释命令，类似于在C语言中的/\\*--------\\*/，它并不会被执行，只是起一个注释的作用，只有在编辑批处理时才会被看到，主要用于方便修改。\n\n* Usage：\n\n\t```batch\n\trem [context]\n\t```\n* Sample:\n\n\t```batch\n\trem 注释内容\n\t```\n\t> **注意**  \n\t> :: 也具有rem的功能，区别如下：  \n\t> 当关闭回显时,rem和::都不显示注释内容;  \n\t> 当打开回显时,rem会显示注释内容,而::却不显示注释内容\n\n\n## pause命令\n暂停命令。运行 Pause 命令时，将显示下面的消息：\n\n* Usage:\n\n\t```batch\n\tPress any key to continue. . .（或：请按任意键继续. . .)\n\t```\n\n## call 命令\n_从一个批处理程序调用另一个批处理程序，并且不终止父批处理程序_.call命令接受用作调用目标的标签。如果在脚本或批处理文件外使用Call，它将不会在命令行起作用。\n\n* Usage：\n\n\t```batch\n\tcall [[Drive:][Path] FileName [BatchParameters]]\n\t[:label [arguments]]\n\t```\n* Sample：\n\n\t```batch\n\tcall file.bat\n\t```\n\n\n## start 命令\n调用外部程序，所有的DOS命令和命令行程序都可以由start命令来调用。\n\n* Usage：\n\n\t```batch\n\tstart FileName [BatchParameters]\n\t```\n\t> **Parameters:**  \n\t> MIN        开始时窗口最小化   \n\t> SEPARATE   在分开的空间内开始 16 位 Windows 程序  \n\t> HIGH       在HIGH 优先级类别开始应用程序   \n\t> REALTIME   在 REALTIME 优先级类别开始应用程序  \n\t> WAIT       启动应用程序并等候它结束\n\n* Sample:\n\n\t```batch\n\tstart calc.exe\n\t```\n\n\n## goto命令\n跳转命令。程序指针跳转到指定的标签，从标签后的第一条命令开始继续执行批处理程序。\n\n* Usage:\n\n\t```batch\n\tgoto label\n\t```\n* Sample:\n\n\t```batch\n\t:label\n\tstart a.exe\n\tgoto label\n\t```\n\n\n## set命令\n显示、设置或删除变量。\n\n* Sample:\n\n\t```batch\n\trem 把变量a定义为hjy。用echo %a%来回显\n\tset a=hjy\n\n\trem 删除变量a\n\tset a=\n\n\trem 显示所有以s开头的变量及其值\n\tset s\t \n\trem 显示批处理当前已定义的所有变量及其值\n\tset\n\t```\n","source":"_posts/2013-09-08-简单批处理之内部命令.md","raw":"---\nlayout:\tpost\ntitle:\t简单批处理之内部命令\ncategories:\n- TECHNOLOGY\ntags:\n- Batch\npermalink:  Summary-basicCommand-Batch\ncomments:\ttrue\n---\n批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中。批处理文件的扩展名为bat 。本文主要介绍批处理比较常用的内部命令.\n<!-- more -->\n\n\n## echo 命令\n打开回显或关闭请求回显功能，或显示消息。如果没有任何参数，echo 命令将显示当前回显设置。\n\n* Usage：\n\n\t```batch\n\techo [{on　off}] [message]\n\t```\n* Sample：\n\n\t```batch\n\t@echo off / echo hello world\n\t```\n\n\n## rem命令\n注释命令，类似于在C语言中的/\\*--------\\*/，它并不会被执行，只是起一个注释的作用，只有在编辑批处理时才会被看到，主要用于方便修改。\n\n* Usage：\n\n\t```batch\n\trem [context]\n\t```\n* Sample:\n\n\t```batch\n\trem 注释内容\n\t```\n\t> **注意**  \n\t> :: 也具有rem的功能，区别如下：  \n\t> 当关闭回显时,rem和::都不显示注释内容;  \n\t> 当打开回显时,rem会显示注释内容,而::却不显示注释内容\n\n\n## pause命令\n暂停命令。运行 Pause 命令时，将显示下面的消息：\n\n* Usage:\n\n\t```batch\n\tPress any key to continue. . .（或：请按任意键继续. . .)\n\t```\n\n## call 命令\n_从一个批处理程序调用另一个批处理程序，并且不终止父批处理程序_.call命令接受用作调用目标的标签。如果在脚本或批处理文件外使用Call，它将不会在命令行起作用。\n\n* Usage：\n\n\t```batch\n\tcall [[Drive:][Path] FileName [BatchParameters]]\n\t[:label [arguments]]\n\t```\n* Sample：\n\n\t```batch\n\tcall file.bat\n\t```\n\n\n## start 命令\n调用外部程序，所有的DOS命令和命令行程序都可以由start命令来调用。\n\n* Usage：\n\n\t```batch\n\tstart FileName [BatchParameters]\n\t```\n\t> **Parameters:**  \n\t> MIN        开始时窗口最小化   \n\t> SEPARATE   在分开的空间内开始 16 位 Windows 程序  \n\t> HIGH       在HIGH 优先级类别开始应用程序   \n\t> REALTIME   在 REALTIME 优先级类别开始应用程序  \n\t> WAIT       启动应用程序并等候它结束\n\n* Sample:\n\n\t```batch\n\tstart calc.exe\n\t```\n\n\n## goto命令\n跳转命令。程序指针跳转到指定的标签，从标签后的第一条命令开始继续执行批处理程序。\n\n* Usage:\n\n\t```batch\n\tgoto label\n\t```\n* Sample:\n\n\t```batch\n\t:label\n\tstart a.exe\n\tgoto label\n\t```\n\n\n## set命令\n显示、设置或删除变量。\n\n* Sample:\n\n\t```batch\n\trem 把变量a定义为hjy。用echo %a%来回显\n\tset a=hjy\n\n\trem 删除变量a\n\tset a=\n\n\trem 显示所有以s开头的变量及其值\n\tset s\t \n\trem 显示批处理当前已定义的所有变量及其值\n\tset\n\t```\n","slug":"Summary-basicCommand-Batch","published":1,"date":"2013-09-07T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0q000al73y6ooz9408","content":"<p>批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中。批处理文件的扩展名为bat 。本文主要介绍批处理比较常用的内部命令. <a id=\"more\"></a></p>\n<h2 id=\"echo-命令\">echo 命令</h2>\n<p>打开回显或关闭请求回显功能，或显示消息。如果没有任何参数，echo 命令将显示当前回显设置。</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo [&#123;on　off&#125;] [message]</div></pre></td></tr></table></figure></li>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@echo off / echo hello world</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"rem命令\">rem命令</h2>\n<p>注释命令，类似于在C语言中的/*——–*/，它并不会被执行，只是起一个注释的作用，只有在编辑批处理时才会被看到，主要用于方便修改。</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem [context]</div></pre></td></tr></table></figure></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem 注释内容</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意</strong><br>\n:: 也具有rem的功能，区别如下：<br>\n当关闭回显时,rem和::都不显示注释内容;<br>\n当打开回显时,rem会显示注释内容,而::却不显示注释内容</p>\n</blockquote></li>\n</ul>\n<h2 id=\"pause命令\">pause命令</h2>\n<p>暂停命令。运行 Pause 命令时，将显示下面的消息：</p>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Press any key to continue. . .（或：请按任意键继续. . .)</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"call-命令\">call 命令</h2>\n<p><em>从一个批处理程序调用另一个批处理程序，并且不终止父批处理程序</em>.call命令接受用作调用目标的标签。如果在脚本或批处理文件外使用Call，它将不会在命令行起作用。</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">call [[Drive:][Path] FileName [BatchParameters]]</div><div class=\"line\">[:label [arguments]]</div></pre></td></tr></table></figure></li>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">call file.bat</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"start-命令\">start 命令</h2>\n<p>调用外部程序，所有的DOS命令和命令行程序都可以由start命令来调用。</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">start FileName [BatchParameters]</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Parameters:</strong><br>\nMIN 开始时窗口最小化<br>\nSEPARATE 在分开的空间内开始 16 位 Windows 程序<br>\nHIGH 在HIGH 优先级类别开始应用程序<br>\nREALTIME 在 REALTIME 优先级类别开始应用程序<br>\nWAIT 启动应用程序并等候它结束</p>\n</blockquote></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">start calc.exe</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"goto命令\">goto命令</h2>\n<p>跳转命令。程序指针跳转到指定的标签，从标签后的第一条命令开始继续执行批处理程序。</p>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">goto label</div></pre></td></tr></table></figure></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">:label</div><div class=\"line\">start a.exe</div><div class=\"line\">goto label</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"set命令\">set命令</h2>\n<p>显示、设置或删除变量。</p>\n<ul>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem 把变量a定义为hjy。用echo %a%来回显</div><div class=\"line\">set a=hjy</div><div class=\"line\"></div><div class=\"line\">rem 删除变量a</div><div class=\"line\">set a=</div><div class=\"line\"></div><div class=\"line\">rem 显示所有以s开头的变量及其值</div><div class=\"line\">set s\t </div><div class=\"line\">rem 显示批处理当前已定义的所有变量及其值</div><div class=\"line\">set</div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中。批处理文件的扩展名为bat 。本文主要介绍批处理比较常用的内部命令.","more":"</p>\n<h2 id=\"echo-命令\">echo 命令</h2>\n<p>打开回显或关闭请求回显功能，或显示消息。如果没有任何参数，echo 命令将显示当前回显设置。</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo [&#123;on　off&#125;] [message]</div></pre></td></tr></table></figure></li>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@echo off / echo hello world</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"rem命令\">rem命令</h2>\n<p>注释命令，类似于在C语言中的/*——–*/，它并不会被执行，只是起一个注释的作用，只有在编辑批处理时才会被看到，主要用于方便修改。</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem [context]</div></pre></td></tr></table></figure></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem 注释内容</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意</strong><br>\n:: 也具有rem的功能，区别如下：<br>\n当关闭回显时,rem和::都不显示注释内容;<br>\n当打开回显时,rem会显示注释内容,而::却不显示注释内容</p>\n</blockquote></li>\n</ul>\n<h2 id=\"pause命令\">pause命令</h2>\n<p>暂停命令。运行 Pause 命令时，将显示下面的消息：</p>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Press any key to continue. . .（或：请按任意键继续. . .)</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"call-命令\">call 命令</h2>\n<p><em>从一个批处理程序调用另一个批处理程序，并且不终止父批处理程序</em>.call命令接受用作调用目标的标签。如果在脚本或批处理文件外使用Call，它将不会在命令行起作用。</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">call [[Drive:][Path] FileName [BatchParameters]]</div><div class=\"line\">[:label [arguments]]</div></pre></td></tr></table></figure></li>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">call file.bat</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"start-命令\">start 命令</h2>\n<p>调用外部程序，所有的DOS命令和命令行程序都可以由start命令来调用。</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">start FileName [BatchParameters]</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Parameters:</strong><br>\nMIN 开始时窗口最小化<br>\nSEPARATE 在分开的空间内开始 16 位 Windows 程序<br>\nHIGH 在HIGH 优先级类别开始应用程序<br>\nREALTIME 在 REALTIME 优先级类别开始应用程序<br>\nWAIT 启动应用程序并等候它结束</p>\n</blockquote></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">start calc.exe</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"goto命令\">goto命令</h2>\n<p>跳转命令。程序指针跳转到指定的标签，从标签后的第一条命令开始继续执行批处理程序。</p>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">goto label</div></pre></td></tr></table></figure></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">:label</div><div class=\"line\">start a.exe</div><div class=\"line\">goto label</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"set命令\">set命令</h2>\n<p>显示、设置或删除变量。</p>\n<ul>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem 把变量a定义为hjy。用echo %a%来回显</div><div class=\"line\">set a=hjy</div><div class=\"line\"></div><div class=\"line\">rem 删除变量a</div><div class=\"line\">set a=</div><div class=\"line\"></div><div class=\"line\">rem 显示所有以s开头的变量及其值</div><div class=\"line\">set s\t </div><div class=\"line\">rem 显示批处理当前已定义的所有变量及其值</div><div class=\"line\">set</div></pre></td></tr></table></figure></li>\n</ul>"},{"layout":"post","title":"简单批处理之符号简介","comments":1,"_content":"本文主要介绍在批处理中常用的符号.\n<!-- more -->\n\n\n## 回显@\n表示不显示@后面的命令\n\n* Sample：\n\n\t```batch\n\t@echo off\n\t@echo Now initializing the program,please wait a minite...\n\t```\n\n## 重定向>与>>\n将输出信息重定向到指定的设备或文件。系统默认输出到显示器。\n\n\n## 重定向<\n将输入信息来源重定向为指定的设备或文件。系统默认从显示器读取输入信息。\n\n\n## 管道|\n将管道符号前面命令的输出结果重定向输出到管道符号后面的命令中去，作为后面命令的输入。\n\n\n## 转义符^\n将特殊符号转化为一般符号，即剥离特殊符号的特殊地位。特殊符号指：| & > <\n\n\n## 逻辑命令符&/&&/||\n* & -- 它的作用是用来连接n个DOS命令，并把这些命令按顺序执行，而不管是否有命令执行失败\n* && -- 当&&前面的命令成功执行时，执行&&后面的命令，否则不执行\n* || -- 当||前面的命令失败时，执行||后面的命令，否则不执行\n","source":"_posts/2013-09-09-简单批处理之符号简介.md","raw":"---\nlayout:\tpost\ntitle:\t简单批处理之符号简介\ncategories:\n- TECHNOLOGY\ntags:\n- Batch\npermalink:  Summary-sign-Batch\ncomments:\ttrue\n---\n本文主要介绍在批处理中常用的符号.\n<!-- more -->\n\n\n## 回显@\n表示不显示@后面的命令\n\n* Sample：\n\n\t```batch\n\t@echo off\n\t@echo Now initializing the program,please wait a minite...\n\t```\n\n## 重定向>与>>\n将输出信息重定向到指定的设备或文件。系统默认输出到显示器。\n\n\n## 重定向<\n将输入信息来源重定向为指定的设备或文件。系统默认从显示器读取输入信息。\n\n\n## 管道|\n将管道符号前面命令的输出结果重定向输出到管道符号后面的命令中去，作为后面命令的输入。\n\n\n## 转义符^\n将特殊符号转化为一般符号，即剥离特殊符号的特殊地位。特殊符号指：| & > <\n\n\n## 逻辑命令符&/&&/||\n* & -- 它的作用是用来连接n个DOS命令，并把这些命令按顺序执行，而不管是否有命令执行失败\n* && -- 当&&前面的命令成功执行时，执行&&后面的命令，否则不执行\n* || -- 当||前面的命令失败时，执行||后面的命令，否则不执行\n","slug":"Summary-sign-Batch","published":1,"date":"2013-09-08T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0r000bl73y36re4cst","content":"<p>本文主要介绍在批处理中常用的符号. <a id=\"more\"></a></p>\n<h2 id=\"回显\">回显@</h2>\n<p>表示不显示@后面的命令</p>\n<ul>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@echo off</div><div class=\"line\">@echo Now initializing the program,please wait a minite...</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"重定向与\">重定向&gt;与&gt;&gt;</h2>\n<p>将输出信息重定向到指定的设备或文件。系统默认输出到显示器。</p>\n<h2 id=\"重定向\">重定向&lt;</h2>\n<p>将输入信息来源重定向为指定的设备或文件。系统默认从显示器读取输入信息。</p>\n<h2 id=\"管道\">管道|</h2>\n<p>将管道符号前面命令的输出结果重定向输出到管道符号后面的命令中去，作为后面命令的输入。</p>\n<h2 id=\"转义符\">转义符^</h2>\n<p>将特殊符号转化为一般符号，即剥离特殊符号的特殊地位。特殊符号指：| &amp; &gt; &lt;</p>\n<h2 id=\"逻辑命令符\">逻辑命令符&amp;/&amp;&amp;/||</h2>\n<ul>\n<li>&amp; – 它的作用是用来连接n个DOS命令，并把这些命令按顺序执行，而不管是否有命令执行失败</li>\n<li>&amp;&amp; – 当&amp;&amp;前面的命令成功执行时，执行&amp;&amp;后面的命令，否则不执行</li>\n<li>|| – 当||前面的命令失败时，执行||后面的命令，否则不执行</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文主要介绍在批处理中常用的符号.","more":"</p>\n<h2 id=\"回显\">回显@</h2>\n<p>表示不显示@后面的命令</p>\n<ul>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@echo off</div><div class=\"line\">@echo Now initializing the program,please wait a minite...</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"重定向与\">重定向&gt;与&gt;&gt;</h2>\n<p>将输出信息重定向到指定的设备或文件。系统默认输出到显示器。</p>\n<h2 id=\"重定向\">重定向&lt;</h2>\n<p>将输入信息来源重定向为指定的设备或文件。系统默认从显示器读取输入信息。</p>\n<h2 id=\"管道\">管道|</h2>\n<p>将管道符号前面命令的输出结果重定向输出到管道符号后面的命令中去，作为后面命令的输入。</p>\n<h2 id=\"转义符\">转义符^</h2>\n<p>将特殊符号转化为一般符号，即剥离特殊符号的特殊地位。特殊符号指：| &amp; &gt; &lt;</p>\n<h2 id=\"逻辑命令符\">逻辑命令符&amp;/&amp;&amp;/||</h2>\n<ul>\n<li>&amp; – 它的作用是用来连接n个DOS命令，并把这些命令按顺序执行，而不管是否有命令执行失败</li>\n<li>&amp;&amp; – 当&amp;&amp;前面的命令成功执行时，执行&amp;&amp;后面的命令，否则不执行</li>\n<li>|| – 当||前面的命令失败时，执行||后面的命令，否则不执行</li>\n</ul>"},{"layout":"post","title":"简单批处理之语法结构","comments":1,"_content":"本文主要介绍批处理的语法结构以方便写bat的脚本文件.\n<!-- more -->\n\n\n## 选择语句\n### 字符串比较\n仅能够对两个字符（串）是否相同、先后顺序进行判断等  \n\n* Usage：\n\n\t```batch\n\tif [not] string1 compare-op string2 command1 [else command2]\n\t```\n\t> **Compare-op：**  \n\t> ==    等于   \n\t> EQU    等于   \n\t> NEQ    不等于  \n\t> LSS    小于  \n\t> LEQ    小于或等于  \n\t> GTR    大于   \n\t> GEQ    大于或等于  \n* Sample：\n\n\t```batch\n\tset /p choice=是否显示当前时间？（y/n)\n\tif /i not %choice% EQU n echo 当前时间是：%date% %time%\n\tpause>nul\n\t```\n\n### 存在判断\n存在判断的功能是判断文件或文件夹是否存在  \n\n* Usage：\n\n\t```batch\n\tif  [not] exist  filename command1 [else command2]\n\t```\n* Sample：\n\n\t```batch\n\tif not exist %~df0 (\n\t\techo 文件夹%~df0不存在！\n\t) else echo 文件夹%~df0存在！\n\t```\n\n\t> **注意：**  \n\t> if语句的多行书写: 多行书写要求command1的左括号必须和if在同一行、else必须和command1的右括号同行、command2的左括号必须与else同行、command1和command2都可以有任意多行，即command可以是命令集。\n\n\n### 定义判断\n定义判断的功能是判断变量是否存在，即是否已被定义  \n\n* Usage：\n\n\t```batch\n\tif [not] defined variable command1 [else command2]\n\t```\n* Sample：\n\n\t```batch\n\tif not defined var （echo var=11）\n\t```\t\t\t \n\n\n### 结果判断\n对上一个命令运行的结果进行判断处理，而上一个命令运行的结果放在errorlevel变量中  \n\n* Sample：\n\n\t```batch\n\tmasm %1.asm\n\trem 错误码为1\n\tif errorlevel 1 pause & edit %1.asm\n\tlink %1.obj\n\t```\n\n\n## 循环语句\n### 无开关\n无开关的for语句能够对设定的范围内进行循环，是最基本的for循环语句\n\n* Usage：\n\n\t```batch\n\tfor %%variable in (set) do command\n\t```\n* Sample：\n\n\t```batch\n\t@echo off\n\tfor %%i in (a,\"b c\",d) do echo %%i\n\tpause>nul\n\t```\n\n### 开关/L\n含开关/L的for语句，可以根据set里面的设置进行循环，从而实现对循环次数的直接控制  \n\n* Usage:\n\n\t```batch\n\tfor /l %%variable in (start,step,end) do command\n\t```\n* Sample:\n\n\t```batch\n\t@echo off\n\tfor /l %%i in (1,2,10) do md %%i\n\tpause\n\t```\n\n### 开关/F\n含开关/F的for语句具有最强大的功能，它能够对字符串进行操作，也能够对命令的返回值进行操作，还可以访问硬盘上的ASCII码文件，比如txt文档等  \n\n* Usage:\n\n\t```batch\n\tfor /f [\"options\"] %%variable in (set) do command\n\t```\n\t> **Parameters:**  \n\t> options是（eol=c、skip=n、delims=xxx、tokens=x,y,m-n、usebackq）中的一个或多个的组合  \n\t> set为（\"string\"、'command'、file-set）中的一个\n* Sample:\n\n\t```batch\n\t@echo off\n\techo 本文件夹里面的文件有：\n\tfor /f \"skip=5 tokens=3* delims= \" %%a in ('dir') do (\n\t\tif not \"%%a\"==\"<DIR>\" if not \"%%b\"==\"字节\" if not \"%%b\"==\"可用字节\" echo %%b\n\t)\n\tpause\n\t```\t\t\t \n\n### 开关/D或/R\n含开关/D或/R的for语句是与目录或文件有关的命令，一般情况下很少使用。含开关/R的命令有时候被用于通过遍历文件夹来查找某一个文件或文件夹  \n\n* Sample：\n\n\t```batch\n\t@echo off\n\tset local enabledelayedexpansion\n\tfor /r d: %%i in (.) do (\n\t\tset dd=%%i\n\t\tset \"dd=!dd:~0,-1!\"\n\t\techo !dd!\n\t)\n\tpause\n\t```\n\t> **注意：**  \n\t> 感叹号其实就是变量百分号(%)的强化版。之所以要用!而不用%，是因为在for循环中，当一个变量被多次赋值时，%dd%所获取的仅仅是dd第一次被赋予的值；要想刷新dd的值，就必须首先通过命令\"setlocal enabledelayedexpansion\"来开启延迟变量开关，然后用!dd!来获取dd的值。\n","source":"_posts/2013-09-11-简单批处理之语法结构.md","raw":"---\nlayout:\tpost\ntitle:\t简单批处理之语法结构\ncategories:\n- TECHNOLOGY\ntags:\n- Batch\npermalink:  Summary-structure-Batch\ncomments:\ttrue\n---\n本文主要介绍批处理的语法结构以方便写bat的脚本文件.\n<!-- more -->\n\n\n## 选择语句\n### 字符串比较\n仅能够对两个字符（串）是否相同、先后顺序进行判断等  \n\n* Usage：\n\n\t```batch\n\tif [not] string1 compare-op string2 command1 [else command2]\n\t```\n\t> **Compare-op：**  \n\t> ==    等于   \n\t> EQU    等于   \n\t> NEQ    不等于  \n\t> LSS    小于  \n\t> LEQ    小于或等于  \n\t> GTR    大于   \n\t> GEQ    大于或等于  \n* Sample：\n\n\t```batch\n\tset /p choice=是否显示当前时间？（y/n)\n\tif /i not %choice% EQU n echo 当前时间是：%date% %time%\n\tpause>nul\n\t```\n\n### 存在判断\n存在判断的功能是判断文件或文件夹是否存在  \n\n* Usage：\n\n\t```batch\n\tif  [not] exist  filename command1 [else command2]\n\t```\n* Sample：\n\n\t```batch\n\tif not exist %~df0 (\n\t\techo 文件夹%~df0不存在！\n\t) else echo 文件夹%~df0存在！\n\t```\n\n\t> **注意：**  \n\t> if语句的多行书写: 多行书写要求command1的左括号必须和if在同一行、else必须和command1的右括号同行、command2的左括号必须与else同行、command1和command2都可以有任意多行，即command可以是命令集。\n\n\n### 定义判断\n定义判断的功能是判断变量是否存在，即是否已被定义  \n\n* Usage：\n\n\t```batch\n\tif [not] defined variable command1 [else command2]\n\t```\n* Sample：\n\n\t```batch\n\tif not defined var （echo var=11）\n\t```\t\t\t \n\n\n### 结果判断\n对上一个命令运行的结果进行判断处理，而上一个命令运行的结果放在errorlevel变量中  \n\n* Sample：\n\n\t```batch\n\tmasm %1.asm\n\trem 错误码为1\n\tif errorlevel 1 pause & edit %1.asm\n\tlink %1.obj\n\t```\n\n\n## 循环语句\n### 无开关\n无开关的for语句能够对设定的范围内进行循环，是最基本的for循环语句\n\n* Usage：\n\n\t```batch\n\tfor %%variable in (set) do command\n\t```\n* Sample：\n\n\t```batch\n\t@echo off\n\tfor %%i in (a,\"b c\",d) do echo %%i\n\tpause>nul\n\t```\n\n### 开关/L\n含开关/L的for语句，可以根据set里面的设置进行循环，从而实现对循环次数的直接控制  \n\n* Usage:\n\n\t```batch\n\tfor /l %%variable in (start,step,end) do command\n\t```\n* Sample:\n\n\t```batch\n\t@echo off\n\tfor /l %%i in (1,2,10) do md %%i\n\tpause\n\t```\n\n### 开关/F\n含开关/F的for语句具有最强大的功能，它能够对字符串进行操作，也能够对命令的返回值进行操作，还可以访问硬盘上的ASCII码文件，比如txt文档等  \n\n* Usage:\n\n\t```batch\n\tfor /f [\"options\"] %%variable in (set) do command\n\t```\n\t> **Parameters:**  \n\t> options是（eol=c、skip=n、delims=xxx、tokens=x,y,m-n、usebackq）中的一个或多个的组合  \n\t> set为（\"string\"、'command'、file-set）中的一个\n* Sample:\n\n\t```batch\n\t@echo off\n\techo 本文件夹里面的文件有：\n\tfor /f \"skip=5 tokens=3* delims= \" %%a in ('dir') do (\n\t\tif not \"%%a\"==\"<DIR>\" if not \"%%b\"==\"字节\" if not \"%%b\"==\"可用字节\" echo %%b\n\t)\n\tpause\n\t```\t\t\t \n\n### 开关/D或/R\n含开关/D或/R的for语句是与目录或文件有关的命令，一般情况下很少使用。含开关/R的命令有时候被用于通过遍历文件夹来查找某一个文件或文件夹  \n\n* Sample：\n\n\t```batch\n\t@echo off\n\tset local enabledelayedexpansion\n\tfor /r d: %%i in (.) do (\n\t\tset dd=%%i\n\t\tset \"dd=!dd:~0,-1!\"\n\t\techo !dd!\n\t)\n\tpause\n\t```\n\t> **注意：**  \n\t> 感叹号其实就是变量百分号(%)的强化版。之所以要用!而不用%，是因为在for循环中，当一个变量被多次赋值时，%dd%所获取的仅仅是dd第一次被赋予的值；要想刷新dd的值，就必须首先通过命令\"setlocal enabledelayedexpansion\"来开启延迟变量开关，然后用!dd!来获取dd的值。\n","slug":"Summary-structure-Batch","published":1,"date":"2013-09-10T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0r000cl73yt664j7za","content":"<p>本文主要介绍批处理的语法结构以方便写bat的脚本文件. <a id=\"more\"></a></p>\n<h2 id=\"选择语句\">选择语句</h2>\n<h3 id=\"字符串比较\">字符串比较</h3>\n<p>仅能够对两个字符（串）是否相同、先后顺序进行判断等</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">if [not] string1 compare-op string2 command1 [else command2]</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Compare-op：</strong><br>\n== 等于<br>\nEQU 等于<br>\nNEQ 不等于<br>\nLSS 小于<br>\nLEQ 小于或等于<br>\nGTR 大于<br>\nGEQ 大于或等于</p>\n</blockquote></li>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">set /p choice=是否显示当前时间？（y/n)</div><div class=\"line\">if /i not %choice% EQU n echo 当前时间是：%date% %time%</div><div class=\"line\">pause&gt;nul</div></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"存在判断\">存在判断</h3>\n<p>存在判断的功能是判断文件或文件夹是否存在</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">if  [not] exist  filename command1 [else command2]</div></pre></td></tr></table></figure></li>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if not exist %~df0 (</div><div class=\"line\">\techo 文件夹%~df0不存在！</div><div class=\"line\">) else echo 文件夹%~df0存在！</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意：</strong><br>\nif语句的多行书写: 多行书写要求command1的左括号必须和if在同一行、else必须和command1的右括号同行、command2的左括号必须与else同行、command1和command2都可以有任意多行，即command可以是命令集。</p>\n</blockquote></li>\n</ul>\n<h3 id=\"定义判断\">定义判断</h3>\n<p>定义判断的功能是判断变量是否存在，即是否已被定义</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">if [not] defined variable command1 [else command2]</div></pre></td></tr></table></figure></li>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tif not defined var （echo var=11）</div><div class=\"line\">\t```\t\t\t </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 结果判断</div><div class=\"line\">对上一个命令运行的结果进行判断处理，而上一个命令运行的结果放在errorlevel变量中  </div><div class=\"line\"></div><div class=\"line\">* Sample：</div><div class=\"line\"></div><div class=\"line\">\t```batch</div><div class=\"line\">\tmasm %1.asm</div><div class=\"line\">\trem 错误码为1</div><div class=\"line\">\tif errorlevel 1 pause &amp; edit %1.asm</div><div class=\"line\">\tlink %1.obj</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"循环语句\">循环语句</h2>\n<h3 id=\"无开关\">无开关</h3>\n<p>无开关的for语句能够对设定的范围内进行循环，是最基本的for循环语句</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">for %%variable in (set) do command</div></pre></td></tr></table></figure></li>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@echo off</div><div class=\"line\">for %%i in (a,&quot;b c&quot;,d) do echo %%i</div><div class=\"line\">pause&gt;nul</div></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"开关l\">开关/L</h3>\n<p>含开关/L的for语句，可以根据set里面的设置进行循环，从而实现对循环次数的直接控制</p>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">for /l %%variable in (start,step,end) do command</div></pre></td></tr></table></figure></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@echo off</div><div class=\"line\">for /l %%i in (1,2,10) do md %%i</div><div class=\"line\">pause</div></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"开关f\">开关/F</h3>\n<p>含开关/F的for语句具有最强大的功能，它能够对字符串进行操作，也能够对命令的返回值进行操作，还可以访问硬盘上的ASCII码文件，比如txt文档等</p>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">for /f [&quot;options&quot;] %%variable in (set) do command</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Parameters:</strong><br>\noptions是（eol=c、skip=n、delims=xxx、tokens=x,y,m-n、usebackq）中的一个或多个的组合<br>\nset为（“string”、‘command’、file-set）中的一个</p>\n</blockquote></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t@echo off</div><div class=\"line\">\techo 本文件夹里面的文件有：</div><div class=\"line\">\tfor /f &quot;skip=5 tokens=3* delims= &quot; %%a in (&apos;dir&apos;) do (</div><div class=\"line\">\t\tif not &quot;%%a&quot;==&quot;&lt;DIR&gt;&quot; if not &quot;%%b&quot;==&quot;字节&quot; if not &quot;%%b&quot;==&quot;可用字节&quot; echo %%b</div><div class=\"line\">\t)</div><div class=\"line\">\tpause</div><div class=\"line\">\t```\t\t\t </div><div class=\"line\"></div><div class=\"line\">### 开关/D或/R</div><div class=\"line\">含开关/D或/R的for语句是与目录或文件有关的命令，一般情况下很少使用。含开关/R的命令有时候被用于通过遍历文件夹来查找某一个文件或文件夹  </div><div class=\"line\"></div><div class=\"line\">* Sample：</div><div class=\"line\"></div><div class=\"line\">\t```batch</div><div class=\"line\">\t@echo off</div><div class=\"line\">\tset local enabledelayedexpansion</div><div class=\"line\">\tfor /r d: %%i in (.) do (</div><div class=\"line\">\t\tset dd=%%i</div><div class=\"line\">\t\tset &quot;dd=!dd:~0,-1!&quot;</div><div class=\"line\">\t\techo !dd!</div><div class=\"line\">\t)</div><div class=\"line\">\tpause</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意：</strong><br>\n感叹号其实就是变量百分号(%)的强化版。之所以要用!而不用%，是因为在for循环中，当一个变量被多次赋值时，%dd%所获取的仅仅是dd第一次被赋予的值；要想刷新dd的值，就必须首先通过命令“setlocal enabledelayedexpansion”来开启延迟变量开关，然后用!dd!来获取dd的值。</p>\n</blockquote></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文主要介绍批处理的语法结构以方便写bat的脚本文件.","more":"</p>\n<h2 id=\"选择语句\">选择语句</h2>\n<h3 id=\"字符串比较\">字符串比较</h3>\n<p>仅能够对两个字符（串）是否相同、先后顺序进行判断等</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">if [not] string1 compare-op string2 command1 [else command2]</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Compare-op：</strong><br>\n== 等于<br>\nEQU 等于<br>\nNEQ 不等于<br>\nLSS 小于<br>\nLEQ 小于或等于<br>\nGTR 大于<br>\nGEQ 大于或等于</p>\n</blockquote></li>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">set /p choice=是否显示当前时间？（y/n)</div><div class=\"line\">if /i not %choice% EQU n echo 当前时间是：%date% %time%</div><div class=\"line\">pause&gt;nul</div></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"存在判断\">存在判断</h3>\n<p>存在判断的功能是判断文件或文件夹是否存在</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">if  [not] exist  filename command1 [else command2]</div></pre></td></tr></table></figure></li>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if not exist %~df0 (</div><div class=\"line\">\techo 文件夹%~df0不存在！</div><div class=\"line\">) else echo 文件夹%~df0存在！</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意：</strong><br>\nif语句的多行书写: 多行书写要求command1的左括号必须和if在同一行、else必须和command1的右括号同行、command2的左括号必须与else同行、command1和command2都可以有任意多行，即command可以是命令集。</p>\n</blockquote></li>\n</ul>\n<h3 id=\"定义判断\">定义判断</h3>\n<p>定义判断的功能是判断变量是否存在，即是否已被定义</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">if [not] defined variable command1 [else command2]</div></pre></td></tr></table></figure></li>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tif not defined var （echo var=11）</div><div class=\"line\">\t```\t\t\t </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 结果判断</div><div class=\"line\">对上一个命令运行的结果进行判断处理，而上一个命令运行的结果放在errorlevel变量中  </div><div class=\"line\"></div><div class=\"line\">* Sample：</div><div class=\"line\"></div><div class=\"line\">\t```batch</div><div class=\"line\">\tmasm %1.asm</div><div class=\"line\">\trem 错误码为1</div><div class=\"line\">\tif errorlevel 1 pause &amp; edit %1.asm</div><div class=\"line\">\tlink %1.obj</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"循环语句\">循环语句</h2>\n<h3 id=\"无开关\">无开关</h3>\n<p>无开关的for语句能够对设定的范围内进行循环，是最基本的for循环语句</p>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">for %%variable in (set) do command</div></pre></td></tr></table></figure></li>\n<li><p>Sample：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@echo off</div><div class=\"line\">for %%i in (a,&quot;b c&quot;,d) do echo %%i</div><div class=\"line\">pause&gt;nul</div></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"开关l\">开关/L</h3>\n<p>含开关/L的for语句，可以根据set里面的设置进行循环，从而实现对循环次数的直接控制</p>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">for /l %%variable in (start,step,end) do command</div></pre></td></tr></table></figure></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@echo off</div><div class=\"line\">for /l %%i in (1,2,10) do md %%i</div><div class=\"line\">pause</div></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"开关f\">开关/F</h3>\n<p>含开关/F的for语句具有最强大的功能，它能够对字符串进行操作，也能够对命令的返回值进行操作，还可以访问硬盘上的ASCII码文件，比如txt文档等</p>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">for /f [&quot;options&quot;] %%variable in (set) do command</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Parameters:</strong><br>\noptions是（eol=c、skip=n、delims=xxx、tokens=x,y,m-n、usebackq）中的一个或多个的组合<br>\nset为（“string”、‘command’、file-set）中的一个</p>\n</blockquote></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t@echo off</div><div class=\"line\">\techo 本文件夹里面的文件有：</div><div class=\"line\">\tfor /f &quot;skip=5 tokens=3* delims= &quot; %%a in (&apos;dir&apos;) do (</div><div class=\"line\">\t\tif not &quot;%%a&quot;==&quot;&lt;DIR&gt;&quot; if not &quot;%%b&quot;==&quot;字节&quot; if not &quot;%%b&quot;==&quot;可用字节&quot; echo %%b</div><div class=\"line\">\t)</div><div class=\"line\">\tpause</div><div class=\"line\">\t```\t\t\t </div><div class=\"line\"></div><div class=\"line\">### 开关/D或/R</div><div class=\"line\">含开关/D或/R的for语句是与目录或文件有关的命令，一般情况下很少使用。含开关/R的命令有时候被用于通过遍历文件夹来查找某一个文件或文件夹  </div><div class=\"line\"></div><div class=\"line\">* Sample：</div><div class=\"line\"></div><div class=\"line\">\t```batch</div><div class=\"line\">\t@echo off</div><div class=\"line\">\tset local enabledelayedexpansion</div><div class=\"line\">\tfor /r d: %%i in (.) do (</div><div class=\"line\">\t\tset dd=%%i</div><div class=\"line\">\t\tset &quot;dd=!dd:~0,-1!&quot;</div><div class=\"line\">\t\techo !dd!</div><div class=\"line\">\t)</div><div class=\"line\">\tpause</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意：</strong><br>\n感叹号其实就是变量百分号(%)的强化版。之所以要用!而不用%，是因为在for循环中，当一个变量被多次赋值时，%dd%所获取的仅仅是dd第一次被赋予的值；要想刷新dd的值，就必须首先通过命令“setlocal enabledelayedexpansion”来开启延迟变量开关，然后用!dd!来获取dd的值。</p>\n</blockquote></li>\n</ul>"},{"layout":"post","title":"简单批处理之字符串处理","comments":1,"_content":"本文主要介绍批处理中字符串的处理.\n<!-- more -->\n\n\n## 截取字符串\n实现截取字符串中的特定位置的一个或多个字符  \n\n* Usage:\n\n\t```batch\n\techo %var:begin,lenth%\n\t```\n* Sample:\n\n\t```batch\n\trem 截取前5个字符：\n\techo %var:~0,5%\n\n\trem 截取最后5个字符:\n\techo %var:~-5%\n\t```\n\n## 替换字符串\n将某一字符串中的特定字符或字符串替换为给定的字符串  \n\n* Usage:\n\n\t```batch\n\tset \"var=%var:replaced=new%\"\n\t```\n* Sample:\n\n\t```batch\n\techo test=1232\n\tset \"test=%test:2=k%\"\n\trem 结果test=1k3k\n\t```\n\n## 字符串合并\n将两个字符串放在一起  \n\n* Sample:\n\n\t```batch\n\techo %var1%%var2%\n\t```\n\n\n## 扩充字符串\n对表示文件路径的字符串进行特殊的处理\n> `~I`    删除任何引号（\")，扩充 %I  \n> `%~fI`    将 %I 扩充到一个完全合格的路径名  \n> `%~dI`    仅将 %I 扩充到一个驱动器号  \n> `%~pI`     仅将 %I 扩充到一个路径  \n> `%~nI`     仅将 %I 扩充到一个文件名  \n> `%~xI`     仅将 %I 扩充到一个文件扩展名  \n> `%~sI`     扩充的路径只含有短名  \n> `%~aI`     将 %I 扩充到文件的文件属性  \n> `%~tI`     将 %I 扩充到文件的日期/时间  \n> `%~zI`     将 %I 扩充到文件的大小  \n> `%~$PATH:I`      查找列在路径环境变量的目录，并将 %I 扩充  \n\n\n## 附:数值计算\n\n* Usage：\n\n\t```batch\n\tset /a expression\n\t```\n* Sample:\n\n\t```batch\n\tset /a var=123+0123+0x123\n\t```\n","source":"_posts/2013-09-12-简单批处理之字符串处理.md","raw":"---\nlayout:\tpost\ntitle:\t简单批处理之字符串处理\ncategories:\n- TECHNOLOGY\ntags:\n- Batch\npermalink:  Summary-string-Batch\ncomments:\ttrue\n---\n本文主要介绍批处理中字符串的处理.\n<!-- more -->\n\n\n## 截取字符串\n实现截取字符串中的特定位置的一个或多个字符  \n\n* Usage:\n\n\t```batch\n\techo %var:begin,lenth%\n\t```\n* Sample:\n\n\t```batch\n\trem 截取前5个字符：\n\techo %var:~0,5%\n\n\trem 截取最后5个字符:\n\techo %var:~-5%\n\t```\n\n## 替换字符串\n将某一字符串中的特定字符或字符串替换为给定的字符串  \n\n* Usage:\n\n\t```batch\n\tset \"var=%var:replaced=new%\"\n\t```\n* Sample:\n\n\t```batch\n\techo test=1232\n\tset \"test=%test:2=k%\"\n\trem 结果test=1k3k\n\t```\n\n## 字符串合并\n将两个字符串放在一起  \n\n* Sample:\n\n\t```batch\n\techo %var1%%var2%\n\t```\n\n\n## 扩充字符串\n对表示文件路径的字符串进行特殊的处理\n> `~I`    删除任何引号（\")，扩充 %I  \n> `%~fI`    将 %I 扩充到一个完全合格的路径名  \n> `%~dI`    仅将 %I 扩充到一个驱动器号  \n> `%~pI`     仅将 %I 扩充到一个路径  \n> `%~nI`     仅将 %I 扩充到一个文件名  \n> `%~xI`     仅将 %I 扩充到一个文件扩展名  \n> `%~sI`     扩充的路径只含有短名  \n> `%~aI`     将 %I 扩充到文件的文件属性  \n> `%~tI`     将 %I 扩充到文件的日期/时间  \n> `%~zI`     将 %I 扩充到文件的大小  \n> `%~$PATH:I`      查找列在路径环境变量的目录，并将 %I 扩充  \n\n\n## 附:数值计算\n\n* Usage：\n\n\t```batch\n\tset /a expression\n\t```\n* Sample:\n\n\t```batch\n\tset /a var=123+0123+0x123\n\t```\n","slug":"Summary-string-Batch","published":1,"date":"2013-09-11T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0s000dl73y1hxym7od","content":"<p>本文主要介绍批处理中字符串的处理. <a id=\"more\"></a></p>\n<h2 id=\"截取字符串\">截取字符串</h2>\n<p>实现截取字符串中的特定位置的一个或多个字符</p>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo %var:begin,lenth%</div></pre></td></tr></table></figure></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem 截取前5个字符：</div><div class=\"line\">echo %var:~0,5%</div><div class=\"line\"></div><div class=\"line\">rem 截取最后5个字符:</div><div class=\"line\">echo %var:~-5%</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"替换字符串\">替换字符串</h2>\n<p>将某一字符串中的特定字符或字符串替换为给定的字符串</p>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set &quot;var=%var:replaced=new%&quot;</div></pre></td></tr></table></figure></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo test=1232</div><div class=\"line\">set &quot;test=%test:2=k%&quot;</div><div class=\"line\">rem 结果test=1k3k</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"字符串合并\">字符串合并</h2>\n<p>将两个字符串放在一起</p>\n<ul>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo %var1%%var2%</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"扩充字符串\">扩充字符串</h2>\n<p>对表示文件路径的字符串进行特殊的处理 &gt; <code>~I</code> 删除任何引号（“)，扩充 %I<br>\n&gt; <code>%~fI</code> 将 %I 扩充到一个完全合格的路径名<br>\n&gt; <code>%~dI</code> 仅将 %I 扩充到一个驱动器号<br>\n&gt; <code>%~pI</code> 仅将 %I 扩充到一个路径<br>\n&gt; <code>%~nI</code> 仅将 %I 扩充到一个文件名<br>\n&gt; <code>%~xI</code> 仅将 %I 扩充到一个文件扩展名<br>\n&gt; <code>%~sI</code> 扩充的路径只含有短名<br>\n&gt; <code>%~aI</code> 将 %I 扩充到文件的文件属性<br>\n&gt; <code>%~tI</code> 将 %I 扩充到文件的日期/时间<br>\n&gt; <code>%~zI</code> 将 %I 扩充到文件的大小<br>\n&gt; <code>%~$PATH:I</code> 查找列在路径环境变量的目录，并将 %I 扩充</p>\n<h2 id=\"附数值计算\">附:数值计算</h2>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set /a expression</div></pre></td></tr></table></figure></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set /a var=123+0123+0x123</div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文主要介绍批处理中字符串的处理.","more":"</p>\n<h2 id=\"截取字符串\">截取字符串</h2>\n<p>实现截取字符串中的特定位置的一个或多个字符</p>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo %var:begin,lenth%</div></pre></td></tr></table></figure></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem 截取前5个字符：</div><div class=\"line\">echo %var:~0,5%</div><div class=\"line\"></div><div class=\"line\">rem 截取最后5个字符:</div><div class=\"line\">echo %var:~-5%</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"替换字符串\">替换字符串</h2>\n<p>将某一字符串中的特定字符或字符串替换为给定的字符串</p>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set &quot;var=%var:replaced=new%&quot;</div></pre></td></tr></table></figure></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo test=1232</div><div class=\"line\">set &quot;test=%test:2=k%&quot;</div><div class=\"line\">rem 结果test=1k3k</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"字符串合并\">字符串合并</h2>\n<p>将两个字符串放在一起</p>\n<ul>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo %var1%%var2%</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"扩充字符串\">扩充字符串</h2>\n<p>对表示文件路径的字符串进行特殊的处理 &gt; <code>~I</code> 删除任何引号（“)，扩充 %I<br>\n&gt; <code>%~fI</code> 将 %I 扩充到一个完全合格的路径名<br>\n&gt; <code>%~dI</code> 仅将 %I 扩充到一个驱动器号<br>\n&gt; <code>%~pI</code> 仅将 %I 扩充到一个路径<br>\n&gt; <code>%~nI</code> 仅将 %I 扩充到一个文件名<br>\n&gt; <code>%~xI</code> 仅将 %I 扩充到一个文件扩展名<br>\n&gt; <code>%~sI</code> 扩充的路径只含有短名<br>\n&gt; <code>%~aI</code> 将 %I 扩充到文件的文件属性<br>\n&gt; <code>%~tI</code> 将 %I 扩充到文件的日期/时间<br>\n&gt; <code>%~zI</code> 将 %I 扩充到文件的大小<br>\n&gt; <code>%~$PATH:I</code> 查找列在路径环境变量的目录，并将 %I 扩充</p>\n<h2 id=\"附数值计算\">附:数值计算</h2>\n<ul>\n<li><p>Usage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set /a expression</div></pre></td></tr></table></figure></li>\n<li><p>Sample:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set /a var=123+0123+0x123</div></pre></td></tr></table></figure></li>\n</ul>"},{"layout":"post","title":"简单批处理之实用脚本片段","comments":1,"_content":"批处理能够很便利的处理一些特定的任务,但是这些都是由基本的脚本片段构成的,所以对这些脚本片段的积累将有利于今后的任务处理.\n<!-- more -->\n\n\n## ACM\n\n1. 用测试数据检验程序正确与否\n\n\t```batch\n\t@echo off\n\t:again\n\trem r.exe生成测试案例\n\tr.exe > input\n\trem a.exe生成结果output.a\n\ta.exe < input > output.a\n\trem b.exe生成结果output.b\n\tb.exe < input > output.b\n\trem 检验output.a和output.b是否一致\n\tfc output.a output.b > null\n\tif not errorlevel 1 goto again\n\t```\n","source":"_posts/2013-09-15-简单批处理之实用脚本片段.md","raw":"---\nlayout: post\ntitle:\t简单批处理之实用脚本片段\ncategories:\n- TECHNOLOGY\ntags:\n- Batch\npermalink:  Summary-snip-Batch\ncomments:\ttrue\n---\n批处理能够很便利的处理一些特定的任务,但是这些都是由基本的脚本片段构成的,所以对这些脚本片段的积累将有利于今后的任务处理.\n<!-- more -->\n\n\n## ACM\n\n1. 用测试数据检验程序正确与否\n\n\t```batch\n\t@echo off\n\t:again\n\trem r.exe生成测试案例\n\tr.exe > input\n\trem a.exe生成结果output.a\n\ta.exe < input > output.a\n\trem b.exe生成结果output.b\n\tb.exe < input > output.b\n\trem 检验output.a和output.b是否一致\n\tfc output.a output.b > null\n\tif not errorlevel 1 goto again\n\t```\n","slug":"Summary-snip-Batch","published":1,"date":"2013-09-14T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0s000el73yuyqmu2c2","content":"<p>批处理能够很便利的处理一些特定的任务,但是这些都是由基本的脚本片段构成的,所以对这些脚本片段的积累将有利于今后的任务处理. <a id=\"more\"></a></p>\n<h2 id=\"acm\">ACM</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>用测试数据检验程序正确与否</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@echo off</div><div class=\"line\">:again</div><div class=\"line\">rem r.exe生成测试案例</div><div class=\"line\">r.exe &gt; input</div><div class=\"line\">rem a.exe生成结果output.a</div><div class=\"line\">a.exe &lt; input &gt; output.a</div><div class=\"line\">rem b.exe生成结果output.b</div><div class=\"line\">b.exe &lt; input &gt; output.b</div><div class=\"line\">rem 检验output.a和output.b是否一致</div><div class=\"line\">fc output.a output.b &gt; null</div><div class=\"line\">if not errorlevel 1 goto again</div></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>批处理能够很便利的处理一些特定的任务,但是这些都是由基本的脚本片段构成的,所以对这些脚本片段的积累将有利于今后的任务处理.","more":"</p>\n<h2 id=\"acm\">ACM</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>用测试数据检验程序正确与否</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@echo off</div><div class=\"line\">:again</div><div class=\"line\">rem r.exe生成测试案例</div><div class=\"line\">r.exe &gt; input</div><div class=\"line\">rem a.exe生成结果output.a</div><div class=\"line\">a.exe &lt; input &gt; output.a</div><div class=\"line\">rem b.exe生成结果output.b</div><div class=\"line\">b.exe &lt; input &gt; output.b</div><div class=\"line\">rem 检验output.a和output.b是否一致</div><div class=\"line\">fc output.a output.b &gt; null</div><div class=\"line\">if not errorlevel 1 goto again</div></pre></td></tr></table></figure></li>\n</ol>"},{"layout":"post","title":"简单批处理之一切尽在at中","comments":1,"_content":"让计算机在自己规定的时间里干自己规定的事，一切尽在计划之中。所以at命令你一定不能错过。\n<!-- more -->\n\n\n## 概述\n列出在指定的时间和日期在计算机上运行的已计划命令或计划命令和程序，以及设置在指定时间和日期在计算机上运行计划命令或程序（必须确保你的系统Task Scheduler服务是开启的）\n\n\n## 用法\n\n* Usage:\n\n\t```batch\n\tat  [\\\\computername] [ [id] [/DELETE] | /DELETE [/YES]]\n\tat  [\\\\computername] time [/INTERACTIVE] [ /EVERY:date[,...] | /NEXT:date[,...]] \"command\"\n\t```\n* Parameter:  \n\t> \\\\computername    指定远程计算机。 如果省略这个参数，会计划在本地计算机上运行命令  \n\t> id                指定给已计划命令的识别号  \n\t> /delete           删除某个已计划的命令。如果省略id，计算机上所有已计划的命令都会被删除\n\t> /yes              不需要进一步确认时，跟删除所有作业的命令一起使用  \n\t> time              指定运行命令的时间。将时间以 24 小时标记(00:00 [午夜] 到 23:59)的方式表示为小时：分钟  \n\t> /interactive      允许作业在运行时，与当时登录的用户桌面进行交互  \n\t> /every:date[,...] 在每个星期或月的指定日期（例如每个星期四，或每月的第三天）运行命令。将 date指定为星期的一天或多天(M,T,W,Th,F,S,Su)，或月的一天或多天（使用1 到 31 的数字）。用逗号分隔多个日期项。如果省略了date，将假定为该月的当前日期   \n\t> \"command\"        准备运行的 Windows NT 命令或批处理程序\n\n\n## 案例\n\n1. 凌晨自动关机\n\n\t```batch\n\tat 00:00 shutdown -s -f -t 0 >nul 2>nul\n\trem 0>nul 2>nul  表示无论命令执行成功与否都不显示消息\n\t```\n2. 在每个周二的上午8点执行系统垃圾的清理(clean.exe)\n\n\t```batch\n\tat 8:00 /every:M cmd /c  d:/clean.bat  \n\tat 8:00 /every:M clean.exe\n\trem    cmd /c dir 是执行完dir命令后关闭命令窗口\n\trem    d:/clean.bat是你要执行垃圾清理的批处理的路径及文件名\n\t```\n3. 计划从周一到周六每天上午2:00执行数据库备份\n\n\t```batch\n\tat 2:00 /every:M,T,W,TH,F,S,Su cmd /c d:autobackup.bat\n\t```\n4. 计划管理\n\n\t```batch\n\trem 列出当前所有计划\n\tat\n\n\trem 取消所有计划\n\tat /del /yes\n\n\trem 取消单个计划,如id为2\n\tat 2 /del\n\t```\n","source":"_posts/2013-09-13-简单批处理之一切尽在at中.md","raw":"---\nlayout:\tpost\ntitle:\t简单批处理之一切尽在at中\ncategories:\n- TECHNOLOGY\ntags:\n- Batch\npermalink:  Summary-at-Batch\ncomments:\ttrue\n---\n让计算机在自己规定的时间里干自己规定的事，一切尽在计划之中。所以at命令你一定不能错过。\n<!-- more -->\n\n\n## 概述\n列出在指定的时间和日期在计算机上运行的已计划命令或计划命令和程序，以及设置在指定时间和日期在计算机上运行计划命令或程序（必须确保你的系统Task Scheduler服务是开启的）\n\n\n## 用法\n\n* Usage:\n\n\t```batch\n\tat  [\\\\computername] [ [id] [/DELETE] | /DELETE [/YES]]\n\tat  [\\\\computername] time [/INTERACTIVE] [ /EVERY:date[,...] | /NEXT:date[,...]] \"command\"\n\t```\n* Parameter:  \n\t> \\\\computername    指定远程计算机。 如果省略这个参数，会计划在本地计算机上运行命令  \n\t> id                指定给已计划命令的识别号  \n\t> /delete           删除某个已计划的命令。如果省略id，计算机上所有已计划的命令都会被删除\n\t> /yes              不需要进一步确认时，跟删除所有作业的命令一起使用  \n\t> time              指定运行命令的时间。将时间以 24 小时标记(00:00 [午夜] 到 23:59)的方式表示为小时：分钟  \n\t> /interactive      允许作业在运行时，与当时登录的用户桌面进行交互  \n\t> /every:date[,...] 在每个星期或月的指定日期（例如每个星期四，或每月的第三天）运行命令。将 date指定为星期的一天或多天(M,T,W,Th,F,S,Su)，或月的一天或多天（使用1 到 31 的数字）。用逗号分隔多个日期项。如果省略了date，将假定为该月的当前日期   \n\t> \"command\"        准备运行的 Windows NT 命令或批处理程序\n\n\n## 案例\n\n1. 凌晨自动关机\n\n\t```batch\n\tat 00:00 shutdown -s -f -t 0 >nul 2>nul\n\trem 0>nul 2>nul  表示无论命令执行成功与否都不显示消息\n\t```\n2. 在每个周二的上午8点执行系统垃圾的清理(clean.exe)\n\n\t```batch\n\tat 8:00 /every:M cmd /c  d:/clean.bat  \n\tat 8:00 /every:M clean.exe\n\trem    cmd /c dir 是执行完dir命令后关闭命令窗口\n\trem    d:/clean.bat是你要执行垃圾清理的批处理的路径及文件名\n\t```\n3. 计划从周一到周六每天上午2:00执行数据库备份\n\n\t```batch\n\tat 2:00 /every:M,T,W,TH,F,S,Su cmd /c d:autobackup.bat\n\t```\n4. 计划管理\n\n\t```batch\n\trem 列出当前所有计划\n\tat\n\n\trem 取消所有计划\n\tat /del /yes\n\n\trem 取消单个计划,如id为2\n\tat 2 /del\n\t```\n","slug":"Summary-at-Batch","published":1,"date":"2013-09-12T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0t000fl73yozr9a4gr","content":"<p>让计算机在自己规定的时间里干自己规定的事，一切尽在计划之中。所以at命令你一定不能错过。 <a id=\"more\"></a></p>\n<h2 id=\"概述\">概述</h2>\n<p>列出在指定的时间和日期在计算机上运行的已计划命令或计划命令和程序，以及设置在指定时间和日期在计算机上运行计划命令或程序（必须确保你的系统Task Scheduler服务是开启的）</p>\n<h2 id=\"用法\">用法</h2>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">at  [\\\\computername] [ [id] [/DELETE] | /DELETE [/YES]]</div><div class=\"line\">at  [\\\\computername] time [/INTERACTIVE] [ /EVERY:date[,...] | /NEXT:date[,...]] &quot;command&quot;</div></pre></td></tr></table></figure></li>\n<li><p>Parameter:<br>\n&gt; \\computername 指定远程计算机。 如果省略这个参数，会计划在本地计算机上运行命令<br>\n&gt; id 指定给已计划命令的识别号<br>\n&gt; /delete 删除某个已计划的命令。如果省略id，计算机上所有已计划的命令都会被删除 &gt; /yes 不需要进一步确认时，跟删除所有作业的命令一起使用<br>\n&gt; time 指定运行命令的时间。将时间以 24 小时标记(00:00 [午夜] 到 23:59)的方式表示为小时：分钟<br>\n&gt; /interactive 允许作业在运行时，与当时登录的用户桌面进行交互<br>\n&gt; /every:date[,…] 在每个星期或月的指定日期（例如每个星期四，或每月的第三天）运行命令。将 date指定为星期的一天或多天(M,T,W,Th,F,S,Su)，或月的一天或多天（使用1 到 31 的数字）。用逗号分隔多个日期项。如果省略了date，将假定为该月的当前日期<br>\n&gt; “command” 准备运行的 Windows NT 命令或批处理程序</p></li>\n</ul>\n<h2 id=\"案例\">案例</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>凌晨自动关机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">at 00:00 shutdown -s -f -t 0 &gt;nul 2&gt;nul</div><div class=\"line\">rem 0&gt;nul 2&gt;nul  表示无论命令执行成功与否都不显示消息</div></pre></td></tr></table></figure></li>\n<li><p>在每个周二的上午8点执行系统垃圾的清理(clean.exe)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">at 8:00 /every:M cmd /c  d:/clean.bat  </div><div class=\"line\">at 8:00 /every:M clean.exe</div><div class=\"line\">rem    cmd /c dir 是执行完dir命令后关闭命令窗口</div><div class=\"line\">rem    d:/clean.bat是你要执行垃圾清理的批处理的路径及文件名</div></pre></td></tr></table></figure></li>\n<li><p>计划从周一到周六每天上午2:00执行数据库备份</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">at 2:00 /every:M,T,W,TH,F,S,Su cmd /c d:autobackup.bat</div></pre></td></tr></table></figure></li>\n<li><p>计划管理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem 列出当前所有计划</div><div class=\"line\">at</div><div class=\"line\"></div><div class=\"line\">rem 取消所有计划</div><div class=\"line\">at /del /yes</div><div class=\"line\"></div><div class=\"line\">rem 取消单个计划,如id为2</div><div class=\"line\">at 2 /del</div></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>让计算机在自己规定的时间里干自己规定的事，一切尽在计划之中。所以at命令你一定不能错过。","more":"</p>\n<h2 id=\"概述\">概述</h2>\n<p>列出在指定的时间和日期在计算机上运行的已计划命令或计划命令和程序，以及设置在指定时间和日期在计算机上运行计划命令或程序（必须确保你的系统Task Scheduler服务是开启的）</p>\n<h2 id=\"用法\">用法</h2>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">at  [\\\\computername] [ [id] [/DELETE] | /DELETE [/YES]]</div><div class=\"line\">at  [\\\\computername] time [/INTERACTIVE] [ /EVERY:date[,...] | /NEXT:date[,...]] &quot;command&quot;</div></pre></td></tr></table></figure></li>\n<li><p>Parameter:<br>\n&gt; \\computername 指定远程计算机。 如果省略这个参数，会计划在本地计算机上运行命令<br>\n&gt; id 指定给已计划命令的识别号<br>\n&gt; /delete 删除某个已计划的命令。如果省略id，计算机上所有已计划的命令都会被删除 &gt; /yes 不需要进一步确认时，跟删除所有作业的命令一起使用<br>\n&gt; time 指定运行命令的时间。将时间以 24 小时标记(00:00 [午夜] 到 23:59)的方式表示为小时：分钟<br>\n&gt; /interactive 允许作业在运行时，与当时登录的用户桌面进行交互<br>\n&gt; /every:date[,…] 在每个星期或月的指定日期（例如每个星期四，或每月的第三天）运行命令。将 date指定为星期的一天或多天(M,T,W,Th,F,S,Su)，或月的一天或多天（使用1 到 31 的数字）。用逗号分隔多个日期项。如果省略了date，将假定为该月的当前日期<br>\n&gt; “command” 准备运行的 Windows NT 命令或批处理程序</p></li>\n</ul>\n<h2 id=\"案例\">案例</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>凌晨自动关机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">at 00:00 shutdown -s -f -t 0 &gt;nul 2&gt;nul</div><div class=\"line\">rem 0&gt;nul 2&gt;nul  表示无论命令执行成功与否都不显示消息</div></pre></td></tr></table></figure></li>\n<li><p>在每个周二的上午8点执行系统垃圾的清理(clean.exe)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">at 8:00 /every:M cmd /c  d:/clean.bat  </div><div class=\"line\">at 8:00 /every:M clean.exe</div><div class=\"line\">rem    cmd /c dir 是执行完dir命令后关闭命令窗口</div><div class=\"line\">rem    d:/clean.bat是你要执行垃圾清理的批处理的路径及文件名</div></pre></td></tr></table></figure></li>\n<li><p>计划从周一到周六每天上午2:00执行数据库备份</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">at 2:00 /every:M,T,W,TH,F,S,Su cmd /c d:autobackup.bat</div></pre></td></tr></table></figure></li>\n<li><p>计划管理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem 列出当前所有计划</div><div class=\"line\">at</div><div class=\"line\"></div><div class=\"line\">rem 取消所有计划</div><div class=\"line\">at /del /yes</div><div class=\"line\"></div><div class=\"line\">rem 取消单个计划,如id为2</div><div class=\"line\">at 2 /del</div></pre></td></tr></table></figure></li>\n</ol>"},{"layout":"post","title":"简单批处理之众里find它一次度","comments":1,"_content":"在批处理的过程中,经常需要查找文件以及在文件中查找相关字符串.在linux中有`grep`,`awk`,`sed`等命令,不过windows里面也有类似的命令,如这次介绍的`find`,`findstr`.\n<!-- more -->\n\n\n## find\n### 用法\n\n* Usage:\n\t```batch\n\trem command:\n\tfind [/v][/c][/n][/i] \"string\" [[drive:][path]filename]\n\t```\n* Parameter:  \n\n\t> `/v`    显示所有未包含指定字符串的行。   \n\t> `/c`    仅显示包含字符串的行数。   \n\t> `/n`    显示行号。  \n\t> `/i`    搜索字符串时忽略大小写。\n\n### 案例\n\n1. 在文本test.txt中查找包含\"Abc”的整行，并显示(不区分大小写)\n\n\t```batch\n\tfind /i “Abc” test.txt\n\t```\n2. 在文本test.txt中查找不包含\"Abc\"的整行，并显示  \n\n\t```batch\n\tfind /v \"Abc\" test.txt\n\t```\n3. 在文本test.txt中查找\"Abc\"出现的次数  \n\n\t```batch\n\tfind /n \"Abc\" test.txt\n\t```\n4. 在字符串\"abcdef”中查找\"abc\"(支持管道用法)  \n\n\t```batch\n\techo abcdef | find \"abc\"\n\t```\n\n## findstr--find的扩展\n### 用法\n\n* Usage:\n\n\t```batch\n\trem Command:\n\tfind [/v][/c][/n][/i] strings [[drive:][path]filename]\n\t```\n* Parameter:  \n\n\t> `/b`    在一行的开始配对模式。(就是指以字符串开头，begin 这样就方便了记忆)  \n\t> `/e`    在一行的结尾配对模式。（就是指以字符串结尾，end 这样就方便记忆）  \n\t> `/l`    按字使用搜索字符串。就是将后面的\"\"里的当成一个字符  \n\t> `/r`    将搜索字符串作为一般表达式使用。  \n\t> `/s`    在当前目录和所有子目录中搜索匹配文件。  \n\t> `/i`    指定搜索不分大小写。（英文：ignore 忽略）  \n\t> `/x`    打印完全匹配的行。/x 是指完全匹配,就是说整行匹配,而不是含有关键字.  \n\t> `/v`    只打印不包含匹配的行。（就是找出不包含字符串的）  \n\t> `/n`    在匹配的每行前打印行数。（就是在输出行的前面加上原文件中的行数--number）  \n\t> `/m`    如果文件含有匹配项，只打印其文件名。（指定文件中输出含有字符串的文件名）  \n\t> `/o`    在每个匹配行前打印字符偏移量。o开关的作用是告诉你每行第一个字符前的位置是该文件中的第几个字节  \t\t \n\t> `/C:string` 使用指定字符串作为文字搜索字符串   \n\t> `/G:file` 从指定的文件获得搜索字符串。(/代表控制台)  \n\t> `/F:file` 从指定文件读文件列表 (/ 代表控制台)。   \n\t> `/D:dir` 查找以分号为分隔符的目录列表  \n\t> **Sign:**  \n\t> `.`\t通配符: 任何字符  \n\t> `*`\t重复: 以前字符或类别出现零或零以上次数  \n\t> `^`\t行位置: 行的开始  \n\t> `$`\t行位置: 行的终点  \n\t> `[class]`\t字符类别: 任何在字符集中的字符  \n\t> `[^class]`\t补字符类别: 任何不在字符集中的字符  \n\t> `[x-y]`\t范围: 在指定范围内的任何字符  \n\t> `\\x`\tEscape: 元字符 x 的文字用法  \n\t> `\\<xyz`\t字位置: 字的开始  \n\t> `xyz\\>`\t字位置: 字的结束  \n\t> `\\<`和`\\>`\t是单词锚定 ^是行首 $是行尾  \n\n### 案例\n\n1. 在文件x.y中搜索\"hello\"或\"there\"\n\n\t```batch\n\tfindstr \"hello there\"  x.y\n\t```\n2. 在文件x.y中搜索\"hello there\"\n\n\t```batch\n\tfindstr /c:\"hello there\" x.y\n\t```\n3. 把1.txt中含有2.txt中任何一行内容的行输出来\n\n\t```batch\n\tfindstr /g:2.txt 1.txt\n\trem 等价于:\n\t@echo off\n\tfor /f \"delims=\" %%a in (2.txt) do (\n\t    findstr \"%%a\" 1.txt\n\t)\n\tpause\n\t```\n4. 行开始/结束与字开始结束\n\n\t```batch\n\tfindstr \"cd\\>\" 1.txt\n\trem 1.txt中两行\"abcd\"和\"abcd e\"都会出现\n\t```\n5. 从文件2.txt中查找包括数字0-9的字符串或行\n\n\t```batch\n\tfindstr \"[0-9]\" 2.txt\n\t```\n6. 匹配找到纯数字,如233432或匹配找到纯字母,如sdfsd\n\n\t```batch\n\tfindstr \"^[0-9]*$\" 2.txt\n\tfindstr “^[a-z]*$\" 2.txt\n\t```\n7. 把1.txt文档中超过10个字符的行输入到2.txt中\n\n\t```batch\n\tfindstr .......... 1.txt > 2.txt\n\t```\n\n## find和findstr的比较\n\n1. 统计含指定字符串的总行数。`find /c \"abc\" test.txt`可以统计test.txt中含有字符串abc的总行数，而findstr则没有直接提供该功能，需要配合for语句才能实现  \n2. find可以读取Unicode格式的文本，而findstr则不行\n","source":"_posts/2013-09-14-简单批处理之众里find它一次度.md","raw":"---\nlayout:\tpost\ntitle:\t简单批处理之众里find它一次度\ncategories:\n- TECHNOLOGY\ntags:\n- Batch\npermalink:  Summary-find-Batch\ncomments:\ttrue\n---\n在批处理的过程中,经常需要查找文件以及在文件中查找相关字符串.在linux中有`grep`,`awk`,`sed`等命令,不过windows里面也有类似的命令,如这次介绍的`find`,`findstr`.\n<!-- more -->\n\n\n## find\n### 用法\n\n* Usage:\n\t```batch\n\trem command:\n\tfind [/v][/c][/n][/i] \"string\" [[drive:][path]filename]\n\t```\n* Parameter:  \n\n\t> `/v`    显示所有未包含指定字符串的行。   \n\t> `/c`    仅显示包含字符串的行数。   \n\t> `/n`    显示行号。  \n\t> `/i`    搜索字符串时忽略大小写。\n\n### 案例\n\n1. 在文本test.txt中查找包含\"Abc”的整行，并显示(不区分大小写)\n\n\t```batch\n\tfind /i “Abc” test.txt\n\t```\n2. 在文本test.txt中查找不包含\"Abc\"的整行，并显示  \n\n\t```batch\n\tfind /v \"Abc\" test.txt\n\t```\n3. 在文本test.txt中查找\"Abc\"出现的次数  \n\n\t```batch\n\tfind /n \"Abc\" test.txt\n\t```\n4. 在字符串\"abcdef”中查找\"abc\"(支持管道用法)  \n\n\t```batch\n\techo abcdef | find \"abc\"\n\t```\n\n## findstr--find的扩展\n### 用法\n\n* Usage:\n\n\t```batch\n\trem Command:\n\tfind [/v][/c][/n][/i] strings [[drive:][path]filename]\n\t```\n* Parameter:  \n\n\t> `/b`    在一行的开始配对模式。(就是指以字符串开头，begin 这样就方便了记忆)  \n\t> `/e`    在一行的结尾配对模式。（就是指以字符串结尾，end 这样就方便记忆）  \n\t> `/l`    按字使用搜索字符串。就是将后面的\"\"里的当成一个字符  \n\t> `/r`    将搜索字符串作为一般表达式使用。  \n\t> `/s`    在当前目录和所有子目录中搜索匹配文件。  \n\t> `/i`    指定搜索不分大小写。（英文：ignore 忽略）  \n\t> `/x`    打印完全匹配的行。/x 是指完全匹配,就是说整行匹配,而不是含有关键字.  \n\t> `/v`    只打印不包含匹配的行。（就是找出不包含字符串的）  \n\t> `/n`    在匹配的每行前打印行数。（就是在输出行的前面加上原文件中的行数--number）  \n\t> `/m`    如果文件含有匹配项，只打印其文件名。（指定文件中输出含有字符串的文件名）  \n\t> `/o`    在每个匹配行前打印字符偏移量。o开关的作用是告诉你每行第一个字符前的位置是该文件中的第几个字节  \t\t \n\t> `/C:string` 使用指定字符串作为文字搜索字符串   \n\t> `/G:file` 从指定的文件获得搜索字符串。(/代表控制台)  \n\t> `/F:file` 从指定文件读文件列表 (/ 代表控制台)。   \n\t> `/D:dir` 查找以分号为分隔符的目录列表  \n\t> **Sign:**  \n\t> `.`\t通配符: 任何字符  \n\t> `*`\t重复: 以前字符或类别出现零或零以上次数  \n\t> `^`\t行位置: 行的开始  \n\t> `$`\t行位置: 行的终点  \n\t> `[class]`\t字符类别: 任何在字符集中的字符  \n\t> `[^class]`\t补字符类别: 任何不在字符集中的字符  \n\t> `[x-y]`\t范围: 在指定范围内的任何字符  \n\t> `\\x`\tEscape: 元字符 x 的文字用法  \n\t> `\\<xyz`\t字位置: 字的开始  \n\t> `xyz\\>`\t字位置: 字的结束  \n\t> `\\<`和`\\>`\t是单词锚定 ^是行首 $是行尾  \n\n### 案例\n\n1. 在文件x.y中搜索\"hello\"或\"there\"\n\n\t```batch\n\tfindstr \"hello there\"  x.y\n\t```\n2. 在文件x.y中搜索\"hello there\"\n\n\t```batch\n\tfindstr /c:\"hello there\" x.y\n\t```\n3. 把1.txt中含有2.txt中任何一行内容的行输出来\n\n\t```batch\n\tfindstr /g:2.txt 1.txt\n\trem 等价于:\n\t@echo off\n\tfor /f \"delims=\" %%a in (2.txt) do (\n\t    findstr \"%%a\" 1.txt\n\t)\n\tpause\n\t```\n4. 行开始/结束与字开始结束\n\n\t```batch\n\tfindstr \"cd\\>\" 1.txt\n\trem 1.txt中两行\"abcd\"和\"abcd e\"都会出现\n\t```\n5. 从文件2.txt中查找包括数字0-9的字符串或行\n\n\t```batch\n\tfindstr \"[0-9]\" 2.txt\n\t```\n6. 匹配找到纯数字,如233432或匹配找到纯字母,如sdfsd\n\n\t```batch\n\tfindstr \"^[0-9]*$\" 2.txt\n\tfindstr “^[a-z]*$\" 2.txt\n\t```\n7. 把1.txt文档中超过10个字符的行输入到2.txt中\n\n\t```batch\n\tfindstr .......... 1.txt > 2.txt\n\t```\n\n## find和findstr的比较\n\n1. 统计含指定字符串的总行数。`find /c \"abc\" test.txt`可以统计test.txt中含有字符串abc的总行数，而findstr则没有直接提供该功能，需要配合for语句才能实现  \n2. find可以读取Unicode格式的文本，而findstr则不行\n","slug":"Summary-find-Batch","published":1,"date":"2013-09-13T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0t000gl73yn97yt65c","content":"<p>在批处理的过程中,经常需要查找文件以及在文件中查找相关字符串.在linux中有<code>grep</code>,<code>awk</code>,<code>sed</code>等命令,不过windows里面也有类似的命令,如这次介绍的<code>find</code>,<code>findstr</code>. <a id=\"more\"></a></p>\n<h2 id=\"find\">find</h2>\n<h3 id=\"用法\">用法</h3>\n<ul>\n<li><p>Usage: <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem command:</div><div class=\"line\">find [/v][/c][/n][/i] &quot;string&quot; [[drive:][path]filename]</div></pre></td></tr></table></figure></p></li>\n<li><p>Parameter:</p>\n<blockquote>\n<p><code>/v</code> 显示所有未包含指定字符串的行。<br>\n<code>/c</code> 仅显示包含字符串的行数。<br>\n<code>/n</code> 显示行号。<br>\n<code>/i</code> 搜索字符串时忽略大小写。</p>\n</blockquote></li>\n</ul>\n<h3 id=\"案例\">案例</h3>\n<ol style=\"list-style-type: decimal\">\n<li><p>在文本test.txt中查找包含“Abc”的整行，并显示(不区分大小写)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find /i “Abc” test.txt</div></pre></td></tr></table></figure></li>\n<li><p>在文本test.txt中查找不包含“Abc”的整行，并显示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find /v &quot;Abc&quot; test.txt</div></pre></td></tr></table></figure></li>\n<li><p>在文本test.txt中查找“Abc”出现的次数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find /n &quot;Abc&quot; test.txt</div></pre></td></tr></table></figure></li>\n<li><p>在字符串“abcdef”中查找“abc”(支持管道用法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo abcdef | find &quot;abc&quot;</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"findstrfind的扩展\">findstr–find的扩展</h2>\n<h3 id=\"用法-1\">用法</h3>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem Command:</div><div class=\"line\">find [/v][/c][/n][/i] strings [[drive:][path]filename]</div></pre></td></tr></table></figure></li>\n<li><p>Parameter:</p>\n<blockquote>\n<p><code>/b</code> 在一行的开始配对模式。(就是指以字符串开头，begin 这样就方便了记忆)<br>\n<code>/e</code> 在一行的结尾配对模式。（就是指以字符串结尾，end 这样就方便记忆）<br>\n<code>/l</code> 按字使用搜索字符串。就是将后面的“”里的当成一个字符<br>\n<code>/r</code> 将搜索字符串作为一般表达式使用。<br>\n<code>/s</code> 在当前目录和所有子目录中搜索匹配文件。<br>\n<code>/i</code> 指定搜索不分大小写。（英文：ignore 忽略）<br>\n<code>/x</code> 打印完全匹配的行。/x 是指完全匹配,就是说整行匹配,而不是含有关键字.<br>\n<code>/v</code> 只打印不包含匹配的行。（就是找出不包含字符串的）<br>\n<code>/n</code> 在匹配的每行前打印行数。（就是在输出行的前面加上原文件中的行数–number）<br>\n<code>/m</code> 如果文件含有匹配项，只打印其文件名。（指定文件中输出含有字符串的文件名）<br>\n<code>/o</code> 在每个匹配行前打印字符偏移量。o开关的作用是告诉你每行第一个字符前的位置是该文件中的第几个字节<br>\n<code>/C:string</code> 使用指定字符串作为文字搜索字符串<br>\n<code>/G:file</code> 从指定的文件获得搜索字符串。(/代表控制台)<br>\n<code>/F:file</code> 从指定文件读文件列表 (/ 代表控制台)。<br>\n<code>/D:dir</code> 查找以分号为分隔符的目录列表<br>\n<strong>Sign:</strong><br>\n<code>.</code> 通配符: 任何字符<br>\n<code>*</code> 重复: 以前字符或类别出现零或零以上次数<br>\n<code>^</code> 行位置: 行的开始<br>\n<code>$</code> 行位置: 行的终点<br>\n<code>[class]</code> 字符类别: 任何在字符集中的字符<br>\n<code>[^class]</code> 补字符类别: 任何不在字符集中的字符<br>\n<code>[x-y]</code> 范围: 在指定范围内的任何字符<br>\n<code>\\x</code> Escape: 元字符 x 的文字用法<br>\n<code>\\&lt;xyz</code> 字位置: 字的开始<br>\n<code>xyz\\&gt;</code> 字位置: 字的结束<br>\n<code>\\&lt;</code>和<code>\\&gt;</code> 是单词锚定 ^是行首 $是行尾</p>\n</blockquote></li>\n</ul>\n<h3 id=\"案例-1\">案例</h3>\n<ol style=\"list-style-type: decimal\">\n<li><p>在文件x.y中搜索“hello”或“there”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr &quot;hello there&quot;  x.y</div></pre></td></tr></table></figure></li>\n<li><p>在文件x.y中搜索“hello there”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr /c:&quot;hello there&quot; x.y</div></pre></td></tr></table></figure></li>\n<li><p>把1.txt中含有2.txt中任何一行内容的行输出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr /g:2.txt 1.txt</div><div class=\"line\">rem 等价于:</div><div class=\"line\">@echo off</div><div class=\"line\">for /f &quot;delims=&quot; %%a in (2.txt) do (</div><div class=\"line\">    findstr &quot;%%a&quot; 1.txt</div><div class=\"line\">)</div><div class=\"line\">pause</div></pre></td></tr></table></figure></li>\n<li><p>行开始/结束与字开始结束</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr &quot;cd\\&gt;&quot; 1.txt</div><div class=\"line\">rem 1.txt中两行&quot;abcd&quot;和&quot;abcd e&quot;都会出现</div></pre></td></tr></table></figure></li>\n<li><p>从文件2.txt中查找包括数字0-9的字符串或行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr &quot;[0-9]&quot; 2.txt</div></pre></td></tr></table></figure></li>\n<li><p>匹配找到纯数字,如233432或匹配找到纯字母,如sdfsd</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr &quot;^[0-9]*$&quot; 2.txt</div><div class=\"line\">findstr “^[a-z]*$&quot; 2.txt</div></pre></td></tr></table></figure></li>\n<li><p>把1.txt文档中超过10个字符的行输入到2.txt中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr .......... 1.txt &gt; 2.txt</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"find和findstr的比较\">find和findstr的比较</h2>\n<ol style=\"list-style-type: decimal\">\n<li>统计含指定字符串的总行数。<code>find /c &quot;abc&quot; test.txt</code>可以统计test.txt中含有字符串abc的总行数，而findstr则没有直接提供该功能，需要配合for语句才能实现<br>\n</li>\n<li>find可以读取Unicode格式的文本，而findstr则不行</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在批处理的过程中,经常需要查找文件以及在文件中查找相关字符串.在linux中有<code>grep</code>,<code>awk</code>,<code>sed</code>等命令,不过windows里面也有类似的命令,如这次介绍的<code>find</code>,<code>findstr</code>.","more":"</p>\n<h2 id=\"find\">find</h2>\n<h3 id=\"用法\">用法</h3>\n<ul>\n<li><p>Usage: <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem command:</div><div class=\"line\">find [/v][/c][/n][/i] &quot;string&quot; [[drive:][path]filename]</div></pre></td></tr></table></figure></p></li>\n<li><p>Parameter:</p>\n<blockquote>\n<p><code>/v</code> 显示所有未包含指定字符串的行。<br>\n<code>/c</code> 仅显示包含字符串的行数。<br>\n<code>/n</code> 显示行号。<br>\n<code>/i</code> 搜索字符串时忽略大小写。</p>\n</blockquote></li>\n</ul>\n<h3 id=\"案例\">案例</h3>\n<ol style=\"list-style-type: decimal\">\n<li><p>在文本test.txt中查找包含“Abc”的整行，并显示(不区分大小写)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find /i “Abc” test.txt</div></pre></td></tr></table></figure></li>\n<li><p>在文本test.txt中查找不包含“Abc”的整行，并显示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find /v &quot;Abc&quot; test.txt</div></pre></td></tr></table></figure></li>\n<li><p>在文本test.txt中查找“Abc”出现的次数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find /n &quot;Abc&quot; test.txt</div></pre></td></tr></table></figure></li>\n<li><p>在字符串“abcdef”中查找“abc”(支持管道用法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo abcdef | find &quot;abc&quot;</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"findstrfind的扩展\">findstr–find的扩展</h2>\n<h3 id=\"用法-1\">用法</h3>\n<ul>\n<li><p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">rem Command:</div><div class=\"line\">find [/v][/c][/n][/i] strings [[drive:][path]filename]</div></pre></td></tr></table></figure></li>\n<li><p>Parameter:</p>\n<blockquote>\n<p><code>/b</code> 在一行的开始配对模式。(就是指以字符串开头，begin 这样就方便了记忆)<br>\n<code>/e</code> 在一行的结尾配对模式。（就是指以字符串结尾，end 这样就方便记忆）<br>\n<code>/l</code> 按字使用搜索字符串。就是将后面的“”里的当成一个字符<br>\n<code>/r</code> 将搜索字符串作为一般表达式使用。<br>\n<code>/s</code> 在当前目录和所有子目录中搜索匹配文件。<br>\n<code>/i</code> 指定搜索不分大小写。（英文：ignore 忽略）<br>\n<code>/x</code> 打印完全匹配的行。/x 是指完全匹配,就是说整行匹配,而不是含有关键字.<br>\n<code>/v</code> 只打印不包含匹配的行。（就是找出不包含字符串的）<br>\n<code>/n</code> 在匹配的每行前打印行数。（就是在输出行的前面加上原文件中的行数–number）<br>\n<code>/m</code> 如果文件含有匹配项，只打印其文件名。（指定文件中输出含有字符串的文件名）<br>\n<code>/o</code> 在每个匹配行前打印字符偏移量。o开关的作用是告诉你每行第一个字符前的位置是该文件中的第几个字节<br>\n<code>/C:string</code> 使用指定字符串作为文字搜索字符串<br>\n<code>/G:file</code> 从指定的文件获得搜索字符串。(/代表控制台)<br>\n<code>/F:file</code> 从指定文件读文件列表 (/ 代表控制台)。<br>\n<code>/D:dir</code> 查找以分号为分隔符的目录列表<br>\n<strong>Sign:</strong><br>\n<code>.</code> 通配符: 任何字符<br>\n<code>*</code> 重复: 以前字符或类别出现零或零以上次数<br>\n<code>^</code> 行位置: 行的开始<br>\n<code>$</code> 行位置: 行的终点<br>\n<code>[class]</code> 字符类别: 任何在字符集中的字符<br>\n<code>[^class]</code> 补字符类别: 任何不在字符集中的字符<br>\n<code>[x-y]</code> 范围: 在指定范围内的任何字符<br>\n<code>\\x</code> Escape: 元字符 x 的文字用法<br>\n<code>\\&lt;xyz</code> 字位置: 字的开始<br>\n<code>xyz\\&gt;</code> 字位置: 字的结束<br>\n<code>\\&lt;</code>和<code>\\&gt;</code> 是单词锚定 ^是行首 $是行尾</p>\n</blockquote></li>\n</ul>\n<h3 id=\"案例-1\">案例</h3>\n<ol style=\"list-style-type: decimal\">\n<li><p>在文件x.y中搜索“hello”或“there”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr &quot;hello there&quot;  x.y</div></pre></td></tr></table></figure></li>\n<li><p>在文件x.y中搜索“hello there”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr /c:&quot;hello there&quot; x.y</div></pre></td></tr></table></figure></li>\n<li><p>把1.txt中含有2.txt中任何一行内容的行输出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr /g:2.txt 1.txt</div><div class=\"line\">rem 等价于:</div><div class=\"line\">@echo off</div><div class=\"line\">for /f &quot;delims=&quot; %%a in (2.txt) do (</div><div class=\"line\">    findstr &quot;%%a&quot; 1.txt</div><div class=\"line\">)</div><div class=\"line\">pause</div></pre></td></tr></table></figure></li>\n<li><p>行开始/结束与字开始结束</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr &quot;cd\\&gt;&quot; 1.txt</div><div class=\"line\">rem 1.txt中两行&quot;abcd&quot;和&quot;abcd e&quot;都会出现</div></pre></td></tr></table></figure></li>\n<li><p>从文件2.txt中查找包括数字0-9的字符串或行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr &quot;[0-9]&quot; 2.txt</div></pre></td></tr></table></figure></li>\n<li><p>匹配找到纯数字,如233432或匹配找到纯字母,如sdfsd</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr &quot;^[0-9]*$&quot; 2.txt</div><div class=\"line\">findstr “^[a-z]*$&quot; 2.txt</div></pre></td></tr></table></figure></li>\n<li><p>把1.txt文档中超过10个字符的行输入到2.txt中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">findstr .......... 1.txt &gt; 2.txt</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"find和findstr的比较\">find和findstr的比较</h2>\n<ol style=\"list-style-type: decimal\">\n<li>统计含指定字符串的总行数。<code>find /c &quot;abc&quot; test.txt</code>可以统计test.txt中含有字符串abc的总行数，而findstr则没有直接提供该功能，需要配合for语句才能实现<br>\n</li>\n<li>find可以读取Unicode格式的文本，而findstr则不行</li>\n</ol>"},{"layout":"post","title":"shell编程之基本内容","comments":1,"_content":"在windows里面进行任务处理通常是用批处理,但是其功能是单薄的.而且一般公司服务器都是用的linux系统,批处理是没有用武之地的,关键时候还是shell给力.其实说白了,shell编程就是linux命令的组合.\n<!-- more -->\n\n\n\n## 变量\n* 定义，赋值：\n\n\t```bash\n\tvar=value\n\t```\n* 引用\n\n\t```bash\n\t$var,${var}\n\t```\n* 特殊变量\n\t* `$?`\t上条命令状态\n\t* `$*`/`$@`\t所有参数列表\n\t* `$#`\t参数个数\n\t* `$0`\t执行的命令名称\n\t* `$1`/`${10}`\t第1/10个参数\n\n## 数值运算\n* 基本用法\n\n\t```bash\n\texpr value1 op value2\t# eg. expr $var1 + $var2\n\t$[ value1 op value2 ]\t# eg. $[var1+var2]\n\t```\n* 变量递更\n\n\t```bash\n\tlet var++\t# 自增1\n\tlet var+=2\t# 自增2\n\t```\n* 随机数生成\n\n\t```bash\n\techo $RANDOM\t# $RANDOM生成随机数\n\t```\n* 生成数字序列\n\n\t```bash\n\t# 显示first，first+1，...，end\n\tseq first end\n\t# 显示first，first+step，...\n\tseq first step end\n\t```\n* 小数计算（bc命令）\n\n\t```bash\n\t# 将运算的字符串传递给bc命令去处理\n\techo “45.6×33.2” | bc\n\t```\n\n\n## 字符串操作\n* 子串截取\n\n\t```bash\n\t# 提取$path里面的目录路径/文件名\n\tdirname/basename $path\n\t# 截取$string字串，从first（起始为1）开始，长度为length\n\texpr substr $string first\n\t# 截取$string子串，从first（起始为0）开始，长度为length\n\t${string:first:length}\n\t# 从左开始匹配patten，从string删除最短的patten\n\t${string#patten}\n\t# 从右开始匹配patten，从string删除最短的patten\n\t${string%patten}\n\t```\n* 字符串替换\n\n\t```bash\n\t# 将string中第一个old替换为new\n\t${string/old/new}\n\t# 将string中所有old替换为new\n\t${string//old/new}\n\t```\n* 生成随机字符串\n\n\t```bash\n\t# 生成长度为8的随机字符串\n\thead -1 /dev/urandom | md5sum | cut -c1-8\n\t```\n","source":"_posts/2014-02-26-shell编程之基本内容.md","raw":"---\nlayout:\tpost\ntitle:\tshell编程之基本内容\ncategories:\n- TECHNOLOGY\ntags:\n- Shell\npermalink:  Summary-basicConcept-Shell\ncomments:\ttrue\n---\n在windows里面进行任务处理通常是用批处理,但是其功能是单薄的.而且一般公司服务器都是用的linux系统,批处理是没有用武之地的,关键时候还是shell给力.其实说白了,shell编程就是linux命令的组合.\n<!-- more -->\n\n\n\n## 变量\n* 定义，赋值：\n\n\t```bash\n\tvar=value\n\t```\n* 引用\n\n\t```bash\n\t$var,${var}\n\t```\n* 特殊变量\n\t* `$?`\t上条命令状态\n\t* `$*`/`$@`\t所有参数列表\n\t* `$#`\t参数个数\n\t* `$0`\t执行的命令名称\n\t* `$1`/`${10}`\t第1/10个参数\n\n## 数值运算\n* 基本用法\n\n\t```bash\n\texpr value1 op value2\t# eg. expr $var1 + $var2\n\t$[ value1 op value2 ]\t# eg. $[var1+var2]\n\t```\n* 变量递更\n\n\t```bash\n\tlet var++\t# 自增1\n\tlet var+=2\t# 自增2\n\t```\n* 随机数生成\n\n\t```bash\n\techo $RANDOM\t# $RANDOM生成随机数\n\t```\n* 生成数字序列\n\n\t```bash\n\t# 显示first，first+1，...，end\n\tseq first end\n\t# 显示first，first+step，...\n\tseq first step end\n\t```\n* 小数计算（bc命令）\n\n\t```bash\n\t# 将运算的字符串传递给bc命令去处理\n\techo “45.6×33.2” | bc\n\t```\n\n\n## 字符串操作\n* 子串截取\n\n\t```bash\n\t# 提取$path里面的目录路径/文件名\n\tdirname/basename $path\n\t# 截取$string字串，从first（起始为1）开始，长度为length\n\texpr substr $string first\n\t# 截取$string子串，从first（起始为0）开始，长度为length\n\t${string:first:length}\n\t# 从左开始匹配patten，从string删除最短的patten\n\t${string#patten}\n\t# 从右开始匹配patten，从string删除最短的patten\n\t${string%patten}\n\t```\n* 字符串替换\n\n\t```bash\n\t# 将string中第一个old替换为new\n\t${string/old/new}\n\t# 将string中所有old替换为new\n\t${string//old/new}\n\t```\n* 生成随机字符串\n\n\t```bash\n\t# 生成长度为8的随机字符串\n\thead -1 /dev/urandom | md5sum | cut -c1-8\n\t```\n","slug":"Summary-basicConcept-Shell","published":1,"date":"2014-02-25T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0u000hl73yqf30qcmy","content":"<p>在windows里面进行任务处理通常是用批处理,但是其功能是单薄的.而且一般公司服务器都是用的linux系统,批处理是没有用武之地的,关键时候还是shell给力.其实说白了,shell编程就是linux命令的组合. <a id=\"more\"></a></p>\n<h2 id=\"变量\">变量</h2>\n<ul>\n<li><p>定义，赋值：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var=value</div></pre></td></tr></table></figure></li>\n<li><p>引用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$var</span>,<span class=\"variable\">$&#123;var&#125;</span></div></pre></td></tr></table></figure></li>\n<li>特殊变量\n<ul>\n<li><code>$?</code> 上条命令状态</li>\n<li><code>$*</code>/<code>$@</code> 所有参数列表</li>\n<li><code>$#</code> 参数个数</li>\n<li><code>$0</code> 执行的命令名称</li>\n<li><code>$1</code>/<code>${10}</code> 第1/10个参数</li>\n</ul></li>\n</ul>\n<h2 id=\"数值运算\">数值运算</h2>\n<ul>\n<li><p>基本用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">expr value1 op value2\t<span class=\"comment\"># eg. expr $var1 + $var2</span></div><div class=\"line\">$[ value1 op value2 ]\t<span class=\"comment\"># eg. $[var1+var2]</span></div></pre></td></tr></table></figure></li>\n<li><p>变量递更</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">let</span> var++\t<span class=\"comment\"># 自增1</span></div><div class=\"line\"><span class=\"built_in\">let</span> var+=2\t<span class=\"comment\"># 自增2</span></div></pre></td></tr></table></figure></li>\n<li><p>随机数生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$RANDOM</span>\t<span class=\"comment\"># $RANDOM生成随机数</span></div></pre></td></tr></table></figure></li>\n<li><p>生成数字序列</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 显示first，first+1，...，end</span></div><div class=\"line\">seq first end</div><div class=\"line\"><span class=\"comment\"># 显示first，first+step，...</span></div><div class=\"line\">seq first step end</div></pre></td></tr></table></figure></li>\n<li><p>小数计算（bc命令）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 将运算的字符串传递给bc命令去处理</span></div><div class=\"line\"><span class=\"built_in\">echo</span> “45.6×33.2” | bc</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"字符串操作\">字符串操作</h2>\n<ul>\n<li><p>子串截取</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 提取$path里面的目录路径/文件名</span></div><div class=\"line\">dirname/basename <span class=\"variable\">$path</span></div><div class=\"line\"><span class=\"comment\"># 截取$string字串，从first（起始为1）开始，长度为length</span></div><div class=\"line\">expr substr <span class=\"variable\">$string</span> first</div><div class=\"line\"><span class=\"comment\"># 截取$string子串，从first（起始为0）开始，长度为length</span></div><div class=\"line\"><span class=\"variable\">$&#123;string:first:length&#125;</span></div><div class=\"line\"><span class=\"comment\"># 从左开始匹配patten，从string删除最短的patten</span></div><div class=\"line\"><span class=\"variable\">$&#123;string#patten&#125;</span></div><div class=\"line\"><span class=\"comment\"># 从右开始匹配patten，从string删除最短的patten</span></div><div class=\"line\"><span class=\"variable\">$&#123;string%patten&#125;</span></div></pre></td></tr></table></figure></li>\n<li><p>字符串替换</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 将string中第一个old替换为new</span></div><div class=\"line\"><span class=\"variable\">$&#123;string/old/new&#125;</span></div><div class=\"line\"><span class=\"comment\"># 将string中所有old替换为new</span></div><div class=\"line\"><span class=\"variable\">$&#123;string//old/new&#125;</span></div></pre></td></tr></table></figure></li>\n<li><p>生成随机字符串</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 生成长度为8的随机字符串</span></div><div class=\"line\">head -1 /dev/urandom | md5sum | cut -c1-8</div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在windows里面进行任务处理通常是用批处理,但是其功能是单薄的.而且一般公司服务器都是用的linux系统,批处理是没有用武之地的,关键时候还是shell给力.其实说白了,shell编程就是linux命令的组合.","more":"</p>\n<h2 id=\"变量\">变量</h2>\n<ul>\n<li><p>定义，赋值：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var=value</div></pre></td></tr></table></figure></li>\n<li><p>引用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$var</span>,<span class=\"variable\">$&#123;var&#125;</span></div></pre></td></tr></table></figure></li>\n<li>特殊变量\n<ul>\n<li><code>$?</code> 上条命令状态</li>\n<li><code>$*</code>/<code>$@</code> 所有参数列表</li>\n<li><code>$#</code> 参数个数</li>\n<li><code>$0</code> 执行的命令名称</li>\n<li><code>$1</code>/<code>${10}</code> 第1/10个参数</li>\n</ul></li>\n</ul>\n<h2 id=\"数值运算\">数值运算</h2>\n<ul>\n<li><p>基本用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">expr value1 op value2\t<span class=\"comment\"># eg. expr $var1 + $var2</span></div><div class=\"line\">$[ value1 op value2 ]\t<span class=\"comment\"># eg. $[var1+var2]</span></div></pre></td></tr></table></figure></li>\n<li><p>变量递更</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">let</span> var++\t<span class=\"comment\"># 自增1</span></div><div class=\"line\"><span class=\"built_in\">let</span> var+=2\t<span class=\"comment\"># 自增2</span></div></pre></td></tr></table></figure></li>\n<li><p>随机数生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$RANDOM</span>\t<span class=\"comment\"># $RANDOM生成随机数</span></div></pre></td></tr></table></figure></li>\n<li><p>生成数字序列</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 显示first，first+1，...，end</span></div><div class=\"line\">seq first end</div><div class=\"line\"><span class=\"comment\"># 显示first，first+step，...</span></div><div class=\"line\">seq first step end</div></pre></td></tr></table></figure></li>\n<li><p>小数计算（bc命令）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 将运算的字符串传递给bc命令去处理</span></div><div class=\"line\"><span class=\"built_in\">echo</span> “45.6×33.2” | bc</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"字符串操作\">字符串操作</h2>\n<ul>\n<li><p>子串截取</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 提取$path里面的目录路径/文件名</span></div><div class=\"line\">dirname/basename <span class=\"variable\">$path</span></div><div class=\"line\"><span class=\"comment\"># 截取$string字串，从first（起始为1）开始，长度为length</span></div><div class=\"line\">expr substr <span class=\"variable\">$string</span> first</div><div class=\"line\"><span class=\"comment\"># 截取$string子串，从first（起始为0）开始，长度为length</span></div><div class=\"line\"><span class=\"variable\">$&#123;string:first:length&#125;</span></div><div class=\"line\"><span class=\"comment\"># 从左开始匹配patten，从string删除最短的patten</span></div><div class=\"line\"><span class=\"variable\">$&#123;string#patten&#125;</span></div><div class=\"line\"><span class=\"comment\"># 从右开始匹配patten，从string删除最短的patten</span></div><div class=\"line\"><span class=\"variable\">$&#123;string%patten&#125;</span></div></pre></td></tr></table></figure></li>\n<li><p>字符串替换</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 将string中第一个old替换为new</span></div><div class=\"line\"><span class=\"variable\">$&#123;string/old/new&#125;</span></div><div class=\"line\"><span class=\"comment\"># 将string中所有old替换为new</span></div><div class=\"line\"><span class=\"variable\">$&#123;string//old/new&#125;</span></div></pre></td></tr></table></figure></li>\n<li><p>生成随机字符串</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 生成长度为8的随机字符串</span></div><div class=\"line\">head -1 /dev/urandom | md5sum | cut -c1-8</div></pre></td></tr></table></figure></li>\n</ul>"},{"layout":"post","title":"shell编程之常用命令","comments":1,"_content":"shell编程说白了就是常用命令和语法结构的自由组合.所以本文将粗略介绍一下常用的命令以及其用法.\n<!-- more -->\n\n\n## 正则表达式\n符号和用法  \n\t* `.`\t匹配任何单个字符[shell用的是?]  \n\t* `^`\t跟行首匹配  \n\t* `$`\t跟行尾匹配  \n\t* `*`\t匹配0或若干个紧靠在星号前的字符[shell是0或若干跟字符]  \n\t* `[]`\t匹配字符组,^表示除外[shell用!表示]  \n\t* `{min,max}`\t匹配min-max个重复的字符串  \n\t* `{...}`\t将小括号中匹配的字符串存储到一个寄存器中\n\n\n## cut命令\n从文件中吸取各种各样的数据域  \n\n1. 取第2-10个字符串\n\n\t```bash\n\tcut -c2-10 file\n\t```\n2. 以:为分割符分割file,取第2个数据域\n\n\t```bash\n\tcut -d: -f2 file\n\t```\n\n## paste命令\npaste与cut相反，把多行合并在一起[行对行]  \n\n1. 以:为分割符,将两个文件行对行合并起来\n\n\t```bash\n\tpaste -d:  file1 file2\n\t```\n## tr命令\ntr可以转换来自标准输入中的字符\n\n1. 将file里面from-chars替换成to-chars\n\n\t```bash\n\ttr ‘from-chars’ 'to-chars' < file\n\t```\n\n## grep命令\ngrep查找多个文件中包含的单词或短语\n\n* 用法 -- 支持正则表达式\n\n\t```bash\n\tgrep ‘patten’ filespatten\n\t```\n* 参数\n\t* `-i`\t忽略大小写\n\t* `-n`\t显示行号\n\t* `-v`\t显示不包含指定模式的行\n\t* `-l`\t显示包含指定模式的文件列表\n\n## awk命令\nawk强大的文本编辑利器之一，方便于列处理\n\n* 用法\n\n\t```bash\n\tawk ‘模式{操作}’ files\n\t```\n* 参数\n\t* `NR`\t当期处理行的行号\n\t* `FS`\t字段分割符，缺省为空格或tab\n\t* `$n`\t当前行的第n个字段\n\t* `$0`\t当前行的所有文本\n\n## sed命令\nsed强大的文本编辑利器之一，方便于行处理\n\n* 用法\n\n\t```bash\n\tsed ‘[地址1[,地址2]]操作’ file\n\t```\n* 参数\n\t* `p`\t打印\n\t* `n`\t转到下一行\n\t* `d`\t删除\n\t* `s`\t替换字符串\n\t* `a`\t追加新的文本\n","source":"_posts/2014-02-28-shell编程之常用命令.md","raw":"---\nlayout:\tpost\ntitle:\tshell编程之常用命令\ncategories:\n- TECHNOLOGY\ntags:\n- Shell\npermalink:  Summary-command-Shell\ncomments:\ttrue\n---\nshell编程说白了就是常用命令和语法结构的自由组合.所以本文将粗略介绍一下常用的命令以及其用法.\n<!-- more -->\n\n\n## 正则表达式\n符号和用法  \n\t* `.`\t匹配任何单个字符[shell用的是?]  \n\t* `^`\t跟行首匹配  \n\t* `$`\t跟行尾匹配  \n\t* `*`\t匹配0或若干个紧靠在星号前的字符[shell是0或若干跟字符]  \n\t* `[]`\t匹配字符组,^表示除外[shell用!表示]  \n\t* `{min,max}`\t匹配min-max个重复的字符串  \n\t* `{...}`\t将小括号中匹配的字符串存储到一个寄存器中\n\n\n## cut命令\n从文件中吸取各种各样的数据域  \n\n1. 取第2-10个字符串\n\n\t```bash\n\tcut -c2-10 file\n\t```\n2. 以:为分割符分割file,取第2个数据域\n\n\t```bash\n\tcut -d: -f2 file\n\t```\n\n## paste命令\npaste与cut相反，把多行合并在一起[行对行]  \n\n1. 以:为分割符,将两个文件行对行合并起来\n\n\t```bash\n\tpaste -d:  file1 file2\n\t```\n## tr命令\ntr可以转换来自标准输入中的字符\n\n1. 将file里面from-chars替换成to-chars\n\n\t```bash\n\ttr ‘from-chars’ 'to-chars' < file\n\t```\n\n## grep命令\ngrep查找多个文件中包含的单词或短语\n\n* 用法 -- 支持正则表达式\n\n\t```bash\n\tgrep ‘patten’ filespatten\n\t```\n* 参数\n\t* `-i`\t忽略大小写\n\t* `-n`\t显示行号\n\t* `-v`\t显示不包含指定模式的行\n\t* `-l`\t显示包含指定模式的文件列表\n\n## awk命令\nawk强大的文本编辑利器之一，方便于列处理\n\n* 用法\n\n\t```bash\n\tawk ‘模式{操作}’ files\n\t```\n* 参数\n\t* `NR`\t当期处理行的行号\n\t* `FS`\t字段分割符，缺省为空格或tab\n\t* `$n`\t当前行的第n个字段\n\t* `$0`\t当前行的所有文本\n\n## sed命令\nsed强大的文本编辑利器之一，方便于行处理\n\n* 用法\n\n\t```bash\n\tsed ‘[地址1[,地址2]]操作’ file\n\t```\n* 参数\n\t* `p`\t打印\n\t* `n`\t转到下一行\n\t* `d`\t删除\n\t* `s`\t替换字符串\n\t* `a`\t追加新的文本\n","slug":"Summary-command-Shell","published":1,"date":"2014-02-27T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0u000il73yun67yae1","content":"<p>shell编程说白了就是常用命令和语法结构的自由组合.所以本文将粗略介绍一下常用的命令以及其用法. <a id=\"more\"></a></p>\n<h2 id=\"正则表达式\">正则表达式</h2>\n<p>符号和用法<br>\n* <code>.</code> 匹配任何单个字符[shell用的是?]<br>\n* <code>^</code> 跟行首匹配<br>\n* <code>$</code> 跟行尾匹配<br>\n* <code>*</code> 匹配0或若干个紧靠在星号前的字符[shell是0或若干跟字符]<br>\n* <code>[]</code> 匹配字符组,^表示除外[shell用!表示]<br>\n* <code>{min,max}</code> 匹配min-max个重复的字符串<br>\n* <code>{...}</code> 将小括号中匹配的字符串存储到一个寄存器中</p>\n<h2 id=\"cut命令\">cut命令</h2>\n<p>从文件中吸取各种各样的数据域</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>取第2-10个字符串</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cut -c2-10 file</div></pre></td></tr></table></figure></li>\n<li><p>以:为分割符分割file,取第2个数据域</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cut <span class=\"_\">-d</span>: <span class=\"_\">-f</span>2 file</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"paste命令\">paste命令</h2>\n<p>paste与cut相反，把多行合并在一起[行对行]</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>以:为分割符,将两个文件行对行合并起来</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">paste <span class=\"_\">-d</span>:  file1 file2</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"tr命令\">tr命令</h2>\n<p>tr可以转换来自标准输入中的字符</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>将file里面from-chars替换成to-chars</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">tr ‘from-chars’ <span class=\"string\">'to-chars'</span> &lt; file</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"grep命令\">grep命令</h2>\n<p>grep查找多个文件中包含的单词或短语</p>\n<ul>\n<li><p>用法 – 支持正则表达式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep ‘patten’ filespatten</div></pre></td></tr></table></figure></li>\n<li>参数\n<ul>\n<li><code>-i</code> 忽略大小写</li>\n<li><code>-n</code> 显示行号</li>\n<li><code>-v</code> 显示不包含指定模式的行</li>\n<li><code>-l</code> 显示包含指定模式的文件列表</li>\n</ul></li>\n</ul>\n<h2 id=\"awk命令\">awk命令</h2>\n<p>awk强大的文本编辑利器之一，方便于列处理</p>\n<ul>\n<li><p>用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk ‘模式&#123;操作&#125;’ files</div></pre></td></tr></table></figure></li>\n<li>参数\n<ul>\n<li><code>NR</code> 当期处理行的行号</li>\n<li><code>FS</code> 字段分割符，缺省为空格或tab</li>\n<li><code>$n</code> 当前行的第n个字段</li>\n<li><code>$0</code> 当前行的所有文本</li>\n</ul></li>\n</ul>\n<h2 id=\"sed命令\">sed命令</h2>\n<p>sed强大的文本编辑利器之一，方便于行处理</p>\n<ul>\n<li><p>用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed ‘[地址1[,地址2]]操作’ file</div></pre></td></tr></table></figure></li>\n<li>参数\n<ul>\n<li><code>p</code> 打印</li>\n<li><code>n</code> 转到下一行</li>\n<li><code>d</code> 删除</li>\n<li><code>s</code> 替换字符串</li>\n<li><code>a</code> 追加新的文本</li>\n</ul></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>shell编程说白了就是常用命令和语法结构的自由组合.所以本文将粗略介绍一下常用的命令以及其用法.","more":"</p>\n<h2 id=\"正则表达式\">正则表达式</h2>\n<p>符号和用法<br>\n* <code>.</code> 匹配任何单个字符[shell用的是?]<br>\n* <code>^</code> 跟行首匹配<br>\n* <code>$</code> 跟行尾匹配<br>\n* <code>*</code> 匹配0或若干个紧靠在星号前的字符[shell是0或若干跟字符]<br>\n* <code>[]</code> 匹配字符组,^表示除外[shell用!表示]<br>\n* <code>{min,max}</code> 匹配min-max个重复的字符串<br>\n* <code>{...}</code> 将小括号中匹配的字符串存储到一个寄存器中</p>\n<h2 id=\"cut命令\">cut命令</h2>\n<p>从文件中吸取各种各样的数据域</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>取第2-10个字符串</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cut -c2-10 file</div></pre></td></tr></table></figure></li>\n<li><p>以:为分割符分割file,取第2个数据域</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cut <span class=\"_\">-d</span>: <span class=\"_\">-f</span>2 file</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"paste命令\">paste命令</h2>\n<p>paste与cut相反，把多行合并在一起[行对行]</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>以:为分割符,将两个文件行对行合并起来</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">paste <span class=\"_\">-d</span>:  file1 file2</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"tr命令\">tr命令</h2>\n<p>tr可以转换来自标准输入中的字符</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>将file里面from-chars替换成to-chars</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">tr ‘from-chars’ <span class=\"string\">'to-chars'</span> &lt; file</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"grep命令\">grep命令</h2>\n<p>grep查找多个文件中包含的单词或短语</p>\n<ul>\n<li><p>用法 – 支持正则表达式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep ‘patten’ filespatten</div></pre></td></tr></table></figure></li>\n<li>参数\n<ul>\n<li><code>-i</code> 忽略大小写</li>\n<li><code>-n</code> 显示行号</li>\n<li><code>-v</code> 显示不包含指定模式的行</li>\n<li><code>-l</code> 显示包含指定模式的文件列表</li>\n</ul></li>\n</ul>\n<h2 id=\"awk命令\">awk命令</h2>\n<p>awk强大的文本编辑利器之一，方便于列处理</p>\n<ul>\n<li><p>用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk ‘模式&#123;操作&#125;’ files</div></pre></td></tr></table></figure></li>\n<li>参数\n<ul>\n<li><code>NR</code> 当期处理行的行号</li>\n<li><code>FS</code> 字段分割符，缺省为空格或tab</li>\n<li><code>$n</code> 当前行的第n个字段</li>\n<li><code>$0</code> 当前行的所有文本</li>\n</ul></li>\n</ul>\n<h2 id=\"sed命令\">sed命令</h2>\n<p>sed强大的文本编辑利器之一，方便于行处理</p>\n<ul>\n<li><p>用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed ‘[地址1[,地址2]]操作’ file</div></pre></td></tr></table></figure></li>\n<li>参数\n<ul>\n<li><code>p</code> 打印</li>\n<li><code>n</code> 转到下一行</li>\n<li><code>d</code> 删除</li>\n<li><code>s</code> 替换字符串</li>\n<li><code>a</code> 追加新的文本</li>\n</ul></li>\n</ul>"},{"layout":"post","title":"shell编程之语法结构","comments":1,"_content":"前一篇博文介绍了shell编程的基本内容,主要介绍了变量,数值计算以及字符串.这些相当于食材,而本文介绍的语法结构就相当于食谱,二者组合方能做出美食.\n<!-- more -->\n\n\n## 判断语句\n\n* 条件判断\n\n\t```bash\n\ttest expression\n\t[ expression ]\n\t```\n* 条件表达式中常用的判断\n\t1. 数值\t\t`-eq` `-ne` `-gt` `-lt` `-ge` `-le` [**e**qual **n**ot **g**reater **t**han **l**ess]\n\t2. 字符串\t`=:` `!=` `-z` `-n`\t[**z**ero **n**ozero]\n\t3. 文件\t\t`-e` `-r` `-w` `-x` `-s` `-d` `-f` `-c` `-b`\t[**e**xist **r**ead **w**rite **e**xecute **s**ize **d**irectory **f**ile **c**har **b**lock]\n* 语句结构\n\n\t```bash\n\tif [ $mark -le 80 ]\n\tthen\n\techo \"Your Grade is Average.\"\n\telif [ $mark -gt 80 -a $mark -le 90 ]\n\techo \"Your Grade is Good.\"\n\telse\n\techo \"Your Grade is Outstanding.\"\n\tfi\n\t```\n\n## case分支\n\n* 语句结构\n\n\t```bash\n\tcase $choice in\n\t1) echo \"choice1\";;\n\t2) echo \"choice2\";;\n\t*) echo \"out of choice\"\n\t```\n\n\n## 循环语句\n\n* for循环语句结构\n\n\t```bash\n\tfor val in vals\n\tdo\n\t...\n\tdone\n\t```\n* while循环语句结构\n\n\t```bash\n\ti=0\n\twhile [ $i -le 100 ]\n\tdo\n\t...\n\t((i=$i+1))\n\tdone\n\t```\t\t \n","source":"_posts/2014-02-27-shell编程之语法结构.md","raw":"---\nlayout:\tpost\ntitle:\tshell编程之语法结构\ncategories:\n- TECHNOLOGY\ntags:\n- Shell\npermalink:  Summary-structure-Shell\ncomments:\ttrue\n---\n前一篇博文介绍了shell编程的基本内容,主要介绍了变量,数值计算以及字符串.这些相当于食材,而本文介绍的语法结构就相当于食谱,二者组合方能做出美食.\n<!-- more -->\n\n\n## 判断语句\n\n* 条件判断\n\n\t```bash\n\ttest expression\n\t[ expression ]\n\t```\n* 条件表达式中常用的判断\n\t1. 数值\t\t`-eq` `-ne` `-gt` `-lt` `-ge` `-le` [**e**qual **n**ot **g**reater **t**han **l**ess]\n\t2. 字符串\t`=:` `!=` `-z` `-n`\t[**z**ero **n**ozero]\n\t3. 文件\t\t`-e` `-r` `-w` `-x` `-s` `-d` `-f` `-c` `-b`\t[**e**xist **r**ead **w**rite **e**xecute **s**ize **d**irectory **f**ile **c**har **b**lock]\n* 语句结构\n\n\t```bash\n\tif [ $mark -le 80 ]\n\tthen\n\techo \"Your Grade is Average.\"\n\telif [ $mark -gt 80 -a $mark -le 90 ]\n\techo \"Your Grade is Good.\"\n\telse\n\techo \"Your Grade is Outstanding.\"\n\tfi\n\t```\n\n## case分支\n\n* 语句结构\n\n\t```bash\n\tcase $choice in\n\t1) echo \"choice1\";;\n\t2) echo \"choice2\";;\n\t*) echo \"out of choice\"\n\t```\n\n\n## 循环语句\n\n* for循环语句结构\n\n\t```bash\n\tfor val in vals\n\tdo\n\t...\n\tdone\n\t```\n* while循环语句结构\n\n\t```bash\n\ti=0\n\twhile [ $i -le 100 ]\n\tdo\n\t...\n\t((i=$i+1))\n\tdone\n\t```\t\t \n","slug":"Summary-structure-Shell","published":1,"date":"2014-02-26T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0u000jl73y6h218src","content":"<p>前一篇博文介绍了shell编程的基本内容,主要介绍了变量,数值计算以及字符串.这些相当于食材,而本文介绍的语法结构就相当于食谱,二者组合方能做出美食. <a id=\"more\"></a></p>\n<h2 id=\"判断语句\">判断语句</h2>\n<ul>\n<li><p>条件判断</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">test</span> expression</div><div class=\"line\">[ expression ]</div></pre></td></tr></table></figure></li>\n<li>条件表达式中常用的判断\n<ol style=\"list-style-type: decimal\">\n<li>数值 <code>-eq</code> <code>-ne</code> <code>-gt</code> <code>-lt</code> <code>-ge</code> <code>-le</code> [<strong>e</strong>qual <strong>n</strong>ot <strong>g</strong>reater <strong>t</strong>han <strong>l</strong>ess]</li>\n<li>字符串 <code>=:</code> <code>!=</code> <code>-z</code> <code>-n</code> [<strong>z</strong>ero <strong>n</strong>ozero]</li>\n<li>文件 <code>-e</code> <code>-r</code> <code>-w</code> <code>-x</code> <code>-s</code> <code>-d</code> <code>-f</code> <code>-c</code> <code>-b</code> [<strong>e</strong>xist <strong>r</strong>ead <strong>w</strong>rite <strong>e</strong>xecute <strong>s</strong>ize <strong>d</strong>irectory <strong>f</strong>ile <strong>c</strong>har <strong>b</strong>lock]</li>\n</ol></li>\n<li><p>语句结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$mark</span> -le 80 ]</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Your Grade is Average.\"</span></div><div class=\"line\"><span class=\"keyword\">elif</span> [ <span class=\"variable\">$mark</span> <span class=\"_\">-gt</span> 80 <span class=\"_\">-a</span> <span class=\"variable\">$mark</span> -le 90 ]</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Your Grade is Good.\"</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Your Grade is Outstanding.\"</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"case分支\">case分支</h2>\n<ul>\n<li><p>语句结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"variable\">$choice</span> <span class=\"keyword\">in</span></div><div class=\"line\">1) <span class=\"built_in\">echo</span> <span class=\"string\">\"choice1\"</span>;;</div><div class=\"line\">2) <span class=\"built_in\">echo</span> <span class=\"string\">\"choice2\"</span>;;</div><div class=\"line\">*) <span class=\"built_in\">echo</span> <span class=\"string\">\"out of choice\"</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"循环语句\">循环语句</h2>\n<ul>\n<li><p>for循环语句结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> val <span class=\"keyword\">in</span> vals</div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">done</span></div></pre></td></tr></table></figure></li>\n<li><p>while循环语句结构</p>\n<div class=\"sourceCode\"><pre class=\"sourceCode bash\"><code class=\"sourceCode bash\"><span class=\"va\">i=</span>0\n<span class=\"kw\">while</span><span class=\"bu\"> [</span> <span class=\"va\">$i</span> <span class=\"ot\">-le</span> 100<span class=\"bu\"> ]</span>\n<span class=\"kw\">do</span>\n<span class=\"ex\">...</span>\n<span class=\"kw\">((</span>i=<span class=\"va\">$i</span>+1<span class=\"kw\">))</span>\n<span class=\"kw\">done</span></code></pre></div></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>前一篇博文介绍了shell编程的基本内容,主要介绍了变量,数值计算以及字符串.这些相当于食材,而本文介绍的语法结构就相当于食谱,二者组合方能做出美食.","more":"</p>\n<h2 id=\"判断语句\">判断语句</h2>\n<ul>\n<li><p>条件判断</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">test</span> expression</div><div class=\"line\">[ expression ]</div></pre></td></tr></table></figure></li>\n<li>条件表达式中常用的判断\n<ol style=\"list-style-type: decimal\">\n<li>数值 <code>-eq</code> <code>-ne</code> <code>-gt</code> <code>-lt</code> <code>-ge</code> <code>-le</code> [<strong>e</strong>qual <strong>n</strong>ot <strong>g</strong>reater <strong>t</strong>han <strong>l</strong>ess]</li>\n<li>字符串 <code>=:</code> <code>!=</code> <code>-z</code> <code>-n</code> [<strong>z</strong>ero <strong>n</strong>ozero]</li>\n<li>文件 <code>-e</code> <code>-r</code> <code>-w</code> <code>-x</code> <code>-s</code> <code>-d</code> <code>-f</code> <code>-c</code> <code>-b</code> [<strong>e</strong>xist <strong>r</strong>ead <strong>w</strong>rite <strong>e</strong>xecute <strong>s</strong>ize <strong>d</strong>irectory <strong>f</strong>ile <strong>c</strong>har <strong>b</strong>lock]</li>\n</ol></li>\n<li><p>语句结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$mark</span> -le 80 ]</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Your Grade is Average.\"</span></div><div class=\"line\"><span class=\"keyword\">elif</span> [ <span class=\"variable\">$mark</span> <span class=\"_\">-gt</span> 80 <span class=\"_\">-a</span> <span class=\"variable\">$mark</span> -le 90 ]</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Your Grade is Good.\"</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Your Grade is Outstanding.\"</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"case分支\">case分支</h2>\n<ul>\n<li><p>语句结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"variable\">$choice</span> <span class=\"keyword\">in</span></div><div class=\"line\">1) <span class=\"built_in\">echo</span> <span class=\"string\">\"choice1\"</span>;;</div><div class=\"line\">2) <span class=\"built_in\">echo</span> <span class=\"string\">\"choice2\"</span>;;</div><div class=\"line\">*) <span class=\"built_in\">echo</span> <span class=\"string\">\"out of choice\"</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"循环语句\">循环语句</h2>\n<ul>\n<li><p>for循环语句结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> val <span class=\"keyword\">in</span> vals</div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">done</span></div></pre></td></tr></table></figure></li>\n<li><p>while循环语句结构</p>\n<div class=\"sourceCode\"><pre class=\"sourceCode bash\"><code class=\"sourceCode bash\"><span class=\"va\">i=</span>0\n<span class=\"kw\">while</span><span class=\"bu\"> [</span> <span class=\"va\">$i</span> <span class=\"ot\">-le</span> 100<span class=\"bu\"> ]</span>\n<span class=\"kw\">do</span>\n<span class=\"ex\">...</span>\n<span class=\"kw\">((</span>i=<span class=\"va\">$i</span>+1<span class=\"kw\">))</span>\n<span class=\"kw\">done</span></code></pre></div></li>\n</ul>"},{"layout":"post","title":"shell编程之实用脚本片段","comments":1,"_content":"现在编程都讲究面向对象,处理的对象不再是最底层的变量,结构等.所以在日常也要注意实用脚本片段的积累.\n<!-- more -->\n\n\n## 校验参数\n\n1. 情景描述  \n\t有些脚本文件需要传入一些参数,那么就需要在脚本里对参数进行预处理,使得用户更好的使用该脚本.\n2. 脚本片段\n\n\t```bash\n\tif [ \"$#\" -ne 1 ]\n\tthen\n\techo \"Incorrect number of arguments\"\n\techo \"Usage: command arg1\"\n\texit 1\n\tfi\n\t```\n\n## 等待程序执行\n\n1. 情景描述  \n\t编程中有些命令执行需要很耗时间和资源,需要提早运行.但是有时还需要等待该命令,对其结果进行进一步处理,此时就需要这样的代码段.\n2. 脚本片段\n\n\t```bash\n\tprog1 &\n\t# 获取prog1的pid\n\tpid = $1\n\t# 等待后台prog1执行完继续脚本\n\twait $pid\n\t...\n\t```\n\n## 提示用户输入\n\n1. 情景描述  \n\t智能提示,让shell脚本更加人性化.\n2. 脚本片段\n\n\t```bash\n\t#!/bin/bash\n\tread -p \"please type the password:\" PW\n\techo $PW\n\t```\n\n## 更改用户密码\n\n1. 情景描述  \n\t更改登录用户密码,懒得每次输入新旧密码\n2. 脚本片段\n\n\t```bash\n\t#!/bin/bash\n\t(echo \"curpw\"; sleep 1; echo \"newpw\"; sleep 1; echo \"newpw\") | passwd\n\t```\n\n## ACM检验\n\n1. 情景描述  \n\tACM中需要对代码的测试数据进行验证.\n2. 脚本片段\n\n\t```bash\n\t#！/bin/bash\n\twhile true\n\tdo\n\t\t#生成随机变量到input文件中,r可以是生成脚本\n\t\t./r > input\n\t\t./a < input > output.a\n\t\t./b < input > output.b\n\t\tdiff output.a output.b\n\t\tif [ $? -ne 0 ]\n\t\tthen\n\t\t\tbreak\n\t\tfi\n\tdone\n\n\n## 跨系统脚本\n\n1. 情景描述  \n    对于不同的Linux发行版本，它们的包管理命令是不同的，比如ubuntu用apt-get命令他，centos用yum命令，mac系统用homebrew命令，但是它们都能运行shell脚本，所以shell脚本可以针对不同的发行版本安装不同的软件，以完成系统的配置。\n2. 脚本片段\n\n    ```bash\n    #！/bin/bash\n    if which apt-get > /dev/null; then\n        echo \"You are using Ubuntu!\"\n        sudo apt-get install-y git\n    elif which yum > /dev/null; then\n        echo \"You are using CentOs!\"\n        sudo yum install -y git\n    elif which brew > /dev/null; then\n        echo \"You are using Mac OS X!\"\n        brew install git\n    fi\n    ```\n","source":"_posts/2014-02-29-shell编程之实用脚本片段.md","raw":"---\nlayout:\tpost\ntitle:\tshell编程之实用脚本片段\ncategories:\n- TECHNOLOGY\ntags:\n- Shell\npermalink:  Summary-snip-Shell\ncomments:\ttrue\n---\n现在编程都讲究面向对象,处理的对象不再是最底层的变量,结构等.所以在日常也要注意实用脚本片段的积累.\n<!-- more -->\n\n\n## 校验参数\n\n1. 情景描述  \n\t有些脚本文件需要传入一些参数,那么就需要在脚本里对参数进行预处理,使得用户更好的使用该脚本.\n2. 脚本片段\n\n\t```bash\n\tif [ \"$#\" -ne 1 ]\n\tthen\n\techo \"Incorrect number of arguments\"\n\techo \"Usage: command arg1\"\n\texit 1\n\tfi\n\t```\n\n## 等待程序执行\n\n1. 情景描述  \n\t编程中有些命令执行需要很耗时间和资源,需要提早运行.但是有时还需要等待该命令,对其结果进行进一步处理,此时就需要这样的代码段.\n2. 脚本片段\n\n\t```bash\n\tprog1 &\n\t# 获取prog1的pid\n\tpid = $1\n\t# 等待后台prog1执行完继续脚本\n\twait $pid\n\t...\n\t```\n\n## 提示用户输入\n\n1. 情景描述  \n\t智能提示,让shell脚本更加人性化.\n2. 脚本片段\n\n\t```bash\n\t#!/bin/bash\n\tread -p \"please type the password:\" PW\n\techo $PW\n\t```\n\n## 更改用户密码\n\n1. 情景描述  \n\t更改登录用户密码,懒得每次输入新旧密码\n2. 脚本片段\n\n\t```bash\n\t#!/bin/bash\n\t(echo \"curpw\"; sleep 1; echo \"newpw\"; sleep 1; echo \"newpw\") | passwd\n\t```\n\n## ACM检验\n\n1. 情景描述  \n\tACM中需要对代码的测试数据进行验证.\n2. 脚本片段\n\n\t```bash\n\t#！/bin/bash\n\twhile true\n\tdo\n\t\t#生成随机变量到input文件中,r可以是生成脚本\n\t\t./r > input\n\t\t./a < input > output.a\n\t\t./b < input > output.b\n\t\tdiff output.a output.b\n\t\tif [ $? -ne 0 ]\n\t\tthen\n\t\t\tbreak\n\t\tfi\n\tdone\n\n\n## 跨系统脚本\n\n1. 情景描述  \n    对于不同的Linux发行版本，它们的包管理命令是不同的，比如ubuntu用apt-get命令他，centos用yum命令，mac系统用homebrew命令，但是它们都能运行shell脚本，所以shell脚本可以针对不同的发行版本安装不同的软件，以完成系统的配置。\n2. 脚本片段\n\n    ```bash\n    #！/bin/bash\n    if which apt-get > /dev/null; then\n        echo \"You are using Ubuntu!\"\n        sudo apt-get install-y git\n    elif which yum > /dev/null; then\n        echo \"You are using CentOs!\"\n        sudo yum install -y git\n    elif which brew > /dev/null; then\n        echo \"You are using Mac OS X!\"\n        brew install git\n    fi\n    ```\n","slug":"Summary-snip-Shell","published":1,"date":"2014-02-28T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0v000kl73yg9tu3pmz","content":"<p>现在编程都讲究面向对象,处理的对象不再是最底层的变量,结构等.所以在日常也要注意实用脚本片段的积累. <a id=\"more\"></a></p>\n<h2 id=\"校验参数\">校验参数</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\n有些脚本文件需要传入一些参数,那么就需要在脚本里对参数进行预处理,使得用户更好的使用该脚本.</li>\n<li><p>脚本片段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$#</span>\"</span> <span class=\"_\">-ne</span> 1 ]</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Incorrect number of arguments\"</span></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Usage: command arg1\"</span></div><div class=\"line\"><span class=\"built_in\">exit</span> 1</div><div class=\"line\"><span class=\"keyword\">fi</span></div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"等待程序执行\">等待程序执行</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\n编程中有些命令执行需要很耗时间和资源,需要提早运行.但是有时还需要等待该命令,对其结果进行进一步处理,此时就需要这样的代码段.</li>\n<li><p>脚本片段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">prog1 &amp;</div><div class=\"line\"><span class=\"comment\"># 获取prog1的pid</span></div><div class=\"line\">pid = <span class=\"variable\">$1</span></div><div class=\"line\"><span class=\"comment\"># 等待后台prog1执行完继续脚本</span></div><div class=\"line\"><span class=\"built_in\">wait</span> <span class=\"variable\">$pid</span></div><div class=\"line\">...</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"提示用户输入\">提示用户输入</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\n智能提示,让shell脚本更加人性化.</li>\n<li><p>脚本片段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\"><span class=\"built_in\">read</span> -p <span class=\"string\">\"please type the password:\"</span> PW</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$PW</span></div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"更改用户密码\">更改用户密码</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\n更改登录用户密码,懒得每次输入新旧密码</li>\n<li><p>脚本片段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\">(<span class=\"built_in\">echo</span> <span class=\"string\">\"curpw\"</span>; sleep 1; <span class=\"built_in\">echo</span> <span class=\"string\">\"newpw\"</span>; sleep 1; <span class=\"built_in\">echo</span> <span class=\"string\">\"newpw\"</span>) | passwd</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"acm检验\">ACM检验</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\nACM中需要对代码的测试数据进行验证.</li>\n<li><p>脚本片段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"comment\">#！/bin/bash</span></div><div class=\"line\">\t<span class=\"keyword\">while</span> <span class=\"literal\">true</span></div><div class=\"line\">\t<span class=\"keyword\">do</span></div><div class=\"line\">\t\t<span class=\"comment\">#生成随机变量到input文件中,r可以是生成脚本</span></div><div class=\"line\">\t\t./r &gt; input</div><div class=\"line\">\t\t./a &lt; input &gt; output.a</div><div class=\"line\">\t\t./b &lt; input &gt; output.b</div><div class=\"line\">\t\tdiff output.a output.b</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> [ $? <span class=\"_\">-ne</span> 0 ]</div><div class=\"line\">\t\t<span class=\"keyword\">then</span></div><div class=\"line\">\t\t\t<span class=\"built_in\">break</span></div><div class=\"line\">\t\t<span class=\"keyword\">fi</span></div><div class=\"line\">\t<span class=\"keyword\">done</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">## 跨系统脚本</span></div><div class=\"line\"></div><div class=\"line\">1. 情景描述  </div><div class=\"line\">    对于不同的Linux发行版本，它们的包管理命令是不同的，比如ubuntu用apt-get命令他，centos用yum命令，mac系统用homebrew命令，但是它们都能运行shell脚本，所以shell脚本可以针对不同的发行版本安装不同的软件，以完成系统的配置。</div><div class=\"line\">2. 脚本片段</div><div class=\"line\"></div><div class=\"line\">    ```bash</div><div class=\"line\">    <span class=\"comment\">#！/bin/bash</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">which</span> apt-get &gt; /dev/null; <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">\"You are using Ubuntu!\"</span></div><div class=\"line\">        sudo apt-get install-y git</div><div class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">which</span> yum &gt; /dev/null; <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">\"You are using CentOs!\"</span></div><div class=\"line\">        sudo yum install -y git</div><div class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">which</span> brew &gt; /dev/null; <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">\"You are using Mac OS X!\"</span></div><div class=\"line\">        brew install git</div><div class=\"line\">    <span class=\"keyword\">fi</span></div></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>现在编程都讲究面向对象,处理的对象不再是最底层的变量,结构等.所以在日常也要注意实用脚本片段的积累.","more":"</p>\n<h2 id=\"校验参数\">校验参数</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\n有些脚本文件需要传入一些参数,那么就需要在脚本里对参数进行预处理,使得用户更好的使用该脚本.</li>\n<li><p>脚本片段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$#</span>\"</span> <span class=\"_\">-ne</span> 1 ]</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Incorrect number of arguments\"</span></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Usage: command arg1\"</span></div><div class=\"line\"><span class=\"built_in\">exit</span> 1</div><div class=\"line\"><span class=\"keyword\">fi</span></div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"等待程序执行\">等待程序执行</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\n编程中有些命令执行需要很耗时间和资源,需要提早运行.但是有时还需要等待该命令,对其结果进行进一步处理,此时就需要这样的代码段.</li>\n<li><p>脚本片段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">prog1 &amp;</div><div class=\"line\"><span class=\"comment\"># 获取prog1的pid</span></div><div class=\"line\">pid = <span class=\"variable\">$1</span></div><div class=\"line\"><span class=\"comment\"># 等待后台prog1执行完继续脚本</span></div><div class=\"line\"><span class=\"built_in\">wait</span> <span class=\"variable\">$pid</span></div><div class=\"line\">...</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"提示用户输入\">提示用户输入</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\n智能提示,让shell脚本更加人性化.</li>\n<li><p>脚本片段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\"><span class=\"built_in\">read</span> -p <span class=\"string\">\"please type the password:\"</span> PW</div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$PW</span></div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"更改用户密码\">更改用户密码</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\n更改登录用户密码,懒得每次输入新旧密码</li>\n<li><p>脚本片段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\">(<span class=\"built_in\">echo</span> <span class=\"string\">\"curpw\"</span>; sleep 1; <span class=\"built_in\">echo</span> <span class=\"string\">\"newpw\"</span>; sleep 1; <span class=\"built_in\">echo</span> <span class=\"string\">\"newpw\"</span>) | passwd</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"acm检验\">ACM检验</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\nACM中需要对代码的测试数据进行验证.</li>\n<li><p>脚本片段</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"comment\">#！/bin/bash</span></div><div class=\"line\">\t<span class=\"keyword\">while</span> <span class=\"literal\">true</span></div><div class=\"line\">\t<span class=\"keyword\">do</span></div><div class=\"line\">\t\t<span class=\"comment\">#生成随机变量到input文件中,r可以是生成脚本</span></div><div class=\"line\">\t\t./r &gt; input</div><div class=\"line\">\t\t./a &lt; input &gt; output.a</div><div class=\"line\">\t\t./b &lt; input &gt; output.b</div><div class=\"line\">\t\tdiff output.a output.b</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> [ $? <span class=\"_\">-ne</span> 0 ]</div><div class=\"line\">\t\t<span class=\"keyword\">then</span></div><div class=\"line\">\t\t\t<span class=\"built_in\">break</span></div><div class=\"line\">\t\t<span class=\"keyword\">fi</span></div><div class=\"line\">\t<span class=\"keyword\">done</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">## 跨系统脚本</span></div><div class=\"line\"></div><div class=\"line\">1. 情景描述  </div><div class=\"line\">    对于不同的Linux发行版本，它们的包管理命令是不同的，比如ubuntu用apt-get命令他，centos用yum命令，mac系统用homebrew命令，但是它们都能运行shell脚本，所以shell脚本可以针对不同的发行版本安装不同的软件，以完成系统的配置。</div><div class=\"line\">2. 脚本片段</div><div class=\"line\"></div><div class=\"line\">    ```bash</div><div class=\"line\">    <span class=\"comment\">#！/bin/bash</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">which</span> apt-get &gt; /dev/null; <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">\"You are using Ubuntu!\"</span></div><div class=\"line\">        sudo apt-get install-y git</div><div class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">which</span> yum &gt; /dev/null; <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">\"You are using CentOs!\"</span></div><div class=\"line\">        sudo yum install -y git</div><div class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">which</span> brew &gt; /dev/null; <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">\"You are using Mac OS X!\"</span></div><div class=\"line\">        brew install git</div><div class=\"line\">    <span class=\"keyword\">fi</span></div></pre></td></tr></table></figure></li>\n</ol>"},{"layout":"post","title":"ACM编程技巧之代码片段","category":["ACM","Coding"],"comments":1,"_content":"ACM编程也是需要一些通用的代码片段的.熟练掌握这些代码片段可以在后面的编程中更加方便.\n<!-- more -->\n\n\n## 验证完全平方数\n\n1. 情景描述  \n\t验证整数n是否是完全平方数\n2. 代码片段  \n\n\t```c\n\t#include<math.h>\n\tdouble m=sqrt(n);\n\tif(floor(m+0.5)==m)\n\t\tprintf(\"%d是完全平方数。\\n\",m);\n\t```\n3. 亮点  \n\t\t函数`floor(x)`返回x的整数部分，但浮点数的运算（`sqrt`）有可能存在误差[不经常，但一定会有]。若由于误差影响，整数1变成0.99999,那么`floor(m)==m`就会产生误差。\n\n## 计算程序所花时间\n1. 情景描述\n\t计算程序片段所花的时间\n2. 代码片段\n\n\t```c\n\t#include<time.h>\n\tprintf(\"Time used=%.2lf\\n\",(double)clock()/CLOCKS_PRE_SEC);\n\t```\n3. 优势  \n\t能够清楚的检验程序是否满足比赛时间要求\n\n## 输入输出重定向\n\n1. 情景描述  \n\t本机测试时用文件重定向，一旦提交到比赛，就自动“删除”重定向语句\n2. 代码片段\n\n\t```c\n\t#ifdef LOCAL\n\t\tfreopen(\"data.in\",\"r\",stdin);\n\t\tfreopen(\"data.out\",\"w\",stdout);\n\t#endif\n\t```\n3. 编译命令  \n\t将上面代码置于main函数最上面。编译时用下面的命令[命令中定义了LOCAL]\n\n\t```bash\n\tgcc main.c -o main -DLOCAL\n\t```\n4. 亮点  \n\t本机测试时，因为定义了LOCAL变量而使用了重定向，而上传后因为比赛编译命令里没有-DLOCAL选项而不会使用重定向。\n","source":"_posts/2014-03-05-ACM编程技巧之代码片段.md","raw":"---\nlayout:\tpost\ntitle:\tACM编程技巧之代码片段\ncategories:\n- TECHNOLOGY\ntags:\n- ACM\n- Coding\npermalink:  Summary-code-ACM\ncategory:\t[ACM, Coding]\ncomments:\ttrue\n---\nACM编程也是需要一些通用的代码片段的.熟练掌握这些代码片段可以在后面的编程中更加方便.\n<!-- more -->\n\n\n## 验证完全平方数\n\n1. 情景描述  \n\t验证整数n是否是完全平方数\n2. 代码片段  \n\n\t```c\n\t#include<math.h>\n\tdouble m=sqrt(n);\n\tif(floor(m+0.5)==m)\n\t\tprintf(\"%d是完全平方数。\\n\",m);\n\t```\n3. 亮点  \n\t\t函数`floor(x)`返回x的整数部分，但浮点数的运算（`sqrt`）有可能存在误差[不经常，但一定会有]。若由于误差影响，整数1变成0.99999,那么`floor(m)==m`就会产生误差。\n\n## 计算程序所花时间\n1. 情景描述\n\t计算程序片段所花的时间\n2. 代码片段\n\n\t```c\n\t#include<time.h>\n\tprintf(\"Time used=%.2lf\\n\",(double)clock()/CLOCKS_PRE_SEC);\n\t```\n3. 优势  \n\t能够清楚的检验程序是否满足比赛时间要求\n\n## 输入输出重定向\n\n1. 情景描述  \n\t本机测试时用文件重定向，一旦提交到比赛，就自动“删除”重定向语句\n2. 代码片段\n\n\t```c\n\t#ifdef LOCAL\n\t\tfreopen(\"data.in\",\"r\",stdin);\n\t\tfreopen(\"data.out\",\"w\",stdout);\n\t#endif\n\t```\n3. 编译命令  \n\t将上面代码置于main函数最上面。编译时用下面的命令[命令中定义了LOCAL]\n\n\t```bash\n\tgcc main.c -o main -DLOCAL\n\t```\n4. 亮点  \n\t本机测试时，因为定义了LOCAL变量而使用了重定向，而上传后因为比赛编译命令里没有-DLOCAL选项而不会使用重定向。\n","slug":"Summary-code-ACM","published":1,"date":"2014-03-04T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0v000ll73yd35d505j","content":"<p>ACM编程也是需要一些通用的代码片段的.熟练掌握这些代码片段可以在后面的编程中更加方便. <a id=\"more\"></a></p>\n<h2 id=\"验证完全平方数\">验证完全平方数</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\n验证整数n是否是完全平方数</li>\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;math.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">double</span> m=<span class=\"built_in\">sqrt</span>(n);</div><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">floor</span>(m+<span class=\"number\">0.5</span>)==m)</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d是完全平方数。\\n\"</span>,m);</div></pre></td></tr></table></figure></li>\n<li><p>亮点<br>\n函数<code>floor(x)</code>返回x的整数部分，但浮点数的运算（<code>sqrt</code>）有可能存在误差[不经常，但一定会有]。若由于误差影响，整数1变成0.99999,那么<code>floor(m)==m</code>就会产生误差。</p></li>\n</ol>\n<h2 id=\"计算程序所花时间\">计算程序所花时间</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述 计算程序片段所花的时间</li>\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;time.h&gt;</span></span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"Time used=%.2lf\\n\"</span>,(<span class=\"keyword\">double</span>)clock()/CLOCKS_PRE_SEC);</div></pre></td></tr></table></figure></li>\n<li><p>优势<br>\n能够清楚的检验程序是否满足比赛时间要求</p></li>\n</ol>\n<h2 id=\"输入输出重定向\">输入输出重定向</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\n本机测试时用文件重定向，一旦提交到比赛，就自动“删除”重定向语句</li>\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOCAL</span></div><div class=\"line\">\tfreopen(<span class=\"string\">\"data.in\"</span>,<span class=\"string\">\"r\"</span>,<span class=\"built_in\">stdin</span>);</div><div class=\"line\">\tfreopen(<span class=\"string\">\"data.out\"</span>,<span class=\"string\">\"w\"</span>,<span class=\"built_in\">stdout</span>);</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div></pre></td></tr></table></figure></li>\n<li><p>编译命令<br>\n将上面代码置于main函数最上面。编译时用下面的命令[命令中定义了LOCAL]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gcc main.c -o main -DLOCAL</div></pre></td></tr></table></figure></li>\n<li><p>亮点<br>\n本机测试时，因为定义了LOCAL变量而使用了重定向，而上传后因为比赛编译命令里没有-DLOCAL选项而不会使用重定向。</p></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>ACM编程也是需要一些通用的代码片段的.熟练掌握这些代码片段可以在后面的编程中更加方便.","more":"</p>\n<h2 id=\"验证完全平方数\">验证完全平方数</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\n验证整数n是否是完全平方数</li>\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;math.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">double</span> m=<span class=\"built_in\">sqrt</span>(n);</div><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">floor</span>(m+<span class=\"number\">0.5</span>)==m)</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d是完全平方数。\\n\"</span>,m);</div></pre></td></tr></table></figure></li>\n<li><p>亮点<br>\n函数<code>floor(x)</code>返回x的整数部分，但浮点数的运算（<code>sqrt</code>）有可能存在误差[不经常，但一定会有]。若由于误差影响，整数1变成0.99999,那么<code>floor(m)==m</code>就会产生误差。</p></li>\n</ol>\n<h2 id=\"计算程序所花时间\">计算程序所花时间</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述 计算程序片段所花的时间</li>\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;time.h&gt;</span></span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"Time used=%.2lf\\n\"</span>,(<span class=\"keyword\">double</span>)clock()/CLOCKS_PRE_SEC);</div></pre></td></tr></table></figure></li>\n<li><p>优势<br>\n能够清楚的检验程序是否满足比赛时间要求</p></li>\n</ol>\n<h2 id=\"输入输出重定向\">输入输出重定向</h2>\n<ol style=\"list-style-type: decimal\">\n<li>情景描述<br>\n本机测试时用文件重定向，一旦提交到比赛，就自动“删除”重定向语句</li>\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> LOCAL</span></div><div class=\"line\">\tfreopen(<span class=\"string\">\"data.in\"</span>,<span class=\"string\">\"r\"</span>,<span class=\"built_in\">stdin</span>);</div><div class=\"line\">\tfreopen(<span class=\"string\">\"data.out\"</span>,<span class=\"string\">\"w\"</span>,<span class=\"built_in\">stdout</span>);</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div></pre></td></tr></table></figure></li>\n<li><p>编译命令<br>\n将上面代码置于main函数最上面。编译时用下面的命令[命令中定义了LOCAL]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gcc main.c -o main -DLOCAL</div></pre></td></tr></table></figure></li>\n<li><p>亮点<br>\n本机测试时，因为定义了LOCAL变量而使用了重定向，而上传后因为比赛编译命令里没有-DLOCAL选项而不会使用重定向。</p></li>\n</ol>"},{"layout":"post","title":"ACM编程技巧之常用字符操作函数","comments":1,"_content":"编程里面最常用的操作就是字符操作,能够熟练的对字符进行操作对后面的编程非常有利.\n<!-- more -->\n\n\n## 类型的转换\n* 描述  \n\t字符串和基本数据类型转换`sscanf``sprintf`\n* 代码演示\n\n\t```c\n\tint sscanf(buff,\"%d%d\",&a,&b);\t//返回值是参数个数\n\tint sprintf(buff,\"%d%d\",a,b);\t//返回值是参数个数\n\t```\n\n## 读取\n* 描述  \n\t字符串读取,最多size大小\n* 代码演示\n\n\t```c\n\tchar *fgets(char *str,int size, FILE *stream);\n\t```\n* 注意点  \n\t\t\t\t最好不要用`gets(s)`，因为它没有指明读取的最大字符数，会存在潜在的问题，即不管s的可用空间。\n\n## 检验包含字符\n* 描述  \n\t校验字符串str中是否包含字符c\n* 代码演示\n\n\t```c\n\tchar *strchr(const char *str,int c);\t//返回值是第一个c所在的位置\n\tchar *strrchr(const char *str,int c);\t//返回值是最后一个c所在的位置\n\t```\n\n## 判断字符\n* 描述  \n\t\t\t\t判断字符是数字，字母，ascii，空格，控制符，数字，大写，小写等\n* 代码演示\n\n\t```c\n\t#include<ctype.h>\n\tint isalnum(int c);\n\tint isalpha(int c);\n\tint isascii(int c);\n\tint isblank(int c);\t//空格 or 制表符\n\tint isspace(int c);\t//空格\n\tint iscntrl(int c);\n\tint isdigit(int c);\n\tint islower(int c);\n\tint isupper(int c);\n\t```\n\n## 字符大小写转换\n* 描述\n\t字符转换成大写或小写\n* 代码演示\n\n\t```c\n\t#include<ctype.h>\n\tint toupper(int c);\n\tint tolower(int c);\n\t```\n\n## 内存复制\n* 描述  \n\t内存空间初始化和复制--数组常用\n* 代码演示\n\n\t```c\n\tvoid *memset(void *s,int c,size_t n);\n\tvoid *memcpy(void *dest,const void *src,size_t n);\n\t```\n","source":"_posts/2014-03-07-ACM编程技巧之常用字符操作函数.md","raw":"---\nlayout:\tpost\ntitle:\tACM编程技巧之常用字符操作函数\ncategories:\n- TECHNOLOGY\ntags:\n- ACM\n- Coding\npermalink:  Summary-string-ACM\ncomments:\ttrue\n---\n编程里面最常用的操作就是字符操作,能够熟练的对字符进行操作对后面的编程非常有利.\n<!-- more -->\n\n\n## 类型的转换\n* 描述  \n\t字符串和基本数据类型转换`sscanf``sprintf`\n* 代码演示\n\n\t```c\n\tint sscanf(buff,\"%d%d\",&a,&b);\t//返回值是参数个数\n\tint sprintf(buff,\"%d%d\",a,b);\t//返回值是参数个数\n\t```\n\n## 读取\n* 描述  \n\t字符串读取,最多size大小\n* 代码演示\n\n\t```c\n\tchar *fgets(char *str,int size, FILE *stream);\n\t```\n* 注意点  \n\t\t\t\t最好不要用`gets(s)`，因为它没有指明读取的最大字符数，会存在潜在的问题，即不管s的可用空间。\n\n## 检验包含字符\n* 描述  \n\t校验字符串str中是否包含字符c\n* 代码演示\n\n\t```c\n\tchar *strchr(const char *str,int c);\t//返回值是第一个c所在的位置\n\tchar *strrchr(const char *str,int c);\t//返回值是最后一个c所在的位置\n\t```\n\n## 判断字符\n* 描述  \n\t\t\t\t判断字符是数字，字母，ascii，空格，控制符，数字，大写，小写等\n* 代码演示\n\n\t```c\n\t#include<ctype.h>\n\tint isalnum(int c);\n\tint isalpha(int c);\n\tint isascii(int c);\n\tint isblank(int c);\t//空格 or 制表符\n\tint isspace(int c);\t//空格\n\tint iscntrl(int c);\n\tint isdigit(int c);\n\tint islower(int c);\n\tint isupper(int c);\n\t```\n\n## 字符大小写转换\n* 描述\n\t字符转换成大写或小写\n* 代码演示\n\n\t```c\n\t#include<ctype.h>\n\tint toupper(int c);\n\tint tolower(int c);\n\t```\n\n## 内存复制\n* 描述  \n\t内存空间初始化和复制--数组常用\n* 代码演示\n\n\t```c\n\tvoid *memset(void *s,int c,size_t n);\n\tvoid *memcpy(void *dest,const void *src,size_t n);\n\t```\n","slug":"Summary-string-ACM","published":1,"date":"2014-03-06T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0w000ml73y5o6b2g5t","content":"<p>编程里面最常用的操作就是字符操作,能够熟练的对字符进行操作对后面的编程非常有利. <a id=\"more\"></a></p>\n<h2 id=\"类型的转换\">类型的转换</h2>\n<ul>\n<li>描述<br>\n字符串和基本数据类型转换<code>sscanf``sprintf</code></li>\n<li><p>代码演示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sscanf</span><span class=\"params\">(buff,<span class=\"string\">\"%d%d\"</span>,&amp;a,&amp;b)</span></span>;\t<span class=\"comment\">//返回值是参数个数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sprintf</span><span class=\"params\">(buff,<span class=\"string\">\"%d%d\"</span>,a,b)</span></span>;\t<span class=\"comment\">//返回值是参数个数</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"读取\">读取</h2>\n<ul>\n<li>描述<br>\n字符串读取,最多size大小</li>\n<li><p>代码演示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">fgets</span><span class=\"params\">(<span class=\"keyword\">char</span> *str,<span class=\"keyword\">int</span> size, FILE *stream)</span></span>;</div></pre></td></tr></table></figure></li>\n<li><p>注意点<br>\n最好不要用<code>gets(s)</code>，因为它没有指明读取的最大字符数，会存在潜在的问题，即不管s的可用空间。</p></li>\n</ul>\n<h2 id=\"检验包含字符\">检验包含字符</h2>\n<ul>\n<li>描述<br>\n校验字符串str中是否包含字符c</li>\n<li><p>代码演示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strchr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str,<span class=\"keyword\">int</span> c)</span></span>;\t<span class=\"comment\">//返回值是第一个c所在的位置</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strrchr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str,<span class=\"keyword\">int</span> c)</span></span>;\t<span class=\"comment\">//返回值是最后一个c所在的位置</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"判断字符\">判断字符</h2>\n<ul>\n<li>描述<br>\n判断字符是数字，字母，ascii，空格，控制符，数字，大写，小写等</li>\n<li><p>代码演示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;ctype.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isalnum</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isalpha</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isascii</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isblank</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;\t<span class=\"comment\">//空格 or 制表符</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isspace</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;\t<span class=\"comment\">//空格</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">iscntrl</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isdigit</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">islower</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isupper</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"字符大小写转换\">字符大小写转换</h2>\n<ul>\n<li>描述 字符转换成大写或小写</li>\n<li><p>代码演示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;ctype.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">toupper</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tolower</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"内存复制\">内存复制</h2>\n<ul>\n<li>描述<br>\n内存空间初始化和复制–数组常用</li>\n<li><p>代码演示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memset</span><span class=\"params\">(<span class=\"keyword\">void</span> *s,<span class=\"keyword\">int</span> c,<span class=\"keyword\">size_t</span> n)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memcpy</span><span class=\"params\">(<span class=\"keyword\">void</span> *dest,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *src,<span class=\"keyword\">size_t</span> n)</span></span>;</div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>编程里面最常用的操作就是字符操作,能够熟练的对字符进行操作对后面的编程非常有利.","more":"</p>\n<h2 id=\"类型的转换\">类型的转换</h2>\n<ul>\n<li>描述<br>\n字符串和基本数据类型转换<code>sscanf``sprintf</code></li>\n<li><p>代码演示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sscanf</span><span class=\"params\">(buff,<span class=\"string\">\"%d%d\"</span>,&amp;a,&amp;b)</span></span>;\t<span class=\"comment\">//返回值是参数个数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sprintf</span><span class=\"params\">(buff,<span class=\"string\">\"%d%d\"</span>,a,b)</span></span>;\t<span class=\"comment\">//返回值是参数个数</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"读取\">读取</h2>\n<ul>\n<li>描述<br>\n字符串读取,最多size大小</li>\n<li><p>代码演示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">fgets</span><span class=\"params\">(<span class=\"keyword\">char</span> *str,<span class=\"keyword\">int</span> size, FILE *stream)</span></span>;</div></pre></td></tr></table></figure></li>\n<li><p>注意点<br>\n最好不要用<code>gets(s)</code>，因为它没有指明读取的最大字符数，会存在潜在的问题，即不管s的可用空间。</p></li>\n</ul>\n<h2 id=\"检验包含字符\">检验包含字符</h2>\n<ul>\n<li>描述<br>\n校验字符串str中是否包含字符c</li>\n<li><p>代码演示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strchr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str,<span class=\"keyword\">int</span> c)</span></span>;\t<span class=\"comment\">//返回值是第一个c所在的位置</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strrchr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str,<span class=\"keyword\">int</span> c)</span></span>;\t<span class=\"comment\">//返回值是最后一个c所在的位置</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"判断字符\">判断字符</h2>\n<ul>\n<li>描述<br>\n判断字符是数字，字母，ascii，空格，控制符，数字，大写，小写等</li>\n<li><p>代码演示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;ctype.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isalnum</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isalpha</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isascii</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isblank</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;\t<span class=\"comment\">//空格 or 制表符</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isspace</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;\t<span class=\"comment\">//空格</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">iscntrl</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isdigit</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">islower</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isupper</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"字符大小写转换\">字符大小写转换</h2>\n<ul>\n<li>描述 字符转换成大写或小写</li>\n<li><p>代码演示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;ctype.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">toupper</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tolower</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"内存复制\">内存复制</h2>\n<ul>\n<li>描述<br>\n内存空间初始化和复制–数组常用</li>\n<li><p>代码演示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memset</span><span class=\"params\">(<span class=\"keyword\">void</span> *s,<span class=\"keyword\">int</span> c,<span class=\"keyword\">size_t</span> n)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memcpy</span><span class=\"params\">(<span class=\"keyword\">void</span> *dest,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *src,<span class=\"keyword\">size_t</span> n)</span></span>;</div></pre></td></tr></table></figure></li>\n</ul>"},{"layout":"post","title":"python基础篇之基本概念","comments":1,"_content":"python里面有一些基本的概念,像模块,函数之类的,理解这些基本概念有利于对python程序的理解和编写.\n<!-- more -->\n\n\n## 模块\n\n*  定义\n模块（类比java中包里面的类）是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用python标准库的方法。\n* 代码示例\n\t* 自己定义的模块\n\n\t\t```python\n\t\t# coding=utf-8\n\t\t#!/usr/bin/python\n\t\t# Filename: mymodule.py\n\n\t\t# 模块中定义的函数\n\t\tdef sayhi():   \n\t\t\tprint '模块就是这样建造的.'\n\n\t\t# 模块中定义的变量\n\t\tversion = '0.1'\n\t\t```\n\t* 引用自己定义好的模块\n\n\t\t```python\n\t\t# coding=utf-8\n\t\t#!/usr/bin/python\n\t\t# Filename: mymodule_demo.py\n\n\t\t# 导入所写模块\n\t\timport mymodule\n\n\t\t# 代码写在main()里面\n\t\tdef main():\n\t\t\t# 显示mymodule中定义的函数和变量\n\t\t\tprint \"mymodule中定义的函数和变量：\" + \"  \".join(dir(mymodule))\n\n\t\t\t# 显示当前main函数中定义的函数的变量\n\t\t\tprint \"main函数中定义的函数和变量：\" + \"  \".join(dir())\n\n\t\t\t# 显示__name__的值\n\t\t\tprint \"main函数中__name__变量的值：\" + __name__\n\n\n\t\t# 调用main()函数来启动程序的样板\n\t\tif __name__ == '__main__':\n\t\t\tmain()\n\n\t\t\t# 显示当前模块中定义的函数的变量\n\t\t\tprint \"当前模块中定义的函数和变量：\" + \"  \".join(dir())\n\n\t\t\t# 显示__name__的值\n\t\t\tprint \"当前模块中__name__变量的值：\" + __name__\n\t\t```\n## 函数\n\n* 定义  \n函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数定义注意点\n\t1. 以def关键字开头，后面接函数名称和参数以及冒号\n\t2. 以return [expression]结束函数\n\t3. 参数类型有多个\n\t\t* 必备参数--一般定义的参数\n\t\t* 命名参数--复制语句作为参数\n\t\t* 缺省参数--参数有默认值\n\t\t* 不定长参数--用*标记，类似指针\n* 代码示例\n\n\t```python\n\t# coding=utf-8\n\t#!/usr/bin/python\n\t# Filename: function_demo.py\n\n\n\t# 导入所写模块\n\timport sys\n\n\t# 自定义函数\n\t# 打印输入的参数和本函数名\n\tdef printStr( str ):\n\t\t# sys._getframe().f_code.co_name 能够获得当前函数的名称\n\t\tprint sys._getframe().f_code.co_name , \":\" , str\n\t\treturn\n\n\t# 打印输入的不定长参数和本函数名\n\tdef printChangePar( argc, *argv ):\n\t\tprint sys._getframe().f_code.co_name , \":\" , argc\n\t\tvars =\"\"\n\t\tfor var in argv:\n\t\t\tvars = vars + var + \" \"\n\t\t\treturn vars\n\n\n\n\t# 代码写在main()里面\n\tdef main():\n\t\t# 传入命名参数\n\t\tprintStr( str = \"I am here .\" )\n\n\t\t# 传入不定长参数\n\t\tprint printChangePar(4,\"I\",\"am\",\"here\",\".\")\n\n\n\t# 调用main()函数来启动程序的样板\n\tif __name__ == '__main__':\n\t\tmain()\n\t```\n","source":"_posts/2014-12-04-python基础篇之基本概念.md","raw":"---\nlayout:\tpost\ntitle:\tpython基础篇之基本概念\ncategories:\n- TECHNOLOGY\ntags:\n- Python\n- Google\npermalink:  Study-basicConcept-Python\ncomments:\ttrue\n---\npython里面有一些基本的概念,像模块,函数之类的,理解这些基本概念有利于对python程序的理解和编写.\n<!-- more -->\n\n\n## 模块\n\n*  定义\n模块（类比java中包里面的类）是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用python标准库的方法。\n* 代码示例\n\t* 自己定义的模块\n\n\t\t```python\n\t\t# coding=utf-8\n\t\t#!/usr/bin/python\n\t\t# Filename: mymodule.py\n\n\t\t# 模块中定义的函数\n\t\tdef sayhi():   \n\t\t\tprint '模块就是这样建造的.'\n\n\t\t# 模块中定义的变量\n\t\tversion = '0.1'\n\t\t```\n\t* 引用自己定义好的模块\n\n\t\t```python\n\t\t# coding=utf-8\n\t\t#!/usr/bin/python\n\t\t# Filename: mymodule_demo.py\n\n\t\t# 导入所写模块\n\t\timport mymodule\n\n\t\t# 代码写在main()里面\n\t\tdef main():\n\t\t\t# 显示mymodule中定义的函数和变量\n\t\t\tprint \"mymodule中定义的函数和变量：\" + \"  \".join(dir(mymodule))\n\n\t\t\t# 显示当前main函数中定义的函数的变量\n\t\t\tprint \"main函数中定义的函数和变量：\" + \"  \".join(dir())\n\n\t\t\t# 显示__name__的值\n\t\t\tprint \"main函数中__name__变量的值：\" + __name__\n\n\n\t\t# 调用main()函数来启动程序的样板\n\t\tif __name__ == '__main__':\n\t\t\tmain()\n\n\t\t\t# 显示当前模块中定义的函数的变量\n\t\t\tprint \"当前模块中定义的函数和变量：\" + \"  \".join(dir())\n\n\t\t\t# 显示__name__的值\n\t\t\tprint \"当前模块中__name__变量的值：\" + __name__\n\t\t```\n## 函数\n\n* 定义  \n函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数定义注意点\n\t1. 以def关键字开头，后面接函数名称和参数以及冒号\n\t2. 以return [expression]结束函数\n\t3. 参数类型有多个\n\t\t* 必备参数--一般定义的参数\n\t\t* 命名参数--复制语句作为参数\n\t\t* 缺省参数--参数有默认值\n\t\t* 不定长参数--用*标记，类似指针\n* 代码示例\n\n\t```python\n\t# coding=utf-8\n\t#!/usr/bin/python\n\t# Filename: function_demo.py\n\n\n\t# 导入所写模块\n\timport sys\n\n\t# 自定义函数\n\t# 打印输入的参数和本函数名\n\tdef printStr( str ):\n\t\t# sys._getframe().f_code.co_name 能够获得当前函数的名称\n\t\tprint sys._getframe().f_code.co_name , \":\" , str\n\t\treturn\n\n\t# 打印输入的不定长参数和本函数名\n\tdef printChangePar( argc, *argv ):\n\t\tprint sys._getframe().f_code.co_name , \":\" , argc\n\t\tvars =\"\"\n\t\tfor var in argv:\n\t\t\tvars = vars + var + \" \"\n\t\t\treturn vars\n\n\n\n\t# 代码写在main()里面\n\tdef main():\n\t\t# 传入命名参数\n\t\tprintStr( str = \"I am here .\" )\n\n\t\t# 传入不定长参数\n\t\tprint printChangePar(4,\"I\",\"am\",\"here\",\".\")\n\n\n\t# 调用main()函数来启动程序的样板\n\tif __name__ == '__main__':\n\t\tmain()\n\t```\n","slug":"Study-basicConcept-Python","published":1,"date":"2014-12-03T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0x000nl73yl1kwefl3","content":"<p>python里面有一些基本的概念,像模块,函数之类的,理解这些基本概念有利于对python程序的理解和编写. <a id=\"more\"></a></p>\n<h2 id=\"模块\">模块</h2>\n<ul>\n<li>定义 模块（类比java中包里面的类）是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用python标准库的方法。</li>\n<li>代码示例\n<ul>\n<li><p>自己定义的模块</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding=utf-8</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># Filename: mymodule.py</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 模块中定义的函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sayhi</span><span class=\"params\">()</span>:</span>   </div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">'模块就是这样建造的.'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 模块中定义的变量</span></div><div class=\"line\">version = <span class=\"string\">'0.1'</span></div></pre></td></tr></table></figure></li>\n<li><p>引用自己定义好的模块</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding=utf-8</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># Filename: mymodule_demo.py</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 导入所写模块</span></div><div class=\"line\"><span class=\"keyword\">import</span> mymodule</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 代码写在main()里面</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">\t<span class=\"comment\"># 显示mymodule中定义的函数和变量</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"mymodule中定义的函数和变量：\"</span> + <span class=\"string\">\"  \"</span>.join(dir(mymodule))</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 显示当前main函数中定义的函数的变量</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"main函数中定义的函数和变量：\"</span> + <span class=\"string\">\"  \"</span>.join(dir())</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 显示__name__的值</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"main函数中__name__变量的值：\"</span> + __name__</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 调用main()函数来启动程序的样板</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">\tmain()</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 显示当前模块中定义的函数的变量</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"当前模块中定义的函数和变量：\"</span> + <span class=\"string\">\"  \"</span>.join(dir())</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 显示__name__的值</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"当前模块中__name__变量的值：\"</span> + __name__</div></pre></td></tr></table></figure></li>\n</ul></li>\n</ul>\n<h2 id=\"函数\">函数</h2>\n<ul>\n<li>定义<br>\n函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数定义注意点\n<ol style=\"list-style-type: decimal\">\n<li>以def关键字开头，后面接函数名称和参数以及冒号</li>\n<li>以return [expression]结束函数</li>\n<li>参数类型有多个\n<ul>\n<li>必备参数–一般定义的参数</li>\n<li>命名参数–复制语句作为参数</li>\n<li>缺省参数–参数有默认值</li>\n<li>不定长参数–用*标记，类似指针</li>\n</ul></li>\n</ol></li>\n<li><p>代码示例</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding=utf-8</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># Filename: function_demo.py</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 导入所写模块</span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 自定义函数</span></div><div class=\"line\"><span class=\"comment\"># 打印输入的参数和本函数名</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printStr</span><span class=\"params\">( str )</span>:</span></div><div class=\"line\">\t<span class=\"comment\"># sys._getframe().f_code.co_name 能够获得当前函数的名称</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> sys._getframe().f_code.co_name , <span class=\"string\">\":\"</span> , str</div><div class=\"line\">\t<span class=\"keyword\">return</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 打印输入的不定长参数和本函数名</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printChangePar</span><span class=\"params\">( argc, *argv )</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> sys._getframe().f_code.co_name , <span class=\"string\">\":\"</span> , argc</div><div class=\"line\">\tvars =<span class=\"string\">\"\"</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> var <span class=\"keyword\">in</span> argv:</div><div class=\"line\">\t\tvars = vars + var + <span class=\"string\">\" \"</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> vars</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 代码写在main()里面</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">\t<span class=\"comment\"># 传入命名参数</span></div><div class=\"line\">\tprintStr( str = <span class=\"string\">\"I am here .\"</span> )</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 传入不定长参数</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> printChangePar(<span class=\"number\">4</span>,<span class=\"string\">\"I\"</span>,<span class=\"string\">\"am\"</span>,<span class=\"string\">\"here\"</span>,<span class=\"string\">\".\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 调用main()函数来启动程序的样板</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">\tmain()</div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>python里面有一些基本的概念,像模块,函数之类的,理解这些基本概念有利于对python程序的理解和编写.","more":"</p>\n<h2 id=\"模块\">模块</h2>\n<ul>\n<li>定义 模块（类比java中包里面的类）是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用python标准库的方法。</li>\n<li>代码示例\n<ul>\n<li><p>自己定义的模块</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding=utf-8</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># Filename: mymodule.py</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 模块中定义的函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sayhi</span><span class=\"params\">()</span>:</span>   </div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">'模块就是这样建造的.'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 模块中定义的变量</span></div><div class=\"line\">version = <span class=\"string\">'0.1'</span></div></pre></td></tr></table></figure></li>\n<li><p>引用自己定义好的模块</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding=utf-8</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># Filename: mymodule_demo.py</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 导入所写模块</span></div><div class=\"line\"><span class=\"keyword\">import</span> mymodule</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 代码写在main()里面</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">\t<span class=\"comment\"># 显示mymodule中定义的函数和变量</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"mymodule中定义的函数和变量：\"</span> + <span class=\"string\">\"  \"</span>.join(dir(mymodule))</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 显示当前main函数中定义的函数的变量</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"main函数中定义的函数和变量：\"</span> + <span class=\"string\">\"  \"</span>.join(dir())</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 显示__name__的值</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"main函数中__name__变量的值：\"</span> + __name__</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 调用main()函数来启动程序的样板</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">\tmain()</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 显示当前模块中定义的函数的变量</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"当前模块中定义的函数和变量：\"</span> + <span class=\"string\">\"  \"</span>.join(dir())</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 显示__name__的值</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"当前模块中__name__变量的值：\"</span> + __name__</div></pre></td></tr></table></figure></li>\n</ul></li>\n</ul>\n<h2 id=\"函数\">函数</h2>\n<ul>\n<li>定义<br>\n函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数定义注意点\n<ol style=\"list-style-type: decimal\">\n<li>以def关键字开头，后面接函数名称和参数以及冒号</li>\n<li>以return [expression]结束函数</li>\n<li>参数类型有多个\n<ul>\n<li>必备参数–一般定义的参数</li>\n<li>命名参数–复制语句作为参数</li>\n<li>缺省参数–参数有默认值</li>\n<li>不定长参数–用*标记，类似指针</li>\n</ul></li>\n</ol></li>\n<li><p>代码示例</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># coding=utf-8</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"><span class=\"comment\"># Filename: function_demo.py</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 导入所写模块</span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 自定义函数</span></div><div class=\"line\"><span class=\"comment\"># 打印输入的参数和本函数名</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printStr</span><span class=\"params\">( str )</span>:</span></div><div class=\"line\">\t<span class=\"comment\"># sys._getframe().f_code.co_name 能够获得当前函数的名称</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> sys._getframe().f_code.co_name , <span class=\"string\">\":\"</span> , str</div><div class=\"line\">\t<span class=\"keyword\">return</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 打印输入的不定长参数和本函数名</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">printChangePar</span><span class=\"params\">( argc, *argv )</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> sys._getframe().f_code.co_name , <span class=\"string\">\":\"</span> , argc</div><div class=\"line\">\tvars =<span class=\"string\">\"\"</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> var <span class=\"keyword\">in</span> argv:</div><div class=\"line\">\t\tvars = vars + var + <span class=\"string\">\" \"</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> vars</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 代码写在main()里面</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">\t<span class=\"comment\"># 传入命名参数</span></div><div class=\"line\">\tprintStr( str = <span class=\"string\">\"I am here .\"</span> )</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 传入不定长参数</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> printChangePar(<span class=\"number\">4</span>,<span class=\"string\">\"I\"</span>,<span class=\"string\">\"am\"</span>,<span class=\"string\">\"here\"</span>,<span class=\"string\">\".\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 调用main()函数来启动程序的样板</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">\tmain()</div></pre></td></tr></table></figure></li>\n</ul>"},{"layout":"post","title":"python基础篇之介绍","comments":1,"_content":"python基础篇是以Google for Education上面的[Google's Python Class课程](https://developers.google.com/edu/python/?csw=1)为主.这是一门非常适合初学者的课程.\n<!-- more -->\n\n\n## 英文介绍\nWelcome to Google's Python Class -- this is a free class for people with a little bit of programming experience who want to learn Python. The class includes written materials, lecture videos, and lots of code exercises to practice Python coding. These materials are used within Google to introduce Python to people who have just a little programming experience. The first exercises work on basic Python concepts like strings and lists, building up to the later exercises which are full programs dealing with text files, processes, and http connections. The class is geared for people who have a little bit of programming experience in some language, enough to know what a \"variable\" or \"if statement\" is. Beyond that, you do not need to be an expert programmer to use this material.\n\n\nTo get started, the Python sections are linked at the left -- Python Set Up to get Python installed on your machine, Python Introduction for an introduction to the language, and then Python Strings starts the coding material, leading to the first exercise. The end of each written section includes a link to the code exercise for that section's material. The lecture videos parallel the written materials, introducing Python, then strings, then first exercises, and so on. At Google, all this material makes up an intensive 2-day class, so the videos are organized as the day-1 and day-2 sections.\n\n\nThis material was created by Nick Parlante working in the engEDU group at Google. Special thanks for the help from my Google colleagues John Cox, Steve Glassman, Piotr Kaminksi, and Antoine Picard. And finally thanks to Google and my director Maggie Johnson for the enlightened generosity to put these materials out on the internet for free under the under the Creative Commons Attribution 2.5 license -- share and enjoy!\n\n\n## 课程结构\n该课程主要包含以下三大模块,当然最重要的莫过于课程后面的练习了.\n\n1. 文档\n2. 视频\n3. 练习\n![课程结构]({{ site.baseurl }}/assets/images/python_struct.png)\n\n\n## 简单python样例\n就像刚刚学习c语言接触第一个\"Hello world!\"程序一样,下面就是一个简单的python版的\"Hello world!\"程序.\n\n* 代码示例\n\n\t```python\n\t#!/usr/bin/python\n\n\t# 导入所用模块 -- sys 是常用的模块\n\timport sys\n\n\t# 代码写在main()里面\n\tdef main():\n\t\tprint 'Hello World!'\n\t\t# 命令行的参数在 sys.argv[1], sys.argv[2] ...\n\t\t# sys.argv[0] 表示脚本名称\n\n\t# 调用main()函数来启动程序的样板\n\tif __name__ == '__main__':\n\t\tmain()\n\t```\n\t> **注意:**  \n\t> 代码第一行`#!/usr/bin/python`是当使用./scrpt.py执行该段程序时指定解释器的路径. 显然这里是linux的路径,windows可以换成`#!C:\\Python2.7`\n\t>\n","source":"_posts/2014-12-03-python基础篇之介绍.md","raw":"---\nlayout:\tpost\ntitle:\tpython基础篇之介绍\ncategories:\n- TECHNOLOGY\ntags:\n- Python\n- Google\npermalink:  Study-introduce-Python\ncomments:\ttrue\n---\npython基础篇是以Google for Education上面的[Google's Python Class课程](https://developers.google.com/edu/python/?csw=1)为主.这是一门非常适合初学者的课程.\n<!-- more -->\n\n\n## 英文介绍\nWelcome to Google's Python Class -- this is a free class for people with a little bit of programming experience who want to learn Python. The class includes written materials, lecture videos, and lots of code exercises to practice Python coding. These materials are used within Google to introduce Python to people who have just a little programming experience. The first exercises work on basic Python concepts like strings and lists, building up to the later exercises which are full programs dealing with text files, processes, and http connections. The class is geared for people who have a little bit of programming experience in some language, enough to know what a \"variable\" or \"if statement\" is. Beyond that, you do not need to be an expert programmer to use this material.\n\n\nTo get started, the Python sections are linked at the left -- Python Set Up to get Python installed on your machine, Python Introduction for an introduction to the language, and then Python Strings starts the coding material, leading to the first exercise. The end of each written section includes a link to the code exercise for that section's material. The lecture videos parallel the written materials, introducing Python, then strings, then first exercises, and so on. At Google, all this material makes up an intensive 2-day class, so the videos are organized as the day-1 and day-2 sections.\n\n\nThis material was created by Nick Parlante working in the engEDU group at Google. Special thanks for the help from my Google colleagues John Cox, Steve Glassman, Piotr Kaminksi, and Antoine Picard. And finally thanks to Google and my director Maggie Johnson for the enlightened generosity to put these materials out on the internet for free under the under the Creative Commons Attribution 2.5 license -- share and enjoy!\n\n\n## 课程结构\n该课程主要包含以下三大模块,当然最重要的莫过于课程后面的练习了.\n\n1. 文档\n2. 视频\n3. 练习\n![课程结构]({{ site.baseurl }}/assets/images/python_struct.png)\n\n\n## 简单python样例\n就像刚刚学习c语言接触第一个\"Hello world!\"程序一样,下面就是一个简单的python版的\"Hello world!\"程序.\n\n* 代码示例\n\n\t```python\n\t#!/usr/bin/python\n\n\t# 导入所用模块 -- sys 是常用的模块\n\timport sys\n\n\t# 代码写在main()里面\n\tdef main():\n\t\tprint 'Hello World!'\n\t\t# 命令行的参数在 sys.argv[1], sys.argv[2] ...\n\t\t# sys.argv[0] 表示脚本名称\n\n\t# 调用main()函数来启动程序的样板\n\tif __name__ == '__main__':\n\t\tmain()\n\t```\n\t> **注意:**  \n\t> 代码第一行`#!/usr/bin/python`是当使用./scrpt.py执行该段程序时指定解释器的路径. 显然这里是linux的路径,windows可以换成`#!C:\\Python2.7`\n\t>\n","slug":"Study-introduce-Python","published":1,"date":"2014-12-02T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0y000ol73ym9rq6was","content":"<p>python基础篇是以Google for Education上面的<a href=\"https://developers.google.com/edu/python/?csw=1\" target=\"_blank\" rel=\"external\">Google’s Python Class课程</a>为主.这是一门非常适合初学者的课程. <a id=\"more\"></a></p>\n<h2 id=\"英文介绍\">英文介绍</h2>\n<p>Welcome to Google’s Python Class – this is a free class for people with a little bit of programming experience who want to learn Python. The class includes written materials, lecture videos, and lots of code exercises to practice Python coding. These materials are used within Google to introduce Python to people who have just a little programming experience. The first exercises work on basic Python concepts like strings and lists, building up to the later exercises which are full programs dealing with text files, processes, and http connections. The class is geared for people who have a little bit of programming experience in some language, enough to know what a “variable” or “if statement” is. Beyond that, you do not need to be an expert programmer to use this material.</p>\n<p>To get started, the Python sections are linked at the left – Python Set Up to get Python installed on your machine, Python Introduction for an introduction to the language, and then Python Strings starts the coding material, leading to the first exercise. The end of each written section includes a link to the code exercise for that section’s material. The lecture videos parallel the written materials, introducing Python, then strings, then first exercises, and so on. At Google, all this material makes up an intensive 2-day class, so the videos are organized as the day-1 and day-2 sections.</p>\n<p>This material was created by Nick Parlante working in the engEDU group at Google. Special thanks for the help from my Google colleagues John Cox, Steve Glassman, Piotr Kaminksi, and Antoine Picard. And finally thanks to Google and my director Maggie Johnson for the enlightened generosity to put these materials out on the internet for free under the under the Creative Commons Attribution 2.5 license – share and enjoy!</p>\n<h2 id=\"课程结构\">课程结构</h2>\n<p>该课程主要包含以下三大模块,当然最重要的莫过于课程后面的练习了.</p>\n<ol style=\"list-style-type: decimal\">\n<li>文档</li>\n<li>视频</li>\n<li>练习 <img src=\"#课程结构\" alt=\"课程结构\">(/assets/images/python_struct.png)</li>\n</ol>\n<h2 id=\"简单python样例\">简单python样例</h2>\n<p>就像刚刚学习c语言接触第一个“Hello world!”程序一样,下面就是一个简单的python版的“Hello world!”程序.</p>\n<ul>\n<li><p>代码示例</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 导入所用模块 -- sys 是常用的模块</span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 代码写在main()里面</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">'Hello World!'</span></div><div class=\"line\">\t<span class=\"comment\"># 命令行的参数在 sys.argv[1], sys.argv[2] ...</span></div><div class=\"line\">\t<span class=\"comment\"># sys.argv[0] 表示脚本名称</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 调用main()函数来启动程序的样板</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">\tmain()</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意:</strong><br>\n代码第一行<code>#!/usr/bin/python</code>是当使用./scrpt.py执行该段程序时指定解释器的路径. 显然这里是linux的路径,windows可以换成<code>#!C:\\Python2.7</code></p>\n</blockquote></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>python基础篇是以Google for Education上面的<a href=\"https://developers.google.com/edu/python/?csw=1\" target=\"_blank\" rel=\"external\">Google’s Python Class课程</a>为主.这是一门非常适合初学者的课程.","more":"</p>\n<h2 id=\"英文介绍\">英文介绍</h2>\n<p>Welcome to Google’s Python Class – this is a free class for people with a little bit of programming experience who want to learn Python. The class includes written materials, lecture videos, and lots of code exercises to practice Python coding. These materials are used within Google to introduce Python to people who have just a little programming experience. The first exercises work on basic Python concepts like strings and lists, building up to the later exercises which are full programs dealing with text files, processes, and http connections. The class is geared for people who have a little bit of programming experience in some language, enough to know what a “variable” or “if statement” is. Beyond that, you do not need to be an expert programmer to use this material.</p>\n<p>To get started, the Python sections are linked at the left – Python Set Up to get Python installed on your machine, Python Introduction for an introduction to the language, and then Python Strings starts the coding material, leading to the first exercise. The end of each written section includes a link to the code exercise for that section’s material. The lecture videos parallel the written materials, introducing Python, then strings, then first exercises, and so on. At Google, all this material makes up an intensive 2-day class, so the videos are organized as the day-1 and day-2 sections.</p>\n<p>This material was created by Nick Parlante working in the engEDU group at Google. Special thanks for the help from my Google colleagues John Cox, Steve Glassman, Piotr Kaminksi, and Antoine Picard. And finally thanks to Google and my director Maggie Johnson for the enlightened generosity to put these materials out on the internet for free under the under the Creative Commons Attribution 2.5 license – share and enjoy!</p>\n<h2 id=\"课程结构\">课程结构</h2>\n<p>该课程主要包含以下三大模块,当然最重要的莫过于课程后面的练习了.</p>\n<ol style=\"list-style-type: decimal\">\n<li>文档</li>\n<li>视频</li>\n<li>练习 <img src=\"#课程结构\" alt=\"课程结构\">(/assets/images/python_struct.png)</li>\n</ol>\n<h2 id=\"简单python样例\">简单python样例</h2>\n<p>就像刚刚学习c语言接触第一个“Hello world!”程序一样,下面就是一个简单的python版的“Hello world!”程序.</p>\n<ul>\n<li><p>代码示例</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 导入所用模块 -- sys 是常用的模块</span></div><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 代码写在main()里面</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">'Hello World!'</span></div><div class=\"line\">\t<span class=\"comment\"># 命令行的参数在 sys.argv[1], sys.argv[2] ...</span></div><div class=\"line\">\t<span class=\"comment\"># sys.argv[0] 表示脚本名称</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 调用main()函数来启动程序的样板</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">\tmain()</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意:</strong><br>\n代码第一行<code>#!/usr/bin/python</code>是当使用./scrpt.py执行该段程序时指定解释器的路径. 显然这里是linux的路径,windows可以换成<code>#!C:\\Python2.7</code></p>\n</blockquote></li>\n</ul>"},{"layout":"post","title":"python基础篇之元组和字典","comments":1,"_content":"除了list之外,python还有两个比较常用的数据结构,就是本文所介绍的元组和字典.元组其实就相当于数组.其元素的大小无法改变.\n<!-- more -->\n\n## 元组表示\n* 赋值(用圆圆括号包含元素)\n\n\t```python\n\ttuple = (1, 2, 'hi')\n\tprint len(tuple)  ## 3\n\tprint tuple[2]    ## hi\n\t```\n* 更改元素\n\n\t```python\n\t# 报错，元组元素无法更改\n\ttuple[2] = 'bye'\n\t# this works\n\ttuple = (1, 2, 'bye')\n\t```\n\n## 字典表示\n* 赋值\n\n\t```python\n\t# 可以以{}开始构建空字典，然后以赋值的形式给字典添加键值对\n\tdict = {}\n\tdict['a'] = 'alpha'\n\tdict['g'] = 'gamma'\n\tdict['o'] = 'omega'\n\n\tprint dict  ## {'a': 'alpha', 'o': 'omega', 'g': 'gamma'}\n\t```\n* 查看和更改元素\n\n\t```python\n\tprint dict['a']     # 查看'a'对应的值 'alpha'\n\tdict['a'] = 6       # 给'a'重新赋值\n\n\tif 'z' in dict: print dict['z']     # 避免报错\n\tprint dict.get('z')  # None (instead of KeyError)\n\t```\n\n## 字典方法\n* 获取字典关键字\n\n\t```python\n\tdict.keys()\n\t```\n* 获取字典值\n\n\t```python\n\tdict.values()\n\t```\n* 获取字典键值对(返回的是一个元组链表)\n\n\t```python\n\tdict.items()\n\t```\n* 循环中获取键和值\n\n\t```python\n\tfor k,v in dict.items():\n\t\tprint k, '>', v\n\t```\n* 删除元素(对list也适用)\n\n\t```python\n\tdict = {'a':1, 'b':2, 'c':3}\n\tdel dict['b']   # 删除'b'元素\n\tprint dict      ## {'a':1, 'c':3}\n\t```\n\n## 字典排序\n* sorted方法\n\n\t```python\n\tdict1={'A': 9, 'C': 5, 'B': 1, 'E': 14, 'D': 3, 'G': 3, 'F': 3, 'I': 9, 'H': 7, 'J': 1, 'L': 2, 'O': 8, 'N': 3, 'P': 4, 'S': 10, 'R': 5, 'U': 1, 'T': 17, 'W': 1, 'V': 1}\n\n\t#对字典按值排序,以元组的形式返回\n\tprint sorted(dict1.iteritems(),key=lambda dict1:dict1[1],reverse=True)\n\t#对字典按键排序,以元组的形式返回\n\tprint sorted(dict1.iteritems(),key=lambda dict1:dict1[0],reverse=False)\n\t```\n","source":"_posts/2014-12-07-python基础篇之元组和字典.md","raw":"---\nlayout:\tpost\ntitle:\tpython基础篇之元组和字典\ncategories:\n- TECHNOLOGY\ntags:\n- Python\n- Google\npermalink:  Study-tupleDict-Python\ncomments:\ttrue\n---\n除了list之外,python还有两个比较常用的数据结构,就是本文所介绍的元组和字典.元组其实就相当于数组.其元素的大小无法改变.\n<!-- more -->\n\n## 元组表示\n* 赋值(用圆圆括号包含元素)\n\n\t```python\n\ttuple = (1, 2, 'hi')\n\tprint len(tuple)  ## 3\n\tprint tuple[2]    ## hi\n\t```\n* 更改元素\n\n\t```python\n\t# 报错，元组元素无法更改\n\ttuple[2] = 'bye'\n\t# this works\n\ttuple = (1, 2, 'bye')\n\t```\n\n## 字典表示\n* 赋值\n\n\t```python\n\t# 可以以{}开始构建空字典，然后以赋值的形式给字典添加键值对\n\tdict = {}\n\tdict['a'] = 'alpha'\n\tdict['g'] = 'gamma'\n\tdict['o'] = 'omega'\n\n\tprint dict  ## {'a': 'alpha', 'o': 'omega', 'g': 'gamma'}\n\t```\n* 查看和更改元素\n\n\t```python\n\tprint dict['a']     # 查看'a'对应的值 'alpha'\n\tdict['a'] = 6       # 给'a'重新赋值\n\n\tif 'z' in dict: print dict['z']     # 避免报错\n\tprint dict.get('z')  # None (instead of KeyError)\n\t```\n\n## 字典方法\n* 获取字典关键字\n\n\t```python\n\tdict.keys()\n\t```\n* 获取字典值\n\n\t```python\n\tdict.values()\n\t```\n* 获取字典键值对(返回的是一个元组链表)\n\n\t```python\n\tdict.items()\n\t```\n* 循环中获取键和值\n\n\t```python\n\tfor k,v in dict.items():\n\t\tprint k, '>', v\n\t```\n* 删除元素(对list也适用)\n\n\t```python\n\tdict = {'a':1, 'b':2, 'c':3}\n\tdel dict['b']   # 删除'b'元素\n\tprint dict      ## {'a':1, 'c':3}\n\t```\n\n## 字典排序\n* sorted方法\n\n\t```python\n\tdict1={'A': 9, 'C': 5, 'B': 1, 'E': 14, 'D': 3, 'G': 3, 'F': 3, 'I': 9, 'H': 7, 'J': 1, 'L': 2, 'O': 8, 'N': 3, 'P': 4, 'S': 10, 'R': 5, 'U': 1, 'T': 17, 'W': 1, 'V': 1}\n\n\t#对字典按值排序,以元组的形式返回\n\tprint sorted(dict1.iteritems(),key=lambda dict1:dict1[1],reverse=True)\n\t#对字典按键排序,以元组的形式返回\n\tprint sorted(dict1.iteritems(),key=lambda dict1:dict1[0],reverse=False)\n\t```\n","slug":"Study-tupleDict-Python","published":1,"date":"2014-12-06T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j0z000pl73yn9igz76h","content":"<p>除了list之外,python还有两个比较常用的数据结构,就是本文所介绍的元组和字典.元组其实就相当于数组.其元素的大小无法改变. <a id=\"more\"></a></p>\n<h2 id=\"元组表示\">元组表示</h2>\n<ul>\n<li><p>赋值(用圆圆括号包含元素)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">tuple = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'hi'</span>)</div><div class=\"line\"><span class=\"keyword\">print</span> len(tuple)  <span class=\"comment\">## 3</span></div><div class=\"line\"><span class=\"keyword\">print</span> tuple[<span class=\"number\">2</span>]    <span class=\"comment\">## hi</span></div></pre></td></tr></table></figure></li>\n<li><p>更改元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 报错，元组元素无法更改</span></div><div class=\"line\">tuple[<span class=\"number\">2</span>] = <span class=\"string\">'bye'</span></div><div class=\"line\"><span class=\"comment\"># this works</span></div><div class=\"line\">tuple = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'bye'</span>)</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"字典表示\">字典表示</h2>\n<ul>\n<li><p>赋值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 可以以&#123;&#125;开始构建空字典，然后以赋值的形式给字典添加键值对</span></div><div class=\"line\">dict = &#123;&#125;</div><div class=\"line\">dict[<span class=\"string\">'a'</span>] = <span class=\"string\">'alpha'</span></div><div class=\"line\">dict[<span class=\"string\">'g'</span>] = <span class=\"string\">'gamma'</span></div><div class=\"line\">dict[<span class=\"string\">'o'</span>] = <span class=\"string\">'omega'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> dict  <span class=\"comment\">## &#123;'a': 'alpha', 'o': 'omega', 'g': 'gamma'&#125;</span></div></pre></td></tr></table></figure></li>\n<li><p>查看和更改元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">print</span> dict[<span class=\"string\">'a'</span>]     <span class=\"comment\"># 查看'a'对应的值 'alpha'</span></div><div class=\"line\">dict[<span class=\"string\">'a'</span>] = <span class=\"number\">6</span>       <span class=\"comment\"># 给'a'重新赋值</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"string\">'z'</span> <span class=\"keyword\">in</span> dict: <span class=\"keyword\">print</span> dict[<span class=\"string\">'z'</span>]     <span class=\"comment\"># 避免报错</span></div><div class=\"line\"><span class=\"keyword\">print</span> dict.get(<span class=\"string\">'z'</span>)  <span class=\"comment\"># None (instead of KeyError)</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"字典方法\">字典方法</h2>\n<ul>\n<li><p>获取字典关键字</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dict.keys()</div></pre></td></tr></table></figure></li>\n<li><p>获取字典值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dict.values()</div></pre></td></tr></table></figure></li>\n<li><p>获取字典键值对(返回的是一个元组链表)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dict.items()</div></pre></td></tr></table></figure></li>\n<li><p>循环中获取键和值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> dict.items():</div><div class=\"line\">\t<span class=\"keyword\">print</span> k, <span class=\"string\">'&gt;'</span>, v</div></pre></td></tr></table></figure></li>\n<li><p>删除元素(对list也适用)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dict = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>:<span class=\"number\">2</span>, <span class=\"string\">'c'</span>:<span class=\"number\">3</span>&#125;</div><div class=\"line\"><span class=\"keyword\">del</span> dict[<span class=\"string\">'b'</span>]   <span class=\"comment\"># 删除'b'元素</span></div><div class=\"line\"><span class=\"keyword\">print</span> dict      <span class=\"comment\">## &#123;'a':1, 'c':3&#125;</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"字典排序\">字典排序</h2>\n<ul>\n<li><p>sorted方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">dict1=&#123;<span class=\"string\">'A'</span>: <span class=\"number\">9</span>, <span class=\"string\">'C'</span>: <span class=\"number\">5</span>, <span class=\"string\">'B'</span>: <span class=\"number\">1</span>, <span class=\"string\">'E'</span>: <span class=\"number\">14</span>, <span class=\"string\">'D'</span>: <span class=\"number\">3</span>, <span class=\"string\">'G'</span>: <span class=\"number\">3</span>, <span class=\"string\">'F'</span>: <span class=\"number\">3</span>, <span class=\"string\">'I'</span>: <span class=\"number\">9</span>, <span class=\"string\">'H'</span>: <span class=\"number\">7</span>, <span class=\"string\">'J'</span>: <span class=\"number\">1</span>, <span class=\"string\">'L'</span>: <span class=\"number\">2</span>, <span class=\"string\">'O'</span>: <span class=\"number\">8</span>, <span class=\"string\">'N'</span>: <span class=\"number\">3</span>, <span class=\"string\">'P'</span>: <span class=\"number\">4</span>, <span class=\"string\">'S'</span>: <span class=\"number\">10</span>, <span class=\"string\">'R'</span>: <span class=\"number\">5</span>, <span class=\"string\">'U'</span>: <span class=\"number\">1</span>, <span class=\"string\">'T'</span>: <span class=\"number\">17</span>, <span class=\"string\">'W'</span>: <span class=\"number\">1</span>, <span class=\"string\">'V'</span>: <span class=\"number\">1</span>&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#对字典按值排序,以元组的形式返回</span></div><div class=\"line\"><span class=\"keyword\">print</span> sorted(dict1.iteritems(),key=<span class=\"keyword\">lambda</span> dict1:dict1[<span class=\"number\">1</span>],reverse=<span class=\"keyword\">True</span>)</div><div class=\"line\"><span class=\"comment\">#对字典按键排序,以元组的形式返回</span></div><div class=\"line\"><span class=\"keyword\">print</span> sorted(dict1.iteritems(),key=<span class=\"keyword\">lambda</span> dict1:dict1[<span class=\"number\">0</span>],reverse=<span class=\"keyword\">False</span>)</div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>除了list之外,python还有两个比较常用的数据结构,就是本文所介绍的元组和字典.元组其实就相当于数组.其元素的大小无法改变.","more":"</p>\n<h2 id=\"元组表示\">元组表示</h2>\n<ul>\n<li><p>赋值(用圆圆括号包含元素)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">tuple = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'hi'</span>)</div><div class=\"line\"><span class=\"keyword\">print</span> len(tuple)  <span class=\"comment\">## 3</span></div><div class=\"line\"><span class=\"keyword\">print</span> tuple[<span class=\"number\">2</span>]    <span class=\"comment\">## hi</span></div></pre></td></tr></table></figure></li>\n<li><p>更改元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 报错，元组元素无法更改</span></div><div class=\"line\">tuple[<span class=\"number\">2</span>] = <span class=\"string\">'bye'</span></div><div class=\"line\"><span class=\"comment\"># this works</span></div><div class=\"line\">tuple = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'bye'</span>)</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"字典表示\">字典表示</h2>\n<ul>\n<li><p>赋值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 可以以&#123;&#125;开始构建空字典，然后以赋值的形式给字典添加键值对</span></div><div class=\"line\">dict = &#123;&#125;</div><div class=\"line\">dict[<span class=\"string\">'a'</span>] = <span class=\"string\">'alpha'</span></div><div class=\"line\">dict[<span class=\"string\">'g'</span>] = <span class=\"string\">'gamma'</span></div><div class=\"line\">dict[<span class=\"string\">'o'</span>] = <span class=\"string\">'omega'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> dict  <span class=\"comment\">## &#123;'a': 'alpha', 'o': 'omega', 'g': 'gamma'&#125;</span></div></pre></td></tr></table></figure></li>\n<li><p>查看和更改元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">print</span> dict[<span class=\"string\">'a'</span>]     <span class=\"comment\"># 查看'a'对应的值 'alpha'</span></div><div class=\"line\">dict[<span class=\"string\">'a'</span>] = <span class=\"number\">6</span>       <span class=\"comment\"># 给'a'重新赋值</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"string\">'z'</span> <span class=\"keyword\">in</span> dict: <span class=\"keyword\">print</span> dict[<span class=\"string\">'z'</span>]     <span class=\"comment\"># 避免报错</span></div><div class=\"line\"><span class=\"keyword\">print</span> dict.get(<span class=\"string\">'z'</span>)  <span class=\"comment\"># None (instead of KeyError)</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"字典方法\">字典方法</h2>\n<ul>\n<li><p>获取字典关键字</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dict.keys()</div></pre></td></tr></table></figure></li>\n<li><p>获取字典值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dict.values()</div></pre></td></tr></table></figure></li>\n<li><p>获取字典键值对(返回的是一个元组链表)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dict.items()</div></pre></td></tr></table></figure></li>\n<li><p>循环中获取键和值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> dict.items():</div><div class=\"line\">\t<span class=\"keyword\">print</span> k, <span class=\"string\">'&gt;'</span>, v</div></pre></td></tr></table></figure></li>\n<li><p>删除元素(对list也适用)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dict = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>:<span class=\"number\">2</span>, <span class=\"string\">'c'</span>:<span class=\"number\">3</span>&#125;</div><div class=\"line\"><span class=\"keyword\">del</span> dict[<span class=\"string\">'b'</span>]   <span class=\"comment\"># 删除'b'元素</span></div><div class=\"line\"><span class=\"keyword\">print</span> dict      <span class=\"comment\">## &#123;'a':1, 'c':3&#125;</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"字典排序\">字典排序</h2>\n<ul>\n<li><p>sorted方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">dict1=&#123;<span class=\"string\">'A'</span>: <span class=\"number\">9</span>, <span class=\"string\">'C'</span>: <span class=\"number\">5</span>, <span class=\"string\">'B'</span>: <span class=\"number\">1</span>, <span class=\"string\">'E'</span>: <span class=\"number\">14</span>, <span class=\"string\">'D'</span>: <span class=\"number\">3</span>, <span class=\"string\">'G'</span>: <span class=\"number\">3</span>, <span class=\"string\">'F'</span>: <span class=\"number\">3</span>, <span class=\"string\">'I'</span>: <span class=\"number\">9</span>, <span class=\"string\">'H'</span>: <span class=\"number\">7</span>, <span class=\"string\">'J'</span>: <span class=\"number\">1</span>, <span class=\"string\">'L'</span>: <span class=\"number\">2</span>, <span class=\"string\">'O'</span>: <span class=\"number\">8</span>, <span class=\"string\">'N'</span>: <span class=\"number\">3</span>, <span class=\"string\">'P'</span>: <span class=\"number\">4</span>, <span class=\"string\">'S'</span>: <span class=\"number\">10</span>, <span class=\"string\">'R'</span>: <span class=\"number\">5</span>, <span class=\"string\">'U'</span>: <span class=\"number\">1</span>, <span class=\"string\">'T'</span>: <span class=\"number\">17</span>, <span class=\"string\">'W'</span>: <span class=\"number\">1</span>, <span class=\"string\">'V'</span>: <span class=\"number\">1</span>&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#对字典按值排序,以元组的形式返回</span></div><div class=\"line\"><span class=\"keyword\">print</span> sorted(dict1.iteritems(),key=<span class=\"keyword\">lambda</span> dict1:dict1[<span class=\"number\">1</span>],reverse=<span class=\"keyword\">True</span>)</div><div class=\"line\"><span class=\"comment\">#对字典按键排序,以元组的形式返回</span></div><div class=\"line\"><span class=\"keyword\">print</span> sorted(dict1.iteritems(),key=<span class=\"keyword\">lambda</span> dict1:dict1[<span class=\"number\">0</span>],reverse=<span class=\"keyword\">False</span>)</div></pre></td></tr></table></figure></li>\n</ul>"},{"layout":"post","title":"python基础篇之基本语法","comments":1,"_content":"在基本的概念和数据结构了解完后,再了解一下基本语法来将这些零件合理的组合起来,这样就可以用python干一下复杂的任务了.\n<!-- more -->\n\n\n## 条件语句\n* 代码演示\n\n\t```python\n\tscore = 70\n\tif score > 100 :\n\t    print 'the score is out of range.'\n\telif score > 60 :\n\t    print 'your score is from 60 to 100.'\n\telif score > 0 :\n\t    print 'your score is from 0 to 60.'\n\telse :\n\t    print 'the score is out of range.'\n\t```\n\n## for循环语句\n* 代码演示\n\n\t```python\n\tcolors = ['red','blue','green']\n\n\tfor color in colors\n\t    print 'color is ' + color\n\t```\n\t```python\n\t# print the numbers from 0 through 99\n\tfor i in range(100):\n\t    print i\n\t```\n\n## while循环语句\n* 代码演示\n\n\t```python\n\t# list中元素a在哪个位置\n\ti = 0\n\twhile i < len(list):\n\t\tif list[i] == a :\n\t\t\tprint i\n\t\t\tbreak\n\t\telse :\n\t\t\ti += 1\n\t```\n","source":"_posts/2014-12-08-python基础篇之基本语法.md","raw":"---\nlayout:\tpost\ntitle:\tpython基础篇之基本语法\ncategories:\n- TECHNOLOGY\ntags:\n- Python\n- Google\npermalink:  Study-syntax-Python\ncomments:\ttrue\n---\n在基本的概念和数据结构了解完后,再了解一下基本语法来将这些零件合理的组合起来,这样就可以用python干一下复杂的任务了.\n<!-- more -->\n\n\n## 条件语句\n* 代码演示\n\n\t```python\n\tscore = 70\n\tif score > 100 :\n\t    print 'the score is out of range.'\n\telif score > 60 :\n\t    print 'your score is from 60 to 100.'\n\telif score > 0 :\n\t    print 'your score is from 0 to 60.'\n\telse :\n\t    print 'the score is out of range.'\n\t```\n\n## for循环语句\n* 代码演示\n\n\t```python\n\tcolors = ['red','blue','green']\n\n\tfor color in colors\n\t    print 'color is ' + color\n\t```\n\t```python\n\t# print the numbers from 0 through 99\n\tfor i in range(100):\n\t    print i\n\t```\n\n## while循环语句\n* 代码演示\n\n\t```python\n\t# list中元素a在哪个位置\n\ti = 0\n\twhile i < len(list):\n\t\tif list[i] == a :\n\t\t\tprint i\n\t\t\tbreak\n\t\telse :\n\t\t\ti += 1\n\t```\n","slug":"Study-syntax-Python","published":1,"date":"2014-12-07T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j10000ql73y0x5ito78","content":"<p>在基本的概念和数据结构了解完后,再了解一下基本语法来将这些零件合理的组合起来,这样就可以用python干一下复杂的任务了. <a id=\"more\"></a></p>\n<h2 id=\"条件语句\">条件语句</h2>\n<ul>\n<li><p>代码演示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">score = <span class=\"number\">70</span></div><div class=\"line\"><span class=\"keyword\">if</span> score &gt; <span class=\"number\">100</span> :</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'the score is out of range.'</span></div><div class=\"line\"><span class=\"keyword\">elif</span> score &gt; <span class=\"number\">60</span> :</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'your score is from 60 to 100.'</span></div><div class=\"line\"><span class=\"keyword\">elif</span> score &gt; <span class=\"number\">0</span> :</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'your score is from 0 to 60.'</span></div><div class=\"line\"><span class=\"keyword\">else</span> :</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'the score is out of range.'</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"for循环语句\">for循环语句</h2>\n<ul>\n<li><p>代码演示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">colors = [<span class=\"string\">'red'</span>,<span class=\"string\">'blue'</span>,<span class=\"string\">'green'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> color <span class=\"keyword\">in</span> colors</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'color is '</span> + color</div></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># print the numbers from 0 through 99</span></div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">100</span>):</div><div class=\"line\">    <span class=\"keyword\">print</span> i</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"while循环语句\">while循环语句</h2>\n<ul>\n<li><p>代码演示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># list中元素a在哪个位置</span></div><div class=\"line\">i = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">while</span> i &lt; len(list):</div><div class=\"line\">\t<span class=\"keyword\">if</span> list[i] == a :</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> i</div><div class=\"line\">\t\t<span class=\"keyword\">break</span></div><div class=\"line\">\t<span class=\"keyword\">else</span> :</div><div class=\"line\">\t\ti += <span class=\"number\">1</span></div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在基本的概念和数据结构了解完后,再了解一下基本语法来将这些零件合理的组合起来,这样就可以用python干一下复杂的任务了.","more":"</p>\n<h2 id=\"条件语句\">条件语句</h2>\n<ul>\n<li><p>代码演示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">score = <span class=\"number\">70</span></div><div class=\"line\"><span class=\"keyword\">if</span> score &gt; <span class=\"number\">100</span> :</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'the score is out of range.'</span></div><div class=\"line\"><span class=\"keyword\">elif</span> score &gt; <span class=\"number\">60</span> :</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'your score is from 60 to 100.'</span></div><div class=\"line\"><span class=\"keyword\">elif</span> score &gt; <span class=\"number\">0</span> :</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'your score is from 0 to 60.'</span></div><div class=\"line\"><span class=\"keyword\">else</span> :</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'the score is out of range.'</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"for循环语句\">for循环语句</h2>\n<ul>\n<li><p>代码演示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">colors = [<span class=\"string\">'red'</span>,<span class=\"string\">'blue'</span>,<span class=\"string\">'green'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> color <span class=\"keyword\">in</span> colors</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'color is '</span> + color</div></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># print the numbers from 0 through 99</span></div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">100</span>):</div><div class=\"line\">    <span class=\"keyword\">print</span> i</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"while循环语句\">while循环语句</h2>\n<ul>\n<li><p>代码演示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># list中元素a在哪个位置</span></div><div class=\"line\">i = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">while</span> i &lt; len(list):</div><div class=\"line\">\t<span class=\"keyword\">if</span> list[i] == a :</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> i</div><div class=\"line\">\t\t<span class=\"keyword\">break</span></div><div class=\"line\">\t<span class=\"keyword\">else</span> :</div><div class=\"line\">\t\ti += <span class=\"number\">1</span></div></pre></td></tr></table></figure></li>\n</ul>"},{"layout":"post","title":"python基础篇之字符串","comments":1,"_content":"个人感觉python对字符串的处理是非常强的,所以掌握一些python对字符串的基本操作是非常有必要的.\n<!-- more -->\n\n## 字符串表示\n* 赋值\n\n\t```python\n\tstr = 'hello'\n\t```\n* 填字符串\n\n\t```python\n\tstr = \"%d little pigs come out or I'll %s and %s and %s\" % (3, 'huff', 'puff', 'blow down')\n\t```\n* 转换\n\n\t```python\n\tpi = 3.14\n\tprint 'pi = ' + str(pi)\n\t```\n## 常用方法\n* 大小写转换\n\n\t```python\n\tstr.lower()\n\tstr.upper()\n\t```\n* 去除首尾空格\n\n\t```python\n\tstr.strip()\n\t```\n* 判断字符里所有的字符是不是字母/数字/空格\n\n\t```python\n\tstr.isalpha()\n\tstr.isdigit()\n\tstr.isspace()\n\t```\n* 判断字符串是不是以某个子串开头/结尾\n\n\t```python\n\tstr.startswith(' ')\n\tstr.endswith()\n\t```\n* 查找子串在字符串中的位置,没找到返回-1\n\n\t```python\n\tstr.find('th')\n\t```\n* 字符串的替换\n\n\t```python\n\tstr.replace('old','new')\n\t```\n* 字符串的分割,返回list\n\n\t```python\n\tstr.split('delim')\n\t'delim'.join(list)\n\n## 编码问题\n在python里面默认都是用unicode编码的,而windows里面的文件默认是gbk编码,而linux里面的文件默认的是utf8编码,所以编码之间的转换是必不可少的.\n\n* 定义unicode字符串\n\n\t```python\n\tustr = u'A unicode \\u018e string \\xf1'\n\t```\n* 转换utf-8编码\n\n\t```python\n\tutfstr = ustr.encode('utf-8')\n\t```\n* 转换会unicode编码\n\n\t```python\n\tunistr = unicode(utfstr, 'utf-8')\n\t```\n\n## 课后练习\n* 基础题: [string1.py]({{ site.baseurl }}/assets/attachs/string1.py.txt)  \n* 提升题: [string2.py]({{ site.baseurl }}/assets/attachs/string2.py.txt)\n","source":"_posts/2014-12-05-python基础篇之字符串.md","raw":"---\nlayout:\tpost\ntitle:\tpython基础篇之字符串\ncategories:\n- TECHNOLOGY\ntags:\n- Python\n- Google\npermalink:  Study-string-Python\ncomments:\ttrue\n---\n个人感觉python对字符串的处理是非常强的,所以掌握一些python对字符串的基本操作是非常有必要的.\n<!-- more -->\n\n## 字符串表示\n* 赋值\n\n\t```python\n\tstr = 'hello'\n\t```\n* 填字符串\n\n\t```python\n\tstr = \"%d little pigs come out or I'll %s and %s and %s\" % (3, 'huff', 'puff', 'blow down')\n\t```\n* 转换\n\n\t```python\n\tpi = 3.14\n\tprint 'pi = ' + str(pi)\n\t```\n## 常用方法\n* 大小写转换\n\n\t```python\n\tstr.lower()\n\tstr.upper()\n\t```\n* 去除首尾空格\n\n\t```python\n\tstr.strip()\n\t```\n* 判断字符里所有的字符是不是字母/数字/空格\n\n\t```python\n\tstr.isalpha()\n\tstr.isdigit()\n\tstr.isspace()\n\t```\n* 判断字符串是不是以某个子串开头/结尾\n\n\t```python\n\tstr.startswith(' ')\n\tstr.endswith()\n\t```\n* 查找子串在字符串中的位置,没找到返回-1\n\n\t```python\n\tstr.find('th')\n\t```\n* 字符串的替换\n\n\t```python\n\tstr.replace('old','new')\n\t```\n* 字符串的分割,返回list\n\n\t```python\n\tstr.split('delim')\n\t'delim'.join(list)\n\n## 编码问题\n在python里面默认都是用unicode编码的,而windows里面的文件默认是gbk编码,而linux里面的文件默认的是utf8编码,所以编码之间的转换是必不可少的.\n\n* 定义unicode字符串\n\n\t```python\n\tustr = u'A unicode \\u018e string \\xf1'\n\t```\n* 转换utf-8编码\n\n\t```python\n\tutfstr = ustr.encode('utf-8')\n\t```\n* 转换会unicode编码\n\n\t```python\n\tunistr = unicode(utfstr, 'utf-8')\n\t```\n\n## 课后练习\n* 基础题: [string1.py]({{ site.baseurl }}/assets/attachs/string1.py.txt)  \n* 提升题: [string2.py]({{ site.baseurl }}/assets/attachs/string2.py.txt)\n","slug":"Study-string-Python","published":1,"date":"2014-12-04T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j12000rl73y72wb4pkf","content":"<p>个人感觉python对字符串的处理是非常强的,所以掌握一些python对字符串的基本操作是非常有必要的. <a id=\"more\"></a></p>\n<h2 id=\"字符串表示\">字符串表示</h2>\n<ul>\n<li><p>赋值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">str = <span class=\"string\">'hello'</span></div></pre></td></tr></table></figure></li>\n<li><p>填字符串</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">str = <span class=\"string\">\"%d little pigs come out or I'll %s and %s and %s\"</span> % (<span class=\"number\">3</span>, <span class=\"string\">'huff'</span>, <span class=\"string\">'puff'</span>, <span class=\"string\">'blow down'</span>)</div></pre></td></tr></table></figure></li>\n<li><p>转换</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pi = <span class=\"number\">3.14</span></div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'pi = '</span> + str(pi)</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"常用方法\">常用方法</h2>\n<ul>\n<li><p>大小写转换</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.lower()</div><div class=\"line\">str.upper()</div></pre></td></tr></table></figure></li>\n<li><p>去除首尾空格</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.strip()</div></pre></td></tr></table></figure></li>\n<li><p>判断字符里所有的字符是不是字母/数字/空格</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.isalpha()</div><div class=\"line\">str.isdigit()</div><div class=\"line\">str.isspace()</div></pre></td></tr></table></figure></li>\n<li><p>判断字符串是不是以某个子串开头/结尾</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.startswith(<span class=\"string\">' '</span>)</div><div class=\"line\">str.endswith()</div></pre></td></tr></table></figure></li>\n<li><p>查找子串在字符串中的位置,没找到返回-1</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.find(<span class=\"string\">'th'</span>)</div></pre></td></tr></table></figure></li>\n<li><p>字符串的替换</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.replace(<span class=\"string\">'old'</span>,<span class=\"string\">'new'</span>)</div></pre></td></tr></table></figure></li>\n<li><p>字符串的分割,返回list</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tstr.split(<span class=\"string\">'delim'</span>)</div><div class=\"line\">\t<span class=\"string\">'delim'</span>.join(list)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">## 编码问题</span></div><div class=\"line\">在python里面默认都是用unicode编码的,而windows里面的文件默认是gbk编码,而linux里面的文件默认的是utf8编码,所以编码之间的转换是必不可少的.</div><div class=\"line\"></div><div class=\"line\">* 定义unicode字符串</div><div class=\"line\"></div><div class=\"line\">\t```python</div><div class=\"line\">\tustr = <span class=\"string\">u'A unicode \\u018e string \\xf1'</span></div></pre></td></tr></table></figure></li>\n<li><p>转换utf-8编码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">utfstr = ustr.encode(<span class=\"string\">'utf-8'</span>)</div></pre></td></tr></table></figure></li>\n<li><p>转换会unicode编码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">unistr = unicode(utfstr, <span class=\"string\">'utf-8'</span>)</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"课后练习\">课后练习</h2>\n<ul>\n<li>基础题: [string1.py](/assets/attachs/string1.py.txt)<br>\n</li>\n<li>提升题: [string2.py](/assets/attachs/string2.py.txt)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>个人感觉python对字符串的处理是非常强的,所以掌握一些python对字符串的基本操作是非常有必要的.","more":"</p>\n<h2 id=\"字符串表示\">字符串表示</h2>\n<ul>\n<li><p>赋值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">str = <span class=\"string\">'hello'</span></div></pre></td></tr></table></figure></li>\n<li><p>填字符串</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">str = <span class=\"string\">\"%d little pigs come out or I'll %s and %s and %s\"</span> % (<span class=\"number\">3</span>, <span class=\"string\">'huff'</span>, <span class=\"string\">'puff'</span>, <span class=\"string\">'blow down'</span>)</div></pre></td></tr></table></figure></li>\n<li><p>转换</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pi = <span class=\"number\">3.14</span></div><div class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'pi = '</span> + str(pi)</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"常用方法\">常用方法</h2>\n<ul>\n<li><p>大小写转换</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.lower()</div><div class=\"line\">str.upper()</div></pre></td></tr></table></figure></li>\n<li><p>去除首尾空格</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.strip()</div></pre></td></tr></table></figure></li>\n<li><p>判断字符里所有的字符是不是字母/数字/空格</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.isalpha()</div><div class=\"line\">str.isdigit()</div><div class=\"line\">str.isspace()</div></pre></td></tr></table></figure></li>\n<li><p>判断字符串是不是以某个子串开头/结尾</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.startswith(<span class=\"string\">' '</span>)</div><div class=\"line\">str.endswith()</div></pre></td></tr></table></figure></li>\n<li><p>查找子串在字符串中的位置,没找到返回-1</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.find(<span class=\"string\">'th'</span>)</div></pre></td></tr></table></figure></li>\n<li><p>字符串的替换</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">str.replace(<span class=\"string\">'old'</span>,<span class=\"string\">'new'</span>)</div></pre></td></tr></table></figure></li>\n<li><p>字符串的分割,返回list</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tstr.split(<span class=\"string\">'delim'</span>)</div><div class=\"line\">\t<span class=\"string\">'delim'</span>.join(list)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">## 编码问题</span></div><div class=\"line\">在python里面默认都是用unicode编码的,而windows里面的文件默认是gbk编码,而linux里面的文件默认的是utf8编码,所以编码之间的转换是必不可少的.</div><div class=\"line\"></div><div class=\"line\">* 定义unicode字符串</div><div class=\"line\"></div><div class=\"line\">\t```python</div><div class=\"line\">\tustr = <span class=\"string\">u'A unicode \\u018e string \\xf1'</span></div></pre></td></tr></table></figure></li>\n<li><p>转换utf-8编码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">utfstr = ustr.encode(<span class=\"string\">'utf-8'</span>)</div></pre></td></tr></table></figure></li>\n<li><p>转换会unicode编码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">unistr = unicode(utfstr, <span class=\"string\">'utf-8'</span>)</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"课后练习\">课后练习</h2>\n<ul>\n<li>基础题: [string1.py](/assets/attachs/string1.py.txt)<br>\n</li>\n<li>提升题: [string2.py](/assets/attachs/string2.py.txt)</li>\n</ul>"},{"layout":"post","title":"python基础篇之链表","comments":1,"_content":"链表是python里面一个很重要的数据结构,也是非常常用的一个数据结构.\n<!-- more -->\n\n\n## 链表的表示\n* 初始化\n\n\t```python\n\tcolors = ['red', 'blue', 'green']\n\t```\n* 扩展\n\n\t```python\n\t# 选择链表fruits中包含字符'a'，并全部转换成大写\n\tfruits = ['apple', 'cherry', 'bannana', 'lemon']\n\t# ['APPLE', 'BANNANA']\n\tafruits = [ s.upper() for s in fruits if 'a' in s ]\n\t```\n\n## list常用方法\n* 添加元素\n\n\t```python\n\tlist.append(elem)\n\t```\n* 在i位置添加元素elem\n\n\t```python\n\tlist.insert(i,elem)\n\t```\n* 将list2中的元素添加到list中\n\n\t```python\n\tlist.extend(list2)\n\t```\n* 获取元素elem的索引号\n\n\t```python\n\tlist.index(elem)\n\t```\n* 删除第一个出现的元素elem\n\n\t```python\n\tlist.remove(elem)\n\t```\n* 删除第i个元素\n\n\t```python\n\tlist.pop(i)\n\t```\n* 给list排序\n\n\t```python\n\tlist.sort()\n\t```\n* 颠倒list\n\n\t```python\n\tlist.reverse()\n\t```\n\n## 链表排序\n* sorted基本方法\n\n\t```python\n\ta = [5, 1, 4, 3]\n\tprint sorted(a)   ## [1, 3, 4, 5]\n\tprint sorted(a, reverse=True)  ##[5, 4, 3, 1]\n\tprint a           ## [5, 1, 4, 3]\n\t```\n* sorted按关键字排序\n\t* 以字符串的长度排序\n\n\t\t```python\n\t\tstrs = ['ccc', 'aaaa', 'd', 'bb']\n\t\tprint sorted(strs, key=len)  ## ['d', 'bb', 'ccc', 'aaaa']\n#len代表len()这个函数\n\t\t```\n\t\t其函数处理细节见下图  \n![sorted-key.png]({{ site.baseurl }}/assets/images/sorted_key.png)\n\t* 以自定义关键字函数排序\n\n\t\t```python\n\t\t# 根据字符串最后一个字符来排序\n\t\tstrs = ['xc', 'zb', 'yd' ,'wa']\n\n\t\t# 定义一个函数，输入是一个字符串，返回最后一个字符\n\t\tdef MyFn(s):\n\t\t\t    return s[-1]\n\n\t\t# 传递key=MyFn作为参数\n\t\tprint sorted(strs, key=MyFn)  ## ['wa', 'zb', 'xc', 'yd']\n\t\t```\n\n\n## 课后习题\n* 基础题: [list1.py]({{ site.baseurl }}/assets/attachs/list1.py.txt)\n* 提升题: [list2.py]({{ site.baseurl }}/assets/attachs/list2.py.txt)\n","source":"_posts/2014-12-06-python基础篇之链表.md","raw":"---\nlayout:\tpost\ntitle:\tpython基础篇之链表\ncategories:\n- TECHNOLOGY\ntags:\n- Python\n- Google\npermalink:  Study-list-Python\ncomments:\ttrue\n---\n链表是python里面一个很重要的数据结构,也是非常常用的一个数据结构.\n<!-- more -->\n\n\n## 链表的表示\n* 初始化\n\n\t```python\n\tcolors = ['red', 'blue', 'green']\n\t```\n* 扩展\n\n\t```python\n\t# 选择链表fruits中包含字符'a'，并全部转换成大写\n\tfruits = ['apple', 'cherry', 'bannana', 'lemon']\n\t# ['APPLE', 'BANNANA']\n\tafruits = [ s.upper() for s in fruits if 'a' in s ]\n\t```\n\n## list常用方法\n* 添加元素\n\n\t```python\n\tlist.append(elem)\n\t```\n* 在i位置添加元素elem\n\n\t```python\n\tlist.insert(i,elem)\n\t```\n* 将list2中的元素添加到list中\n\n\t```python\n\tlist.extend(list2)\n\t```\n* 获取元素elem的索引号\n\n\t```python\n\tlist.index(elem)\n\t```\n* 删除第一个出现的元素elem\n\n\t```python\n\tlist.remove(elem)\n\t```\n* 删除第i个元素\n\n\t```python\n\tlist.pop(i)\n\t```\n* 给list排序\n\n\t```python\n\tlist.sort()\n\t```\n* 颠倒list\n\n\t```python\n\tlist.reverse()\n\t```\n\n## 链表排序\n* sorted基本方法\n\n\t```python\n\ta = [5, 1, 4, 3]\n\tprint sorted(a)   ## [1, 3, 4, 5]\n\tprint sorted(a, reverse=True)  ##[5, 4, 3, 1]\n\tprint a           ## [5, 1, 4, 3]\n\t```\n* sorted按关键字排序\n\t* 以字符串的长度排序\n\n\t\t```python\n\t\tstrs = ['ccc', 'aaaa', 'd', 'bb']\n\t\tprint sorted(strs, key=len)  ## ['d', 'bb', 'ccc', 'aaaa']\n#len代表len()这个函数\n\t\t```\n\t\t其函数处理细节见下图  \n![sorted-key.png]({{ site.baseurl }}/assets/images/sorted_key.png)\n\t* 以自定义关键字函数排序\n\n\t\t```python\n\t\t# 根据字符串最后一个字符来排序\n\t\tstrs = ['xc', 'zb', 'yd' ,'wa']\n\n\t\t# 定义一个函数，输入是一个字符串，返回最后一个字符\n\t\tdef MyFn(s):\n\t\t\t    return s[-1]\n\n\t\t# 传递key=MyFn作为参数\n\t\tprint sorted(strs, key=MyFn)  ## ['wa', 'zb', 'xc', 'yd']\n\t\t```\n\n\n## 课后习题\n* 基础题: [list1.py]({{ site.baseurl }}/assets/attachs/list1.py.txt)\n* 提升题: [list2.py]({{ site.baseurl }}/assets/attachs/list2.py.txt)\n","slug":"Study-list-Python","published":1,"date":"2014-12-05T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j13000sl73yjhgal45b","content":"<p>链表是python里面一个很重要的数据结构,也是非常常用的一个数据结构. <a id=\"more\"></a></p>\n<h2 id=\"链表的表示\">链表的表示</h2>\n<ul>\n<li><p>初始化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>]</div></pre></td></tr></table></figure></li>\n<li><p>扩展</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 选择链表fruits中包含字符'a'，并全部转换成大写</span></div><div class=\"line\">fruits = [<span class=\"string\">'apple'</span>, <span class=\"string\">'cherry'</span>, <span class=\"string\">'bannana'</span>, <span class=\"string\">'lemon'</span>]</div><div class=\"line\"><span class=\"comment\"># ['APPLE', 'BANNANA']</span></div><div class=\"line\">afruits = [ s.upper() <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> fruits <span class=\"keyword\">if</span> <span class=\"string\">'a'</span> <span class=\"keyword\">in</span> s ]</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"list常用方法\">list常用方法</h2>\n<ul>\n<li><p>添加元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.append(elem)</div></pre></td></tr></table></figure></li>\n<li><p>在i位置添加元素elem</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.insert(i,elem)</div></pre></td></tr></table></figure></li>\n<li><p>将list2中的元素添加到list中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.extend(list2)</div></pre></td></tr></table></figure></li>\n<li><p>获取元素elem的索引号</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.index(elem)</div></pre></td></tr></table></figure></li>\n<li><p>删除第一个出现的元素elem</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.remove(elem)</div></pre></td></tr></table></figure></li>\n<li><p>删除第i个元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.pop(i)</div></pre></td></tr></table></figure></li>\n<li><p>给list排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.sort()</div></pre></td></tr></table></figure></li>\n<li><p>颠倒list</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.reverse()</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"链表排序\">链表排序</h2>\n<ul>\n<li><p>sorted基本方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">a = [<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"keyword\">print</span> sorted(a)   <span class=\"comment\">## [1, 3, 4, 5]</span></div><div class=\"line\"><span class=\"keyword\">print</span> sorted(a, reverse=<span class=\"keyword\">True</span>)  <span class=\"comment\">##[5, 4, 3, 1]</span></div><div class=\"line\"><span class=\"keyword\">print</span> a           <span class=\"comment\">## [5, 1, 4, 3]</span></div></pre></td></tr></table></figure></li>\n<li>sorted按关键字排序\n<ul>\n<li><p>以字符串的长度排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t\tstrs = [<span class=\"string\">'ccc'</span>, <span class=\"string\">'aaaa'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'bb'</span>]</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> sorted(strs, key=len)  <span class=\"comment\">## ['d', 'bb', 'ccc', 'aaaa']</span></div><div class=\"line\"><span class=\"comment\">#len代表len()这个函数</span></div></pre></td></tr></table></figure>\n其函数处理细节见下图<br>\n[sorted-key.png](/assets/images/sorted_key.png)</li>\n<li><p>以自定义关键字函数排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 根据字符串最后一个字符来排序</span></div><div class=\"line\">strs = [<span class=\"string\">'xc'</span>, <span class=\"string\">'zb'</span>, <span class=\"string\">'yd'</span> ,<span class=\"string\">'wa'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 定义一个函数，输入是一个字符串，返回最后一个字符</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MyFn</span><span class=\"params\">(s)</span>:</span></div><div class=\"line\">\t    <span class=\"keyword\">return</span> s[<span class=\"number\">-1</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 传递key=MyFn作为参数</span></div><div class=\"line\"><span class=\"keyword\">print</span> sorted(strs, key=MyFn)  <span class=\"comment\">## ['wa', 'zb', 'xc', 'yd']</span></div></pre></td></tr></table></figure></li>\n</ul></li>\n</ul>\n<h2 id=\"课后习题\">课后习题</h2>\n<ul>\n<li>基础题: [list1.py](/assets/attachs/list1.py.txt)</li>\n<li>提升题: [list2.py](/assets/attachs/list2.py.txt)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>链表是python里面一个很重要的数据结构,也是非常常用的一个数据结构.","more":"</p>\n<h2 id=\"链表的表示\">链表的表示</h2>\n<ul>\n<li><p>初始化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>]</div></pre></td></tr></table></figure></li>\n<li><p>扩展</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 选择链表fruits中包含字符'a'，并全部转换成大写</span></div><div class=\"line\">fruits = [<span class=\"string\">'apple'</span>, <span class=\"string\">'cherry'</span>, <span class=\"string\">'bannana'</span>, <span class=\"string\">'lemon'</span>]</div><div class=\"line\"><span class=\"comment\"># ['APPLE', 'BANNANA']</span></div><div class=\"line\">afruits = [ s.upper() <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> fruits <span class=\"keyword\">if</span> <span class=\"string\">'a'</span> <span class=\"keyword\">in</span> s ]</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"list常用方法\">list常用方法</h2>\n<ul>\n<li><p>添加元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.append(elem)</div></pre></td></tr></table></figure></li>\n<li><p>在i位置添加元素elem</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.insert(i,elem)</div></pre></td></tr></table></figure></li>\n<li><p>将list2中的元素添加到list中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.extend(list2)</div></pre></td></tr></table></figure></li>\n<li><p>获取元素elem的索引号</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.index(elem)</div></pre></td></tr></table></figure></li>\n<li><p>删除第一个出现的元素elem</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.remove(elem)</div></pre></td></tr></table></figure></li>\n<li><p>删除第i个元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.pop(i)</div></pre></td></tr></table></figure></li>\n<li><p>给list排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.sort()</div></pre></td></tr></table></figure></li>\n<li><p>颠倒list</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">list.reverse()</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"链表排序\">链表排序</h2>\n<ul>\n<li><p>sorted基本方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">a = [<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"keyword\">print</span> sorted(a)   <span class=\"comment\">## [1, 3, 4, 5]</span></div><div class=\"line\"><span class=\"keyword\">print</span> sorted(a, reverse=<span class=\"keyword\">True</span>)  <span class=\"comment\">##[5, 4, 3, 1]</span></div><div class=\"line\"><span class=\"keyword\">print</span> a           <span class=\"comment\">## [5, 1, 4, 3]</span></div></pre></td></tr></table></figure></li>\n<li>sorted按关键字排序\n<ul>\n<li><p>以字符串的长度排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t\tstrs = [<span class=\"string\">'ccc'</span>, <span class=\"string\">'aaaa'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'bb'</span>]</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> sorted(strs, key=len)  <span class=\"comment\">## ['d', 'bb', 'ccc', 'aaaa']</span></div><div class=\"line\"><span class=\"comment\">#len代表len()这个函数</span></div></pre></td></tr></table></figure>\n其函数处理细节见下图<br>\n[sorted-key.png](/assets/images/sorted_key.png)</li>\n<li><p>以自定义关键字函数排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 根据字符串最后一个字符来排序</span></div><div class=\"line\">strs = [<span class=\"string\">'xc'</span>, <span class=\"string\">'zb'</span>, <span class=\"string\">'yd'</span> ,<span class=\"string\">'wa'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 定义一个函数，输入是一个字符串，返回最后一个字符</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MyFn</span><span class=\"params\">(s)</span>:</span></div><div class=\"line\">\t    <span class=\"keyword\">return</span> s[<span class=\"number\">-1</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 传递key=MyFn作为参数</span></div><div class=\"line\"><span class=\"keyword\">print</span> sorted(strs, key=MyFn)  <span class=\"comment\">## ['wa', 'zb', 'xc', 'yd']</span></div></pre></td></tr></table></figure></li>\n</ul></li>\n</ul>\n<h2 id=\"课后习题\">课后习题</h2>\n<ul>\n<li>基础题: [list1.py](/assets/attachs/list1.py.txt)</li>\n<li>提升题: [list2.py](/assets/attachs/list2.py.txt)</li>\n</ul>"},{"layout":"post","title":"python基础篇之文件操作","comments":1,"_content":"python处理文件也是有一手的,所以熟练掌握文件操作对日后的任务操作非常有利.\n<!-- more -->\n\n\n## 打开/关闭文件\n* 代码演示\n\n\t```python\n\t# 显示文本\n\tf = open('foo.txt', 'rU')     ## r/w/a同c里面的意义，U代表通用，最终的结尾符转换成'\\n'\n\tfor line in f:     # 遍历文件的每一行\n\t    print line,    # 紧跟 ,这样print就不会输出换行符，因为line里面就有换行符\n\tf.close()\n\t```\n\n## 读写文本\n* 读文本到内存,返回一个list\n\n\t```python\n\tf.readlines()\n\t```\n* 读文本到字符串,返回字符串(配合正则表达式)\n\n\t```python\n\tf.read()\n\t```\n* 写数据到输出文件\n\n\t```python\n\tf.write(string)\n\tprint >>f ,string\n\tprint(string, file=f)\n\t```\n\n## unicode文本操作\n* codecs模块支持\n\n\t```python\n\timport codecs\n\n\tf = codecs.open('foo.txt', 'rU', 'utf-8')\n\tfor line in f:\n\t  # here line is a *unicode* string\n\n\t# 用f.write()写文件，print不完全支持unicode\n\t```\n\n## 课后习题\n* 练习题: [wordcount.py]({{ site.baseurl }}/assets/attachs/wordcount.py.txt)\n","source":"_posts/2014-12-09-python基础篇之文件操作.md","raw":"---\nlayout:\tpost\ntitle:\tpython基础篇之文件操作\ncategories:\n- TECHNOLOGY\ntags:\n- Python\n- Google\npermalink:  Study-file-Python\ncomments:\ttrue\n---\npython处理文件也是有一手的,所以熟练掌握文件操作对日后的任务操作非常有利.\n<!-- more -->\n\n\n## 打开/关闭文件\n* 代码演示\n\n\t```python\n\t# 显示文本\n\tf = open('foo.txt', 'rU')     ## r/w/a同c里面的意义，U代表通用，最终的结尾符转换成'\\n'\n\tfor line in f:     # 遍历文件的每一行\n\t    print line,    # 紧跟 ,这样print就不会输出换行符，因为line里面就有换行符\n\tf.close()\n\t```\n\n## 读写文本\n* 读文本到内存,返回一个list\n\n\t```python\n\tf.readlines()\n\t```\n* 读文本到字符串,返回字符串(配合正则表达式)\n\n\t```python\n\tf.read()\n\t```\n* 写数据到输出文件\n\n\t```python\n\tf.write(string)\n\tprint >>f ,string\n\tprint(string, file=f)\n\t```\n\n## unicode文本操作\n* codecs模块支持\n\n\t```python\n\timport codecs\n\n\tf = codecs.open('foo.txt', 'rU', 'utf-8')\n\tfor line in f:\n\t  # here line is a *unicode* string\n\n\t# 用f.write()写文件，print不完全支持unicode\n\t```\n\n## 课后习题\n* 练习题: [wordcount.py]({{ site.baseurl }}/assets/attachs/wordcount.py.txt)\n","slug":"Study-file-Python","published":1,"date":"2014-12-08T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j13000tl73y3kqfthco","content":"<p>python处理文件也是有一手的,所以熟练掌握文件操作对日后的任务操作非常有利. <a id=\"more\"></a></p>\n<h2 id=\"打开关闭文件\">打开/关闭文件</h2>\n<ul>\n<li><p>代码演示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 显示文本</span></div><div class=\"line\">f = open(<span class=\"string\">'foo.txt'</span>, <span class=\"string\">'rU'</span>)     <span class=\"comment\">## r/w/a同c里面的意义，U代表通用，最终的结尾符转换成'\\n'</span></div><div class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f:     <span class=\"comment\"># 遍历文件的每一行</span></div><div class=\"line\">    <span class=\"keyword\">print</span> line,    <span class=\"comment\"># 紧跟 ,这样print就不会输出换行符，因为line里面就有换行符</span></div><div class=\"line\">f.close()</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"读写文本\">读写文本</h2>\n<ul>\n<li><p>读文本到内存,返回一个list</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f.readlines()</div></pre></td></tr></table></figure></li>\n<li><p>读文本到字符串,返回字符串(配合正则表达式)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f.read()</div></pre></td></tr></table></figure></li>\n<li><p>写数据到输出文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">f.write(string)</div><div class=\"line\"><span class=\"keyword\">print</span> &gt;&gt;f ,string</div><div class=\"line\">print(string, file=f)</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"unicode文本操作\">unicode文本操作</h2>\n<ul>\n<li><p>codecs模块支持</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> codecs</div><div class=\"line\"></div><div class=\"line\">f = codecs.open(<span class=\"string\">'foo.txt'</span>, <span class=\"string\">'rU'</span>, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f:</div><div class=\"line\">  <span class=\"comment\"># here line is a *unicode* string</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 用f.write()写文件，print不完全支持unicode</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"课后习题\">课后习题</h2>\n<ul>\n<li>练习题: [wordcount.py](/assets/attachs/wordcount.py.txt)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>python处理文件也是有一手的,所以熟练掌握文件操作对日后的任务操作非常有利.","more":"</p>\n<h2 id=\"打开关闭文件\">打开/关闭文件</h2>\n<ul>\n<li><p>代码演示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 显示文本</span></div><div class=\"line\">f = open(<span class=\"string\">'foo.txt'</span>, <span class=\"string\">'rU'</span>)     <span class=\"comment\">## r/w/a同c里面的意义，U代表通用，最终的结尾符转换成'\\n'</span></div><div class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f:     <span class=\"comment\"># 遍历文件的每一行</span></div><div class=\"line\">    <span class=\"keyword\">print</span> line,    <span class=\"comment\"># 紧跟 ,这样print就不会输出换行符，因为line里面就有换行符</span></div><div class=\"line\">f.close()</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"读写文本\">读写文本</h2>\n<ul>\n<li><p>读文本到内存,返回一个list</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f.readlines()</div></pre></td></tr></table></figure></li>\n<li><p>读文本到字符串,返回字符串(配合正则表达式)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f.read()</div></pre></td></tr></table></figure></li>\n<li><p>写数据到输出文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">f.write(string)</div><div class=\"line\"><span class=\"keyword\">print</span> &gt;&gt;f ,string</div><div class=\"line\">print(string, file=f)</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"unicode文本操作\">unicode文本操作</h2>\n<ul>\n<li><p>codecs模块支持</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> codecs</div><div class=\"line\"></div><div class=\"line\">f = codecs.open(<span class=\"string\">'foo.txt'</span>, <span class=\"string\">'rU'</span>, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f:</div><div class=\"line\">  <span class=\"comment\"># here line is a *unicode* string</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 用f.write()写文件，print不完全支持unicode</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"课后习题\">课后习题</h2>\n<ul>\n<li>练习题: [wordcount.py](/assets/attachs/wordcount.py.txt)</li>\n</ul>"},{"layout":"post","title":"ubuntukylin(64bit)安装推荐","comments":1,"_content":"在网上经常会看到[安装ubuntu后必做的n件事](http://www.linuxidc.com/Linux/2014-04/100411.htm),不过这些事情都是大众通用的,并不是完全适合自己的.所以本文就是对自己使用ubuntukylin这些年来的记录总结.\n<!-- more -->\n\n\n## ubuntukylin简介\nUbuntuKylin是Ubuntu社区中面向中文用户的Ubuntu衍生版本，与麒麟系统没有关系。它是由工信部软件、集成电路促进中心（CSIP）、国防科技大学（NUDT）与国际著名开源社区UBUNTU的支持公司CANONICAL发起的一款开源社区操作系统项目。\n\n发行版本从13.04开始，其有以下特性  \n\n* Dash中的在线音乐搜索: 更加简单、方便的音乐搜索，帮助用户发现最新、最热的中国流行音乐\n* 农历（中国传统历法）： 便于查询传统假日和节气时令的中文日历，包含公历\n天气插件：提供来自中国气象局的天气预报信息，为用户日常起居和旅行提供参考\n* 中文输入法：默认使用fctix输入法，支持云拼音输入，更加智能的联想功能\n* 与WPS合作：提供中国本土办公软件WPS，兼容多种文档格式，具有强大的图形布局功能和丰富的网络资源，文档工作将更加专业和轻松   \n\n\n## 事后三件事\n\n1. 联网  \n\t后面所有的操作都依赖于网络。\n2. 更新语言包以及软件更新器  \n\t安装时建议用英语,一方面安装过程更快一些,另一方面保持通用文件夹为英文名(命令行操作更方便快捷).此时更新时需要安装中文语言包，大概有400M左右的应用需要升级到最新。\n3. 安装日常所用软件  \n\t常用软件可以直接在软件中心中查找安装,不过建议是用shell脚本[ubuntukylin_install.sh]({{ site.baseurl }}/assets/attachs/ubuntukylin_install.sh.txt)安装.\n\n\t1. 浏览器 -- chrome\n\n\t\t```bash\n\t\t# 安装chrome浏览器\n\t\tsudo apt-get install chromium-browser\n\t\t# 安装在线视频播放插件\n\t\tsudo apt-get install pepperflashplugin-nonfree\n\t\t```\n\n\t\t> **注意:**   \n\t\t> 安装完成后,需要登陆google帐号,可以同步书签并扩展应用\n\t2. 安装gcc编译环境\n\n\t\t```bash\n\t\tsudo apt-get install build-essential\n\t\t```\n\t3. 安装osdlyrics,以方便rhythmbox显示歌词\n\n\t\t```bash\n\t\tsudo apt-get install osdlyrics\n\t\t```\n\n\t\t> **注意:**  \n\t\t> 安装完成,需要启动osdlyrics并设置其自动启动的播放器\n\t4. 安装starDict字典\n\n\t\t```bash\n\t\tsudo apt-get install stardict\n\t\t```\n\n\t\t> **安装软件所需要的字典和发音包**  \n\t\t>\n\t\t> 1. [下载](http://share.weiyun.com/39678cb7bef4a4ad0be537f10578be2d)字典和发音包\n\t\t> 2. 命令安装\n\t\t>\n\t\t>\t```bash\n\t\t>\tcd stardict\n\t\t>\tchmod 755 installDicts.sh installPron.sh\n\t\t>\tsudo ./installDicts.sh\n\t\t>\tsudo ./installPron.sh\n\t\t>\t```\n\t5. 安装压缩工具p7zip\n\n\t\t```bash\n\t\tsudo apt-get install p7zip-full\n\t\t```\n\t6. 安装文本编辑器geany\n\n\t\t```bash\n\t\tsudo apt-get install geany\n\t\t```\n\t7. 安装视频播放器VLC\n\n\t\t```bash\n\t\tsudo apt-get install vlc\n\t\t```\n\t8. 安装位图图像处理软件gimp\n\n\t\t```bash\n\t\tsudo apt-get install gimp\n\t\t```\n\t9. 安装专业画图软件dia\n\n\t\t```bash\n\t\tsudo apt-get install dia\n\t\tsudo apt-get install dia-gnome\n\t\t```\n\t10. 安装tex软件\n\n\t\t```bash\n\t\tsudo apt-get install texlive-full\n\t\tsudo apt-get install texlive-fonts-recommended\n\t\tsudo apt-get install texmaker\n\t\t```\n\n\t\t> **安装win下的字体**  \n\t\t>\n\t\t> 1. [下载](http://share.weiyun.com/b298e1e21a18cf7278b4d8005aecfe7d)win字体和安装脚本\n\t\t> 2. 命令安装\n\t\t>\n\t\t>\t```bash\n\t\t>\tcd addWinFonts\n\t\t>\tchmod 755 addWinFonts.sh\n\t\t>\tsudo ./addWinFonts.sh\n\t\t>\t```\n\t11. 安装java集成环境Eclipse\n\n\t\t```bash\n\t\tsudo apt-get install eclipse\n\t\tsudo apt-get install eclipse-jdt\n\t\tsudo apt-get install eclipse-pde\n\t\t```\n\t12. 安装python集成环境idle\n\n\t\t```bash\n\t\tsudo apt-get install idle-python2.7\n\t\t```\n\t13. 安装longene QQ\n\t\t* [下载](http://share.weiyun.com/c5367cd7a608d8737770356a70a7f393)deb包\n\t\t* 命令安装\n\n\t\t\t```bash\n\t\t\tsudo dpkg -i wine-qqintl_0.1.3-2_i386.deb\n\t\t\tsudo apt-get -f install\n\t\t\t```\n\t14. 安装pdf2htmlEx\n\n\t\t```bash\n\t\tsudo add-apt-repository ppa:coolwanglu/pdf2htmlex\n\t\tsudo apt-get update\n\t\tsudo apt-get install pdf2htmlEX\n\t\t```\n\n## 待续\n","source":"_posts/2014-12-30-ubuntukylin安装推荐.md","raw":"---\nlayout:\tpost\ntitle:\tubuntukylin(64bit)安装推荐\ncategories:\n- TECHNOLOGY\ntags:\n- Ubuntu\n- Software\npermalink:  Explore-software-ubuntu\ncomments:\ttrue\n---\n在网上经常会看到[安装ubuntu后必做的n件事](http://www.linuxidc.com/Linux/2014-04/100411.htm),不过这些事情都是大众通用的,并不是完全适合自己的.所以本文就是对自己使用ubuntukylin这些年来的记录总结.\n<!-- more -->\n\n\n## ubuntukylin简介\nUbuntuKylin是Ubuntu社区中面向中文用户的Ubuntu衍生版本，与麒麟系统没有关系。它是由工信部软件、集成电路促进中心（CSIP）、国防科技大学（NUDT）与国际著名开源社区UBUNTU的支持公司CANONICAL发起的一款开源社区操作系统项目。\n\n发行版本从13.04开始，其有以下特性  \n\n* Dash中的在线音乐搜索: 更加简单、方便的音乐搜索，帮助用户发现最新、最热的中国流行音乐\n* 农历（中国传统历法）： 便于查询传统假日和节气时令的中文日历，包含公历\n天气插件：提供来自中国气象局的天气预报信息，为用户日常起居和旅行提供参考\n* 中文输入法：默认使用fctix输入法，支持云拼音输入，更加智能的联想功能\n* 与WPS合作：提供中国本土办公软件WPS，兼容多种文档格式，具有强大的图形布局功能和丰富的网络资源，文档工作将更加专业和轻松   \n\n\n## 事后三件事\n\n1. 联网  \n\t后面所有的操作都依赖于网络。\n2. 更新语言包以及软件更新器  \n\t安装时建议用英语,一方面安装过程更快一些,另一方面保持通用文件夹为英文名(命令行操作更方便快捷).此时更新时需要安装中文语言包，大概有400M左右的应用需要升级到最新。\n3. 安装日常所用软件  \n\t常用软件可以直接在软件中心中查找安装,不过建议是用shell脚本[ubuntukylin_install.sh]({{ site.baseurl }}/assets/attachs/ubuntukylin_install.sh.txt)安装.\n\n\t1. 浏览器 -- chrome\n\n\t\t```bash\n\t\t# 安装chrome浏览器\n\t\tsudo apt-get install chromium-browser\n\t\t# 安装在线视频播放插件\n\t\tsudo apt-get install pepperflashplugin-nonfree\n\t\t```\n\n\t\t> **注意:**   \n\t\t> 安装完成后,需要登陆google帐号,可以同步书签并扩展应用\n\t2. 安装gcc编译环境\n\n\t\t```bash\n\t\tsudo apt-get install build-essential\n\t\t```\n\t3. 安装osdlyrics,以方便rhythmbox显示歌词\n\n\t\t```bash\n\t\tsudo apt-get install osdlyrics\n\t\t```\n\n\t\t> **注意:**  \n\t\t> 安装完成,需要启动osdlyrics并设置其自动启动的播放器\n\t4. 安装starDict字典\n\n\t\t```bash\n\t\tsudo apt-get install stardict\n\t\t```\n\n\t\t> **安装软件所需要的字典和发音包**  \n\t\t>\n\t\t> 1. [下载](http://share.weiyun.com/39678cb7bef4a4ad0be537f10578be2d)字典和发音包\n\t\t> 2. 命令安装\n\t\t>\n\t\t>\t```bash\n\t\t>\tcd stardict\n\t\t>\tchmod 755 installDicts.sh installPron.sh\n\t\t>\tsudo ./installDicts.sh\n\t\t>\tsudo ./installPron.sh\n\t\t>\t```\n\t5. 安装压缩工具p7zip\n\n\t\t```bash\n\t\tsudo apt-get install p7zip-full\n\t\t```\n\t6. 安装文本编辑器geany\n\n\t\t```bash\n\t\tsudo apt-get install geany\n\t\t```\n\t7. 安装视频播放器VLC\n\n\t\t```bash\n\t\tsudo apt-get install vlc\n\t\t```\n\t8. 安装位图图像处理软件gimp\n\n\t\t```bash\n\t\tsudo apt-get install gimp\n\t\t```\n\t9. 安装专业画图软件dia\n\n\t\t```bash\n\t\tsudo apt-get install dia\n\t\tsudo apt-get install dia-gnome\n\t\t```\n\t10. 安装tex软件\n\n\t\t```bash\n\t\tsudo apt-get install texlive-full\n\t\tsudo apt-get install texlive-fonts-recommended\n\t\tsudo apt-get install texmaker\n\t\t```\n\n\t\t> **安装win下的字体**  \n\t\t>\n\t\t> 1. [下载](http://share.weiyun.com/b298e1e21a18cf7278b4d8005aecfe7d)win字体和安装脚本\n\t\t> 2. 命令安装\n\t\t>\n\t\t>\t```bash\n\t\t>\tcd addWinFonts\n\t\t>\tchmod 755 addWinFonts.sh\n\t\t>\tsudo ./addWinFonts.sh\n\t\t>\t```\n\t11. 安装java集成环境Eclipse\n\n\t\t```bash\n\t\tsudo apt-get install eclipse\n\t\tsudo apt-get install eclipse-jdt\n\t\tsudo apt-get install eclipse-pde\n\t\t```\n\t12. 安装python集成环境idle\n\n\t\t```bash\n\t\tsudo apt-get install idle-python2.7\n\t\t```\n\t13. 安装longene QQ\n\t\t* [下载](http://share.weiyun.com/c5367cd7a608d8737770356a70a7f393)deb包\n\t\t* 命令安装\n\n\t\t\t```bash\n\t\t\tsudo dpkg -i wine-qqintl_0.1.3-2_i386.deb\n\t\t\tsudo apt-get -f install\n\t\t\t```\n\t14. 安装pdf2htmlEx\n\n\t\t```bash\n\t\tsudo add-apt-repository ppa:coolwanglu/pdf2htmlex\n\t\tsudo apt-get update\n\t\tsudo apt-get install pdf2htmlEX\n\t\t```\n\n## 待续\n","slug":"Explore-software-ubuntu","published":1,"date":"2014-12-29T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j14000ul73yapbp9l6o","content":"<p>在网上经常会看到<a href=\"http://www.linuxidc.com/Linux/2014-04/100411.htm\" target=\"_blank\" rel=\"external\">安装ubuntu后必做的n件事</a>,不过这些事情都是大众通用的,并不是完全适合自己的.所以本文就是对自己使用ubuntukylin这些年来的记录总结. <a id=\"more\"></a></p>\n<h2 id=\"ubuntukylin简介\">ubuntukylin简介</h2>\n<p>UbuntuKylin是Ubuntu社区中面向中文用户的Ubuntu衍生版本，与麒麟系统没有关系。它是由工信部软件、集成电路促进中心（CSIP）、国防科技大学（NUDT）与国际著名开源社区UBUNTU的支持公司CANONICAL发起的一款开源社区操作系统项目。</p>\n<p>发行版本从13.04开始，其有以下特性</p>\n<ul>\n<li>Dash中的在线音乐搜索: 更加简单、方便的音乐搜索，帮助用户发现最新、最热的中国流行音乐</li>\n<li>农历（中国传统历法）： 便于查询传统假日和节气时令的中文日历，包含公历 天气插件：提供来自中国气象局的天气预报信息，为用户日常起居和旅行提供参考</li>\n<li>中文输入法：默认使用fctix输入法，支持云拼音输入，更加智能的联想功能</li>\n<li>与WPS合作：提供中国本土办公软件WPS，兼容多种文档格式，具有强大的图形布局功能和丰富的网络资源，文档工作将更加专业和轻松</li>\n</ul>\n<h2 id=\"事后三件事\">事后三件事</h2>\n<ol style=\"list-style-type: decimal\">\n<li>联网<br>\n后面所有的操作都依赖于网络。</li>\n<li>更新语言包以及软件更新器<br>\n安装时建议用英语,一方面安装过程更快一些,另一方面保持通用文件夹为英文名(命令行操作更方便快捷).此时更新时需要安装中文语言包，大概有400M左右的应用需要升级到最新。</li>\n<li><p>安装日常所用软件<br>\n常用软件可以直接在软件中心中查找安装,不过建议是用shell脚本[ubuntukylin_install.sh](/assets/attachs/ubuntukylin_install.sh.txt)安装.</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>浏览器 – chrome</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装chrome浏览器</span></div><div class=\"line\">sudo apt-get install chromium-browser</div><div class=\"line\"><span class=\"comment\"># 安装在线视频播放插件</span></div><div class=\"line\">sudo apt-get install pepperflashplugin-nonfree</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意:</strong><br>\n安装完成后,需要登陆google帐号,可以同步书签并扩展应用</p>\n</blockquote></li>\n<li><p>安装gcc编译环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install build-essential</div></pre></td></tr></table></figure></li>\n<li><p>安装osdlyrics,以方便rhythmbox显示歌词</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install osdlyrics</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意:</strong><br>\n安装完成,需要启动osdlyrics并设置其自动启动的播放器</p>\n</blockquote></li>\n<li><p>安装starDict字典</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install stardict</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>安装软件所需要的字典和发音包</strong></p>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://share.weiyun.com/39678cb7bef4a4ad0be537f10578be2d\" target=\"_blank\" rel=\"external\">下载</a>字典和发音包</li>\n<li>命令安装</li>\n</ol>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;\t<span class=\"built_in\">cd</span> stardict</div><div class=\"line\">&gt;\tchmod 755 installDicts.sh installPron.sh</div><div class=\"line\">&gt;\tsudo ./installDicts.sh</div><div class=\"line\">&gt;\tsudo ./installPron.sh</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n</blockquote></li>\n<li><p>安装压缩工具p7zip</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install p7zip-full</div></pre></td></tr></table></figure></li>\n<li><p>安装文本编辑器geany</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install geany</div></pre></td></tr></table></figure></li>\n<li><p>安装视频播放器VLC</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install vlc</div></pre></td></tr></table></figure></li>\n<li><p>安装位图图像处理软件gimp</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install gimp</div></pre></td></tr></table></figure></li>\n<li><p>安装专业画图软件dia</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install dia</div><div class=\"line\">sudo apt-get install dia-gnome</div></pre></td></tr></table></figure></li>\n<li><p>安装tex软件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install texlive-full</div><div class=\"line\">sudo apt-get install texlive-fonts-recommended</div><div class=\"line\">sudo apt-get install texmaker</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>安装win下的字体</strong></p>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://share.weiyun.com/b298e1e21a18cf7278b4d8005aecfe7d\" target=\"_blank\" rel=\"external\">下载</a>win字体和安装脚本</li>\n<li>命令安装</li>\n</ol>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;\t<span class=\"built_in\">cd</span> addW<span class=\"keyword\">in</span>Fonts</div><div class=\"line\">&gt;\tchmod 755 addW<span class=\"keyword\">in</span>Fonts.sh</div><div class=\"line\">&gt;\tsudo ./addW<span class=\"keyword\">in</span>Fonts.sh</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n</blockquote></li>\n<li><p>安装java集成环境Eclipse</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install eclipse</div><div class=\"line\">sudo apt-get install eclipse-jdt</div><div class=\"line\">sudo apt-get install eclipse-pde</div></pre></td></tr></table></figure></li>\n<li><p>安装python集成环境idle</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install idle-python2.7</div></pre></td></tr></table></figure></li>\n<li>安装longene QQ\n<ul>\n<li><a href=\"http://share.weiyun.com/c5367cd7a608d8737770356a70a7f393\" target=\"_blank\" rel=\"external\">下载</a>deb包</li>\n<li><p>命令安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo dpkg -i wine-qqintl_0.1.3-2_i386.deb</div><div class=\"line\">sudo apt-get <span class=\"_\">-f</span> install</div></pre></td></tr></table></figure></li>\n</ul></li>\n<li><p>安装pdf2htmlEx</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo add-apt-repository ppa:coolwanglu/pdf2htmlex</div><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install pdf2htmlEX</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ol>\n<h2 id=\"待续\">待续</h2>\n","site":{"data":{}},"excerpt":"<p>在网上经常会看到<a href=\"http://www.linuxidc.com/Linux/2014-04/100411.htm\" target=\"_blank\" rel=\"external\">安装ubuntu后必做的n件事</a>,不过这些事情都是大众通用的,并不是完全适合自己的.所以本文就是对自己使用ubuntukylin这些年来的记录总结.","more":"</p>\n<h2 id=\"ubuntukylin简介\">ubuntukylin简介</h2>\n<p>UbuntuKylin是Ubuntu社区中面向中文用户的Ubuntu衍生版本，与麒麟系统没有关系。它是由工信部软件、集成电路促进中心（CSIP）、国防科技大学（NUDT）与国际著名开源社区UBUNTU的支持公司CANONICAL发起的一款开源社区操作系统项目。</p>\n<p>发行版本从13.04开始，其有以下特性</p>\n<ul>\n<li>Dash中的在线音乐搜索: 更加简单、方便的音乐搜索，帮助用户发现最新、最热的中国流行音乐</li>\n<li>农历（中国传统历法）： 便于查询传统假日和节气时令的中文日历，包含公历 天气插件：提供来自中国气象局的天气预报信息，为用户日常起居和旅行提供参考</li>\n<li>中文输入法：默认使用fctix输入法，支持云拼音输入，更加智能的联想功能</li>\n<li>与WPS合作：提供中国本土办公软件WPS，兼容多种文档格式，具有强大的图形布局功能和丰富的网络资源，文档工作将更加专业和轻松</li>\n</ul>\n<h2 id=\"事后三件事\">事后三件事</h2>\n<ol style=\"list-style-type: decimal\">\n<li>联网<br>\n后面所有的操作都依赖于网络。</li>\n<li>更新语言包以及软件更新器<br>\n安装时建议用英语,一方面安装过程更快一些,另一方面保持通用文件夹为英文名(命令行操作更方便快捷).此时更新时需要安装中文语言包，大概有400M左右的应用需要升级到最新。</li>\n<li><p>安装日常所用软件<br>\n常用软件可以直接在软件中心中查找安装,不过建议是用shell脚本[ubuntukylin_install.sh](/assets/attachs/ubuntukylin_install.sh.txt)安装.</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>浏览器 – chrome</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装chrome浏览器</span></div><div class=\"line\">sudo apt-get install chromium-browser</div><div class=\"line\"><span class=\"comment\"># 安装在线视频播放插件</span></div><div class=\"line\">sudo apt-get install pepperflashplugin-nonfree</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意:</strong><br>\n安装完成后,需要登陆google帐号,可以同步书签并扩展应用</p>\n</blockquote></li>\n<li><p>安装gcc编译环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install build-essential</div></pre></td></tr></table></figure></li>\n<li><p>安装osdlyrics,以方便rhythmbox显示歌词</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install osdlyrics</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意:</strong><br>\n安装完成,需要启动osdlyrics并设置其自动启动的播放器</p>\n</blockquote></li>\n<li><p>安装starDict字典</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install stardict</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>安装软件所需要的字典和发音包</strong></p>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://share.weiyun.com/39678cb7bef4a4ad0be537f10578be2d\" target=\"_blank\" rel=\"external\">下载</a>字典和发音包</li>\n<li>命令安装</li>\n</ol>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;\t<span class=\"built_in\">cd</span> stardict</div><div class=\"line\">&gt;\tchmod 755 installDicts.sh installPron.sh</div><div class=\"line\">&gt;\tsudo ./installDicts.sh</div><div class=\"line\">&gt;\tsudo ./installPron.sh</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n</blockquote></li>\n<li><p>安装压缩工具p7zip</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install p7zip-full</div></pre></td></tr></table></figure></li>\n<li><p>安装文本编辑器geany</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install geany</div></pre></td></tr></table></figure></li>\n<li><p>安装视频播放器VLC</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install vlc</div></pre></td></tr></table></figure></li>\n<li><p>安装位图图像处理软件gimp</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install gimp</div></pre></td></tr></table></figure></li>\n<li><p>安装专业画图软件dia</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install dia</div><div class=\"line\">sudo apt-get install dia-gnome</div></pre></td></tr></table></figure></li>\n<li><p>安装tex软件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install texlive-full</div><div class=\"line\">sudo apt-get install texlive-fonts-recommended</div><div class=\"line\">sudo apt-get install texmaker</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>安装win下的字体</strong></p>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://share.weiyun.com/b298e1e21a18cf7278b4d8005aecfe7d\" target=\"_blank\" rel=\"external\">下载</a>win字体和安装脚本</li>\n<li>命令安装</li>\n</ol>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;\t<span class=\"built_in\">cd</span> addW<span class=\"keyword\">in</span>Fonts</div><div class=\"line\">&gt;\tchmod 755 addW<span class=\"keyword\">in</span>Fonts.sh</div><div class=\"line\">&gt;\tsudo ./addW<span class=\"keyword\">in</span>Fonts.sh</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n</blockquote></li>\n<li><p>安装java集成环境Eclipse</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install eclipse</div><div class=\"line\">sudo apt-get install eclipse-jdt</div><div class=\"line\">sudo apt-get install eclipse-pde</div></pre></td></tr></table></figure></li>\n<li><p>安装python集成环境idle</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install idle-python2.7</div></pre></td></tr></table></figure></li>\n<li>安装longene QQ\n<ul>\n<li><a href=\"http://share.weiyun.com/c5367cd7a608d8737770356a70a7f393\" target=\"_blank\" rel=\"external\">下载</a>deb包</li>\n<li><p>命令安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo dpkg -i wine-qqintl_0.1.3-2_i386.deb</div><div class=\"line\">sudo apt-get <span class=\"_\">-f</span> install</div></pre></td></tr></table></figure></li>\n</ul></li>\n<li><p>安装pdf2htmlEx</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo add-apt-repository ppa:coolwanglu/pdf2htmlex</div><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install pdf2htmlEX</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ol>\n<h2 id=\"待续\">待续</h2>"},{"layout":"post","title":"python基础篇之正则表达式","comments":1,"_content":"初学Python，对Python的文字处理能力有很深的印象，除了str对象自带的一些方法外，就是正则表达式这个强大的模块了。关于python里面正则表达式的使用网上有很多博文,如[python正则式学习笔记](http://blog.csdn.net/whycadi/article/details/2011046)等,这里做一下自己的总结.\n<!-- more -->\n\n\n## 基本使用\n* match方法\n\n\t```python\n\timport re\n\n\tstr = 'an example word:cat!!'\n\tmatch = re.search(r'word:\\w\\w\\w', str)\n\n\t# If语句紧跟来检验search()是否成功\n\tif match:                      \n\t\tprint 'found', match.group()  ## 找到cat\n\telse:\n\t\tprint 'did not find'\n\t```\n* findall方法\n\n\t```python\n\timport re\n\n\t# 在字符串中查找\n\tstr = 'purple alice@google.com, blah monkey bob@abc.com blah dishwasher'\n\n\t# 找出str中所有的正规的邮箱\n\temails = re.findall(r'[\\w\\.-]+@[\\w\\.-]+', str) ## ['alice@google.com', 'bob@abc.com']\n\tfor email in emails:\n\t    print email\n\n\n\t# 在文件中查找\n\tf = open（'test.txt','r'）\n\n\tstrings = re.findall(r'pattern',f.read())\n\t```\n\n## 基本模式\n* `普通字符`\ta-z,A-Z,0-9\n* `.`\t\t\t匹配任何一个单字符,除了换行符`\\n`\n* `\\w`\t\t\t匹配字母/数字/下划线,等价于[a-zA-Z0-9],`\\W`与`\\w`互为补集\n* `\\b`\t\t\t匹配词和非词的分隔界限\n* `\\s`\t\t\t匹配单个空格字符,等价于[ \\n\\r\\t\\f\\v].`\\S`和`\\s`互为补集\n* `\\t\\n\\r`\t\t匹配制表符,换行符,回车符\n* `\\d`\t\t\t匹配数字,等价于[0-9]\n* `^ $`\t\t\t`^`匹配开头,`$`匹配结尾\n\n## 重复模式\n* `+`\t\t\t匹配至少有一个和左边相同的字符构成的串.eg 'i+'匹配i/ii/iii etc\n* `*`\t\t\t匹配0个或多个和左边相同的字符构成的串.eg 'i*'匹配 /i/ii/iii etc\n* `?`\t\t\t匹配0个或一个和左边相同的字符.eg 'i?'匹配/i\n\n\t> **注意:**  \n\t> `+`和`*`都是尽可能多的匹配字符串\n\n## 特殊符号\n* `[]`\t\t\t代表单个字符,这个字符是属于[]中的元素\n* `()`\t\t\t()中匹配的字符串构成的一个group，可以通过match.group(i)提取第i个组合\n\n## 课后习题\n* 练习题: [babynames.py]({{ site.baseurl }}/assets/attachs/babynames.py.txt)  [baby2006.html]({{ site.baseurl }}/assets/attachs/baby2006.html.txt)\n","source":"_posts/2014-12-10-python基础篇之正则表达式.md","raw":"---\nlayout:\tpost\ntitle:\tpython基础篇之正则表达式\ncategories:\n- TECHNOLOGY\ntags:\n- Python\n- Google\npermalink:  Study-reg-Python\ncomments:\ttrue\n---\n初学Python，对Python的文字处理能力有很深的印象，除了str对象自带的一些方法外，就是正则表达式这个强大的模块了。关于python里面正则表达式的使用网上有很多博文,如[python正则式学习笔记](http://blog.csdn.net/whycadi/article/details/2011046)等,这里做一下自己的总结.\n<!-- more -->\n\n\n## 基本使用\n* match方法\n\n\t```python\n\timport re\n\n\tstr = 'an example word:cat!!'\n\tmatch = re.search(r'word:\\w\\w\\w', str)\n\n\t# If语句紧跟来检验search()是否成功\n\tif match:                      \n\t\tprint 'found', match.group()  ## 找到cat\n\telse:\n\t\tprint 'did not find'\n\t```\n* findall方法\n\n\t```python\n\timport re\n\n\t# 在字符串中查找\n\tstr = 'purple alice@google.com, blah monkey bob@abc.com blah dishwasher'\n\n\t# 找出str中所有的正规的邮箱\n\temails = re.findall(r'[\\w\\.-]+@[\\w\\.-]+', str) ## ['alice@google.com', 'bob@abc.com']\n\tfor email in emails:\n\t    print email\n\n\n\t# 在文件中查找\n\tf = open（'test.txt','r'）\n\n\tstrings = re.findall(r'pattern',f.read())\n\t```\n\n## 基本模式\n* `普通字符`\ta-z,A-Z,0-9\n* `.`\t\t\t匹配任何一个单字符,除了换行符`\\n`\n* `\\w`\t\t\t匹配字母/数字/下划线,等价于[a-zA-Z0-9],`\\W`与`\\w`互为补集\n* `\\b`\t\t\t匹配词和非词的分隔界限\n* `\\s`\t\t\t匹配单个空格字符,等价于[ \\n\\r\\t\\f\\v].`\\S`和`\\s`互为补集\n* `\\t\\n\\r`\t\t匹配制表符,换行符,回车符\n* `\\d`\t\t\t匹配数字,等价于[0-9]\n* `^ $`\t\t\t`^`匹配开头,`$`匹配结尾\n\n## 重复模式\n* `+`\t\t\t匹配至少有一个和左边相同的字符构成的串.eg 'i+'匹配i/ii/iii etc\n* `*`\t\t\t匹配0个或多个和左边相同的字符构成的串.eg 'i*'匹配 /i/ii/iii etc\n* `?`\t\t\t匹配0个或一个和左边相同的字符.eg 'i?'匹配/i\n\n\t> **注意:**  \n\t> `+`和`*`都是尽可能多的匹配字符串\n\n## 特殊符号\n* `[]`\t\t\t代表单个字符,这个字符是属于[]中的元素\n* `()`\t\t\t()中匹配的字符串构成的一个group，可以通过match.group(i)提取第i个组合\n\n## 课后习题\n* 练习题: [babynames.py]({{ site.baseurl }}/assets/attachs/babynames.py.txt)  [baby2006.html]({{ site.baseurl }}/assets/attachs/baby2006.html.txt)\n","slug":"Study-reg-Python","published":1,"date":"2014-12-09T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j14000vl73y9ocds9sq","content":"<p>初学Python，对Python的文字处理能力有很深的印象，除了str对象自带的一些方法外，就是正则表达式这个强大的模块了。关于python里面正则表达式的使用网上有很多博文,如<a href=\"http://blog.csdn.net/whycadi/article/details/2011046\" target=\"_blank\" rel=\"external\">python正则式学习笔记</a>等,这里做一下自己的总结. <a id=\"more\"></a></p>\n<h2 id=\"基本使用\">基本使用</h2>\n<ul>\n<li><p>match方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> re</div><div class=\"line\"></div><div class=\"line\">str = <span class=\"string\">'an example word:cat!!'</span></div><div class=\"line\">match = re.search(<span class=\"string\">r'word:\\w\\w\\w'</span>, str)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># If语句紧跟来检验search()是否成功</span></div><div class=\"line\"><span class=\"keyword\">if</span> match:                      </div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">'found'</span>, match.group()  <span class=\"comment\">## 找到cat</span></div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">'did not find'</span></div></pre></td></tr></table></figure></li>\n<li><p>findall方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> re</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 在字符串中查找</span></div><div class=\"line\">str = <span class=\"string\">'purple alice@google.com, blah monkey bob@abc.com blah dishwasher'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 找出str中所有的正规的邮箱</span></div><div class=\"line\">emails = re.findall(<span class=\"string\">r'[\\w\\.-]+@[\\w\\.-]+'</span>, str) <span class=\"comment\">## ['alice@google.com', 'bob@abc.com']</span></div><div class=\"line\"><span class=\"keyword\">for</span> email <span class=\"keyword\">in</span> emails:</div><div class=\"line\">    <span class=\"keyword\">print</span> email</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 在文件中查找</span></div><div class=\"line\">f = open（<span class=\"string\">'test.txt'</span>,<span class=\"string\">'r'</span>）</div><div class=\"line\"></div><div class=\"line\">strings = re.findall(<span class=\"string\">r'pattern'</span>,f.read())</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"基本模式\">基本模式</h2>\n<ul>\n<li><code>普通字符</code> a-z,A-Z,0-9</li>\n<li><code>.</code> 匹配任何一个单字符,除了换行符<code>\\n</code></li>\n<li><code>\\w</code> 匹配字母/数字/下划线,等价于[a-zA-Z0-9],<code>\\W</code>与<code>\\w</code>互为补集</li>\n<li><code>\\b</code> 匹配词和非词的分隔界限</li>\n<li><code>\\s</code> 匹配单个空格字符,等价于[ ].<code>\\S</code>和<code>\\s</code>互为补集</li>\n<li><code>\\t\\n\\r</code> 匹配制表符,换行符,回车符</li>\n<li><code>\\d</code> 匹配数字,等价于[0-9]</li>\n<li><code>^ $</code> <code>^</code>匹配开头,<code>$</code>匹配结尾</li>\n</ul>\n<h2 id=\"重复模式\">重复模式</h2>\n<ul>\n<li><code>+</code> 匹配至少有一个和左边相同的字符构成的串.eg ’i+’匹配i/ii/iii etc</li>\n<li><code>*</code> 匹配0个或多个和左边相同的字符构成的串.eg ’i*’匹配 /i/ii/iii etc</li>\n<li><p><code>?</code> 匹配0个或一个和左边相同的字符.eg ’i?’匹配/i</p>\n<blockquote>\n<p><strong>注意:</strong><br>\n<code>+</code>和<code>*</code>都是尽可能多的匹配字符串</p>\n</blockquote></li>\n</ul>\n<h2 id=\"特殊符号\">特殊符号</h2>\n<ul>\n<li><code>[]</code> 代表单个字符,这个字符是属于[]中的元素</li>\n<li><code>()</code> ()中匹配的字符串构成的一个group，可以通过match.group(i)提取第i个组合</li>\n</ul>\n<h2 id=\"课后习题\">课后习题</h2>\n<ul>\n<li>练习题: [babynames.py](/assets/attachs/babynames.py.txt) [baby2006.html](/assets/attachs/baby2006.html.txt)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>初学Python，对Python的文字处理能力有很深的印象，除了str对象自带的一些方法外，就是正则表达式这个强大的模块了。关于python里面正则表达式的使用网上有很多博文,如<a href=\"http://blog.csdn.net/whycadi/article/details/2011046\" target=\"_blank\" rel=\"external\">python正则式学习笔记</a>等,这里做一下自己的总结.","more":"</p>\n<h2 id=\"基本使用\">基本使用</h2>\n<ul>\n<li><p>match方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> re</div><div class=\"line\"></div><div class=\"line\">str = <span class=\"string\">'an example word:cat!!'</span></div><div class=\"line\">match = re.search(<span class=\"string\">r'word:\\w\\w\\w'</span>, str)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># If语句紧跟来检验search()是否成功</span></div><div class=\"line\"><span class=\"keyword\">if</span> match:                      </div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">'found'</span>, match.group()  <span class=\"comment\">## 找到cat</span></div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">'did not find'</span></div></pre></td></tr></table></figure></li>\n<li><p>findall方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> re</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 在字符串中查找</span></div><div class=\"line\">str = <span class=\"string\">'purple alice@google.com, blah monkey bob@abc.com blah dishwasher'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 找出str中所有的正规的邮箱</span></div><div class=\"line\">emails = re.findall(<span class=\"string\">r'[\\w\\.-]+@[\\w\\.-]+'</span>, str) <span class=\"comment\">## ['alice@google.com', 'bob@abc.com']</span></div><div class=\"line\"><span class=\"keyword\">for</span> email <span class=\"keyword\">in</span> emails:</div><div class=\"line\">    <span class=\"keyword\">print</span> email</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 在文件中查找</span></div><div class=\"line\">f = open（<span class=\"string\">'test.txt'</span>,<span class=\"string\">'r'</span>）</div><div class=\"line\"></div><div class=\"line\">strings = re.findall(<span class=\"string\">r'pattern'</span>,f.read())</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"基本模式\">基本模式</h2>\n<ul>\n<li><code>普通字符</code> a-z,A-Z,0-9</li>\n<li><code>.</code> 匹配任何一个单字符,除了换行符<code>\\n</code></li>\n<li><code>\\w</code> 匹配字母/数字/下划线,等价于[a-zA-Z0-9],<code>\\W</code>与<code>\\w</code>互为补集</li>\n<li><code>\\b</code> 匹配词和非词的分隔界限</li>\n<li><code>\\s</code> 匹配单个空格字符,等价于[ ].<code>\\S</code>和<code>\\s</code>互为补集</li>\n<li><code>\\t\\n\\r</code> 匹配制表符,换行符,回车符</li>\n<li><code>\\d</code> 匹配数字,等价于[0-9]</li>\n<li><code>^ $</code> <code>^</code>匹配开头,<code>$</code>匹配结尾</li>\n</ul>\n<h2 id=\"重复模式\">重复模式</h2>\n<ul>\n<li><code>+</code> 匹配至少有一个和左边相同的字符构成的串.eg ’i+’匹配i/ii/iii etc</li>\n<li><code>*</code> 匹配0个或多个和左边相同的字符构成的串.eg ’i*’匹配 /i/ii/iii etc</li>\n<li><p><code>?</code> 匹配0个或一个和左边相同的字符.eg ’i?’匹配/i</p>\n<blockquote>\n<p><strong>注意:</strong><br>\n<code>+</code>和<code>*</code>都是尽可能多的匹配字符串</p>\n</blockquote></li>\n</ul>\n<h2 id=\"特殊符号\">特殊符号</h2>\n<ul>\n<li><code>[]</code> 代表单个字符,这个字符是属于[]中的元素</li>\n<li><code>()</code> ()中匹配的字符串构成的一个group，可以通过match.group(i)提取第i个组合</li>\n</ul>\n<h2 id=\"课后习题\">课后习题</h2>\n<ul>\n<li>练习题: [babynames.py](/assets/attachs/babynames.py.txt) [baby2006.html](/assets/attachs/baby2006.html.txt)</li>\n</ul>"},{"layout":"post","title":"python基础篇之实用工具","comments":1,"_content":"个人觉得python越来越实用离不开其强大的模块,框架的支持,像文件模块,命令行模块,django框架,sk-learning工具箱等等.这些都让python能够非常方便的处理不同领域的问题.\n<!-- more -->\n\n\n## 文件模块\n* 模块支持\n\n\t```python\n\timport os\n\timport shutil\n\t```\n* 常用函数\n\n\t```python\n\t# 获取文件列表\n\tfilenames = os.listdir(dir)\n\n\t# 拼接文件路径\n\tos.path.join(dir,filename)\n\n\t# 获取绝对路径\n\tos.path.abspath(path)\n\n\t# 从完整路径中获取目录和文件名\n\tos.path.dirname(path)\n\tos.path.basename(path)\n\n\t# 判断完整路径是否存在\n\tos.path.exists(path)\n\n\t# 创建目录\n\tos.mkdir(dir_path)\n\t# 创建路径上的所有文件夹\n\tos.makedirs(dir_path)   \n\n\t# 拷贝文件\n\tshutil.copy(src,dest)\n\t```\n## 命令行模块\n* 模块支持\n\n\t```python\n\timport commands\n\t```\n* 常用函数\n\n\t```python\n\t# 运行命令，等待结束。返回状态（正常返回是0）和结果。\n\t(status, output) = commands.getstatusoutput(cmd)\n\n\t# 不返回状态的执行命令\n\toutput = commands.getoutput(cmd)\n\n\t# 不关心结果，只要执行即可\n\tos.system(cmd)\n\t```\n* 样例代码\n\n\t```python\n\t# 给定一个dir路径，运行 'ls -l'\n\tdef listdir(dir):\n\t\tcmd = 'ls -l ' + dir\n\t\tprint \"Command to run:\", cmd   ## 易于调试\n\t\t(status, output) = commands.getstatusoutput(cmd)\n\t\tif status:    ## 错误情况，打印错误信息并退出\n\t\t\tsys.stderr.write(output)\n\t\t\tsys.exit(1)\n\t\tprint output  ## 否则显示输出结果\n\t```\n\n## 异常处理\n* 样例代码\n\n\t```python\n\ttry:\n\t    # 打开文件或读取文件出现问题将抛出 IOError 异常.\n\t    f = open(filename, 'rU')\n\t\ttext = f.read()\n\t\tf.close()\n\texcept IOError:\n\t\t# 处理 IOError 异常.\n\t\tsys.stderr.write('problem reading:' + filename)\n\t# try/except后面的代码将继续执行\n\t```\n\n## 网络模块\n* 模块支持\n\n\t```python\n\timport urllib\n\t```\n* 常用函数\n\n\t```python\n\t# 返回一个文件\n\tufile = urllib.urlopen(url)\n\n\t# 读取文件信息\n\ttext = ufile.read()\n\n\t# 获取网络文件meta/type 信息\n\tinfo = ufile.info()\n\ttype = info.gettype()\n\n\t# 获取最初始的url（针对重定向）\n\tbaseurl = ufile.geturl()\n\n\t# 下载url数据到指定的文件\n\turllib.urlretrieve(url,filename)\n\n\t# 获取完整url\n\turlparse.urljoin(baseurl,url)\n\t```\n* 样例代码\n\n\t```python\n\t## 用try/except处理网络异常\n\tdef wget(url):\n\t\ttry:\n\t\t\tufile = urllib.urlopen(url)\n\t\t\tif ufile.info().gettype() == 'text/html':\n\t\t\t\tprint ufile.read()\n\t\texcept IOError:\n\t\t\tprint 'problem reading url:', url\n\n\twget('http://www.baidu.com')  # 一定要加http://\n\t```\n\n## 课后练习\n* 练习题1: [copyspecial.py]({{ site.baseurl }}/assets/attachs/copyspecial.py.txt)\n* 练习题2: [logpuzzle.py]({{ site.baseurl }}/assets/attachs/logpuzzle.py.txt)\n","source":"_posts/2014-12-11-python基础篇之实用工具.md","raw":"---\nlayout:\tpost\ntitle:\tpython基础篇之实用工具\ncategories:\n- TECHNOLOGY\ntags:\n- Python\n- Google\npermalink:  Study-tool-Python\ncomments:\ttrue\n---\n个人觉得python越来越实用离不开其强大的模块,框架的支持,像文件模块,命令行模块,django框架,sk-learning工具箱等等.这些都让python能够非常方便的处理不同领域的问题.\n<!-- more -->\n\n\n## 文件模块\n* 模块支持\n\n\t```python\n\timport os\n\timport shutil\n\t```\n* 常用函数\n\n\t```python\n\t# 获取文件列表\n\tfilenames = os.listdir(dir)\n\n\t# 拼接文件路径\n\tos.path.join(dir,filename)\n\n\t# 获取绝对路径\n\tos.path.abspath(path)\n\n\t# 从完整路径中获取目录和文件名\n\tos.path.dirname(path)\n\tos.path.basename(path)\n\n\t# 判断完整路径是否存在\n\tos.path.exists(path)\n\n\t# 创建目录\n\tos.mkdir(dir_path)\n\t# 创建路径上的所有文件夹\n\tos.makedirs(dir_path)   \n\n\t# 拷贝文件\n\tshutil.copy(src,dest)\n\t```\n## 命令行模块\n* 模块支持\n\n\t```python\n\timport commands\n\t```\n* 常用函数\n\n\t```python\n\t# 运行命令，等待结束。返回状态（正常返回是0）和结果。\n\t(status, output) = commands.getstatusoutput(cmd)\n\n\t# 不返回状态的执行命令\n\toutput = commands.getoutput(cmd)\n\n\t# 不关心结果，只要执行即可\n\tos.system(cmd)\n\t```\n* 样例代码\n\n\t```python\n\t# 给定一个dir路径，运行 'ls -l'\n\tdef listdir(dir):\n\t\tcmd = 'ls -l ' + dir\n\t\tprint \"Command to run:\", cmd   ## 易于调试\n\t\t(status, output) = commands.getstatusoutput(cmd)\n\t\tif status:    ## 错误情况，打印错误信息并退出\n\t\t\tsys.stderr.write(output)\n\t\t\tsys.exit(1)\n\t\tprint output  ## 否则显示输出结果\n\t```\n\n## 异常处理\n* 样例代码\n\n\t```python\n\ttry:\n\t    # 打开文件或读取文件出现问题将抛出 IOError 异常.\n\t    f = open(filename, 'rU')\n\t\ttext = f.read()\n\t\tf.close()\n\texcept IOError:\n\t\t# 处理 IOError 异常.\n\t\tsys.stderr.write('problem reading:' + filename)\n\t# try/except后面的代码将继续执行\n\t```\n\n## 网络模块\n* 模块支持\n\n\t```python\n\timport urllib\n\t```\n* 常用函数\n\n\t```python\n\t# 返回一个文件\n\tufile = urllib.urlopen(url)\n\n\t# 读取文件信息\n\ttext = ufile.read()\n\n\t# 获取网络文件meta/type 信息\n\tinfo = ufile.info()\n\ttype = info.gettype()\n\n\t# 获取最初始的url（针对重定向）\n\tbaseurl = ufile.geturl()\n\n\t# 下载url数据到指定的文件\n\turllib.urlretrieve(url,filename)\n\n\t# 获取完整url\n\turlparse.urljoin(baseurl,url)\n\t```\n* 样例代码\n\n\t```python\n\t## 用try/except处理网络异常\n\tdef wget(url):\n\t\ttry:\n\t\t\tufile = urllib.urlopen(url)\n\t\t\tif ufile.info().gettype() == 'text/html':\n\t\t\t\tprint ufile.read()\n\t\texcept IOError:\n\t\t\tprint 'problem reading url:', url\n\n\twget('http://www.baidu.com')  # 一定要加http://\n\t```\n\n## 课后练习\n* 练习题1: [copyspecial.py]({{ site.baseurl }}/assets/attachs/copyspecial.py.txt)\n* 练习题2: [logpuzzle.py]({{ site.baseurl }}/assets/attachs/logpuzzle.py.txt)\n","slug":"Study-tool-Python","published":1,"date":"2014-12-10T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j16000wl73yvq9xqodo","content":"<p>个人觉得python越来越实用离不开其强大的模块,框架的支持,像文件模块,命令行模块,django框架,sk-learning工具箱等等.这些都让python能够非常方便的处理不同领域的问题. <a id=\"more\"></a></p>\n<h2 id=\"文件模块\">文件模块</h2>\n<ul>\n<li><p>模块支持</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> os</div><div class=\"line\"><span class=\"keyword\">import</span> shutil</div></pre></td></tr></table></figure></li>\n<li><p>常用函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 获取文件列表</span></div><div class=\"line\">filenames = os.listdir(dir)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 拼接文件路径</span></div><div class=\"line\">os.path.join(dir,filename)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 获取绝对路径</span></div><div class=\"line\">os.path.abspath(path)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 从完整路径中获取目录和文件名</span></div><div class=\"line\">os.path.dirname(path)</div><div class=\"line\">os.path.basename(path)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 判断完整路径是否存在</span></div><div class=\"line\">os.path.exists(path)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 创建目录</span></div><div class=\"line\">os.mkdir(dir_path)</div><div class=\"line\"><span class=\"comment\"># 创建路径上的所有文件夹</span></div><div class=\"line\">os.makedirs(dir_path)   </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 拷贝文件</span></div><div class=\"line\">shutil.copy(src,dest)</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"命令行模块\">命令行模块</h2>\n<ul>\n<li><p>模块支持</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> commands</div></pre></td></tr></table></figure></li>\n<li><p>常用函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 运行命令，等待结束。返回状态（正常返回是0）和结果。</span></div><div class=\"line\">(status, output) = commands.getstatusoutput(cmd)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 不返回状态的执行命令</span></div><div class=\"line\">output = commands.getoutput(cmd)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 不关心结果，只要执行即可</span></div><div class=\"line\">os.system(cmd)</div></pre></td></tr></table></figure></li>\n<li><p>样例代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 给定一个dir路径，运行 'ls -l'</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">listdir</span><span class=\"params\">(dir)</span>:</span></div><div class=\"line\">\tcmd = <span class=\"string\">'ls -l '</span> + dir</div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"Command to run:\"</span>, cmd   <span class=\"comment\">## 易于调试</span></div><div class=\"line\">\t(status, output) = commands.getstatusoutput(cmd)</div><div class=\"line\">\t<span class=\"keyword\">if</span> status:    <span class=\"comment\">## 错误情况，打印错误信息并退出</span></div><div class=\"line\">\t\tsys.stderr.write(output)</div><div class=\"line\">\t\tsys.exit(<span class=\"number\">1</span>)</div><div class=\"line\">\t<span class=\"keyword\">print</span> output  <span class=\"comment\">## 否则显示输出结果</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"异常处理\">异常处理</h2>\n<ul>\n<li><p>样例代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    <span class=\"comment\"># 打开文件或读取文件出现问题将抛出 IOError 异常.</span></div><div class=\"line\">    f = open(filename, <span class=\"string\">'rU'</span>)</div><div class=\"line\">\ttext = f.read()</div><div class=\"line\">\tf.close()</div><div class=\"line\"><span class=\"keyword\">except</span> IOError:</div><div class=\"line\">\t<span class=\"comment\"># 处理 IOError 异常.</span></div><div class=\"line\">\tsys.stderr.write(<span class=\"string\">'problem reading:'</span> + filename)</div><div class=\"line\"><span class=\"comment\"># try/except后面的代码将继续执行</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"网络模块\">网络模块</h2>\n<ul>\n<li><p>模块支持</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> urllib</div></pre></td></tr></table></figure></li>\n<li><p>常用函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 返回一个文件</span></div><div class=\"line\">ufile = urllib.urlopen(url)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 读取文件信息</span></div><div class=\"line\">text = ufile.read()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 获取网络文件meta/type 信息</span></div><div class=\"line\">info = ufile.info()</div><div class=\"line\">type = info.gettype()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 获取最初始的url（针对重定向）</span></div><div class=\"line\">baseurl = ufile.geturl()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 下载url数据到指定的文件</span></div><div class=\"line\">urllib.urlretrieve(url,filename)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 获取完整url</span></div><div class=\"line\">urlparse.urljoin(baseurl,url)</div></pre></td></tr></table></figure></li>\n<li><p>样例代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">## 用try/except处理网络异常</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wget</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">try</span>:</div><div class=\"line\">\t\tufile = urllib.urlopen(url)</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ufile.info().gettype() == <span class=\"string\">'text/html'</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">print</span> ufile.read()</div><div class=\"line\">\t<span class=\"keyword\">except</span> IOError:</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> <span class=\"string\">'problem reading url:'</span>, url</div><div class=\"line\"></div><div class=\"line\">wget(<span class=\"string\">'http://www.baidu.com'</span>)  <span class=\"comment\"># 一定要加http://</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"课后练习\">课后练习</h2>\n<ul>\n<li>练习题1: [copyspecial.py](/assets/attachs/copyspecial.py.txt)</li>\n<li>练习题2: [logpuzzle.py](/assets/attachs/logpuzzle.py.txt)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>个人觉得python越来越实用离不开其强大的模块,框架的支持,像文件模块,命令行模块,django框架,sk-learning工具箱等等.这些都让python能够非常方便的处理不同领域的问题.","more":"</p>\n<h2 id=\"文件模块\">文件模块</h2>\n<ul>\n<li><p>模块支持</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> os</div><div class=\"line\"><span class=\"keyword\">import</span> shutil</div></pre></td></tr></table></figure></li>\n<li><p>常用函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 获取文件列表</span></div><div class=\"line\">filenames = os.listdir(dir)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 拼接文件路径</span></div><div class=\"line\">os.path.join(dir,filename)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 获取绝对路径</span></div><div class=\"line\">os.path.abspath(path)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 从完整路径中获取目录和文件名</span></div><div class=\"line\">os.path.dirname(path)</div><div class=\"line\">os.path.basename(path)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 判断完整路径是否存在</span></div><div class=\"line\">os.path.exists(path)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 创建目录</span></div><div class=\"line\">os.mkdir(dir_path)</div><div class=\"line\"><span class=\"comment\"># 创建路径上的所有文件夹</span></div><div class=\"line\">os.makedirs(dir_path)   </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 拷贝文件</span></div><div class=\"line\">shutil.copy(src,dest)</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"命令行模块\">命令行模块</h2>\n<ul>\n<li><p>模块支持</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> commands</div></pre></td></tr></table></figure></li>\n<li><p>常用函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 运行命令，等待结束。返回状态（正常返回是0）和结果。</span></div><div class=\"line\">(status, output) = commands.getstatusoutput(cmd)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 不返回状态的执行命令</span></div><div class=\"line\">output = commands.getoutput(cmd)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 不关心结果，只要执行即可</span></div><div class=\"line\">os.system(cmd)</div></pre></td></tr></table></figure></li>\n<li><p>样例代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 给定一个dir路径，运行 'ls -l'</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">listdir</span><span class=\"params\">(dir)</span>:</span></div><div class=\"line\">\tcmd = <span class=\"string\">'ls -l '</span> + dir</div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"Command to run:\"</span>, cmd   <span class=\"comment\">## 易于调试</span></div><div class=\"line\">\t(status, output) = commands.getstatusoutput(cmd)</div><div class=\"line\">\t<span class=\"keyword\">if</span> status:    <span class=\"comment\">## 错误情况，打印错误信息并退出</span></div><div class=\"line\">\t\tsys.stderr.write(output)</div><div class=\"line\">\t\tsys.exit(<span class=\"number\">1</span>)</div><div class=\"line\">\t<span class=\"keyword\">print</span> output  <span class=\"comment\">## 否则显示输出结果</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"异常处理\">异常处理</h2>\n<ul>\n<li><p>样例代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    <span class=\"comment\"># 打开文件或读取文件出现问题将抛出 IOError 异常.</span></div><div class=\"line\">    f = open(filename, <span class=\"string\">'rU'</span>)</div><div class=\"line\">\ttext = f.read()</div><div class=\"line\">\tf.close()</div><div class=\"line\"><span class=\"keyword\">except</span> IOError:</div><div class=\"line\">\t<span class=\"comment\"># 处理 IOError 异常.</span></div><div class=\"line\">\tsys.stderr.write(<span class=\"string\">'problem reading:'</span> + filename)</div><div class=\"line\"><span class=\"comment\"># try/except后面的代码将继续执行</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"网络模块\">网络模块</h2>\n<ul>\n<li><p>模块支持</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> urllib</div></pre></td></tr></table></figure></li>\n<li><p>常用函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 返回一个文件</span></div><div class=\"line\">ufile = urllib.urlopen(url)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 读取文件信息</span></div><div class=\"line\">text = ufile.read()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 获取网络文件meta/type 信息</span></div><div class=\"line\">info = ufile.info()</div><div class=\"line\">type = info.gettype()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 获取最初始的url（针对重定向）</span></div><div class=\"line\">baseurl = ufile.geturl()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 下载url数据到指定的文件</span></div><div class=\"line\">urllib.urlretrieve(url,filename)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 获取完整url</span></div><div class=\"line\">urlparse.urljoin(baseurl,url)</div></pre></td></tr></table></figure></li>\n<li><p>样例代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">## 用try/except处理网络异常</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wget</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">try</span>:</div><div class=\"line\">\t\tufile = urllib.urlopen(url)</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ufile.info().gettype() == <span class=\"string\">'text/html'</span>:</div><div class=\"line\">\t\t\t<span class=\"keyword\">print</span> ufile.read()</div><div class=\"line\">\t<span class=\"keyword\">except</span> IOError:</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> <span class=\"string\">'problem reading url:'</span>, url</div><div class=\"line\"></div><div class=\"line\">wget(<span class=\"string\">'http://www.baidu.com'</span>)  <span class=\"comment\"># 一定要加http://</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"课后练习\">课后练习</h2>\n<ul>\n<li>练习题1: [copyspecial.py](/assets/attachs/copyspecial.py.txt)</li>\n<li>练习题2: [logpuzzle.py](/assets/attachs/logpuzzle.py.txt)</li>\n</ul>"},{"layout":"post","title":"linux经久不衰的应用程序","comments":1,"_content":"Linux系统里面的应用程序一贯具备高安全性和高性价比(功能/所占空间),而且它在科研领域的好软件的确要比windows里面多很多,而且功能强大很多.这里记录下Linux里面比较常用的而且经久不衰的应用程序.\n<!-- more -->\n\n\n## 程序清单\n\n* shell\n\t1. **bash**  \n\t结合了csh和ksh的优点,并且有readline功能,可以随意绑定自己的键盘.\n* 编辑器\n\t1. **VIM**  \n\t目前使用的编辑器中感觉功能最强大,最炫酷的编辑器.最喜欢它的DIY功能,已经离不开它了.\n\t2. **Geany**  \n\t功能比较强大的编辑器,而且加上插件后,就会变成开发环境.\n\t3. Emacs  \n\t听说功能也挺强大,目前还没有使用过.\n* 程序开发\n\t1. **GCC/G++**  \n\t\tC/C++的编译器,远离集成环境\n\t2. **make**  \n\t\t自动化管理工具,可以自动编译程序，自动编译文档，自动更新插图…… 全自动，不会重复劳动.\n\t3. **jdk**  \n\t\tjava运行环境\n\t4. **python**  \n\t\tpython运行环境\n\t5.\tScheme48，j2sdk，Perl，Tcl/Tk\n* 论文/PPT  \n\t1. **Latex**  \n\t专业的文字排版工具,优美的公式排版甩office好几条街.\n* 绘图工具\n\t1. **dia**  \n\t基于GTK的图形绘制工具,代替visio基本没问题.\n\t2. **MetaPost**  \n\t它是一种描述性的语言, 用它可以作出非常漂亮的图形. 特别适合于精确的图形.\n* 图像处理\n\t1. **gimp**  \n\t专业的位图处理工具,比肩photoshop\n\t2. **inkscape**  \n\t专业的矢量图处理工具\n* 数值计算工具\n\t1. **octave**  \n\t和matlab同样的用法,不过其GUI界面不是很方便.\n\t2. **matlab**\n\t3. SciLab\n* 代数计算程序\n\t1. MAXIMA  \n\t这个程序基于世界上最老的计算机代数系统之一: 由美国能源部(DOE)发行的 MIT Macsyma 系统。\n* 加密程序\n\t1. GnuPG  \n\t\t以GNU通用公共许可证释出的开放源码用于加密或签名的软件，可用来取代PGP\n* 打包/压缩\n\t1. **tar**  \n\t2. **p7zip**  \n\t3. gzip/bzip2/zip/rar\n* ftp服务器\n\t1. proftpd\n\t2. vsftpd\n* ftp客户端\n\t1. **FileZilla**  \n\t2. lftp/ncftp\n* www服务器\n\t1. **apache**  \n* 自动下载工具\n\t1. wget\n* 窗口管理器\n\t1. FVWM  \n\t编译加入libstroke，中文输入SCIM\n* Email管理\n\t1. **Thunderbird**\n* 看pdf,Djvu\n\t1. **evince**\n\t2. djvu/netscape\n* 英汉字典\n\t1. **星际译王**  \n\t完全可以替代有道词典.\n* 远程登录\n\t1. openSSH/Telnet\n* QQ\n\t1. **longeneQQ**  \n\t基于wine,除了偶尔不流畅外,完全等同windows里的QQ\n* 视频\n\t1. **xbmc**  \n\t庞大的插件,让你可以将pps,优酷,乐视等全部整合在一起,关键是以后家庭电视也可通用.\n\t2. **VLC**\n* 音乐\n\t1. **Rhythm**\n* 后台程序\n\t1. **crond**  \n\t定时工作服务\n\t2. telnetd/xinetd\n","source":"_posts/2014-12-31-Linux经久不衰的应用程序.md","raw":"---\nlayout:\tpost\ntitle:\tlinux经久不衰的应用程序\ncategories:\n- TECHNOLOGY\ntags:\n- Ubuntu\n- Software\npermalink:  Explore-popularSoftware-Ubuntu\ncomments:\ttrue\n---\nLinux系统里面的应用程序一贯具备高安全性和高性价比(功能/所占空间),而且它在科研领域的好软件的确要比windows里面多很多,而且功能强大很多.这里记录下Linux里面比较常用的而且经久不衰的应用程序.\n<!-- more -->\n\n\n## 程序清单\n\n* shell\n\t1. **bash**  \n\t结合了csh和ksh的优点,并且有readline功能,可以随意绑定自己的键盘.\n* 编辑器\n\t1. **VIM**  \n\t目前使用的编辑器中感觉功能最强大,最炫酷的编辑器.最喜欢它的DIY功能,已经离不开它了.\n\t2. **Geany**  \n\t功能比较强大的编辑器,而且加上插件后,就会变成开发环境.\n\t3. Emacs  \n\t听说功能也挺强大,目前还没有使用过.\n* 程序开发\n\t1. **GCC/G++**  \n\t\tC/C++的编译器,远离集成环境\n\t2. **make**  \n\t\t自动化管理工具,可以自动编译程序，自动编译文档，自动更新插图…… 全自动，不会重复劳动.\n\t3. **jdk**  \n\t\tjava运行环境\n\t4. **python**  \n\t\tpython运行环境\n\t5.\tScheme48，j2sdk，Perl，Tcl/Tk\n* 论文/PPT  \n\t1. **Latex**  \n\t专业的文字排版工具,优美的公式排版甩office好几条街.\n* 绘图工具\n\t1. **dia**  \n\t基于GTK的图形绘制工具,代替visio基本没问题.\n\t2. **MetaPost**  \n\t它是一种描述性的语言, 用它可以作出非常漂亮的图形. 特别适合于精确的图形.\n* 图像处理\n\t1. **gimp**  \n\t专业的位图处理工具,比肩photoshop\n\t2. **inkscape**  \n\t专业的矢量图处理工具\n* 数值计算工具\n\t1. **octave**  \n\t和matlab同样的用法,不过其GUI界面不是很方便.\n\t2. **matlab**\n\t3. SciLab\n* 代数计算程序\n\t1. MAXIMA  \n\t这个程序基于世界上最老的计算机代数系统之一: 由美国能源部(DOE)发行的 MIT Macsyma 系统。\n* 加密程序\n\t1. GnuPG  \n\t\t以GNU通用公共许可证释出的开放源码用于加密或签名的软件，可用来取代PGP\n* 打包/压缩\n\t1. **tar**  \n\t2. **p7zip**  \n\t3. gzip/bzip2/zip/rar\n* ftp服务器\n\t1. proftpd\n\t2. vsftpd\n* ftp客户端\n\t1. **FileZilla**  \n\t2. lftp/ncftp\n* www服务器\n\t1. **apache**  \n* 自动下载工具\n\t1. wget\n* 窗口管理器\n\t1. FVWM  \n\t编译加入libstroke，中文输入SCIM\n* Email管理\n\t1. **Thunderbird**\n* 看pdf,Djvu\n\t1. **evince**\n\t2. djvu/netscape\n* 英汉字典\n\t1. **星际译王**  \n\t完全可以替代有道词典.\n* 远程登录\n\t1. openSSH/Telnet\n* QQ\n\t1. **longeneQQ**  \n\t基于wine,除了偶尔不流畅外,完全等同windows里的QQ\n* 视频\n\t1. **xbmc**  \n\t庞大的插件,让你可以将pps,优酷,乐视等全部整合在一起,关键是以后家庭电视也可通用.\n\t2. **VLC**\n* 音乐\n\t1. **Rhythm**\n* 后台程序\n\t1. **crond**  \n\t定时工作服务\n\t2. telnetd/xinetd\n","slug":"Explore-popularSoftware-Ubuntu","published":1,"date":"2014-12-30T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j18000xl73ytwln3sq3","content":"<p>Linux系统里面的应用程序一贯具备高安全性和高性价比(功能/所占空间),而且它在科研领域的好软件的确要比windows里面多很多,而且功能强大很多.这里记录下Linux里面比较常用的而且经久不衰的应用程序. <a id=\"more\"></a></p>\n<h2 id=\"程序清单\">程序清单</h2>\n<ul>\n<li>shell\n<ol style=\"list-style-type: decimal\">\n<li><strong>bash</strong><br>\n结合了csh和ksh的优点,并且有readline功能,可以随意绑定自己的键盘.</li>\n</ol></li>\n<li>编辑器\n<ol style=\"list-style-type: decimal\">\n<li><strong>VIM</strong><br>\n目前使用的编辑器中感觉功能最强大,最炫酷的编辑器.最喜欢它的DIY功能,已经离不开它了.</li>\n<li><strong>Geany</strong><br>\n功能比较强大的编辑器,而且加上插件后,就会变成开发环境.</li>\n<li>Emacs<br>\n听说功能也挺强大,目前还没有使用过.</li>\n</ol></li>\n<li>程序开发\n<ol style=\"list-style-type: decimal\">\n<li><strong>GCC/G++</strong><br>\nC/C++的编译器,远离集成环境</li>\n<li><strong>make</strong><br>\n自动化管理工具,可以自动编译程序，自动编译文档，自动更新插图…… 全自动，不会重复劳动.</li>\n<li><strong>jdk</strong><br>\njava运行环境</li>\n<li><strong>python</strong><br>\npython运行环境</li>\n<li>Scheme48，j2sdk，Perl，Tcl/Tk</li>\n</ol></li>\n<li>论文/PPT\n<ol style=\"list-style-type: decimal\">\n<li><strong>Latex</strong><br>\n专业的文字排版工具,优美的公式排版甩office好几条街.</li>\n</ol></li>\n<li>绘图工具\n<ol style=\"list-style-type: decimal\">\n<li><strong>dia</strong><br>\n基于GTK的图形绘制工具,代替visio基本没问题.</li>\n<li><strong>MetaPost</strong><br>\n它是一种描述性的语言, 用它可以作出非常漂亮的图形. 特别适合于精确的图形.</li>\n</ol></li>\n<li>图像处理\n<ol style=\"list-style-type: decimal\">\n<li><strong>gimp</strong><br>\n专业的位图处理工具,比肩photoshop</li>\n<li><strong>inkscape</strong><br>\n专业的矢量图处理工具</li>\n</ol></li>\n<li>数值计算工具\n<ol style=\"list-style-type: decimal\">\n<li><strong>octave</strong><br>\n和matlab同样的用法,不过其GUI界面不是很方便.</li>\n<li><strong>matlab</strong></li>\n<li>SciLab</li>\n</ol></li>\n<li>代数计算程序\n<ol style=\"list-style-type: decimal\">\n<li>MAXIMA<br>\n这个程序基于世界上最老的计算机代数系统之一: 由美国能源部(DOE)发行的 MIT Macsyma 系统。</li>\n</ol></li>\n<li>加密程序\n<ol style=\"list-style-type: decimal\">\n<li>GnuPG<br>\n以GNU通用公共许可证释出的开放源码用于加密或签名的软件，可用来取代PGP</li>\n</ol></li>\n<li>打包/压缩\n<ol style=\"list-style-type: decimal\">\n<li><strong>tar</strong><br>\n</li>\n<li><strong>p7zip</strong><br>\n</li>\n<li>gzip/bzip2/zip/rar</li>\n</ol></li>\n<li>ftp服务器\n<ol style=\"list-style-type: decimal\">\n<li>proftpd</li>\n<li>vsftpd</li>\n</ol></li>\n<li>ftp客户端\n<ol style=\"list-style-type: decimal\">\n<li><strong>FileZilla</strong><br>\n</li>\n<li>lftp/ncftp</li>\n</ol></li>\n<li>www服务器\n<ol style=\"list-style-type: decimal\">\n<li><strong>apache</strong><br>\n</li>\n</ol></li>\n<li>自动下载工具\n<ol style=\"list-style-type: decimal\">\n<li>wget</li>\n</ol></li>\n<li>窗口管理器\n<ol style=\"list-style-type: decimal\">\n<li>FVWM<br>\n编译加入libstroke，中文输入SCIM</li>\n</ol></li>\n<li>Email管理\n<ol style=\"list-style-type: decimal\">\n<li><strong>Thunderbird</strong></li>\n</ol></li>\n<li>看pdf,Djvu\n<ol style=\"list-style-type: decimal\">\n<li><strong>evince</strong></li>\n<li>djvu/netscape</li>\n</ol></li>\n<li>英汉字典\n<ol style=\"list-style-type: decimal\">\n<li><strong>星际译王</strong><br>\n完全可以替代有道词典.</li>\n</ol></li>\n<li>远程登录\n<ol style=\"list-style-type: decimal\">\n<li>openSSH/Telnet</li>\n</ol></li>\n<li>QQ\n<ol style=\"list-style-type: decimal\">\n<li><strong>longeneQQ</strong><br>\n基于wine,除了偶尔不流畅外,完全等同windows里的QQ</li>\n</ol></li>\n<li>视频\n<ol style=\"list-style-type: decimal\">\n<li><strong>xbmc</strong><br>\n庞大的插件,让你可以将pps,优酷,乐视等全部整合在一起,关键是以后家庭电视也可通用.</li>\n<li><strong>VLC</strong></li>\n</ol></li>\n<li>音乐\n<ol style=\"list-style-type: decimal\">\n<li><strong>Rhythm</strong></li>\n</ol></li>\n<li>后台程序\n<ol style=\"list-style-type: decimal\">\n<li><strong>crond</strong><br>\n定时工作服务</li>\n<li>telnetd/xinetd</li>\n</ol></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Linux系统里面的应用程序一贯具备高安全性和高性价比(功能/所占空间),而且它在科研领域的好软件的确要比windows里面多很多,而且功能强大很多.这里记录下Linux里面比较常用的而且经久不衰的应用程序.","more":"</p>\n<h2 id=\"程序清单\">程序清单</h2>\n<ul>\n<li>shell\n<ol style=\"list-style-type: decimal\">\n<li><strong>bash</strong><br>\n结合了csh和ksh的优点,并且有readline功能,可以随意绑定自己的键盘.</li>\n</ol></li>\n<li>编辑器\n<ol style=\"list-style-type: decimal\">\n<li><strong>VIM</strong><br>\n目前使用的编辑器中感觉功能最强大,最炫酷的编辑器.最喜欢它的DIY功能,已经离不开它了.</li>\n<li><strong>Geany</strong><br>\n功能比较强大的编辑器,而且加上插件后,就会变成开发环境.</li>\n<li>Emacs<br>\n听说功能也挺强大,目前还没有使用过.</li>\n</ol></li>\n<li>程序开发\n<ol style=\"list-style-type: decimal\">\n<li><strong>GCC/G++</strong><br>\nC/C++的编译器,远离集成环境</li>\n<li><strong>make</strong><br>\n自动化管理工具,可以自动编译程序，自动编译文档，自动更新插图…… 全自动，不会重复劳动.</li>\n<li><strong>jdk</strong><br>\njava运行环境</li>\n<li><strong>python</strong><br>\npython运行环境</li>\n<li>Scheme48，j2sdk，Perl，Tcl/Tk</li>\n</ol></li>\n<li>论文/PPT\n<ol style=\"list-style-type: decimal\">\n<li><strong>Latex</strong><br>\n专业的文字排版工具,优美的公式排版甩office好几条街.</li>\n</ol></li>\n<li>绘图工具\n<ol style=\"list-style-type: decimal\">\n<li><strong>dia</strong><br>\n基于GTK的图形绘制工具,代替visio基本没问题.</li>\n<li><strong>MetaPost</strong><br>\n它是一种描述性的语言, 用它可以作出非常漂亮的图形. 特别适合于精确的图形.</li>\n</ol></li>\n<li>图像处理\n<ol style=\"list-style-type: decimal\">\n<li><strong>gimp</strong><br>\n专业的位图处理工具,比肩photoshop</li>\n<li><strong>inkscape</strong><br>\n专业的矢量图处理工具</li>\n</ol></li>\n<li>数值计算工具\n<ol style=\"list-style-type: decimal\">\n<li><strong>octave</strong><br>\n和matlab同样的用法,不过其GUI界面不是很方便.</li>\n<li><strong>matlab</strong></li>\n<li>SciLab</li>\n</ol></li>\n<li>代数计算程序\n<ol style=\"list-style-type: decimal\">\n<li>MAXIMA<br>\n这个程序基于世界上最老的计算机代数系统之一: 由美国能源部(DOE)发行的 MIT Macsyma 系统。</li>\n</ol></li>\n<li>加密程序\n<ol style=\"list-style-type: decimal\">\n<li>GnuPG<br>\n以GNU通用公共许可证释出的开放源码用于加密或签名的软件，可用来取代PGP</li>\n</ol></li>\n<li>打包/压缩\n<ol style=\"list-style-type: decimal\">\n<li><strong>tar</strong><br>\n</li>\n<li><strong>p7zip</strong><br>\n</li>\n<li>gzip/bzip2/zip/rar</li>\n</ol></li>\n<li>ftp服务器\n<ol style=\"list-style-type: decimal\">\n<li>proftpd</li>\n<li>vsftpd</li>\n</ol></li>\n<li>ftp客户端\n<ol style=\"list-style-type: decimal\">\n<li><strong>FileZilla</strong><br>\n</li>\n<li>lftp/ncftp</li>\n</ol></li>\n<li>www服务器\n<ol style=\"list-style-type: decimal\">\n<li><strong>apache</strong><br>\n</li>\n</ol></li>\n<li>自动下载工具\n<ol style=\"list-style-type: decimal\">\n<li>wget</li>\n</ol></li>\n<li>窗口管理器\n<ol style=\"list-style-type: decimal\">\n<li>FVWM<br>\n编译加入libstroke，中文输入SCIM</li>\n</ol></li>\n<li>Email管理\n<ol style=\"list-style-type: decimal\">\n<li><strong>Thunderbird</strong></li>\n</ol></li>\n<li>看pdf,Djvu\n<ol style=\"list-style-type: decimal\">\n<li><strong>evince</strong></li>\n<li>djvu/netscape</li>\n</ol></li>\n<li>英汉字典\n<ol style=\"list-style-type: decimal\">\n<li><strong>星际译王</strong><br>\n完全可以替代有道词典.</li>\n</ol></li>\n<li>远程登录\n<ol style=\"list-style-type: decimal\">\n<li>openSSH/Telnet</li>\n</ol></li>\n<li>QQ\n<ol style=\"list-style-type: decimal\">\n<li><strong>longeneQQ</strong><br>\n基于wine,除了偶尔不流畅外,完全等同windows里的QQ</li>\n</ol></li>\n<li>视频\n<ol style=\"list-style-type: decimal\">\n<li><strong>xbmc</strong><br>\n庞大的插件,让你可以将pps,优酷,乐视等全部整合在一起,关键是以后家庭电视也可通用.</li>\n<li><strong>VLC</strong></li>\n</ol></li>\n<li>音乐\n<ol style=\"list-style-type: decimal\">\n<li><strong>Rhythm</strong></li>\n</ol></li>\n<li>后台程序\n<ol style=\"list-style-type: decimal\">\n<li><strong>crond</strong><br>\n定时工作服务</li>\n<li>telnetd/xinetd</li>\n</ol></li>\n</ul>"},{"layout":"post","title":"shell编程之内容查找grep","comments":1,"_content":"GREP (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用**正则表达式**搜索文本，并把匹配的行打印出来。\n<!-- more -->\n\n\n## 简介\nUnix的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。\n\n## 使用方法\n* 基本用法\n\n\t```bash\n\t# 搜索原始字符串\n\tgrep [-cinv] '搜索字符串' filename\n\t# 用正则表达式搜索字符串\n\tgrep -E 'pattern' filename\n\t```\n* 参数说明\n\t* `-c`\t统计查找到字符串的次数\n\t* `-i`\t忽略大小写\n\t* `-n`\t显示查找字符串的行号\n\t* `-v`\t反向选择\n\t* `-E`\tpattern中可以用扩展的正则表达式\n\n## 样例演示\n* 在/etc/passwd中查找root字符串,并显示所在行号\n\n\t```bash\n\tgrep -n 'root' /etc/passwd\n\t```\n![grep-n]({{ site.baseurl }}/assets/images/grep-n.png)\n* 在/etc/passwd中查找oo字符串出现的行次数\n\n\t```bash\n\tgrep -c 'oo' /etc/passwd\n\t```\n![grep-c]({{ site.baseurl }}/assets/images/grep-c.png)\n* 在/etc/passwd中查找oo字符串未出现的行\n\n\t```bash\n\tgrep -vn 'oo' /etc/passwd\n\t```\n![grep-v]({{ site.baseurl }}/assets/images/grep-v.png)\n* 在/etc/passwd中查找以b开头的字符串\n\n\t```bash\n\tgrep -E '^[b]' /etc/passwd\n\t```\n![grep-E]({{ site.baseurl }}/assets/images/grep-E.png)\n","source":"_posts/2015-05-16-shell编程之内容查找grep.md","raw":"---\nlayout:\tpost\ntitle:\tshell编程之内容查找grep\ncategories:\n- TECHNOLOGY\ntags:\n- Shell\npermalink:  Explore-grep-Shell\ncomments:\ttrue\n---\nGREP (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用**正则表达式**搜索文本，并把匹配的行打印出来。\n<!-- more -->\n\n\n## 简介\nUnix的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。\n\n## 使用方法\n* 基本用法\n\n\t```bash\n\t# 搜索原始字符串\n\tgrep [-cinv] '搜索字符串' filename\n\t# 用正则表达式搜索字符串\n\tgrep -E 'pattern' filename\n\t```\n* 参数说明\n\t* `-c`\t统计查找到字符串的次数\n\t* `-i`\t忽略大小写\n\t* `-n`\t显示查找字符串的行号\n\t* `-v`\t反向选择\n\t* `-E`\tpattern中可以用扩展的正则表达式\n\n## 样例演示\n* 在/etc/passwd中查找root字符串,并显示所在行号\n\n\t```bash\n\tgrep -n 'root' /etc/passwd\n\t```\n![grep-n]({{ site.baseurl }}/assets/images/grep-n.png)\n* 在/etc/passwd中查找oo字符串出现的行次数\n\n\t```bash\n\tgrep -c 'oo' /etc/passwd\n\t```\n![grep-c]({{ site.baseurl }}/assets/images/grep-c.png)\n* 在/etc/passwd中查找oo字符串未出现的行\n\n\t```bash\n\tgrep -vn 'oo' /etc/passwd\n\t```\n![grep-v]({{ site.baseurl }}/assets/images/grep-v.png)\n* 在/etc/passwd中查找以b开头的字符串\n\n\t```bash\n\tgrep -E '^[b]' /etc/passwd\n\t```\n![grep-E]({{ site.baseurl }}/assets/images/grep-E.png)\n","slug":"Explore-grep-Shell","published":1,"date":"2015-05-15T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j18000yl73y606x3i7q","content":"<p>GREP (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用<strong>正则表达式</strong>搜索文本，并把匹配的行打印出来。 <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p>Unix的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。</p>\n<h2 id=\"使用方法\">使用方法</h2>\n<ul>\n<li><p>基本用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 搜索原始字符串</span></div><div class=\"line\">grep [-cinv] <span class=\"string\">'搜索字符串'</span> filename</div><div class=\"line\"><span class=\"comment\"># 用正则表达式搜索字符串</span></div><div class=\"line\">grep -E <span class=\"string\">'pattern'</span> filename</div></pre></td></tr></table></figure></li>\n<li>参数说明\n<ul>\n<li><code>-c</code> 统计查找到字符串的次数</li>\n<li><code>-i</code> 忽略大小写</li>\n<li><code>-n</code> 显示查找字符串的行号</li>\n<li><code>-v</code> 反向选择</li>\n<li><code>-E</code> pattern中可以用扩展的正则表达式</li>\n</ul></li>\n</ul>\n<h2 id=\"样例演示\">样例演示</h2>\n<ul>\n<li><p>在/etc/passwd中查找root字符串,并显示所在行号</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep -n <span class=\"string\">'root'</span> /etc/passwd</div></pre></td></tr></table></figure></li>\n</ul>\n<p>[grep-n](/assets/images/grep-n.png) * 在/etc/passwd中查找oo字符串出现的行次数</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep -c <span class=\"string\">'oo'</span> /etc/passwd</div></pre></td></tr></table></figure></code></pre>\n<p>[grep-c]({{ site.baseurl }}/assets/images/grep-c.png) * 在/etc/passwd中查找oo字符串未出现的行</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep -vn <span class=\"string\">'oo'</span> /etc/passwd</div></pre></td></tr></table></figure></code></pre>\n<p>[grep-v](/assets/images/grep-v.png) * 在/etc/passwd中查找以b开头的字符串</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep -E <span class=\"string\">'^[b]'</span> /etc/passwd</div></pre></td></tr></table></figure></code></pre>\n<p>[grep-E](/assets/images/grep-E.png)</p>\n","site":{"data":{}},"excerpt":"<p>GREP (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用<strong>正则表达式</strong>搜索文本，并把匹配的行打印出来。","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p>Unix的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。</p>\n<h2 id=\"使用方法\">使用方法</h2>\n<ul>\n<li><p>基本用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 搜索原始字符串</span></div><div class=\"line\">grep [-cinv] <span class=\"string\">'搜索字符串'</span> filename</div><div class=\"line\"><span class=\"comment\"># 用正则表达式搜索字符串</span></div><div class=\"line\">grep -E <span class=\"string\">'pattern'</span> filename</div></pre></td></tr></table></figure></li>\n<li>参数说明\n<ul>\n<li><code>-c</code> 统计查找到字符串的次数</li>\n<li><code>-i</code> 忽略大小写</li>\n<li><code>-n</code> 显示查找字符串的行号</li>\n<li><code>-v</code> 反向选择</li>\n<li><code>-E</code> pattern中可以用扩展的正则表达式</li>\n</ul></li>\n</ul>\n<h2 id=\"样例演示\">样例演示</h2>\n<ul>\n<li><p>在/etc/passwd中查找root字符串,并显示所在行号</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep -n <span class=\"string\">'root'</span> /etc/passwd</div></pre></td></tr></table></figure></li>\n</ul>\n<p>[grep-n](/assets/images/grep-n.png) * 在/etc/passwd中查找oo字符串出现的行次数</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep -c <span class=\"string\">'oo'</span> /etc/passwd</div></pre></td></tr></table></figure></code></pre>\n<p>[grep-c]({{ site.baseurl }}/assets/images/grep-c.png) * 在/etc/passwd中查找oo字符串未出现的行</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep -vn <span class=\"string\">'oo'</span> /etc/passwd</div></pre></td></tr></table></figure></code></pre>\n<p>[grep-v](/assets/images/grep-v.png) * 在/etc/passwd中查找以b开头的字符串</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep -E <span class=\"string\">'^[b]'</span> /etc/passwd</div></pre></td></tr></table></figure></code></pre>\n<p>[grep-E](/assets/images/grep-E.png)</p>"},{"layout":"post","title":"shell编程之文本处理工具sed","comments":1,"_content":"SED命令的功能同awk类似，差别在于，sed简单，对列处理的功能要差一些，awk的功能复杂，对列处理的功能比较强大，sed全称是：Stream EDitor.它主要是**以行为单位**进行处理，可以将数据行进行*替换*、*删除*、*新增*、*选取*等特定工作.特别强调一点,==sed的操作对源文件不作修改==.\n\n\n\n## 使用方法\n* 基本用法\n\n\t```bash\n\tsed [-nei] 'command' filename\n\t```\n* 参数说明\n\t* `-n`\t使用安静模式.只有经过处理的那一行才会被列出来.[一般情况,所有内容都会被列到屏幕上]\n\t* `-e`\t直接在指令列模式上进行sed的动作编辑\n\t* `-i`\t直接修改读取的档案内容,而不是有屏幕输出\n* 核心命令\n\t* `a`\t**新增**,a后面可以接字符串,而这些字符串会在新的一行出现(目前的下一行)\n\t* `c`\t**取代**,c后面可以接字符串,这些字符串可以取代n1,n2之间的行\n\t* `d`\t**删除**,d后面不接任何字符串.\n\t* `i`\t**插入**,i后面可以接字符串,而这些字符串会在新的一行出现(目前的上一行)\n\t* `p`\t**打印**,通常会和sed -n 一起使用\n\t* `s`\t**取代**,通常这个s动作可以搭配正则表达式一起使用.\n\t* `n`\t读取下一行\n\t* `y`\t指定**替换**[sed 'y/abc/ABC' file -- a换成A,b换成B,c换成C]\n\t* `q`\t**退出**\n\n## 样例演示\n* 显示第40行到最后一行\n\n\t```bash\n\tsed -n '40,$p' /etc/passwd\n\t```\n![sed-n]({{ site.baseurl }}/assets/images/sed-n.png)\n* 在第40行到最后一行后面添加字符串\"\\=\\=\\=I am here\\=\\=\\=\"\n\n\t```bash\n\tsed '40,$a ===I am here===' /etc/passwd\n\t```\n![sed-a]({{ site.baseurl }}/assets/images/sed-a.png)\n* 使用模式进行查询sys字符\n\n\t```bash\n\tsed -n '/sys/p' /etc/passwd\n\t```\n![sed-ns]({{ site.baseurl }}/assets/images/sed-ns.png)\n* 替换一行中的某部分\n\n\t```bash\n\tsed -n 's/sys/replace/p' /etc/passwd\n\t```\n![sed-rep]({{ site.baseurl }}/assets/images/sed-rep.png)\n","source":"_posts/2015-05-20-shell编程之文本处理工具sed.md","raw":"---\nlayout:\tpost\ntitle:\tshell编程之文本处理工具sed\ncategories:\n- TECHNOLOGY\ntags:\n- Shell\npermalink:  Explore-sed-Shell\ncomments:\ttrue\n---\nSED命令的功能同awk类似，差别在于，sed简单，对列处理的功能要差一些，awk的功能复杂，对列处理的功能比较强大，sed全称是：Stream EDitor.它主要是**以行为单位**进行处理，可以将数据行进行*替换*、*删除*、*新增*、*选取*等特定工作.特别强调一点,==sed的操作对源文件不作修改==.\n\n\n\n## 使用方法\n* 基本用法\n\n\t```bash\n\tsed [-nei] 'command' filename\n\t```\n* 参数说明\n\t* `-n`\t使用安静模式.只有经过处理的那一行才会被列出来.[一般情况,所有内容都会被列到屏幕上]\n\t* `-e`\t直接在指令列模式上进行sed的动作编辑\n\t* `-i`\t直接修改读取的档案内容,而不是有屏幕输出\n* 核心命令\n\t* `a`\t**新增**,a后面可以接字符串,而这些字符串会在新的一行出现(目前的下一行)\n\t* `c`\t**取代**,c后面可以接字符串,这些字符串可以取代n1,n2之间的行\n\t* `d`\t**删除**,d后面不接任何字符串.\n\t* `i`\t**插入**,i后面可以接字符串,而这些字符串会在新的一行出现(目前的上一行)\n\t* `p`\t**打印**,通常会和sed -n 一起使用\n\t* `s`\t**取代**,通常这个s动作可以搭配正则表达式一起使用.\n\t* `n`\t读取下一行\n\t* `y`\t指定**替换**[sed 'y/abc/ABC' file -- a换成A,b换成B,c换成C]\n\t* `q`\t**退出**\n\n## 样例演示\n* 显示第40行到最后一行\n\n\t```bash\n\tsed -n '40,$p' /etc/passwd\n\t```\n![sed-n]({{ site.baseurl }}/assets/images/sed-n.png)\n* 在第40行到最后一行后面添加字符串\"\\=\\=\\=I am here\\=\\=\\=\"\n\n\t```bash\n\tsed '40,$a ===I am here===' /etc/passwd\n\t```\n![sed-a]({{ site.baseurl }}/assets/images/sed-a.png)\n* 使用模式进行查询sys字符\n\n\t```bash\n\tsed -n '/sys/p' /etc/passwd\n\t```\n![sed-ns]({{ site.baseurl }}/assets/images/sed-ns.png)\n* 替换一行中的某部分\n\n\t```bash\n\tsed -n 's/sys/replace/p' /etc/passwd\n\t```\n![sed-rep]({{ site.baseurl }}/assets/images/sed-rep.png)\n","slug":"Explore-sed-Shell","published":1,"date":"2015-05-19T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j19000zl73ysdkbqfks","content":"<p>SED命令的功能同awk类似，差别在于，sed简单，对列处理的功能要差一些，awk的功能复杂，对列处理的功能比较强大，sed全称是：Stream EDitor.它主要是<strong>以行为单位</strong>进行处理，可以将数据行进行<em>替换</em>、<em>删除</em>、<em>新增</em>、<em>选取</em>等特定工作.特别强调一点,==sed的操作对源文件不作修改==.</p>\n<h2 id=\"使用方法\">使用方法</h2>\n<ul>\n<li><p>基本用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed [-nei] <span class=\"string\">'command'</span> filename</div></pre></td></tr></table></figure></li>\n<li>参数说明\n<ul>\n<li><code>-n</code> 使用安静模式.只有经过处理的那一行才会被列出来.[一般情况,所有内容都会被列到屏幕上]</li>\n<li><code>-e</code> 直接在指令列模式上进行sed的动作编辑</li>\n<li><code>-i</code> 直接修改读取的档案内容,而不是有屏幕输出</li>\n</ul></li>\n<li>核心命令\n<ul>\n<li><code>a</code> <strong>新增</strong>,a后面可以接字符串,而这些字符串会在新的一行出现(目前的下一行)</li>\n<li><code>c</code> <strong>取代</strong>,c后面可以接字符串,这些字符串可以取代n1,n2之间的行</li>\n<li><code>d</code> <strong>删除</strong>,d后面不接任何字符串.</li>\n<li><code>i</code> <strong>插入</strong>,i后面可以接字符串,而这些字符串会在新的一行出现(目前的上一行)</li>\n<li><code>p</code> <strong>打印</strong>,通常会和sed -n 一起使用</li>\n<li><code>s</code> <strong>取代</strong>,通常这个s动作可以搭配正则表达式一起使用.</li>\n<li><code>n</code> 读取下一行</li>\n<li><code>y</code> 指定<strong>替换</strong>[sed ‘y/abc/ABC’ file – a换成A,b换成B,c换成C]</li>\n<li><code>q</code> <strong>退出</strong></li>\n</ul></li>\n</ul>\n<h2 id=\"样例演示\">样例演示</h2>\n<ul>\n<li><p>显示第40行到最后一行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -n <span class=\"string\">'40,$p'</span> /etc/passwd</div></pre></td></tr></table></figure></li>\n</ul>\n<p>[sed-n](/assets/images/sed-n.png) * 在第40行到最后一行后面添加字符串“===I am here===”</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed <span class=\"string\">'40,$a ===I am here==='</span> /etc/passwd</div></pre></td></tr></table></figure></code></pre>\n<p>[sed-a]({{ site.baseurl }}/assets/images/sed-a.png) * 使用模式进行查询sys字符</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -n <span class=\"string\">'/sys/p'</span> /etc/passwd</div></pre></td></tr></table></figure></code></pre>\n<p>[sed-ns](/assets/images/sed-ns.png) * 替换一行中的某部分</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -n <span class=\"string\">'s/sys/replace/p'</span> /etc/passwd</div></pre></td></tr></table></figure></code></pre>\n<p>[sed-rep](/assets/images/sed-rep.png)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>SED命令的功能同awk类似，差别在于，sed简单，对列处理的功能要差一些，awk的功能复杂，对列处理的功能比较强大，sed全称是：Stream EDitor.它主要是<strong>以行为单位</strong>进行处理，可以将数据行进行<em>替换</em>、<em>删除</em>、<em>新增</em>、<em>选取</em>等特定工作.特别强调一点,==sed的操作对源文件不作修改==.</p>\n<h2 id=\"使用方法\">使用方法</h2>\n<ul>\n<li><p>基本用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed [-nei] <span class=\"string\">'command'</span> filename</div></pre></td></tr></table></figure></li>\n<li>参数说明\n<ul>\n<li><code>-n</code> 使用安静模式.只有经过处理的那一行才会被列出来.[一般情况,所有内容都会被列到屏幕上]</li>\n<li><code>-e</code> 直接在指令列模式上进行sed的动作编辑</li>\n<li><code>-i</code> 直接修改读取的档案内容,而不是有屏幕输出</li>\n</ul></li>\n<li>核心命令\n<ul>\n<li><code>a</code> <strong>新增</strong>,a后面可以接字符串,而这些字符串会在新的一行出现(目前的下一行)</li>\n<li><code>c</code> <strong>取代</strong>,c后面可以接字符串,这些字符串可以取代n1,n2之间的行</li>\n<li><code>d</code> <strong>删除</strong>,d后面不接任何字符串.</li>\n<li><code>i</code> <strong>插入</strong>,i后面可以接字符串,而这些字符串会在新的一行出现(目前的上一行)</li>\n<li><code>p</code> <strong>打印</strong>,通常会和sed -n 一起使用</li>\n<li><code>s</code> <strong>取代</strong>,通常这个s动作可以搭配正则表达式一起使用.</li>\n<li><code>n</code> 读取下一行</li>\n<li><code>y</code> 指定<strong>替换</strong>[sed ‘y/abc/ABC’ file – a换成A,b换成B,c换成C]</li>\n<li><code>q</code> <strong>退出</strong></li>\n</ul></li>\n</ul>\n<h2 id=\"样例演示\">样例演示</h2>\n<ul>\n<li><p>显示第40行到最后一行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -n <span class=\"string\">'40,$p'</span> /etc/passwd</div></pre></td></tr></table></figure></li>\n</ul>\n<p>[sed-n](/assets/images/sed-n.png) * 在第40行到最后一行后面添加字符串“===I am here===”</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed <span class=\"string\">'40,$a ===I am here==='</span> /etc/passwd</div></pre></td></tr></table></figure></code></pre>\n<p>[sed-a]({{ site.baseurl }}/assets/images/sed-a.png) * 使用模式进行查询sys字符</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -n <span class=\"string\">'/sys/p'</span> /etc/passwd</div></pre></td></tr></table></figure></code></pre>\n<p>[sed-ns](/assets/images/sed-ns.png) * 替换一行中的某部分</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -n <span class=\"string\">'s/sys/replace/p'</span> /etc/passwd</div></pre></td></tr></table></figure></code></pre>\n<p>[sed-rep](/assets/images/sed-rep.png)</p>\n"},{"layout":"post","title":"shell编程之文本处理工具awk","comments":1,"_content":"AWK是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说==awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理==。\n<!-- more -->\n\n\n## 简介\nAWK其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序**读取输入文件**、**为数据排序**、**处理数据**、**对输入执行计算**以及**生成报表**，还有无数其他的功能。\n\n## 使用方法\n* 基本用法\n\n\t```bash\n\tawk [-F FS] 'pattern{action}' filename\n\t```\n* 参数说明\n\t* pattern\t表示awk在数据中查找的内容\n\t* action\t在找到匹配内容时所执行的一系列命令\n\t* `-F FS`\t指定域分割符为FS[==一行代表一个记录,一个记录按FS分割成多个域==]\n* 核心action\n\t* 内置变量\n\t\t* `ARGC`\t命令行数量个数\n\t\t* `ARGV`\t命令行变元数组\n\t\t* `FILENAME`\t当前输入文件名\n\t\t* `NR`\t当前文件中的记录号(行号)\n\t\t* `FS`\t设置域分隔符,等价于-F\n\t\t* `RS`\t设置记录分隔符,默认是'\\n'\n\t\t* `NF`\t浏览记录中域的个数\n\t\t* `NR`\t已读的记录数\n\t\t* `OFS`\t输出域分隔符\n\t\t* `ORS`\t输出记录分隔符\n\t\t* `$0`\t整条记录\n\t\t* `$1/2`\t第1/2个域\n\t* 变量和赋值\n\t\t* 变量值可以是数字或字符串,关键是怎么用.\n\t* 条件语句和循环语句完全借鉴c语言\n\t* 内置函数\n\t\t* 数字\t`atan2`/`cos`/`exp`/`int`/`log`/`rand`/`sin`/`sqrt`/`srand`\n\t\t* 字符串\t`index`/`length`/`match`/`toupper`/`tolower`/`substr`/`system`/`systime`\n\n## 样例演示\n* 统计/etc/passwd:文件名,每行的行号,每行的列数,对应的完整行内容\n\n\t```bash\n\tawk -F ':' '{printf(\"filename:%11s,linenumber:%s,columns:%s,linecontent:%s\\n\",FILENAME,NR,NF,$0)}'\n\t```\n![awk-var]({{ site.baseurl }}/assets/images/awk-var.png)\n* 统计/etc/passwd中出现oo次数\n\n\t```bash\n\tawk -F ':' 'BEGIN{count=0;printf(\"login_name\\tpasswd\\n\")} /oo/{printf(\"%-15s\\t%s\\n\",$1,$2);count++} END{printf(\"count is %d\\n\",count)}'\n\t```\n![awk-begend]({{ site.baseurl }}/assets/images/awk-begend.png)\n\t> **注意:**   \n\t> BEGIN{}表示在处理任意行之前进行的操作.END{}表示在处理完所有行之后进行的操作.\n* 统计/etc/passwd中第1列以s开头的行\n\n\t```bash\n\tawk -F ':' '$1~/^s/{printf(\"%s\\n\",$1)}'\n\t```\n![awk-s]({{ site.baseurl }}/assets/images/awk-s.png)\n* 统计/etc/passwd中第1列为sys的行\n\n\t```bash\n\tawk -F ':' '$1==\"sys\"{printf(\"%s\\n\",$1)}'\n\t```\n![awk==]({{ site.baseurl }}/assets/images/awk==.png)\n\t> **注意:**   \n\t> ~和==都是匹配,不过~是不精确的比较,一般跟正则连用\n","source":"_posts/2015-05-18-shell编程之文本处理工具awk.md","raw":"---\nlayout:\tpost\ntitle:\tshell编程之文本处理工具awk\ncategories:\n- TECHNOLOGY\ntags:\n- Shell\npermalink:  Explore-awk-Shell\ncomments:\ttrue\n---\nAWK是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说==awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理==。\n<!-- more -->\n\n\n## 简介\nAWK其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序**读取输入文件**、**为数据排序**、**处理数据**、**对输入执行计算**以及**生成报表**，还有无数其他的功能。\n\n## 使用方法\n* 基本用法\n\n\t```bash\n\tawk [-F FS] 'pattern{action}' filename\n\t```\n* 参数说明\n\t* pattern\t表示awk在数据中查找的内容\n\t* action\t在找到匹配内容时所执行的一系列命令\n\t* `-F FS`\t指定域分割符为FS[==一行代表一个记录,一个记录按FS分割成多个域==]\n* 核心action\n\t* 内置变量\n\t\t* `ARGC`\t命令行数量个数\n\t\t* `ARGV`\t命令行变元数组\n\t\t* `FILENAME`\t当前输入文件名\n\t\t* `NR`\t当前文件中的记录号(行号)\n\t\t* `FS`\t设置域分隔符,等价于-F\n\t\t* `RS`\t设置记录分隔符,默认是'\\n'\n\t\t* `NF`\t浏览记录中域的个数\n\t\t* `NR`\t已读的记录数\n\t\t* `OFS`\t输出域分隔符\n\t\t* `ORS`\t输出记录分隔符\n\t\t* `$0`\t整条记录\n\t\t* `$1/2`\t第1/2个域\n\t* 变量和赋值\n\t\t* 变量值可以是数字或字符串,关键是怎么用.\n\t* 条件语句和循环语句完全借鉴c语言\n\t* 内置函数\n\t\t* 数字\t`atan2`/`cos`/`exp`/`int`/`log`/`rand`/`sin`/`sqrt`/`srand`\n\t\t* 字符串\t`index`/`length`/`match`/`toupper`/`tolower`/`substr`/`system`/`systime`\n\n## 样例演示\n* 统计/etc/passwd:文件名,每行的行号,每行的列数,对应的完整行内容\n\n\t```bash\n\tawk -F ':' '{printf(\"filename:%11s,linenumber:%s,columns:%s,linecontent:%s\\n\",FILENAME,NR,NF,$0)}'\n\t```\n![awk-var]({{ site.baseurl }}/assets/images/awk-var.png)\n* 统计/etc/passwd中出现oo次数\n\n\t```bash\n\tawk -F ':' 'BEGIN{count=0;printf(\"login_name\\tpasswd\\n\")} /oo/{printf(\"%-15s\\t%s\\n\",$1,$2);count++} END{printf(\"count is %d\\n\",count)}'\n\t```\n![awk-begend]({{ site.baseurl }}/assets/images/awk-begend.png)\n\t> **注意:**   \n\t> BEGIN{}表示在处理任意行之前进行的操作.END{}表示在处理完所有行之后进行的操作.\n* 统计/etc/passwd中第1列以s开头的行\n\n\t```bash\n\tawk -F ':' '$1~/^s/{printf(\"%s\\n\",$1)}'\n\t```\n![awk-s]({{ site.baseurl }}/assets/images/awk-s.png)\n* 统计/etc/passwd中第1列为sys的行\n\n\t```bash\n\tawk -F ':' '$1==\"sys\"{printf(\"%s\\n\",$1)}'\n\t```\n![awk==]({{ site.baseurl }}/assets/images/awk==.png)\n\t> **注意:**   \n\t> ~和==都是匹配,不过~是不精确的比较,一般跟正则连用\n","slug":"Explore-awk-Shell","published":1,"date":"2015-05-17T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j190010l73ybd73fl7r","content":"<p>AWK是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说==awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理==。 <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p>AWK其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序<strong>读取输入文件</strong>、<strong>为数据排序</strong>、<strong>处理数据</strong>、<strong>对输入执行计算</strong>以及<strong>生成报表</strong>，还有无数其他的功能。</p>\n<h2 id=\"使用方法\">使用方法</h2>\n<ul>\n<li><p>基本用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk [-F FS] <span class=\"string\">'pattern&#123;action&#125;'</span> filename</div></pre></td></tr></table></figure></li>\n<li>参数说明\n<ul>\n<li>pattern 表示awk在数据中查找的内容</li>\n<li>action 在找到匹配内容时所执行的一系列命令</li>\n<li><code>-F FS</code> 指定域分割符为FS[==一行代表一个记录,一个记录按FS分割成多个域==]</li>\n</ul></li>\n<li>核心action\n<ul>\n<li>内置变量\n<ul>\n<li><code>ARGC</code> 命令行数量个数</li>\n<li><code>ARGV</code> 命令行变元数组</li>\n<li><code>FILENAME</code> 当前输入文件名</li>\n<li><code>NR</code> 当前文件中的记录号(行号)</li>\n<li><code>FS</code> 设置域分隔符,等价于-F</li>\n<li><code>RS</code> 设置记录分隔符,默认是’’</li>\n<li><code>NF</code> 浏览记录中域的个数</li>\n<li><code>NR</code> 已读的记录数</li>\n<li><code>OFS</code> 输出域分隔符</li>\n<li><code>ORS</code> 输出记录分隔符</li>\n<li><code>$0</code> 整条记录</li>\n<li><code>$1/2</code> 第1/2个域</li>\n</ul></li>\n<li>变量和赋值\n<ul>\n<li>变量值可以是数字或字符串,关键是怎么用.</li>\n</ul></li>\n<li>条件语句和循环语句完全借鉴c语言</li>\n<li>内置函数\n<ul>\n<li>数字 <code>atan2</code>/<code>cos</code>/<code>exp</code>/<code>int</code>/<code>log</code>/<code>rand</code>/<code>sin</code>/<code>sqrt</code>/<code>srand</code></li>\n<li>字符串 <code>index</code>/<code>length</code>/<code>match</code>/<code>toupper</code>/<code>tolower</code>/<code>substr</code>/<code>system</code>/<code>systime</code></li>\n</ul></li>\n</ul></li>\n</ul>\n<h2 id=\"样例演示\">样例演示</h2>\n<ul>\n<li><p>统计/etc/passwd:文件名,每行的行号,每行的列数,对应的完整行内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk -F <span class=\"string\">':'</span> <span class=\"string\">'&#123;printf(\"filename:%11s,linenumber:%s,columns:%s,linecontent:%s\\n\",FILENAME,NR,NF,$0)&#125;'</span></div></pre></td></tr></table></figure></li>\n</ul>\n<p>[awk-var](/assets/images/awk-var.png) * 统计/etc/passwd中出现oo次数</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk -F <span class=\"string\">':'</span> <span class=\"string\">'BEGIN&#123;count=0;printf(\"login_name\\tpasswd\\n\")&#125; /oo/&#123;printf(\"%-15s\\t%s\\n\",$1,$2);count++&#125; END&#123;printf(\"count is %d\\n\",count)&#125;'</span></div></pre></td></tr></table></figure></code></pre>\n<p>[awk-begend]({{ site.baseurl }}/assets/images/awk-begend.png) &gt; <strong>注意:</strong><br>\n&gt; BEGIN{}表示在处理任意行之前进行的操作.END{}表示在处理完所有行之后进行的操作. * 统计/etc/passwd中第1列以s开头的行</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk -F <span class=\"string\">':'</span> <span class=\"string\">'$1~/^s/&#123;printf(\"%s\\n\",$1)&#125;'</span></div></pre></td></tr></table></figure></code></pre>\n<p>[awk-s](/assets/images/awk-s.png) * 统计/etc/passwd中第1列为sys的行</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk -F <span class=\"string\">':'</span> <span class=\"string\">'$1==\"sys\"&#123;printf(\"%s\\n\",$1)&#125;'</span></div></pre></td></tr></table></figure></code></pre>\n<p>[awk==](/assets/images/awk==.png) &gt; <strong>注意:</strong><br>\n&gt; <sub>和==都是匹配,不过</sub>是不精确的比较,一般跟正则连用</p>\n","site":{"data":{}},"excerpt":"<p>AWK是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说==awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理==。","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p>AWK其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序<strong>读取输入文件</strong>、<strong>为数据排序</strong>、<strong>处理数据</strong>、<strong>对输入执行计算</strong>以及<strong>生成报表</strong>，还有无数其他的功能。</p>\n<h2 id=\"使用方法\">使用方法</h2>\n<ul>\n<li><p>基本用法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk [-F FS] <span class=\"string\">'pattern&#123;action&#125;'</span> filename</div></pre></td></tr></table></figure></li>\n<li>参数说明\n<ul>\n<li>pattern 表示awk在数据中查找的内容</li>\n<li>action 在找到匹配内容时所执行的一系列命令</li>\n<li><code>-F FS</code> 指定域分割符为FS[==一行代表一个记录,一个记录按FS分割成多个域==]</li>\n</ul></li>\n<li>核心action\n<ul>\n<li>内置变量\n<ul>\n<li><code>ARGC</code> 命令行数量个数</li>\n<li><code>ARGV</code> 命令行变元数组</li>\n<li><code>FILENAME</code> 当前输入文件名</li>\n<li><code>NR</code> 当前文件中的记录号(行号)</li>\n<li><code>FS</code> 设置域分隔符,等价于-F</li>\n<li><code>RS</code> 设置记录分隔符,默认是’’</li>\n<li><code>NF</code> 浏览记录中域的个数</li>\n<li><code>NR</code> 已读的记录数</li>\n<li><code>OFS</code> 输出域分隔符</li>\n<li><code>ORS</code> 输出记录分隔符</li>\n<li><code>$0</code> 整条记录</li>\n<li><code>$1/2</code> 第1/2个域</li>\n</ul></li>\n<li>变量和赋值\n<ul>\n<li>变量值可以是数字或字符串,关键是怎么用.</li>\n</ul></li>\n<li>条件语句和循环语句完全借鉴c语言</li>\n<li>内置函数\n<ul>\n<li>数字 <code>atan2</code>/<code>cos</code>/<code>exp</code>/<code>int</code>/<code>log</code>/<code>rand</code>/<code>sin</code>/<code>sqrt</code>/<code>srand</code></li>\n<li>字符串 <code>index</code>/<code>length</code>/<code>match</code>/<code>toupper</code>/<code>tolower</code>/<code>substr</code>/<code>system</code>/<code>systime</code></li>\n</ul></li>\n</ul></li>\n</ul>\n<h2 id=\"样例演示\">样例演示</h2>\n<ul>\n<li><p>统计/etc/passwd:文件名,每行的行号,每行的列数,对应的完整行内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk -F <span class=\"string\">':'</span> <span class=\"string\">'&#123;printf(\"filename:%11s,linenumber:%s,columns:%s,linecontent:%s\\n\",FILENAME,NR,NF,$0)&#125;'</span></div></pre></td></tr></table></figure></li>\n</ul>\n<p>[awk-var](/assets/images/awk-var.png) * 统计/etc/passwd中出现oo次数</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk -F <span class=\"string\">':'</span> <span class=\"string\">'BEGIN&#123;count=0;printf(\"login_name\\tpasswd\\n\")&#125; /oo/&#123;printf(\"%-15s\\t%s\\n\",$1,$2);count++&#125; END&#123;printf(\"count is %d\\n\",count)&#125;'</span></div></pre></td></tr></table></figure></code></pre>\n<p>[awk-begend]({{ site.baseurl }}/assets/images/awk-begend.png) &gt; <strong>注意:</strong><br>\n&gt; BEGIN{}表示在处理任意行之前进行的操作.END{}表示在处理完所有行之后进行的操作. * 统计/etc/passwd中第1列以s开头的行</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk -F <span class=\"string\">':'</span> <span class=\"string\">'$1~/^s/&#123;printf(\"%s\\n\",$1)&#125;'</span></div></pre></td></tr></table></figure></code></pre>\n<p>[awk-s](/assets/images/awk-s.png) * 统计/etc/passwd中第1列为sys的行</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">awk -F <span class=\"string\">':'</span> <span class=\"string\">'$1==\"sys\"&#123;printf(\"%s\\n\",$1)&#125;'</span></div></pre></td></tr></table></figure></code></pre>\n<p>[awk==](/assets/images/awk==.png) &gt; <strong>注意:</strong><br>\n&gt; <sub>和==都是匹配,不过</sub>是不精确的比较,一般跟正则连用</p>"},{"layout":"post","title":"shell编程之系统进程监控","comments":1,"_content":"本问内容均是根据网络上一篇博文[使用shell脚本对linux系统和进程资源进行监控](http://blog.jobbole.com/22318/)对其验证学习的总结.\n<!-- more -->\n\n\n## 命令支持\n* `ps`\t查看系统中瞬间进程信息\n\t* `-u`\t指定所属用户\n* `grep`\t查找文件中符号字符串的当前行\n\t* `-v`\t反向选择,用于剔除包含'某些字符串'的行\n* `sed`\t一个非交互性文本编辑器，它编辑文件或标准输入导出的文件，一次只能处理一行内容\n\t* `-n`\t读取下一个输入行，用下一个命令处理新的行而不是用第一个命令(同时阻止sed的自动输出)\n* `awk`\t每接收文件的一行，然后执行相应的命令，来处理文本\n* `vimstat`\t展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况\n* `bc`\t数字计算\n\n## 获取进程id\n* 代码演示\n\n\t```bash\n\t#! /bin/bash\n\t# 通过进程的使用者和名称来获取进程的PID\n\n\t# 提示脚本用法\n\tif [ \"$#\" -ne 2 ]\n\tthen\n\t\techo \"Usage: $0 pUser pName\"\n\t\texit 1\n\tfi\n\n\tpUser=$1\n\tpName=$2\n\tpId=`ps -u $pUser | grep $pName | grep -v 'grep' | grep -v 'vi' | grep -v 'dbx\\n' | grep -v 'tail' | grep -v 'start' | grep -v 'stop' | sed -n 1p | awk '{print $1}'`\n\n\t# 检测进程是否存在\n\tif [ \"-$pId\" == \"-\" ]\n\tthen\n\t\techo \"The process does not exist.\"\n\telse\n\t\techo $pId\n\tfi\n\t```\n* 个人理解\n在获取pId的命令中,ps挑选用户,再用grep查找进程,剔除掉包含grep,vi,dbx,tail,start,stop的命令行==[不懂为嘛]==,sed选取第一行,awk提取出pId.\n\n## 监控进程使用的CPU&内存\n* 监控CPU\n\n\t```bash\n\t# 通过pId来获取该进程CPU的使用情况\n\tfunction GetCpu\n\t{\n\t\tcpuValue=`ps -p $1 -o pcpu | grep -v CPU | awk '{print $1}' | awk -F. '{print $1}'`\n\t\techo $cpuValue\n\t}\n\t```\n\t> **注意:**  \n\t> 最后的`awk`是取整的目的.\n* 监控内存\n\n\t```bash\n\t# 通过pId来获取进程内存使用情况\n\tfunction GetMem\n\t{\n\t\tmemUsage=`ps -p $1 -o vsz | grep -v VSZ`\n\t\t((memUsage /= 1000))\n\t\techo $memUsage\n\t}\n\t```\n* 句柄数\n句柄使用过高可能由于负载过高，句柄泄露等情况，通过脚本对业务进程句柄使用量进行时时监控，可以在异常时及时发送告警（例如通过短信），便于维护人员及时处理\n\n\t```bash\n\t# 通过pId来获取该进程句柄使用量\n\tfunction GetHandle\n\t{\n\t\thandle=`ls /proc/$1/fd | wc -l`\n\t\techo $handle\n\t}\n\t```\n* 监控系统CPU\n\n\t```bash\n\t# 获取系统CPU负载\n\tfunction GetSysCpu\n\t{\n\t\tcpuIdle=`vmstat 1 5 | sed -n '3,$p' | awk '{x = x + $15} END {print x/5}' | awk -F. '{print $1}'`\n\t\tcpuNum=`echo \"100-$cpuIdle\" | bc`\n\t\techo $cpuNum\n\t}\n\t```\n\t> **注解:**  \n\t> 使用 vmstat 取 5 次系统 CPU 的 idle 值，取平均值，然后通过与 100 取差得到当前 CPU 的实际占用值。\n\n## 完整演示\n* 代码文件[checkPerform.sh]({{ site.baseurl }}/assets/attachs/checkPerform.sh.txt)\n* 效果演示\n查询由hjy打开的google浏览器chromium的使用情况\n![perform]({{ site.baseurl }}/assets/images/perform.png)\n* 结果分析\n==目前google浏览器cpu使用占3%,而整个系统的cpu使用是5%.内存使用是2210M,超了不少,运行的进程有40个,也超了不少,而占用的句柄数是426,也是比较多的.==\n","source":"_posts/2015-05-22-shell编程之系统进程监控.md","raw":"---\nlayout:\tpost\ntitle:\tshell编程之系统进程监控\ncategories:\n- TECHNOLOGY\ntags:\n- Shell\npermalink:  Explore-systemMonitor-shell\ncomments:\ttrue\n---\n本问内容均是根据网络上一篇博文[使用shell脚本对linux系统和进程资源进行监控](http://blog.jobbole.com/22318/)对其验证学习的总结.\n<!-- more -->\n\n\n## 命令支持\n* `ps`\t查看系统中瞬间进程信息\n\t* `-u`\t指定所属用户\n* `grep`\t查找文件中符号字符串的当前行\n\t* `-v`\t反向选择,用于剔除包含'某些字符串'的行\n* `sed`\t一个非交互性文本编辑器，它编辑文件或标准输入导出的文件，一次只能处理一行内容\n\t* `-n`\t读取下一个输入行，用下一个命令处理新的行而不是用第一个命令(同时阻止sed的自动输出)\n* `awk`\t每接收文件的一行，然后执行相应的命令，来处理文本\n* `vimstat`\t展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况\n* `bc`\t数字计算\n\n## 获取进程id\n* 代码演示\n\n\t```bash\n\t#! /bin/bash\n\t# 通过进程的使用者和名称来获取进程的PID\n\n\t# 提示脚本用法\n\tif [ \"$#\" -ne 2 ]\n\tthen\n\t\techo \"Usage: $0 pUser pName\"\n\t\texit 1\n\tfi\n\n\tpUser=$1\n\tpName=$2\n\tpId=`ps -u $pUser | grep $pName | grep -v 'grep' | grep -v 'vi' | grep -v 'dbx\\n' | grep -v 'tail' | grep -v 'start' | grep -v 'stop' | sed -n 1p | awk '{print $1}'`\n\n\t# 检测进程是否存在\n\tif [ \"-$pId\" == \"-\" ]\n\tthen\n\t\techo \"The process does not exist.\"\n\telse\n\t\techo $pId\n\tfi\n\t```\n* 个人理解\n在获取pId的命令中,ps挑选用户,再用grep查找进程,剔除掉包含grep,vi,dbx,tail,start,stop的命令行==[不懂为嘛]==,sed选取第一行,awk提取出pId.\n\n## 监控进程使用的CPU&内存\n* 监控CPU\n\n\t```bash\n\t# 通过pId来获取该进程CPU的使用情况\n\tfunction GetCpu\n\t{\n\t\tcpuValue=`ps -p $1 -o pcpu | grep -v CPU | awk '{print $1}' | awk -F. '{print $1}'`\n\t\techo $cpuValue\n\t}\n\t```\n\t> **注意:**  \n\t> 最后的`awk`是取整的目的.\n* 监控内存\n\n\t```bash\n\t# 通过pId来获取进程内存使用情况\n\tfunction GetMem\n\t{\n\t\tmemUsage=`ps -p $1 -o vsz | grep -v VSZ`\n\t\t((memUsage /= 1000))\n\t\techo $memUsage\n\t}\n\t```\n* 句柄数\n句柄使用过高可能由于负载过高，句柄泄露等情况，通过脚本对业务进程句柄使用量进行时时监控，可以在异常时及时发送告警（例如通过短信），便于维护人员及时处理\n\n\t```bash\n\t# 通过pId来获取该进程句柄使用量\n\tfunction GetHandle\n\t{\n\t\thandle=`ls /proc/$1/fd | wc -l`\n\t\techo $handle\n\t}\n\t```\n* 监控系统CPU\n\n\t```bash\n\t# 获取系统CPU负载\n\tfunction GetSysCpu\n\t{\n\t\tcpuIdle=`vmstat 1 5 | sed -n '3,$p' | awk '{x = x + $15} END {print x/5}' | awk -F. '{print $1}'`\n\t\tcpuNum=`echo \"100-$cpuIdle\" | bc`\n\t\techo $cpuNum\n\t}\n\t```\n\t> **注解:**  \n\t> 使用 vmstat 取 5 次系统 CPU 的 idle 值，取平均值，然后通过与 100 取差得到当前 CPU 的实际占用值。\n\n## 完整演示\n* 代码文件[checkPerform.sh]({{ site.baseurl }}/assets/attachs/checkPerform.sh.txt)\n* 效果演示\n查询由hjy打开的google浏览器chromium的使用情况\n![perform]({{ site.baseurl }}/assets/images/perform.png)\n* 结果分析\n==目前google浏览器cpu使用占3%,而整个系统的cpu使用是5%.内存使用是2210M,超了不少,运行的进程有40个,也超了不少,而占用的句柄数是426,也是比较多的.==\n","slug":"Explore-systemMonitor-shell","published":1,"date":"2015-05-21T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1a0011l73y9larlp7u","content":"<p>本问内容均是根据网络上一篇博文<a href=\"http://blog.jobbole.com/22318/\" target=\"_blank\" rel=\"external\">使用shell脚本对linux系统和进程资源进行监控</a>对其验证学习的总结. <a id=\"more\"></a></p>\n<h2 id=\"命令支持\">命令支持</h2>\n<ul>\n<li><code>ps</code> 查看系统中瞬间进程信息\n<ul>\n<li><code>-u</code> 指定所属用户</li>\n</ul></li>\n<li><code>grep</code> 查找文件中符号字符串的当前行\n<ul>\n<li><code>-v</code> 反向选择,用于剔除包含’某些字符串’的行</li>\n</ul></li>\n<li><code>sed</code> 一个非交互性文本编辑器，它编辑文件或标准输入导出的文件，一次只能处理一行内容\n<ul>\n<li><code>-n</code> 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令(同时阻止sed的自动输出)</li>\n</ul></li>\n<li><code>awk</code> 每接收文件的一行，然后执行相应的命令，来处理文本</li>\n<li><code>vimstat</code> 展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况</li>\n<li><code>bc</code> 数字计算</li>\n</ul>\n<h2 id=\"获取进程id\">获取进程id</h2>\n<ul>\n<li><p>代码演示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#! /bin/bash</span></div><div class=\"line\"><span class=\"comment\"># 通过进程的使用者和名称来获取进程的PID</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 提示脚本用法</span></div><div class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$#</span>\"</span> <span class=\"_\">-ne</span> 2 ]</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"Usage: <span class=\"variable\">$0</span> pUser pName\"</span></div><div class=\"line\">\t<span class=\"built_in\">exit</span> 1</div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\">pUser=<span class=\"variable\">$1</span></div><div class=\"line\">pName=<span class=\"variable\">$2</span></div><div class=\"line\">pId=`ps -u <span class=\"variable\">$pUser</span> | grep <span class=\"variable\">$pName</span> | grep -v <span class=\"string\">'grep'</span> | grep -v <span class=\"string\">'vi'</span> | grep -v <span class=\"string\">'dbx\\n'</span> | grep -v <span class=\"string\">'tail'</span> | grep -v <span class=\"string\">'start'</span> | grep -v <span class=\"string\">'stop'</span> | sed -n 1p | awk <span class=\"string\">'&#123;print $1&#125;'</span>`</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 检测进程是否存在</span></div><div class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"-<span class=\"variable\">$pId</span>\"</span> == <span class=\"string\">\"-\"</span> ]</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"The process does not exist.\"</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$pId</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div></pre></td></tr></table></figure></li>\n<li><p>个人理解 在获取pId的命令中,ps挑选用户,再用grep查找进程,剔除掉包含grep,vi,dbx,tail,start,stop的命令行==[不懂为嘛]==,sed选取第一行,awk提取出pId.</p></li>\n</ul>\n<h2 id=\"监控进程使用的cpu内存\">监控进程使用的CPU&amp;内存</h2>\n<ul>\n<li><p>监控CPU</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 通过pId来获取该进程CPU的使用情况</span></div><div class=\"line\"><span class=\"keyword\">function</span> GetCpu</div><div class=\"line\">&#123;</div><div class=\"line\">\tcpuValue=`ps -p <span class=\"variable\">$1</span> -o pcpu | grep -v CPU | awk <span class=\"string\">'&#123;print $1&#125;'</span> | awk -F. <span class=\"string\">'&#123;print $1&#125;'</span>`</div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$cpuValue</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意:</strong><br>\n最后的<code>awk</code>是取整的目的.</p>\n</blockquote></li>\n<li><p>监控内存</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 通过pId来获取进程内存使用情况</span></div><div class=\"line\"><span class=\"keyword\">function</span> GetMem</div><div class=\"line\">&#123;</div><div class=\"line\">\tmemUsage=`ps -p <span class=\"variable\">$1</span> -o vsz | grep -v VSZ`</div><div class=\"line\">\t((memUsage /= 1000))</div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$memUsage</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><p>句柄数 句柄使用过高可能由于负载过高，句柄泄露等情况，通过脚本对业务进程句柄使用量进行时时监控，可以在异常时及时发送告警（例如通过短信），便于维护人员及时处理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 通过pId来获取该进程句柄使用量</span></div><div class=\"line\"><span class=\"keyword\">function</span> GetHandle</div><div class=\"line\">&#123;</div><div class=\"line\">\thandle=`ls /proc/<span class=\"variable\">$1</span>/fd | wc <span class=\"_\">-l</span>`</div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$handle</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><p>监控系统CPU</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 获取系统CPU负载</span></div><div class=\"line\"><span class=\"keyword\">function</span> GetSysCpu</div><div class=\"line\">&#123;</div><div class=\"line\">\tcpuIdle=`vmstat 1 5 | sed -n <span class=\"string\">'3,$p'</span> | awk <span class=\"string\">'&#123;x = x + $15&#125; END &#123;print x/5&#125;'</span> | awk -F. <span class=\"string\">'&#123;print $1&#125;'</span>`</div><div class=\"line\">\tcpuNum=`<span class=\"built_in\">echo</span> <span class=\"string\">\"100-<span class=\"variable\">$cpuIdle</span>\"</span> | bc`</div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$cpuNum</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注解:</strong><br>\n使用 vmstat 取 5 次系统 CPU 的 idle 值，取平均值，然后通过与 100 取差得到当前 CPU 的实际占用值。</p>\n</blockquote></li>\n</ul>\n<h2 id=\"完整演示\">完整演示</h2>\n<ul>\n<li>代码文件[checkPerform.sh](/assets/attachs/checkPerform.sh.txt)</li>\n<li>效果演示 查询由hjy打开的google浏览器chromium的使用情况 [perform](/assets/images/perform.png)</li>\n<li>结果分析 ==目前google浏览器cpu使用占3%,而整个系统的cpu使用是5%.内存使用是2210M,超了不少,运行的进程有40个,也超了不少,而占用的句柄数是426,也是比较多的.==</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本问内容均是根据网络上一篇博文<a href=\"http://blog.jobbole.com/22318/\" target=\"_blank\" rel=\"external\">使用shell脚本对linux系统和进程资源进行监控</a>对其验证学习的总结.","more":"</p>\n<h2 id=\"命令支持\">命令支持</h2>\n<ul>\n<li><code>ps</code> 查看系统中瞬间进程信息\n<ul>\n<li><code>-u</code> 指定所属用户</li>\n</ul></li>\n<li><code>grep</code> 查找文件中符号字符串的当前行\n<ul>\n<li><code>-v</code> 反向选择,用于剔除包含’某些字符串’的行</li>\n</ul></li>\n<li><code>sed</code> 一个非交互性文本编辑器，它编辑文件或标准输入导出的文件，一次只能处理一行内容\n<ul>\n<li><code>-n</code> 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令(同时阻止sed的自动输出)</li>\n</ul></li>\n<li><code>awk</code> 每接收文件的一行，然后执行相应的命令，来处理文本</li>\n<li><code>vimstat</code> 展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况</li>\n<li><code>bc</code> 数字计算</li>\n</ul>\n<h2 id=\"获取进程id\">获取进程id</h2>\n<ul>\n<li><p>代码演示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#! /bin/bash</span></div><div class=\"line\"><span class=\"comment\"># 通过进程的使用者和名称来获取进程的PID</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 提示脚本用法</span></div><div class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$#</span>\"</span> <span class=\"_\">-ne</span> 2 ]</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"Usage: <span class=\"variable\">$0</span> pUser pName\"</span></div><div class=\"line\">\t<span class=\"built_in\">exit</span> 1</div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\">pUser=<span class=\"variable\">$1</span></div><div class=\"line\">pName=<span class=\"variable\">$2</span></div><div class=\"line\">pId=`ps -u <span class=\"variable\">$pUser</span> | grep <span class=\"variable\">$pName</span> | grep -v <span class=\"string\">'grep'</span> | grep -v <span class=\"string\">'vi'</span> | grep -v <span class=\"string\">'dbx\\n'</span> | grep -v <span class=\"string\">'tail'</span> | grep -v <span class=\"string\">'start'</span> | grep -v <span class=\"string\">'stop'</span> | sed -n 1p | awk <span class=\"string\">'&#123;print $1&#125;'</span>`</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 检测进程是否存在</span></div><div class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"-<span class=\"variable\">$pId</span>\"</span> == <span class=\"string\">\"-\"</span> ]</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"The process does not exist.\"</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$pId</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div></pre></td></tr></table></figure></li>\n<li><p>个人理解 在获取pId的命令中,ps挑选用户,再用grep查找进程,剔除掉包含grep,vi,dbx,tail,start,stop的命令行==[不懂为嘛]==,sed选取第一行,awk提取出pId.</p></li>\n</ul>\n<h2 id=\"监控进程使用的cpu内存\">监控进程使用的CPU&amp;内存</h2>\n<ul>\n<li><p>监控CPU</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 通过pId来获取该进程CPU的使用情况</span></div><div class=\"line\"><span class=\"keyword\">function</span> GetCpu</div><div class=\"line\">&#123;</div><div class=\"line\">\tcpuValue=`ps -p <span class=\"variable\">$1</span> -o pcpu | grep -v CPU | awk <span class=\"string\">'&#123;print $1&#125;'</span> | awk -F. <span class=\"string\">'&#123;print $1&#125;'</span>`</div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$cpuValue</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意:</strong><br>\n最后的<code>awk</code>是取整的目的.</p>\n</blockquote></li>\n<li><p>监控内存</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 通过pId来获取进程内存使用情况</span></div><div class=\"line\"><span class=\"keyword\">function</span> GetMem</div><div class=\"line\">&#123;</div><div class=\"line\">\tmemUsage=`ps -p <span class=\"variable\">$1</span> -o vsz | grep -v VSZ`</div><div class=\"line\">\t((memUsage /= 1000))</div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$memUsage</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><p>句柄数 句柄使用过高可能由于负载过高，句柄泄露等情况，通过脚本对业务进程句柄使用量进行时时监控，可以在异常时及时发送告警（例如通过短信），便于维护人员及时处理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 通过pId来获取该进程句柄使用量</span></div><div class=\"line\"><span class=\"keyword\">function</span> GetHandle</div><div class=\"line\">&#123;</div><div class=\"line\">\thandle=`ls /proc/<span class=\"variable\">$1</span>/fd | wc <span class=\"_\">-l</span>`</div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$handle</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><p>监控系统CPU</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 获取系统CPU负载</span></div><div class=\"line\"><span class=\"keyword\">function</span> GetSysCpu</div><div class=\"line\">&#123;</div><div class=\"line\">\tcpuIdle=`vmstat 1 5 | sed -n <span class=\"string\">'3,$p'</span> | awk <span class=\"string\">'&#123;x = x + $15&#125; END &#123;print x/5&#125;'</span> | awk -F. <span class=\"string\">'&#123;print $1&#125;'</span>`</div><div class=\"line\">\tcpuNum=`<span class=\"built_in\">echo</span> <span class=\"string\">\"100-<span class=\"variable\">$cpuIdle</span>\"</span> | bc`</div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"variable\">$cpuNum</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注解:</strong><br>\n使用 vmstat 取 5 次系统 CPU 的 idle 值，取平均值，然后通过与 100 取差得到当前 CPU 的实际占用值。</p>\n</blockquote></li>\n</ul>\n<h2 id=\"完整演示\">完整演示</h2>\n<ul>\n<li>代码文件[checkPerform.sh](/assets/attachs/checkPerform.sh.txt)</li>\n<li>效果演示 查询由hjy打开的google浏览器chromium的使用情况 [perform](/assets/images/perform.png)</li>\n<li>结果分析 ==目前google浏览器cpu使用占3%,而整个系统的cpu使用是5%.内存使用是2210M,超了不少,运行的进程有40个,也超了不少,而占用的句柄数是426,也是比较多的.==</li>\n</ul>"},{"layout":"post","title":"ubuntu下lamp的构建","comments":1,"_content":"LAMP（Linux-Apache-MySQL-PHP）网站架构是目前国际流行的Web框架，该框架包括：Linux操作系统，Apache网络服务器，MySQL数据库，Perl、PHP或者Python编程语言，所有组成产品均是开源软件，是国际上成熟的架构框架，很多流行的商业应用都是采取这个架构，和Java/J2EE架构相比，LAMP具有Web资源丰富、轻量、快速开发等特点，微软的.NET架构相比，LAMP具有通用、跨平台、高性能、低价格的优势，因此LAMP无论是性能、质量还是价格都是企业搭建网站的首选平台。(附带安装mysql的管理软件phpmyadmin)\n<!-- more -->\n\n\n## 安装流程\n* 安装apache2\n\n\t```bash\n\tsudo apt-get install apache2\n\t```\n* 在浏览器中输入localhost,显示如下界面\n![localhost]({{ site.baseurl }}/assets/images/apache.png)\n* 安装php5\n\n\t```bash\n\tsudo apt-get install php5\n\t```\n* 安装mysql\n\n\t```bash\n\tsudo apt-get install mysql-server\n\t```\n* 安装phpmyadmin\nphpmyadmin是基于php,并通过web的方式管理mysql数据库.\n\t* 代码安装\n\n\t\t```bash\n\t\tsudo apt-get install phpmyadmin\n\t\t# 根据提示选择apache2,输入root密码和数据库密码\n\t\t```\n\t* 更改/var/www目录的权限,并创建phpmyadmin链接\n\n\t\t```bash\n\t\tsudo chmod 777 /var/www\n\t\tsudo ln -s /usr/share/phpmyadmin /var/www/html/\n\t\t```\n\t* 在浏览器中输入localhost/phpmyadmin\n\t![phpmyadmin]({{ site.baseurl }}/assets/images/phpmyadmin.png)\n","source":"_posts/2015-05-31-ubuntu下lamp的构建.md","raw":"---\nlayout:\tpost\ntitle:\tubuntu下lamp的构建\ncategories:\n- TECHNOLOGY\ntags:\n- Ubuntu\n- OPS\npermalink:  Build-lamp\ncomments:\ttrue\n---\nLAMP（Linux-Apache-MySQL-PHP）网站架构是目前国际流行的Web框架，该框架包括：Linux操作系统，Apache网络服务器，MySQL数据库，Perl、PHP或者Python编程语言，所有组成产品均是开源软件，是国际上成熟的架构框架，很多流行的商业应用都是采取这个架构，和Java/J2EE架构相比，LAMP具有Web资源丰富、轻量、快速开发等特点，微软的.NET架构相比，LAMP具有通用、跨平台、高性能、低价格的优势，因此LAMP无论是性能、质量还是价格都是企业搭建网站的首选平台。(附带安装mysql的管理软件phpmyadmin)\n<!-- more -->\n\n\n## 安装流程\n* 安装apache2\n\n\t```bash\n\tsudo apt-get install apache2\n\t```\n* 在浏览器中输入localhost,显示如下界面\n![localhost]({{ site.baseurl }}/assets/images/apache.png)\n* 安装php5\n\n\t```bash\n\tsudo apt-get install php5\n\t```\n* 安装mysql\n\n\t```bash\n\tsudo apt-get install mysql-server\n\t```\n* 安装phpmyadmin\nphpmyadmin是基于php,并通过web的方式管理mysql数据库.\n\t* 代码安装\n\n\t\t```bash\n\t\tsudo apt-get install phpmyadmin\n\t\t# 根据提示选择apache2,输入root密码和数据库密码\n\t\t```\n\t* 更改/var/www目录的权限,并创建phpmyadmin链接\n\n\t\t```bash\n\t\tsudo chmod 777 /var/www\n\t\tsudo ln -s /usr/share/phpmyadmin /var/www/html/\n\t\t```\n\t* 在浏览器中输入localhost/phpmyadmin\n\t![phpmyadmin]({{ site.baseurl }}/assets/images/phpmyadmin.png)\n","slug":"Build-lamp","published":1,"date":"2015-05-30T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1a0012l73yp3qyzcjp","content":"<p>LAMP（Linux-Apache-MySQL-PHP）网站架构是目前国际流行的Web框架，该框架包括：Linux操作系统，Apache网络服务器，MySQL数据库，Perl、PHP或者Python编程语言，所有组成产品均是开源软件，是国际上成熟的架构框架，很多流行的商业应用都是采取这个架构，和Java/J2EE架构相比，LAMP具有Web资源丰富、轻量、快速开发等特点，微软的.NET架构相比，LAMP具有通用、跨平台、高性能、低价格的优势，因此LAMP无论是性能、质量还是价格都是企业搭建网站的首选平台。(附带安装mysql的管理软件phpmyadmin) <a id=\"more\"></a></p>\n<h2 id=\"安装流程\">安装流程</h2>\n<ul>\n<li><p>安装apache2</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install apache2</div></pre></td></tr></table></figure></li>\n<li>在浏览器中输入localhost,显示如下界面 [localhost](/assets/images/apache.png)</li>\n<li><p>安装php5</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install php5</div></pre></td></tr></table></figure></li>\n<li><p>安装mysql</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install mysql-server</div></pre></td></tr></table></figure></li>\n<li>安装phpmyadmin phpmyadmin是基于php,并通过web的方式管理mysql数据库.\n<ul>\n<li><p>代码安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install phpmyadmin</div><div class=\"line\"><span class=\"comment\"># 根据提示选择apache2,输入root密码和数据库密码</span></div></pre></td></tr></table></figure></li>\n<li><p>更改/var/www目录的权限,并创建phpmyadmin链接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo chmod 777 /var/www</div><div class=\"line\">sudo ln <span class=\"_\">-s</span> /usr/share/phpmyadmin /var/www/html/</div></pre></td></tr></table></figure></li>\n<li><p>在浏览器中输入localhost/phpmyadmin [phpmyadmin](/assets/images/phpmyadmin.png)</p></li>\n</ul></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>LAMP（Linux-Apache-MySQL-PHP）网站架构是目前国际流行的Web框架，该框架包括：Linux操作系统，Apache网络服务器，MySQL数据库，Perl、PHP或者Python编程语言，所有组成产品均是开源软件，是国际上成熟的架构框架，很多流行的商业应用都是采取这个架构，和Java/J2EE架构相比，LAMP具有Web资源丰富、轻量、快速开发等特点，微软的.NET架构相比，LAMP具有通用、跨平台、高性能、低价格的优势，因此LAMP无论是性能、质量还是价格都是企业搭建网站的首选平台。(附带安装mysql的管理软件phpmyadmin)","more":"</p>\n<h2 id=\"安装流程\">安装流程</h2>\n<ul>\n<li><p>安装apache2</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install apache2</div></pre></td></tr></table></figure></li>\n<li>在浏览器中输入localhost,显示如下界面 [localhost](/assets/images/apache.png)</li>\n<li><p>安装php5</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install php5</div></pre></td></tr></table></figure></li>\n<li><p>安装mysql</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install mysql-server</div></pre></td></tr></table></figure></li>\n<li>安装phpmyadmin phpmyadmin是基于php,并通过web的方式管理mysql数据库.\n<ul>\n<li><p>代码安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install phpmyadmin</div><div class=\"line\"><span class=\"comment\"># 根据提示选择apache2,输入root密码和数据库密码</span></div></pre></td></tr></table></figure></li>\n<li><p>更改/var/www目录的权限,并创建phpmyadmin链接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo chmod 777 /var/www</div><div class=\"line\">sudo ln <span class=\"_\">-s</span> /usr/share/phpmyadmin /var/www/html/</div></pre></td></tr></table></figure></li>\n<li><p>在浏览器中输入localhost/phpmyadmin [phpmyadmin](/assets/images/phpmyadmin.png)</p></li>\n</ul></li>\n</ul>"},{"layout":"post","title":"版本控制神器git","comments":1,"_content":"当使用git管理代码,有github帐号,至少有一个自己创建的项目出现在求职的综合加分项里时,了解git,github就应该成为一项立即,马上,现在去做的事.\n<!-- more -->\n\n\n## Git简介\nGit是一个免费的、分布式的版本控制工具，或是一个强调了速度快的源代码管理工具。每一个Git的工作目录都是一个完全独立的代码库，并拥有完整的历史记录和版本追踪能力，不依赖于网络和中心服务器。\n\n\nGit 在管理项目时，在本地会有三个工作区域：Git 的本地数据目录，工作目录以及暂存区域。如下图所示：![git-three-workspace]({{ site.baseurl }}/assets/images/git-three-workspace.png).\n\n因此对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。\n\n## GitHub简介\nGitHub是一个利用Git提供免费的代码托管服务的网站（类似的网站还有老牌的SourceForge），很多著名的项目都托管在上面。说白一点就是将Git的本地数据库同步到GitHub网站上。用户一般通过公钥认证的方式连接到GitHub的SSH服务器.\n\n## Git\\&GitHub的结合\nGit命令的实际操作图:\n![git-github]({{ site.baseurl }}/assets/images/git-github.jpg)\n\n图中**workspace**代表当前工作目录,**index**代表暂存区域，也叫索引,**Repository**代表本地仓库,而**Remote**代表远程服务器上的数据仓库，这里一般指GitHub网站的服务器.\n\n## Git远程操作详解\n* `git clone`\t从远程主机克隆一个版本库\n\n\t```bash\n\t# 用法 从版本库的网址上拷贝文件到本地文件夹\n\tgit clone <版本库的网址> <本地目录名>\n\t# 用例 支持多种文件协议\n\tgit clone http[s]://example.com/path/to/repo.git/  # http协议\n\tgit clone ssh://example.com/path/to/repo.git/      # ssh协议\n\tgit clone git://example.com/path/to/repo.git/      # git协议\n\tgit clone /opt/git/project.git                     # 本地文件\n\tgit clone file:///opt/git/project.git              # 本地文件\n\tgit clone ftp[s]://example.com/path/to/repo.git/   # ftp协议\n\tgit clone rsync://example.com/path/to/repo.git/    # rsync协议\n\t```\n* `git remote`\t管理远程主机名\n\n\t```bash\n\t# 用法\n\tgit remote add <主机名> <网址>    # 添加远程主机名\n\tgit remote rm <主机名>           # 删除远程主机名\n\tgit remote rename <原主机名> <新主机名>   # 更改原主机名\n\tgit remote show <主机名>         # 显示主机名的详细信息\n\t```\n* `git fetch`\t将远程主机的版本库更新取回本地==[clone是从无到有,fetch是从有到有]==\n\n\t```bash\n\tgit fetch <主机名> <分支名>\n\t```\n* `git branch/checkout/merge/rebase`\t管理分支\n\n\t```bash\n\t# 用法 查看分支情况\n\tgit branch -r    # 查看远程分支\n\tgit branch -a    # 查看所有分支，远程分支以remotes/开头\n\t# 用法 创建新分支\n\tgit checkout -b newBranch origin/master   # 在origin/master的基础上创建新分支\n\t# 用法 合并分支\n\tgit merge origin/master      # 将origin/master分支合并到本地分支\n\tgit rebase origin/master\n\t```\n* `git pull`\t取回远程主机某个分支的更新，再与本地的指定分支合并\n\n\t```bash\n\tgit pull <远程主机名> <远程分支名>:<本地分支名>\n\t# 等价于\n\tgit fetch <远程主机名> <远程分支名>\n\tgit merge <远程主机名>/<远程分支名>\n\t```\n* `git push`\t将本地分支的更新,推送到远程主机\n\n\t```bash\n\tgit push <远程主机名> <本地分支名>:<远程分支名>\n\t```\n\n## ubuntu下安装\n* 安装git\n\n\t```bash\n\tsudo apt-get install git\n\t```\n* 配置SSH Keys\n\n\t```bash\n\t# 以haojunyu2012@gmail.com创建ssh key，并将私钥保存在github文件中，公钥保存在github.pub文件中\n\tssh-keygen -C \"haojunyu2012@gmail.com\" -f ~/.ssh/github\n\t```\n* 配置GitHub  \n登录自己的GitHub,依次点击Settings=>SSH keys=>Add SSH key,将github.pub中的公钥添加进去.\n* 验证成功\n\n\t```bash\n\t# 执行命令\n\tssh -T git@github.com\n\t# 提示\n\tHi haojunyu! You've successfully authenticated, but GitHub does not provide shell access.\n\t```\n* 配置git的个人信息\n\n\t```bash\n\t# 设置用户名\n\tgit config --global user.name \"haojunyu\"\n\t# 设置email邮箱\n\tgit config --global user.email \"haojunyu2012@gmail.com\"\n\t```\n\n## ubuntu下使用\n* 为已有的项目[project]创建代码仓库[repository]\n\n\t```bash\n\t# 在项目[project]的根目录执行以下命令\n\n\t# 创建README.md文件\n\techo \"# NLP\" >> README.md\n\t# 创建一个空的git版本库[.git文件夹]\n\tgit init\n\t# 添加所有文件到暂存区域\n\tgit add *\n\t# 将暂存区域文件提交到本地仓库，并标注信息“initial project”\n\tgit commit -m \"initial project\"\n\t# 添加远程主机名origin，它代表网址“https://github.com/haojunyu/SHELL.git”\n\tgit remote add origin https://github.com/haojunyu/SHELL.git\n\t# 将本地的master分支推送到origin主机上的master分支，并设定origin为默认主机\n\tgit push -u origin master\n\t```\n* 从远程服务器上克隆一个仓库到本地\n\n\t```bash\n\t# 从https://github.com/haojunyu上克隆SHELL.git到本地shell文件夹\n\tgit clone https://github.com/haojunyu/SHELL.git shell\n\t```\n* 忽略某些文件或文件夹\n有些文件无需纳入 Git 的管理,也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件,像是日志或者编译过程中创建的等等。可以创建.gitignore文件来屏蔽这些\n\n\t```bash\n\t# 此为注释 – 将被 Git 忽略\n\t*.a        # 忽略所有 .a 结尾的文件\n\t!lib.a     # 但 lib.a 除外\n\t/TODO      # 仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODO\n\tbuild/     # 忽略 build/ 目录下的所有文件\n\tdoc/*.txt  # 会忽略 doc/notes.txt， 但不包括 doc/server/arch.txt\n\t```\n* 查看提交的更新\n\n\t```bash\n\t# 查看提交的日志，并显示最近两次提交更新区别\n\tgit log -p -2\n\t```\n\t> **选项说明**  \n\t> `-p`\t按补丁格式显示每个更新之间的差异。  \n\t> `--stat`\t显示每次更新的文件修改统计信息。  \n\t> `--shortstat`\t只显示 --stat 中最后的行数修改添加移除统计  。  \n\t> `--pretty`\t\t\t\t使用其他格式显示历史提交信息。可用的选项包括 oneline,short,full,fuller 和 format(后跟指定格式)。  \n* 存储当前工作空间\n储藏（stashing）可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中,随时可以重新应用。\n\n\t```bash\n\t# 存储当前工作空间，以方便进行切换\n\tgit stash\n\t# 此时工作空间所有文件的状态就干净了,可以切换到其他工作空间\n\n\t# 显示之前存储的工作空间\n\tgit stash list\n\n\t# 重新启用存储的工作空间\n\tgit stash apply stash@2\n\n\t# 移除存储的工作空间\n\tgit stash drop stash@2\n\n\t# 从存储中创建分支\n\tgit stash branch testchanges\n\t```\n\n## Git文件结构\n* 文件夹：\n\t* `branches`\n\t* `hooks`\t客户端或服务端钩子脚本\n\t* `info`\t保存了一份不希望在 .gitignore 文件中管理的忽略模式 (ignored patterns) 的全局\n* 可执行文件\n\t* `refs`\t存储指向数据 (分支) 的提交对象的指针\n\t* `objects`\t存储所有数据内容\n* 文件\n\t* `HEAD`\t指向当前分支\n\t* `config`\t包含了项目特有的配置选项\n\t* `description`\t仅供GitWeb 程序使用\n\t* `index`\t保存了暂存区域信息\n","source":"_posts/2015-05-31-版本控制神器git.md","raw":"---\nlayout:\tpost\ntitle:\t版本控制神器git\ncategories:\n- TECHNOLOGY\ntags:\n- Git\n- Ubuntu\npermalink:  Explore-git\ncomments:\ttrue\n---\n当使用git管理代码,有github帐号,至少有一个自己创建的项目出现在求职的综合加分项里时,了解git,github就应该成为一项立即,马上,现在去做的事.\n<!-- more -->\n\n\n## Git简介\nGit是一个免费的、分布式的版本控制工具，或是一个强调了速度快的源代码管理工具。每一个Git的工作目录都是一个完全独立的代码库，并拥有完整的历史记录和版本追踪能力，不依赖于网络和中心服务器。\n\n\nGit 在管理项目时，在本地会有三个工作区域：Git 的本地数据目录，工作目录以及暂存区域。如下图所示：![git-three-workspace]({{ site.baseurl }}/assets/images/git-three-workspace.png).\n\n因此对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。\n\n## GitHub简介\nGitHub是一个利用Git提供免费的代码托管服务的网站（类似的网站还有老牌的SourceForge），很多著名的项目都托管在上面。说白一点就是将Git的本地数据库同步到GitHub网站上。用户一般通过公钥认证的方式连接到GitHub的SSH服务器.\n\n## Git\\&GitHub的结合\nGit命令的实际操作图:\n![git-github]({{ site.baseurl }}/assets/images/git-github.jpg)\n\n图中**workspace**代表当前工作目录,**index**代表暂存区域，也叫索引,**Repository**代表本地仓库,而**Remote**代表远程服务器上的数据仓库，这里一般指GitHub网站的服务器.\n\n## Git远程操作详解\n* `git clone`\t从远程主机克隆一个版本库\n\n\t```bash\n\t# 用法 从版本库的网址上拷贝文件到本地文件夹\n\tgit clone <版本库的网址> <本地目录名>\n\t# 用例 支持多种文件协议\n\tgit clone http[s]://example.com/path/to/repo.git/  # http协议\n\tgit clone ssh://example.com/path/to/repo.git/      # ssh协议\n\tgit clone git://example.com/path/to/repo.git/      # git协议\n\tgit clone /opt/git/project.git                     # 本地文件\n\tgit clone file:///opt/git/project.git              # 本地文件\n\tgit clone ftp[s]://example.com/path/to/repo.git/   # ftp协议\n\tgit clone rsync://example.com/path/to/repo.git/    # rsync协议\n\t```\n* `git remote`\t管理远程主机名\n\n\t```bash\n\t# 用法\n\tgit remote add <主机名> <网址>    # 添加远程主机名\n\tgit remote rm <主机名>           # 删除远程主机名\n\tgit remote rename <原主机名> <新主机名>   # 更改原主机名\n\tgit remote show <主机名>         # 显示主机名的详细信息\n\t```\n* `git fetch`\t将远程主机的版本库更新取回本地==[clone是从无到有,fetch是从有到有]==\n\n\t```bash\n\tgit fetch <主机名> <分支名>\n\t```\n* `git branch/checkout/merge/rebase`\t管理分支\n\n\t```bash\n\t# 用法 查看分支情况\n\tgit branch -r    # 查看远程分支\n\tgit branch -a    # 查看所有分支，远程分支以remotes/开头\n\t# 用法 创建新分支\n\tgit checkout -b newBranch origin/master   # 在origin/master的基础上创建新分支\n\t# 用法 合并分支\n\tgit merge origin/master      # 将origin/master分支合并到本地分支\n\tgit rebase origin/master\n\t```\n* `git pull`\t取回远程主机某个分支的更新，再与本地的指定分支合并\n\n\t```bash\n\tgit pull <远程主机名> <远程分支名>:<本地分支名>\n\t# 等价于\n\tgit fetch <远程主机名> <远程分支名>\n\tgit merge <远程主机名>/<远程分支名>\n\t```\n* `git push`\t将本地分支的更新,推送到远程主机\n\n\t```bash\n\tgit push <远程主机名> <本地分支名>:<远程分支名>\n\t```\n\n## ubuntu下安装\n* 安装git\n\n\t```bash\n\tsudo apt-get install git\n\t```\n* 配置SSH Keys\n\n\t```bash\n\t# 以haojunyu2012@gmail.com创建ssh key，并将私钥保存在github文件中，公钥保存在github.pub文件中\n\tssh-keygen -C \"haojunyu2012@gmail.com\" -f ~/.ssh/github\n\t```\n* 配置GitHub  \n登录自己的GitHub,依次点击Settings=>SSH keys=>Add SSH key,将github.pub中的公钥添加进去.\n* 验证成功\n\n\t```bash\n\t# 执行命令\n\tssh -T git@github.com\n\t# 提示\n\tHi haojunyu! You've successfully authenticated, but GitHub does not provide shell access.\n\t```\n* 配置git的个人信息\n\n\t```bash\n\t# 设置用户名\n\tgit config --global user.name \"haojunyu\"\n\t# 设置email邮箱\n\tgit config --global user.email \"haojunyu2012@gmail.com\"\n\t```\n\n## ubuntu下使用\n* 为已有的项目[project]创建代码仓库[repository]\n\n\t```bash\n\t# 在项目[project]的根目录执行以下命令\n\n\t# 创建README.md文件\n\techo \"# NLP\" >> README.md\n\t# 创建一个空的git版本库[.git文件夹]\n\tgit init\n\t# 添加所有文件到暂存区域\n\tgit add *\n\t# 将暂存区域文件提交到本地仓库，并标注信息“initial project”\n\tgit commit -m \"initial project\"\n\t# 添加远程主机名origin，它代表网址“https://github.com/haojunyu/SHELL.git”\n\tgit remote add origin https://github.com/haojunyu/SHELL.git\n\t# 将本地的master分支推送到origin主机上的master分支，并设定origin为默认主机\n\tgit push -u origin master\n\t```\n* 从远程服务器上克隆一个仓库到本地\n\n\t```bash\n\t# 从https://github.com/haojunyu上克隆SHELL.git到本地shell文件夹\n\tgit clone https://github.com/haojunyu/SHELL.git shell\n\t```\n* 忽略某些文件或文件夹\n有些文件无需纳入 Git 的管理,也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件,像是日志或者编译过程中创建的等等。可以创建.gitignore文件来屏蔽这些\n\n\t```bash\n\t# 此为注释 – 将被 Git 忽略\n\t*.a        # 忽略所有 .a 结尾的文件\n\t!lib.a     # 但 lib.a 除外\n\t/TODO      # 仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODO\n\tbuild/     # 忽略 build/ 目录下的所有文件\n\tdoc/*.txt  # 会忽略 doc/notes.txt， 但不包括 doc/server/arch.txt\n\t```\n* 查看提交的更新\n\n\t```bash\n\t# 查看提交的日志，并显示最近两次提交更新区别\n\tgit log -p -2\n\t```\n\t> **选项说明**  \n\t> `-p`\t按补丁格式显示每个更新之间的差异。  \n\t> `--stat`\t显示每次更新的文件修改统计信息。  \n\t> `--shortstat`\t只显示 --stat 中最后的行数修改添加移除统计  。  \n\t> `--pretty`\t\t\t\t使用其他格式显示历史提交信息。可用的选项包括 oneline,short,full,fuller 和 format(后跟指定格式)。  \n* 存储当前工作空间\n储藏（stashing）可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中,随时可以重新应用。\n\n\t```bash\n\t# 存储当前工作空间，以方便进行切换\n\tgit stash\n\t# 此时工作空间所有文件的状态就干净了,可以切换到其他工作空间\n\n\t# 显示之前存储的工作空间\n\tgit stash list\n\n\t# 重新启用存储的工作空间\n\tgit stash apply stash@2\n\n\t# 移除存储的工作空间\n\tgit stash drop stash@2\n\n\t# 从存储中创建分支\n\tgit stash branch testchanges\n\t```\n\n## Git文件结构\n* 文件夹：\n\t* `branches`\n\t* `hooks`\t客户端或服务端钩子脚本\n\t* `info`\t保存了一份不希望在 .gitignore 文件中管理的忽略模式 (ignored patterns) 的全局\n* 可执行文件\n\t* `refs`\t存储指向数据 (分支) 的提交对象的指针\n\t* `objects`\t存储所有数据内容\n* 文件\n\t* `HEAD`\t指向当前分支\n\t* `config`\t包含了项目特有的配置选项\n\t* `description`\t仅供GitWeb 程序使用\n\t* `index`\t保存了暂存区域信息\n","slug":"Explore-git","published":1,"date":"2015-05-30T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1b0013l73ydwfvuqkq","content":"<p>当使用git管理代码,有github帐号,至少有一个自己创建的项目出现在求职的综合加分项里时,了解git,github就应该成为一项立即,马上,现在去做的事. <a id=\"more\"></a></p>\n<h2 id=\"git简介\">Git简介</h2>\n<p>Git是一个免费的、分布式的版本控制工具，或是一个强调了速度快的源代码管理工具。每一个Git的工作目录都是一个完全独立的代码库，并拥有完整的历史记录和版本追踪能力，不依赖于网络和中心服务器。</p>\n<p>Git 在管理项目时，在本地会有三个工作区域：Git 的本地数据目录，工作目录以及暂存区域。如下图所示：[git-three-workspace](/assets/images/git-three-workspace.png).</p>\n<p>因此对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。</p>\n<h2 id=\"github简介\">GitHub简介</h2>\n<p>GitHub是一个利用Git提供免费的代码托管服务的网站（类似的网站还有老牌的SourceForge），很多著名的项目都托管在上面。说白一点就是将Git的本地数据库同步到GitHub网站上。用户一般通过公钥认证的方式连接到GitHub的SSH服务器.</p>\n<h2 id=\"gitgithub的结合\">Git&amp;GitHub的结合</h2>\n<p>Git命令的实际操作图: [git-github](/assets/images/git-github.jpg)</p>\n<p>图中<strong>workspace</strong>代表当前工作目录,<strong>index</strong>代表暂存区域，也叫索引,<strong>Repository</strong>代表本地仓库,而<strong>Remote</strong>代表远程服务器上的数据仓库，这里一般指GitHub网站的服务器.</p>\n<h2 id=\"git远程操作详解\">Git远程操作详解</h2>\n<ul>\n<li><p><code>git clone</code> 从远程主机克隆一个版本库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 用法 从版本库的网址上拷贝文件到本地文件夹</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> &lt;版本库的网址&gt; &lt;本地目录名&gt;</div><div class=\"line\"><span class=\"comment\"># 用例 支持多种文件协议</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> http[s]://example.com/path/to/repo.git/  <span class=\"comment\"># http协议</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> ssh://example.com/path/to/repo.git/      <span class=\"comment\"># ssh协议</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> git://example.com/path/to/repo.git/      <span class=\"comment\"># git协议</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> /opt/git/project.git                     <span class=\"comment\"># 本地文件</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> file:///opt/git/project.git              <span class=\"comment\"># 本地文件</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> ftp[s]://example.com/path/to/repo.git/   <span class=\"comment\"># ftp协议</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> rsync://example.com/path/to/repo.git/    <span class=\"comment\"># rsync协议</span></div></pre></td></tr></table></figure></li>\n<li><p><code>git remote</code> 管理远程主机名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 用法</span></div><div class=\"line\">git remote add &lt;主机名&gt; &lt;网址&gt;    <span class=\"comment\"># 添加远程主机名</span></div><div class=\"line\">git remote rm &lt;主机名&gt;           <span class=\"comment\"># 删除远程主机名</span></div><div class=\"line\">git remote rename &lt;原主机名&gt; &lt;新主机名&gt;   <span class=\"comment\"># 更改原主机名</span></div><div class=\"line\">git remote show &lt;主机名&gt;         <span class=\"comment\"># 显示主机名的详细信息</span></div></pre></td></tr></table></figure></li>\n<li><p><code>git fetch</code> 将远程主机的版本库更新取回本地==[clone是从无到有,fetch是从有到有]==</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git fetch &lt;主机名&gt; &lt;分支名&gt;</div></pre></td></tr></table></figure></li>\n<li><p><code>git branch/checkout/merge/rebase</code> 管理分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 用法 查看分支情况</span></div><div class=\"line\">git branch -r    <span class=\"comment\"># 查看远程分支</span></div><div class=\"line\">git branch <span class=\"_\">-a</span>    <span class=\"comment\"># 查看所有分支，远程分支以remotes/开头</span></div><div class=\"line\"><span class=\"comment\"># 用法 创建新分支</span></div><div class=\"line\">git checkout -b newBranch origin/master   <span class=\"comment\"># 在origin/master的基础上创建新分支</span></div><div class=\"line\"><span class=\"comment\"># 用法 合并分支</span></div><div class=\"line\">git merge origin/master      <span class=\"comment\"># 将origin/master分支合并到本地分支</span></div><div class=\"line\">git rebase origin/master</div></pre></td></tr></table></figure></li>\n<li><p><code>git pull</code> 取回远程主机某个分支的更新，再与本地的指定分支合并</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</div><div class=\"line\"><span class=\"comment\"># 等价于</span></div><div class=\"line\">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;</div><div class=\"line\">git merge &lt;远程主机名&gt;/&lt;远程分支名&gt;</div></pre></td></tr></table></figure></li>\n<li><p><code>git push</code> 将本地分支的更新,推送到远程主机</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"ubuntu下安装\">ubuntu下安装</h2>\n<ul>\n<li><p>安装git</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install git</div></pre></td></tr></table></figure></li>\n<li><p>配置SSH Keys</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 以haojunyu2012@gmail.com创建ssh key，并将私钥保存在github文件中，公钥保存在github.pub文件中</span></div><div class=\"line\">ssh-keygen -C <span class=\"string\">\"haojunyu2012@gmail.com\"</span> <span class=\"_\">-f</span> ~/.ssh/github</div></pre></td></tr></table></figure></li>\n<li>配置GitHub<br>\n登录自己的GitHub,依次点击Settings=&gt;SSH keys=&gt;Add SSH key,将github.pub中的公钥添加进去.</li>\n<li><p>验证成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 执行命令</span></div><div class=\"line\">ssh -T git@github.com</div><div class=\"line\"><span class=\"comment\"># 提示</span></div><div class=\"line\">Hi haojunyu! You<span class=\"string\">'ve successfully authenticated, but GitHub does not provide shell access.</span></div></pre></td></tr></table></figure></li>\n<li><p>配置git的个人信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 设置用户名</span></div><div class=\"line\">git config --global user.name <span class=\"string\">\"haojunyu\"</span></div><div class=\"line\"><span class=\"comment\"># 设置email邮箱</span></div><div class=\"line\">git config --global user.email <span class=\"string\">\"haojunyu2012@gmail.com\"</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"ubuntu下使用\">ubuntu下使用</h2>\n<ul>\n<li><p>为已有的项目[project]创建代码仓库[repository]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 在项目[project]的根目录执行以下命令</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 创建README.md文件</span></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"# NLP\"</span> &gt;&gt; README.md</div><div class=\"line\"><span class=\"comment\"># 创建一个空的git版本库[.git文件夹]</span></div><div class=\"line\">git init</div><div class=\"line\"><span class=\"comment\"># 添加所有文件到暂存区域</span></div><div class=\"line\">git add *</div><div class=\"line\"><span class=\"comment\"># 将暂存区域文件提交到本地仓库，并标注信息“initial project”</span></div><div class=\"line\">git commit -m <span class=\"string\">\"initial project\"</span></div><div class=\"line\"><span class=\"comment\"># 添加远程主机名origin，它代表网址“https://github.com/haojunyu/SHELL.git”</span></div><div class=\"line\">git remote add origin https://github.com/haojunyu/SHELL.git</div><div class=\"line\"><span class=\"comment\"># 将本地的master分支推送到origin主机上的master分支，并设定origin为默认主机</span></div><div class=\"line\">git push -u origin master</div></pre></td></tr></table></figure></li>\n<li><p>从远程服务器上克隆一个仓库到本地</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 从https://github.com/haojunyu上克隆SHELL.git到本地shell文件夹</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/haojunyu/SHELL.git shell</div></pre></td></tr></table></figure></li>\n<li><p>忽略某些文件或文件夹 有些文件无需纳入 Git 的管理,也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件,像是日志或者编译过程中创建的等等。可以创建.gitignore文件来屏蔽这些</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 此为注释 – 将被 Git 忽略</span></div><div class=\"line\">*.a        <span class=\"comment\"># 忽略所有 .a 结尾的文件</span></div><div class=\"line\">!lib.a     <span class=\"comment\"># 但 lib.a 除外</span></div><div class=\"line\">/TODO      <span class=\"comment\"># 仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODO</span></div><div class=\"line\">build/     <span class=\"comment\"># 忽略 build/ 目录下的所有文件</span></div><div class=\"line\">doc/*.txt  <span class=\"comment\"># 会忽略 doc/notes.txt， 但不包括 doc/server/arch.txt</span></div></pre></td></tr></table></figure></li>\n<li><p>查看提交的更新</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 查看提交的日志，并显示最近两次提交更新区别</span></div><div class=\"line\">git <span class=\"built_in\">log</span> -p -2</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>选项说明</strong><br>\n<code>-p</code> 按补丁格式显示每个更新之间的差异。<br>\n<code>--stat</code> 显示每次更新的文件修改统计信息。<br>\n<code>--shortstat</code> 只显示 –stat 中最后的行数修改添加移除统计 。<br>\n<code>--pretty</code> 使用其他格式显示历史提交信息。可用的选项包括 oneline,short,full,fuller 和 format(后跟指定格式)。</p>\n</blockquote></li>\n<li><p>存储当前工作空间 储藏（stashing）可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中,随时可以重新应用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 存储当前工作空间，以方便进行切换</span></div><div class=\"line\">git stash</div><div class=\"line\"><span class=\"comment\"># 此时工作空间所有文件的状态就干净了,可以切换到其他工作空间</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 显示之前存储的工作空间</span></div><div class=\"line\">git stash list</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 重新启用存储的工作空间</span></div><div class=\"line\">git stash apply stash@2</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 移除存储的工作空间</span></div><div class=\"line\">git stash drop stash@2</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 从存储中创建分支</span></div><div class=\"line\">git stash branch testchanges</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"git文件结构\">Git文件结构</h2>\n<ul>\n<li>文件夹：\n<ul>\n<li><code>branches</code></li>\n<li><code>hooks</code> 客户端或服务端钩子脚本</li>\n<li><code>info</code> 保存了一份不希望在 .gitignore 文件中管理的忽略模式 (ignored patterns) 的全局</li>\n</ul></li>\n<li>可执行文件\n<ul>\n<li><code>refs</code> 存储指向数据 (分支) 的提交对象的指针</li>\n<li><code>objects</code> 存储所有数据内容</li>\n</ul></li>\n<li>文件\n<ul>\n<li><code>HEAD</code> 指向当前分支</li>\n<li><code>config</code> 包含了项目特有的配置选项</li>\n<li><code>description</code> 仅供GitWeb 程序使用</li>\n<li><code>index</code> 保存了暂存区域信息</li>\n</ul></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>当使用git管理代码,有github帐号,至少有一个自己创建的项目出现在求职的综合加分项里时,了解git,github就应该成为一项立即,马上,现在去做的事.","more":"</p>\n<h2 id=\"git简介\">Git简介</h2>\n<p>Git是一个免费的、分布式的版本控制工具，或是一个强调了速度快的源代码管理工具。每一个Git的工作目录都是一个完全独立的代码库，并拥有完整的历史记录和版本追踪能力，不依赖于网络和中心服务器。</p>\n<p>Git 在管理项目时，在本地会有三个工作区域：Git 的本地数据目录，工作目录以及暂存区域。如下图所示：[git-three-workspace](/assets/images/git-three-workspace.png).</p>\n<p>因此对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。</p>\n<h2 id=\"github简介\">GitHub简介</h2>\n<p>GitHub是一个利用Git提供免费的代码托管服务的网站（类似的网站还有老牌的SourceForge），很多著名的项目都托管在上面。说白一点就是将Git的本地数据库同步到GitHub网站上。用户一般通过公钥认证的方式连接到GitHub的SSH服务器.</p>\n<h2 id=\"gitgithub的结合\">Git&amp;GitHub的结合</h2>\n<p>Git命令的实际操作图: [git-github](/assets/images/git-github.jpg)</p>\n<p>图中<strong>workspace</strong>代表当前工作目录,<strong>index</strong>代表暂存区域，也叫索引,<strong>Repository</strong>代表本地仓库,而<strong>Remote</strong>代表远程服务器上的数据仓库，这里一般指GitHub网站的服务器.</p>\n<h2 id=\"git远程操作详解\">Git远程操作详解</h2>\n<ul>\n<li><p><code>git clone</code> 从远程主机克隆一个版本库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 用法 从版本库的网址上拷贝文件到本地文件夹</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> &lt;版本库的网址&gt; &lt;本地目录名&gt;</div><div class=\"line\"><span class=\"comment\"># 用例 支持多种文件协议</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> http[s]://example.com/path/to/repo.git/  <span class=\"comment\"># http协议</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> ssh://example.com/path/to/repo.git/      <span class=\"comment\"># ssh协议</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> git://example.com/path/to/repo.git/      <span class=\"comment\"># git协议</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> /opt/git/project.git                     <span class=\"comment\"># 本地文件</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> file:///opt/git/project.git              <span class=\"comment\"># 本地文件</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> ftp[s]://example.com/path/to/repo.git/   <span class=\"comment\"># ftp协议</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> rsync://example.com/path/to/repo.git/    <span class=\"comment\"># rsync协议</span></div></pre></td></tr></table></figure></li>\n<li><p><code>git remote</code> 管理远程主机名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 用法</span></div><div class=\"line\">git remote add &lt;主机名&gt; &lt;网址&gt;    <span class=\"comment\"># 添加远程主机名</span></div><div class=\"line\">git remote rm &lt;主机名&gt;           <span class=\"comment\"># 删除远程主机名</span></div><div class=\"line\">git remote rename &lt;原主机名&gt; &lt;新主机名&gt;   <span class=\"comment\"># 更改原主机名</span></div><div class=\"line\">git remote show &lt;主机名&gt;         <span class=\"comment\"># 显示主机名的详细信息</span></div></pre></td></tr></table></figure></li>\n<li><p><code>git fetch</code> 将远程主机的版本库更新取回本地==[clone是从无到有,fetch是从有到有]==</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git fetch &lt;主机名&gt; &lt;分支名&gt;</div></pre></td></tr></table></figure></li>\n<li><p><code>git branch/checkout/merge/rebase</code> 管理分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 用法 查看分支情况</span></div><div class=\"line\">git branch -r    <span class=\"comment\"># 查看远程分支</span></div><div class=\"line\">git branch <span class=\"_\">-a</span>    <span class=\"comment\"># 查看所有分支，远程分支以remotes/开头</span></div><div class=\"line\"><span class=\"comment\"># 用法 创建新分支</span></div><div class=\"line\">git checkout -b newBranch origin/master   <span class=\"comment\"># 在origin/master的基础上创建新分支</span></div><div class=\"line\"><span class=\"comment\"># 用法 合并分支</span></div><div class=\"line\">git merge origin/master      <span class=\"comment\"># 将origin/master分支合并到本地分支</span></div><div class=\"line\">git rebase origin/master</div></pre></td></tr></table></figure></li>\n<li><p><code>git pull</code> 取回远程主机某个分支的更新，再与本地的指定分支合并</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</div><div class=\"line\"><span class=\"comment\"># 等价于</span></div><div class=\"line\">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;</div><div class=\"line\">git merge &lt;远程主机名&gt;/&lt;远程分支名&gt;</div></pre></td></tr></table></figure></li>\n<li><p><code>git push</code> 将本地分支的更新,推送到远程主机</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"ubuntu下安装\">ubuntu下安装</h2>\n<ul>\n<li><p>安装git</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install git</div></pre></td></tr></table></figure></li>\n<li><p>配置SSH Keys</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 以haojunyu2012@gmail.com创建ssh key，并将私钥保存在github文件中，公钥保存在github.pub文件中</span></div><div class=\"line\">ssh-keygen -C <span class=\"string\">\"haojunyu2012@gmail.com\"</span> <span class=\"_\">-f</span> ~/.ssh/github</div></pre></td></tr></table></figure></li>\n<li>配置GitHub<br>\n登录自己的GitHub,依次点击Settings=&gt;SSH keys=&gt;Add SSH key,将github.pub中的公钥添加进去.</li>\n<li><p>验证成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 执行命令</span></div><div class=\"line\">ssh -T git@github.com</div><div class=\"line\"><span class=\"comment\"># 提示</span></div><div class=\"line\">Hi haojunyu! You<span class=\"string\">'ve successfully authenticated, but GitHub does not provide shell access.</span></div></pre></td></tr></table></figure></li>\n<li><p>配置git的个人信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 设置用户名</span></div><div class=\"line\">git config --global user.name <span class=\"string\">\"haojunyu\"</span></div><div class=\"line\"><span class=\"comment\"># 设置email邮箱</span></div><div class=\"line\">git config --global user.email <span class=\"string\">\"haojunyu2012@gmail.com\"</span></div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"ubuntu下使用\">ubuntu下使用</h2>\n<ul>\n<li><p>为已有的项目[project]创建代码仓库[repository]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 在项目[project]的根目录执行以下命令</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 创建README.md文件</span></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"# NLP\"</span> &gt;&gt; README.md</div><div class=\"line\"><span class=\"comment\"># 创建一个空的git版本库[.git文件夹]</span></div><div class=\"line\">git init</div><div class=\"line\"><span class=\"comment\"># 添加所有文件到暂存区域</span></div><div class=\"line\">git add *</div><div class=\"line\"><span class=\"comment\"># 将暂存区域文件提交到本地仓库，并标注信息“initial project”</span></div><div class=\"line\">git commit -m <span class=\"string\">\"initial project\"</span></div><div class=\"line\"><span class=\"comment\"># 添加远程主机名origin，它代表网址“https://github.com/haojunyu/SHELL.git”</span></div><div class=\"line\">git remote add origin https://github.com/haojunyu/SHELL.git</div><div class=\"line\"><span class=\"comment\"># 将本地的master分支推送到origin主机上的master分支，并设定origin为默认主机</span></div><div class=\"line\">git push -u origin master</div></pre></td></tr></table></figure></li>\n<li><p>从远程服务器上克隆一个仓库到本地</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 从https://github.com/haojunyu上克隆SHELL.git到本地shell文件夹</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/haojunyu/SHELL.git shell</div></pre></td></tr></table></figure></li>\n<li><p>忽略某些文件或文件夹 有些文件无需纳入 Git 的管理,也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件,像是日志或者编译过程中创建的等等。可以创建.gitignore文件来屏蔽这些</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 此为注释 – 将被 Git 忽略</span></div><div class=\"line\">*.a        <span class=\"comment\"># 忽略所有 .a 结尾的文件</span></div><div class=\"line\">!lib.a     <span class=\"comment\"># 但 lib.a 除外</span></div><div class=\"line\">/TODO      <span class=\"comment\"># 仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODO</span></div><div class=\"line\">build/     <span class=\"comment\"># 忽略 build/ 目录下的所有文件</span></div><div class=\"line\">doc/*.txt  <span class=\"comment\"># 会忽略 doc/notes.txt， 但不包括 doc/server/arch.txt</span></div></pre></td></tr></table></figure></li>\n<li><p>查看提交的更新</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 查看提交的日志，并显示最近两次提交更新区别</span></div><div class=\"line\">git <span class=\"built_in\">log</span> -p -2</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>选项说明</strong><br>\n<code>-p</code> 按补丁格式显示每个更新之间的差异。<br>\n<code>--stat</code> 显示每次更新的文件修改统计信息。<br>\n<code>--shortstat</code> 只显示 –stat 中最后的行数修改添加移除统计 。<br>\n<code>--pretty</code> 使用其他格式显示历史提交信息。可用的选项包括 oneline,short,full,fuller 和 format(后跟指定格式)。</p>\n</blockquote></li>\n<li><p>存储当前工作空间 储藏（stashing）可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中,随时可以重新应用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 存储当前工作空间，以方便进行切换</span></div><div class=\"line\">git stash</div><div class=\"line\"><span class=\"comment\"># 此时工作空间所有文件的状态就干净了,可以切换到其他工作空间</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 显示之前存储的工作空间</span></div><div class=\"line\">git stash list</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 重新启用存储的工作空间</span></div><div class=\"line\">git stash apply stash@2</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 移除存储的工作空间</span></div><div class=\"line\">git stash drop stash@2</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 从存储中创建分支</span></div><div class=\"line\">git stash branch testchanges</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"git文件结构\">Git文件结构</h2>\n<ul>\n<li>文件夹：\n<ul>\n<li><code>branches</code></li>\n<li><code>hooks</code> 客户端或服务端钩子脚本</li>\n<li><code>info</code> 保存了一份不希望在 .gitignore 文件中管理的忽略模式 (ignored patterns) 的全局</li>\n</ul></li>\n<li>可执行文件\n<ul>\n<li><code>refs</code> 存储指向数据 (分支) 的提交对象的指针</li>\n<li><code>objects</code> 存储所有数据内容</li>\n</ul></li>\n<li>文件\n<ul>\n<li><code>HEAD</code> 指向当前分支</li>\n<li><code>config</code> 包含了项目特有的配置选项</li>\n<li><code>description</code> 仅供GitWeb 程序使用</li>\n<li><code>index</code> 保存了暂存区域信息</li>\n</ul></li>\n</ul>"},{"layout":"post","title":"实用的写博语言markdown","comments":1,"_content":"Markdown是一种可以使用普通文本编辑器编写的标记语言,通过类似HTML的标记语法,它可以使普通文本内容具有一定的格式.用它来书写博客是非常方便的.\n<!-- more -->\n\n## 简介\nMarkdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在换行等细节上也有改动。其有如下的优势:\n\t* 写博客专用,省去后期对文字格式进行改动\n\t* 纯文本编辑,脱离鼠标,专注文字100年\n\t* 受用面积广,windows/linux/mac都支持,而且有浏览器插件支持.perfect!\n\t* 支持转成Latex格式,方便以后整理.\n\n## 基本用法\n### 标题\n* H1:\t`# Header 1`\n* H2:\t`## Header 2`\n* H3:\t`### Header 3`\n* H4:\t`#### Header 4`\n\n### 块注释\n> **Note:**  \n> 可以嵌套引用  \n>> * item1   \n>> * item2   \n>\n> 结束\n\n### 字体格式\n* **加粗**:\t`**加粗**`\n* *斜体*:\t`*斜体*`\n* ~~删除线~~:\t`~~删除线~~`\n* ==高亮==:\t`==高亮==`\n* 水平线:\t`---`\n\n### 列表\n#### 无序\n* 用星号标注\n\t* 可以嵌套\n\t\t* 再嵌套\n\n#### 有序\n1. 第一点\n2. 第二点\n\t1. 嵌套\n\t\t1. 再嵌套\n\t\t2. 再嵌套\n\n### 链接\n`[名称](链接)`   \n[百度百科](http://baike.baidu.com/view/1.htm)\n\n### 图片\n`![名称](链接)`  \n![apache]({{ site.baseurl }}/assets/images/apache.png)\n\n### 代码\n\n```bash\nsudo apt-get install command\n```\n\n### 脚注\nI get 10 times more traffic from Google[^google] than from Yahoo[^2] or MSN[^3].\n\n[^google]: Google http://google.com/\n[^2]: Yahoo\thttp://search.yahoo.com/\n[^3]: MSN\thttp://search.msn.com/\n","source":"_posts/2015-06-04-实用的写博语言markdown.md","raw":"---\nlayout:\tpost\ntitle:\t实用的写博语言markdown\ncategories:\n- TECHNOLOGY\ntags:\n- Markdown\npermalink:  Explore-markdown\ncomments:\ttrue\n---\nMarkdown是一种可以使用普通文本编辑器编写的标记语言,通过类似HTML的标记语法,它可以使普通文本内容具有一定的格式.用它来书写博客是非常方便的.\n<!-- more -->\n\n## 简介\nMarkdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在换行等细节上也有改动。其有如下的优势:\n\t* 写博客专用,省去后期对文字格式进行改动\n\t* 纯文本编辑,脱离鼠标,专注文字100年\n\t* 受用面积广,windows/linux/mac都支持,而且有浏览器插件支持.perfect!\n\t* 支持转成Latex格式,方便以后整理.\n\n## 基本用法\n### 标题\n* H1:\t`# Header 1`\n* H2:\t`## Header 2`\n* H3:\t`### Header 3`\n* H4:\t`#### Header 4`\n\n### 块注释\n> **Note:**  \n> 可以嵌套引用  \n>> * item1   \n>> * item2   \n>\n> 结束\n\n### 字体格式\n* **加粗**:\t`**加粗**`\n* *斜体*:\t`*斜体*`\n* ~~删除线~~:\t`~~删除线~~`\n* ==高亮==:\t`==高亮==`\n* 水平线:\t`---`\n\n### 列表\n#### 无序\n* 用星号标注\n\t* 可以嵌套\n\t\t* 再嵌套\n\n#### 有序\n1. 第一点\n2. 第二点\n\t1. 嵌套\n\t\t1. 再嵌套\n\t\t2. 再嵌套\n\n### 链接\n`[名称](链接)`   \n[百度百科](http://baike.baidu.com/view/1.htm)\n\n### 图片\n`![名称](链接)`  \n![apache]({{ site.baseurl }}/assets/images/apache.png)\n\n### 代码\n\n```bash\nsudo apt-get install command\n```\n\n### 脚注\nI get 10 times more traffic from Google[^google] than from Yahoo[^2] or MSN[^3].\n\n[^google]: Google http://google.com/\n[^2]: Yahoo\thttp://search.yahoo.com/\n[^3]: MSN\thttp://search.msn.com/\n","slug":"Explore-markdown","published":1,"date":"2015-06-03T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1c0014l73yu3ott1p7","content":"<p>Markdown是一种可以使用普通文本编辑器编写的标记语言,通过类似HTML的标记语法,它可以使普通文本内容具有一定的格式.用它来书写博客是非常方便的. <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p>Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在换行等细节上也有改动。其有如下的优势: * 写博客专用,省去后期对文字格式进行改动 * 纯文本编辑,脱离鼠标,专注文字100年 * 受用面积广,windows/linux/mac都支持,而且有浏览器插件支持.perfect! * 支持转成Latex格式,方便以后整理.</p>\n<h2 id=\"基本用法\">基本用法</h2>\n<h3 id=\"标题\">标题</h3>\n<ul>\n<li>H1: <code># Header 1</code></li>\n<li>H2: <code>## Header 2</code></li>\n<li>H3: <code>### Header 3</code></li>\n<li>H4: <code>#### Header 4</code></li>\n</ul>\n<h3 id=\"块注释\">块注释</h3>\n<blockquote>\n<p><strong>Note:</strong><br>\n可以嵌套引用<br>\n&gt; * item1<br>\n&gt; * item2</p>\n<p>结束</p>\n</blockquote>\n<h3 id=\"字体格式\">字体格式</h3>\n<ul>\n<li><strong>加粗</strong>: <code>**加粗**</code></li>\n<li><em>斜体</em>: <code>*斜体*</code></li>\n<li><del>删除线</del>: <code>~~删除线~~</code></li>\n<li>==高亮==: <code>==高亮==</code></li>\n<li>水平线: <code>---</code></li>\n</ul>\n<h3 id=\"列表\">列表</h3>\n<h4 id=\"无序\">无序</h4>\n<ul>\n<li>用星号标注\n<ul>\n<li>可以嵌套\n<ul>\n<li>再嵌套</li>\n</ul></li>\n</ul></li>\n</ul>\n<h4 id=\"有序\">有序</h4>\n<ol style=\"list-style-type: decimal\">\n<li>第一点</li>\n<li>第二点\n<ol style=\"list-style-type: decimal\">\n<li>嵌套\n<ol style=\"list-style-type: decimal\">\n<li>再嵌套</li>\n<li>再嵌套</li>\n</ol></li>\n</ol></li>\n</ol>\n<h3 id=\"链接\">链接</h3>\n<p><code>[名称](链接)</code><br>\n<a href=\"http://baike.baidu.com/view/1.htm\" target=\"_blank\" rel=\"external\">百度百科</a></p>\n<h3 id=\"图片\">图片</h3>\n<p><code>![名称](链接)</code><br>\n[apache](/assets/images/apache.png)</p>\n<h3 id=\"代码\">代码</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install <span class=\"built_in\">command</span></div></pre></td></tr></table></figure>\n<h3 id=\"脚注\">脚注</h3>\n<p>I get 10 times more traffic from Google<a href=\"#fn1\" class=\"footnoteRef\" id=\"fnref1\"><sup>1</sup></a> than from Yahoo<a href=\"#fn2\" class=\"footnoteRef\" id=\"fnref2\"><sup>2</sup></a> or MSN<a href=\"#fn3\" class=\"footnoteRef\" id=\"fnref3\"><sup>3</sup></a>.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn1\"><p>Google http://google.com/<a href=\"#fnref1\">↩</a></p></li>\n<li id=\"fn2\"><p>Yahoo http://search.yahoo.com/<a href=\"#fnref2\">↩</a></p></li>\n<li id=\"fn3\"><p>MSN http://search.msn.com/<a href=\"#fnref3\">↩</a></p></li>\n</ol>\n</div>\n","site":{"data":{}},"excerpt":"<p>Markdown是一种可以使用普通文本编辑器编写的标记语言,通过类似HTML的标记语法,它可以使普通文本内容具有一定的格式.用它来书写博客是非常方便的.","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p>Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在换行等细节上也有改动。其有如下的优势: * 写博客专用,省去后期对文字格式进行改动 * 纯文本编辑,脱离鼠标,专注文字100年 * 受用面积广,windows/linux/mac都支持,而且有浏览器插件支持.perfect! * 支持转成Latex格式,方便以后整理.</p>\n<h2 id=\"基本用法\">基本用法</h2>\n<h3 id=\"标题\">标题</h3>\n<ul>\n<li>H1: <code># Header 1</code></li>\n<li>H2: <code>## Header 2</code></li>\n<li>H3: <code>### Header 3</code></li>\n<li>H4: <code>#### Header 4</code></li>\n</ul>\n<h3 id=\"块注释\">块注释</h3>\n<blockquote>\n<p><strong>Note:</strong><br>\n可以嵌套引用<br>\n&gt; * item1<br>\n&gt; * item2</p>\n<p>结束</p>\n</blockquote>\n<h3 id=\"字体格式\">字体格式</h3>\n<ul>\n<li><strong>加粗</strong>: <code>**加粗**</code></li>\n<li><em>斜体</em>: <code>*斜体*</code></li>\n<li><del>删除线</del>: <code>~~删除线~~</code></li>\n<li>==高亮==: <code>==高亮==</code></li>\n<li>水平线: <code>---</code></li>\n</ul>\n<h3 id=\"列表\">列表</h3>\n<h4 id=\"无序\">无序</h4>\n<ul>\n<li>用星号标注\n<ul>\n<li>可以嵌套\n<ul>\n<li>再嵌套</li>\n</ul></li>\n</ul></li>\n</ul>\n<h4 id=\"有序\">有序</h4>\n<ol style=\"list-style-type: decimal\">\n<li>第一点</li>\n<li>第二点\n<ol style=\"list-style-type: decimal\">\n<li>嵌套\n<ol style=\"list-style-type: decimal\">\n<li>再嵌套</li>\n<li>再嵌套</li>\n</ol></li>\n</ol></li>\n</ol>\n<h3 id=\"链接\">链接</h3>\n<p><code>[名称](链接)</code><br>\n<a href=\"http://baike.baidu.com/view/1.htm\" target=\"_blank\" rel=\"external\">百度百科</a></p>\n<h3 id=\"图片\">图片</h3>\n<p><code>![名称](链接)</code><br>\n[apache](/assets/images/apache.png)</p>\n<h3 id=\"代码\">代码</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install <span class=\"built_in\">command</span></div></pre></td></tr></table></figure>\n<h3 id=\"脚注\">脚注</h3>\n<p>I get 10 times more traffic from Google<a href=\"#fn1\" class=\"footnoteRef\" id=\"fnref1\"><sup>1</sup></a> than from Yahoo<a href=\"#fn2\" class=\"footnoteRef\" id=\"fnref2\"><sup>2</sup></a> or MSN<a href=\"#fn3\" class=\"footnoteRef\" id=\"fnref3\"><sup>3</sup></a>.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn1\"><p>Google http://google.com/<a href=\"#fnref1\">↩</a></p></li>\n<li id=\"fn2\"><p>Yahoo http://search.yahoo.com/<a href=\"#fnref2\">↩</a></p></li>\n<li id=\"fn3\"><p>MSN http://search.msn.com/<a href=\"#fnref3\">↩</a></p></li>\n</ol>\n</div>"},{"layout":"post","title":"shell编程之文件检索find","comments":1,"_content":"`find`命令是用来搜索指定目录下面符合搜索选项的文件.它跟`awk`,`sed`,`grep`的区别是它搜索到的对象是文件,而后三者是文件里的字符或字符串.\n<!-- more -->\n\n\n## 用法\n* 命令格式\n\n    ```bash\n    find path -option\n    ```\n* 参数说明\n    * `-name 'pattern'\t根据名称来查找\n    * `-user 'pattern'` 根据所属用户\n    * `-size n`\t\t根据文件大小   \n    * `-type [fdbl]`\t根据文件类型\n    * `-empty`\t\t是否时空文件\n    * `-exec command {} \\;`\t对查找到的文件进一步命令处理\n    * `-mtime n`\t根据文件内容修改时间(单位是天)\n    * `-ctime n`\t根据文件属性改变[`chmod`]时间(单位时天)\n    * `-atime n`\t根据文件访问[`cat`]时间(单位是天)\n\n\t> ***注意:***  \n\t> `-mmin n`/`-cmin n`/`-amin n`和上面三个区别是单位是分钟   \n\t> 对于n,`n`是指正好n天前的当天,`+n`是指所有n天前,`-n`是指所有n天内\n\n\n## 案例\n1. 查找_posts/目录下面文件名包含shell字符串的文件\n\n    ```bash\n    find _posts/ -name '*shell*'\n    ```\n    结果显示如下:\n    ![shell]({{ site.baseurl }}/assets/images/shell.png)\n2. 查找_posts/目录下面文件名包含shell字符串的文件,并统计每个文件有多少行\n\n    ```bash\n    find _posts/ -name '*shell*' -exec wc -l {} \\;\n    ```\n    结果显示如下:\n    ![findwc]({{ site.baseurl }}/assets/images/findwc.png)\n3. 下面根据文件内容修改时间(单位是分钟)进行查找\n目前_posts中的文件显示如下,以时间先后排序,其中swp的文件的修改时间为7月1号18:12,而原文件是17:59,其他的都是6月30号的文件.\n![shell]({{ site.baseurl }}/assets/images/states.png)\n    1. 查询19分钟之前那一分中哪些文件被修改了\n\n\t```bash\n\tfind _posts/ -mmin 19\n\t```\n\t结果显示如下:\n\t![19]({{ site.baseurl }}/assets/images/19.png)\n    2. 查询前19分钟之前所有被修改了的文件\n\n\t```bash\n\tfind _posts/ -mmin +19\n\t```\n\t结果显示如下:\n\t![+19]({{ site.baseurl }}/assets/images/+19.png)\n    3. 查询前19分钟以内所有被修改了的文件\n\n\t```bash\n\tfind _posts/ -mmin -19\n\t```\n\t结果显示如下:\n\t![-19]({{ site.baseurl }}/assets/images/-19.png)\n4. 查询_posts/目录下面文件大小大于3k的文件\n\n    ```bash\n    find _posts/ -size +3k\n    ```\n    结果显示如下:\n    ![10k]({{ site.baseurl }}/assets/images/10k.png)\n","source":"_posts/2015-07-01-shell编程之文件检索find.md","raw":"---\nlayout:\tpost\ntitle:\tshell编程之文件检索find\ncategories:\n- TECHNOLOGY\ntags:\n- Shell\npermalink:  Explore-find-Shell\ncomments:   true\n---\n`find`命令是用来搜索指定目录下面符合搜索选项的文件.它跟`awk`,`sed`,`grep`的区别是它搜索到的对象是文件,而后三者是文件里的字符或字符串.\n<!-- more -->\n\n\n## 用法\n* 命令格式\n\n    ```bash\n    find path -option\n    ```\n* 参数说明\n    * `-name 'pattern'\t根据名称来查找\n    * `-user 'pattern'` 根据所属用户\n    * `-size n`\t\t根据文件大小   \n    * `-type [fdbl]`\t根据文件类型\n    * `-empty`\t\t是否时空文件\n    * `-exec command {} \\;`\t对查找到的文件进一步命令处理\n    * `-mtime n`\t根据文件内容修改时间(单位是天)\n    * `-ctime n`\t根据文件属性改变[`chmod`]时间(单位时天)\n    * `-atime n`\t根据文件访问[`cat`]时间(单位是天)\n\n\t> ***注意:***  \n\t> `-mmin n`/`-cmin n`/`-amin n`和上面三个区别是单位是分钟   \n\t> 对于n,`n`是指正好n天前的当天,`+n`是指所有n天前,`-n`是指所有n天内\n\n\n## 案例\n1. 查找_posts/目录下面文件名包含shell字符串的文件\n\n    ```bash\n    find _posts/ -name '*shell*'\n    ```\n    结果显示如下:\n    ![shell]({{ site.baseurl }}/assets/images/shell.png)\n2. 查找_posts/目录下面文件名包含shell字符串的文件,并统计每个文件有多少行\n\n    ```bash\n    find _posts/ -name '*shell*' -exec wc -l {} \\;\n    ```\n    结果显示如下:\n    ![findwc]({{ site.baseurl }}/assets/images/findwc.png)\n3. 下面根据文件内容修改时间(单位是分钟)进行查找\n目前_posts中的文件显示如下,以时间先后排序,其中swp的文件的修改时间为7月1号18:12,而原文件是17:59,其他的都是6月30号的文件.\n![shell]({{ site.baseurl }}/assets/images/states.png)\n    1. 查询19分钟之前那一分中哪些文件被修改了\n\n\t```bash\n\tfind _posts/ -mmin 19\n\t```\n\t结果显示如下:\n\t![19]({{ site.baseurl }}/assets/images/19.png)\n    2. 查询前19分钟之前所有被修改了的文件\n\n\t```bash\n\tfind _posts/ -mmin +19\n\t```\n\t结果显示如下:\n\t![+19]({{ site.baseurl }}/assets/images/+19.png)\n    3. 查询前19分钟以内所有被修改了的文件\n\n\t```bash\n\tfind _posts/ -mmin -19\n\t```\n\t结果显示如下:\n\t![-19]({{ site.baseurl }}/assets/images/-19.png)\n4. 查询_posts/目录下面文件大小大于3k的文件\n\n    ```bash\n    find _posts/ -size +3k\n    ```\n    结果显示如下:\n    ![10k]({{ site.baseurl }}/assets/images/10k.png)\n","slug":"Explore-find-Shell","published":1,"date":"2015-06-30T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1d0015l73yll777kaq","content":"<p><code>find</code>命令是用来搜索指定目录下面符合搜索选项的文件.它跟<code>awk</code>,<code>sed</code>,<code>grep</code>的区别是它搜索到的对象是文件,而后三者是文件里的字符或字符串. <a id=\"more\"></a></p>\n<h2 id=\"用法\">用法</h2>\n<ul>\n<li><p>命令格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find path -option</div></pre></td></tr></table></figure></li>\n<li>参数说明\n<ul>\n<li>`-name ‘pattern’ 根据名称来查找</li>\n<li><code>-user 'pattern'</code> 根据所属用户</li>\n<li><code>-size n</code> 根据文件大小<br>\n</li>\n<li><code>-type [fdbl]</code> 根据文件类型</li>\n<li><code>-empty</code> 是否时空文件</li>\n<li><code>-exec command {} \\;</code> 对查找到的文件进一步命令处理</li>\n<li><code>-mtime n</code> 根据文件内容修改时间(单位是天)</li>\n<li><code>-ctime n</code> 根据文件属性改变[<code>chmod</code>]时间(单位时天)</li>\n<li><code>-atime n</code> 根据文件访问[<code>cat</code>]时间(单位是天)</li>\n</ul>\n<blockquote>\n<p><strong><em>注意:</em></strong><br>\n<code>-mmin n</code>/<code>-cmin n</code>/<code>-amin n</code>和上面三个区别是单位是分钟<br>\n对于n,<code>n</code>是指正好n天前的当天,<code>+n</code>是指所有n天前,<code>-n</code>是指所有n天内</p>\n</blockquote></li>\n</ul>\n<h2 id=\"案例\">案例</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>查找_posts/目录下面文件名包含shell字符串的文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find _posts/ -name <span class=\"string\">'*shell*'</span></div></pre></td></tr></table></figure>\n结果显示如下: [shell](/assets/images/shell.png)</li>\n<li><p>查找_posts/目录下面文件名包含shell字符串的文件,并统计每个文件有多少行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find _posts/ -name <span class=\"string\">'*shell*'</span> -exec wc <span class=\"_\">-l</span> &#123;&#125; \\;</div></pre></td></tr></table></figure>\n结果显示如下: [findwc](/assets/images/findwc.png)</li>\n<li>下面根据文件内容修改时间(单位是分钟)进行查找 目前_posts中的文件显示如下,以时间先后排序,其中swp的文件的修改时间为7月1号18:12,而原文件是17:59,其他的都是6月30号的文件. [shell](/assets/images/states.png)\n<ol style=\"list-style-type: decimal\">\n<li>查询19分钟之前那一分中哪些文件被修改了</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find _posts/ -mmin 19</div></pre></td></tr></table></figure>\n结果显示如下: [19](/assets/images/19.png)\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>查询前19分钟之前所有被修改了的文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find _posts/ -mmin +19</div></pre></td></tr></table></figure>\n结果显示如下: [+19](/assets/images/+19.png)\n<ol start=\"3\" style=\"list-style-type: decimal\">\n<li>查询前19分钟以内所有被修改了的文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find _posts/ -mmin -19</div></pre></td></tr></table></figure>\n结果显示如下: [-19](/assets/images/-19.png)</li>\n<li><p>查询_posts/目录下面文件大小大于3k的文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find _posts/ -size +3k</div></pre></td></tr></table></figure>\n<p>结果显示如下: [10k](/assets/images/10k.png)</p></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><code>find</code>命令是用来搜索指定目录下面符合搜索选项的文件.它跟<code>awk</code>,<code>sed</code>,<code>grep</code>的区别是它搜索到的对象是文件,而后三者是文件里的字符或字符串.","more":"</p>\n<h2 id=\"用法\">用法</h2>\n<ul>\n<li><p>命令格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find path -option</div></pre></td></tr></table></figure></li>\n<li>参数说明\n<ul>\n<li>`-name ‘pattern’ 根据名称来查找</li>\n<li><code>-user 'pattern'</code> 根据所属用户</li>\n<li><code>-size n</code> 根据文件大小<br>\n</li>\n<li><code>-type [fdbl]</code> 根据文件类型</li>\n<li><code>-empty</code> 是否时空文件</li>\n<li><code>-exec command {} \\;</code> 对查找到的文件进一步命令处理</li>\n<li><code>-mtime n</code> 根据文件内容修改时间(单位是天)</li>\n<li><code>-ctime n</code> 根据文件属性改变[<code>chmod</code>]时间(单位时天)</li>\n<li><code>-atime n</code> 根据文件访问[<code>cat</code>]时间(单位是天)</li>\n</ul>\n<blockquote>\n<p><strong><em>注意:</em></strong><br>\n<code>-mmin n</code>/<code>-cmin n</code>/<code>-amin n</code>和上面三个区别是单位是分钟<br>\n对于n,<code>n</code>是指正好n天前的当天,<code>+n</code>是指所有n天前,<code>-n</code>是指所有n天内</p>\n</blockquote></li>\n</ul>\n<h2 id=\"案例\">案例</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>查找_posts/目录下面文件名包含shell字符串的文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find _posts/ -name <span class=\"string\">'*shell*'</span></div></pre></td></tr></table></figure>\n结果显示如下: [shell](/assets/images/shell.png)</li>\n<li><p>查找_posts/目录下面文件名包含shell字符串的文件,并统计每个文件有多少行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find _posts/ -name <span class=\"string\">'*shell*'</span> -exec wc <span class=\"_\">-l</span> &#123;&#125; \\;</div></pre></td></tr></table></figure>\n结果显示如下: [findwc](/assets/images/findwc.png)</li>\n<li>下面根据文件内容修改时间(单位是分钟)进行查找 目前_posts中的文件显示如下,以时间先后排序,其中swp的文件的修改时间为7月1号18:12,而原文件是17:59,其他的都是6月30号的文件. [shell](/assets/images/states.png)\n<ol style=\"list-style-type: decimal\">\n<li>查询19分钟之前那一分中哪些文件被修改了</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find _posts/ -mmin 19</div></pre></td></tr></table></figure>\n结果显示如下: [19](/assets/images/19.png)\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>查询前19分钟之前所有被修改了的文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find _posts/ -mmin +19</div></pre></td></tr></table></figure>\n结果显示如下: [+19](/assets/images/+19.png)\n<ol start=\"3\" style=\"list-style-type: decimal\">\n<li>查询前19分钟以内所有被修改了的文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find _posts/ -mmin -19</div></pre></td></tr></table></figure>\n结果显示如下: [-19](/assets/images/-19.png)</li>\n<li><p>查询_posts/目录下面文件大小大于3k的文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find _posts/ -size +3k</div></pre></td></tr></table></figure>\n<p>结果显示如下: [10k](/assets/images/10k.png)</p></li>\n</ol>"},{"layout":"post","title":"ACM算法之约数个数原理","comments":1,"_content":"在数论里面除了老生常谈的素数问题，还有一个就是约数个数问题。对于这个问题的解法可能还停留在用n除以 $1,\\cdots,\\sqrt n$，然后统计能够整除的个数。其时间复杂度为 $O(\\sqrt n)$。本文主要介绍约数个数定理以及它在实际题目中的应用。\n<!-- more -->\n\n\n## 约数个数原理\n\n* 原理  \n对于一个大于1的正整数n，n可以因式分解为\n$$\nn = \\prod _{ i = 1 } ^k p _i ^{ a _i } = p _1 ^{ a _1 } * \\cdots * p _k ^{ a _k }\n$$,\n其中$ p _i $是质数，$ a _i \\in N $，那么n的约数个数就是\n$$\nf ( n ) = \\prod _{ i = 1 } ^k ( a _i + 1) = ( a _i + 1) * \\cdots *( a _k + 1 )\n$$\n\n* 简证  \n因为$ p _i $都是质数，无法再进行因式分解，所以任意$ p _i $的组合都可以构成一个约数，对于质数$ p _i $有$ (a _i+1) $种可能，分别是 $ 0,1,\\cdots,a _i $，那么对于k个$ p _i $共有 $ \\prod _{i=1}^k (a _i +1) $种可能的组合。\n\n## 代码实现\n* 思路  \n要求解一个整数n的约数个数$ f(n) $，其关键就是通过因式分解获取各个质数的指数。不过通常情况下，我们无法获取比n小的质数有哪些（$ 10^{16} $以内的质数有104165820+个，所以数目还是可观的。）这里我们通过n不断除以除数m，$ m \\in {2,3,5,7,9,\\cdots} $，如果能够整除的话，就更新n为$ n/m $，这样虽然除数里面有9这样的合数，但经过除以2次3后，9将会不被更新后的n整除，所以实际的情况还是除以质数。\n\n* c++代码  \n\n\t```c++\n\t// 快速计算n的约数个数\n\tint NumOfFac(long long n){\n\t\tunsigned int i,k,count=1;\n\t\tlong long m=n;\n\t\twhile(m!=1){\n\t\t\tfor(i=2; i<=m; i+=2){\n\t\t\t\tif(m % i == 0){\n\t\t\t\t\tk=1;\n\t\t\t\t\twhile(m % i == 0){\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tm = m / i;\n\t\t\t\t\t}\n\t\t\t\tcount = count*k;\n\t\t\t\t}\n\t\t\t// 2,3,5,7,11...避开2->3之间差1\n\t\t\tif(i == 2)\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t```\n\n## 解题报告\n* HihoCoder\n\t1. divisors: [divisors](http://hihocoder.com/contest/mstest2015july1/problem/2) | [源码]({{ site.baseurl }}/assets/attachs/hiho_divisors.cpp.txt) | [报告细节]({{ site.baseurl }}/acm_report/2015/07/23/ACM解题报告之最大约数个数.html)\n\n\t\t注意点：\n\t\t1. 暴力求解(==遍历比n小的数，依次求解每个数的约数个数==)是行不通的。\n\t\t2. 合理利用约数个数原理，并对其进行优化求解。\n\n\t\t\t> **TIPS:**  \n\t\t\t> 最终求解的拥有最大约数个数的数一定满足下面的推论：  \n\t\t\t> 若$p _1 < p _2 <  \\cdots < p _k$,则$a _1 > a _2 > \\cdots > a _k$\n","source":"_posts/2015-07-15-ACM算法之约数个数原理.md","raw":"---\nlayout:\tpost\ntitle:\tACM算法之约数个数原理\ncategories:\n- TECHNOLOGY\ntags:\n- ACM\n- Algorithm\npermalink:  Explore-numOfDivisor\ncomments:\ttrue\n---\n在数论里面除了老生常谈的素数问题，还有一个就是约数个数问题。对于这个问题的解法可能还停留在用n除以 $1,\\cdots,\\sqrt n$，然后统计能够整除的个数。其时间复杂度为 $O(\\sqrt n)$。本文主要介绍约数个数定理以及它在实际题目中的应用。\n<!-- more -->\n\n\n## 约数个数原理\n\n* 原理  \n对于一个大于1的正整数n，n可以因式分解为\n$$\nn = \\prod _{ i = 1 } ^k p _i ^{ a _i } = p _1 ^{ a _1 } * \\cdots * p _k ^{ a _k }\n$$,\n其中$ p _i $是质数，$ a _i \\in N $，那么n的约数个数就是\n$$\nf ( n ) = \\prod _{ i = 1 } ^k ( a _i + 1) = ( a _i + 1) * \\cdots *( a _k + 1 )\n$$\n\n* 简证  \n因为$ p _i $都是质数，无法再进行因式分解，所以任意$ p _i $的组合都可以构成一个约数，对于质数$ p _i $有$ (a _i+1) $种可能，分别是 $ 0,1,\\cdots,a _i $，那么对于k个$ p _i $共有 $ \\prod _{i=1}^k (a _i +1) $种可能的组合。\n\n## 代码实现\n* 思路  \n要求解一个整数n的约数个数$ f(n) $，其关键就是通过因式分解获取各个质数的指数。不过通常情况下，我们无法获取比n小的质数有哪些（$ 10^{16} $以内的质数有104165820+个，所以数目还是可观的。）这里我们通过n不断除以除数m，$ m \\in {2,3,5,7,9,\\cdots} $，如果能够整除的话，就更新n为$ n/m $，这样虽然除数里面有9这样的合数，但经过除以2次3后，9将会不被更新后的n整除，所以实际的情况还是除以质数。\n\n* c++代码  \n\n\t```c++\n\t// 快速计算n的约数个数\n\tint NumOfFac(long long n){\n\t\tunsigned int i,k,count=1;\n\t\tlong long m=n;\n\t\twhile(m!=1){\n\t\t\tfor(i=2; i<=m; i+=2){\n\t\t\t\tif(m % i == 0){\n\t\t\t\t\tk=1;\n\t\t\t\t\twhile(m % i == 0){\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tm = m / i;\n\t\t\t\t\t}\n\t\t\t\tcount = count*k;\n\t\t\t\t}\n\t\t\t// 2,3,5,7,11...避开2->3之间差1\n\t\t\tif(i == 2)\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t```\n\n## 解题报告\n* HihoCoder\n\t1. divisors: [divisors](http://hihocoder.com/contest/mstest2015july1/problem/2) | [源码]({{ site.baseurl }}/assets/attachs/hiho_divisors.cpp.txt) | [报告细节]({{ site.baseurl }}/acm_report/2015/07/23/ACM解题报告之最大约数个数.html)\n\n\t\t注意点：\n\t\t1. 暴力求解(==遍历比n小的数，依次求解每个数的约数个数==)是行不通的。\n\t\t2. 合理利用约数个数原理，并对其进行优化求解。\n\n\t\t\t> **TIPS:**  \n\t\t\t> 最终求解的拥有最大约数个数的数一定满足下面的推论：  \n\t\t\t> 若$p _1 < p _2 <  \\cdots < p _k$,则$a _1 > a _2 > \\cdots > a _k$\n","slug":"Explore-numOfDivisor","published":1,"date":"2015-07-14T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1d0016l73y8zt76jmx","content":"<p>在数论里面除了老生常谈的素数问题，还有一个就是约数个数问题。对于这个问题的解法可能还停留在用n除以 <span class=\"math inline\">\\(1,\\cdots,\\sqrt n\\)</span>，然后统计能够整除的个数。其时间复杂度为 <span class=\"math inline\">\\(O(\\sqrt n)\\)</span>。本文主要介绍约数个数定理以及它在实际题目中的应用。 <a id=\"more\"></a></p>\n<h2 id=\"约数个数原理\">约数个数原理</h2>\n<ul>\n<li><p>原理<br>\n对于一个大于1的正整数n，n可以因式分解为 <span class=\"math display\">\\[\nn = \\prod _{ i = 1 } ^k p _i ^{ a _i } = p _1 ^{ a _1 } * \\cdots * p _k ^{ a _k }\n\\]</span>, 其中$ p _i <span class=\"math inline\">\\(是质数，\\)</span> a _i N $，那么n的约数个数就是 <span class=\"math display\">\\[\nf ( n ) = \\prod _{ i = 1 } ^k ( a _i + 1) = ( a _i + 1) * \\cdots *( a _k + 1 )\n\\]</span></p></li>\n<li><p>简证<br>\n因为$ p _i <span class=\"math inline\">\\(都是质数，无法再进行因式分解，所以任意\\)</span> p _i <span class=\"math inline\">\\(的组合都可以构成一个约数，对于质数\\)</span> p _i <span class=\"math inline\">\\(有\\)</span> (a _i+1) $种可能，分别是 $ 0,1,,a _i <span class=\"math inline\">\\(，那么对于k个\\)</span> p <em>i $共有 $ </em>{i=1}^k (a _i +1) $种可能的组合。</p></li>\n</ul>\n<h2 id=\"代码实现\">代码实现</h2>\n<ul>\n<li><p>思路<br>\n要求解一个整数n的约数个数$ f(n) <span class=\"math inline\">\\(，其关键就是通过因式分解获取各个质数的指数。不过通常情况下，我们无法获取比n小的质数有哪些（\\)</span> 10^{16} <span class=\"math inline\">\\(以内的质数有104165820+个，所以数目还是可观的。）这里我们通过n不断除以除数m，\\)</span> m  <span class=\"math inline\">\\(，如果能够整除的话，就更新n为\\)</span> n/m $，这样虽然除数里面有9这样的合数，但经过除以2次3后，9将会不被更新后的n整除，所以实际的情况还是除以质数。</p></li>\n<li><p>c++代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 快速计算n的约数个数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">NumOfFac</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i,k,count=<span class=\"number\">1</span>;</div><div class=\"line\">\t<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> m=n;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(m!=<span class=\"number\">1</span>)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(i=<span class=\"number\">2</span>; i&lt;=m; i+=<span class=\"number\">2</span>)&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(m % i == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t\t\tk=<span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">while</span>(m % i == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t\t\t\tk++;</div><div class=\"line\">\t\t\t\t\tm = m / i;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\tcount = count*k;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">// 2,3,5,7,11...避开2-&gt;3之间差1</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(i == <span class=\"number\">2</span>)</div><div class=\"line\">\t\t\ti--;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> count;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"解题报告\">解题报告</h2>\n<ul>\n<li>HihoCoder\n<ol style=\"list-style-type: decimal\">\n<li><p>divisors: <a href=\"http://hihocoder.com/contest/mstest2015july1/problem/2\" target=\"_blank\" rel=\"external\">divisors</a> | [源码](/assets/attachs/hiho_divisors.cpp.txt) | [报告细节](/acm_report/2015/07/23/ACM解题报告之最大约数个数.html)</p>\n注意点：\n<ol style=\"list-style-type: decimal\">\n<li>暴力求解(==遍历比n小的数，依次求解每个数的约数个数==)是行不通的。</li>\n<li><p>合理利用约数个数原理，并对其进行优化求解。</p>\n<blockquote>\n<p><strong>TIPS:</strong><br>\n最终求解的拥有最大约数个数的数一定满足下面的推论：<br>\n若<span class=\"math inline\">\\(p _1 &lt; p _2 &lt; \\cdots &lt; p _k\\)</span>,则<span class=\"math inline\">\\(a _1 &gt; a _2 &gt; \\cdots &gt; a _k\\)</span></p>\n</blockquote></li>\n</ol></li>\n</ol></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在数论里面除了老生常谈的素数问题，还有一个就是约数个数问题。对于这个问题的解法可能还停留在用n除以 <span class=\"math inline\">\\(1,\\cdots,\\sqrt n\\)</span>，然后统计能够整除的个数。其时间复杂度为 <span class=\"math inline\">\\(O(\\sqrt n)\\)</span>。本文主要介绍约数个数定理以及它在实际题目中的应用。","more":"</p>\n<h2 id=\"约数个数原理\">约数个数原理</h2>\n<ul>\n<li><p>原理<br>\n对于一个大于1的正整数n，n可以因式分解为 <span class=\"math display\">\\[\nn = \\prod _{ i = 1 } ^k p _i ^{ a _i } = p _1 ^{ a _1 } * \\cdots * p _k ^{ a _k }\n\\]</span>, 其中$ p _i <span class=\"math inline\">\\(是质数，\\)</span> a _i N $，那么n的约数个数就是 <span class=\"math display\">\\[\nf ( n ) = \\prod _{ i = 1 } ^k ( a _i + 1) = ( a _i + 1) * \\cdots *( a _k + 1 )\n\\]</span></p></li>\n<li><p>简证<br>\n因为$ p _i <span class=\"math inline\">\\(都是质数，无法再进行因式分解，所以任意\\)</span> p _i <span class=\"math inline\">\\(的组合都可以构成一个约数，对于质数\\)</span> p _i <span class=\"math inline\">\\(有\\)</span> (a _i+1) $种可能，分别是 $ 0,1,,a _i <span class=\"math inline\">\\(，那么对于k个\\)</span> p <em>i $共有 $ </em>{i=1}^k (a _i +1) $种可能的组合。</p></li>\n</ul>\n<h2 id=\"代码实现\">代码实现</h2>\n<ul>\n<li><p>思路<br>\n要求解一个整数n的约数个数$ f(n) <span class=\"math inline\">\\(，其关键就是通过因式分解获取各个质数的指数。不过通常情况下，我们无法获取比n小的质数有哪些（\\)</span> 10^{16} <span class=\"math inline\">\\(以内的质数有104165820+个，所以数目还是可观的。）这里我们通过n不断除以除数m，\\)</span> m  <span class=\"math inline\">\\(，如果能够整除的话，就更新n为\\)</span> n/m $，这样虽然除数里面有9这样的合数，但经过除以2次3后，9将会不被更新后的n整除，所以实际的情况还是除以质数。</p></li>\n<li><p>c++代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 快速计算n的约数个数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">NumOfFac</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i,k,count=<span class=\"number\">1</span>;</div><div class=\"line\">\t<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> m=n;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(m!=<span class=\"number\">1</span>)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(i=<span class=\"number\">2</span>; i&lt;=m; i+=<span class=\"number\">2</span>)&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(m % i == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t\t\tk=<span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">while</span>(m % i == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t\t\t\tk++;</div><div class=\"line\">\t\t\t\t\tm = m / i;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\tcount = count*k;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t<span class=\"comment\">// 2,3,5,7,11...避开2-&gt;3之间差1</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(i == <span class=\"number\">2</span>)</div><div class=\"line\">\t\t\ti--;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> count;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"解题报告\">解题报告</h2>\n<ul>\n<li>HihoCoder\n<ol style=\"list-style-type: decimal\">\n<li><p>divisors: <a href=\"http://hihocoder.com/contest/mstest2015july1/problem/2\" target=\"_blank\" rel=\"external\">divisors</a> | [源码](/assets/attachs/hiho_divisors.cpp.txt) | [报告细节](/acm_report/2015/07/23/ACM解题报告之最大约数个数.html)</p>\n注意点：\n<ol style=\"list-style-type: decimal\">\n<li>暴力求解(==遍历比n小的数，依次求解每个数的约数个数==)是行不通的。</li>\n<li><p>合理利用约数个数原理，并对其进行优化求解。</p>\n<blockquote>\n<p><strong>TIPS:</strong><br>\n最终求解的拥有最大约数个数的数一定满足下面的推论：<br>\n若<span class=\"math inline\">\\(p _1 &lt; p _2 &lt; \\cdots &lt; p _k\\)</span>,则<span class=\"math inline\">\\(a _1 &gt; a _2 &gt; \\cdots &gt; a _k\\)</span></p>\n</blockquote></li>\n</ol></li>\n</ol></li>\n</ul>"},{"layout":"post","title":"shell编程之软硬链接ln","comments":1,"_content":"在windows里面我们经常通过快捷方式来创建链接以方便我们使用电脑。而linux中有两种方式创建链接，分别为软链接和硬链接。下面我们就来详细说下二者的区别。\n<!-- more -->\n\n\n## 定义\n`ln`命令是为某个文件在另外一个位置建立一个同步链接，当我们需要在不同的目录用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，此时只需用`ln`创建对应文件的链接，不必重复的占用磁盘空间。\n\n* 命令格式\n\n\t```bash\n\t# 硬链接\n\tln source target\n\t# 软链接\n\tln -s source target\n\t```\n* 软链接\n\n\t软链接跟windows里面的快捷方式等价。它的内容是指向另一个文件的位置。所以可以创建某个目录的软链接，也可以对一个不存在的文件进行链接。除此之外，它可以跨文件系统。这三点硬链接都无法实现。\n* 硬链接\n\n\t硬链接可以理解为文件的别名，而且别名可以有多个。\n\n## 原理\n对于linux而言，文件的结构与windows有点类似，由文件名，inode（类似于windows下的FCB文件控制块，保存文件的一些信息）和数据组成。比如创建origin文件，会得到下面的信息。\n![origin]({{ site.baseurl }}/assets/images/origin.png)\n\n注意Inode和硬链接，下面创建origin的硬链接hardlink。\n![hardlink]({{ site.baseurl }}/assets/images/hardlink.png)\n\n比对发现，创建硬链接的文件hardlink与原文件origin之间除了名称不同之外其他完全相同，就像同一个人它有个正式的名称也可能会有小名。它们的数据显然完全一样。\n\n接下来，我们创建origin的软链接softlink。\n![softlink]({{ site.baseurl }}/assets/images/softlink.png)\n\n对比发现，origin和softlink是完全不同的文件，有着不同的size，不同的块，不同的Inode，不同的type。唯一的联系是softlink文件指向origin文件。\n\n\n## 用例\n*  删除源文件对软硬链接的影响\n\t![rmorigin]({{ site.baseurl }}/assets/images/rmorigin.png)\n\n\t由上图可以看出hardlink中硬链接的个数少了一个，而softlink还是安然无恙的存在着。接着我们通过两个链接来打开文件。\n\t![linkshow]({{ site.baseurl}}/assets/images/linkshow.png)\n\n\t由上图发觉，hardlink依旧能打开文件，而软链接却无法查看原文件。\n","source":"_posts/2015-07-06-shell编程之软硬链接ln.md","raw":"---\nlayout:\tpost\ntitle:\tshell编程之软硬链接ln\ncategories:\n- TECHNOLOGY\ntags:\n- Shell\npermalink:  Explore-ln-Shell\ncomments:\ttrue\n---\n在windows里面我们经常通过快捷方式来创建链接以方便我们使用电脑。而linux中有两种方式创建链接，分别为软链接和硬链接。下面我们就来详细说下二者的区别。\n<!-- more -->\n\n\n## 定义\n`ln`命令是为某个文件在另外一个位置建立一个同步链接，当我们需要在不同的目录用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，此时只需用`ln`创建对应文件的链接，不必重复的占用磁盘空间。\n\n* 命令格式\n\n\t```bash\n\t# 硬链接\n\tln source target\n\t# 软链接\n\tln -s source target\n\t```\n* 软链接\n\n\t软链接跟windows里面的快捷方式等价。它的内容是指向另一个文件的位置。所以可以创建某个目录的软链接，也可以对一个不存在的文件进行链接。除此之外，它可以跨文件系统。这三点硬链接都无法实现。\n* 硬链接\n\n\t硬链接可以理解为文件的别名，而且别名可以有多个。\n\n## 原理\n对于linux而言，文件的结构与windows有点类似，由文件名，inode（类似于windows下的FCB文件控制块，保存文件的一些信息）和数据组成。比如创建origin文件，会得到下面的信息。\n![origin]({{ site.baseurl }}/assets/images/origin.png)\n\n注意Inode和硬链接，下面创建origin的硬链接hardlink。\n![hardlink]({{ site.baseurl }}/assets/images/hardlink.png)\n\n比对发现，创建硬链接的文件hardlink与原文件origin之间除了名称不同之外其他完全相同，就像同一个人它有个正式的名称也可能会有小名。它们的数据显然完全一样。\n\n接下来，我们创建origin的软链接softlink。\n![softlink]({{ site.baseurl }}/assets/images/softlink.png)\n\n对比发现，origin和softlink是完全不同的文件，有着不同的size，不同的块，不同的Inode，不同的type。唯一的联系是softlink文件指向origin文件。\n\n\n## 用例\n*  删除源文件对软硬链接的影响\n\t![rmorigin]({{ site.baseurl }}/assets/images/rmorigin.png)\n\n\t由上图可以看出hardlink中硬链接的个数少了一个，而softlink还是安然无恙的存在着。接着我们通过两个链接来打开文件。\n\t![linkshow]({{ site.baseurl}}/assets/images/linkshow.png)\n\n\t由上图发觉，hardlink依旧能打开文件，而软链接却无法查看原文件。\n","slug":"Explore-ln-Shell","published":1,"date":"2015-07-05T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1e0017l73yhruv5f0p","content":"<p>在windows里面我们经常通过快捷方式来创建链接以方便我们使用电脑。而linux中有两种方式创建链接，分别为软链接和硬链接。下面我们就来详细说下二者的区别。 <a id=\"more\"></a></p>\n<h2 id=\"定义\">定义</h2>\n<p><code>ln</code>命令是为某个文件在另外一个位置建立一个同步链接，当我们需要在不同的目录用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，此时只需用<code>ln</code>创建对应文件的链接，不必重复的占用磁盘空间。</p>\n<ul>\n<li><p>命令格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 硬链接</span></div><div class=\"line\">ln <span class=\"built_in\">source</span> target</div><div class=\"line\"><span class=\"comment\"># 软链接</span></div><div class=\"line\">ln <span class=\"_\">-s</span> <span class=\"built_in\">source</span> target</div></pre></td></tr></table></figure></li>\n<li><p>软链接</p>\n软链接跟windows里面的快捷方式等价。它的内容是指向另一个文件的位置。所以可以创建某个目录的软链接，也可以对一个不存在的文件进行链接。除此之外，它可以跨文件系统。这三点硬链接都无法实现。</li>\n<li><p>硬链接</p>\n<p>硬链接可以理解为文件的别名，而且别名可以有多个。</p></li>\n</ul>\n<h2 id=\"原理\">原理</h2>\n<p>对于linux而言，文件的结构与windows有点类似，由文件名，inode（类似于windows下的FCB文件控制块，保存文件的一些信息）和数据组成。比如创建origin文件，会得到下面的信息。 [origin](/assets/images/origin.png)</p>\n<p>注意Inode和硬链接，下面创建origin的硬链接hardlink。 [hardlink](/assets/images/hardlink.png)</p>\n<p>比对发现，创建硬链接的文件hardlink与原文件origin之间除了名称不同之外其他完全相同，就像同一个人它有个正式的名称也可能会有小名。它们的数据显然完全一样。</p>\n<p>接下来，我们创建origin的软链接softlink。 [softlink](/assets/images/softlink.png)</p>\n<p>对比发现，origin和softlink是完全不同的文件，有着不同的size，不同的块，不同的Inode，不同的type。唯一的联系是softlink文件指向origin文件。</p>\n<h2 id=\"用例\">用例</h2>\n<ul>\n<li><p>删除源文件对软硬链接的影响 [rmorigin](/assets/images/rmorigin.png)</p>\n<p>由上图可以看出hardlink中硬链接的个数少了一个，而softlink还是安然无恙的存在着。接着我们通过两个链接来打开文件。 [linkshow](/assets/images/linkshow.png)</p>\n<p>由上图发觉，hardlink依旧能打开文件，而软链接却无法查看原文件。</p></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在windows里面我们经常通过快捷方式来创建链接以方便我们使用电脑。而linux中有两种方式创建链接，分别为软链接和硬链接。下面我们就来详细说下二者的区别。","more":"</p>\n<h2 id=\"定义\">定义</h2>\n<p><code>ln</code>命令是为某个文件在另外一个位置建立一个同步链接，当我们需要在不同的目录用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，此时只需用<code>ln</code>创建对应文件的链接，不必重复的占用磁盘空间。</p>\n<ul>\n<li><p>命令格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 硬链接</span></div><div class=\"line\">ln <span class=\"built_in\">source</span> target</div><div class=\"line\"><span class=\"comment\"># 软链接</span></div><div class=\"line\">ln <span class=\"_\">-s</span> <span class=\"built_in\">source</span> target</div></pre></td></tr></table></figure></li>\n<li><p>软链接</p>\n软链接跟windows里面的快捷方式等价。它的内容是指向另一个文件的位置。所以可以创建某个目录的软链接，也可以对一个不存在的文件进行链接。除此之外，它可以跨文件系统。这三点硬链接都无法实现。</li>\n<li><p>硬链接</p>\n<p>硬链接可以理解为文件的别名，而且别名可以有多个。</p></li>\n</ul>\n<h2 id=\"原理\">原理</h2>\n<p>对于linux而言，文件的结构与windows有点类似，由文件名，inode（类似于windows下的FCB文件控制块，保存文件的一些信息）和数据组成。比如创建origin文件，会得到下面的信息。 [origin](/assets/images/origin.png)</p>\n<p>注意Inode和硬链接，下面创建origin的硬链接hardlink。 [hardlink](/assets/images/hardlink.png)</p>\n<p>比对发现，创建硬链接的文件hardlink与原文件origin之间除了名称不同之外其他完全相同，就像同一个人它有个正式的名称也可能会有小名。它们的数据显然完全一样。</p>\n<p>接下来，我们创建origin的软链接softlink。 [softlink](/assets/images/softlink.png)</p>\n<p>对比发现，origin和softlink是完全不同的文件，有着不同的size，不同的块，不同的Inode，不同的type。唯一的联系是softlink文件指向origin文件。</p>\n<h2 id=\"用例\">用例</h2>\n<ul>\n<li><p>删除源文件对软硬链接的影响 [rmorigin](/assets/images/rmorigin.png)</p>\n<p>由上图可以看出hardlink中硬链接的个数少了一个，而softlink还是安然无恙的存在着。接着我们通过两个链接来打开文件。 [linkshow](/assets/images/linkshow.png)</p>\n<p>由上图发觉，hardlink依旧能打开文件，而软链接却无法查看原文件。</p></li>\n</ul>"},{"layout":"post","title":"ACM算法之基本并查集","comments":1,"_content":"并查集是一种用途广泛的数据结构，能够快速地处理集合的合并和查询问题，并且实现起来非常方便，在很多场合中都有着非常巧妙的应用。本文首先介绍并查集的定义、原理及具体实现，然后结合hihocoder以及poj上的题目做一些具体实践。\n<!-- more -->\n\n## 定义和原理\n[并查集](https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86)(Union-Find Set)是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个操作用于此数据结构：\n\n* `Find`\t\t\t确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。  \n* `Union`\t将两个子集合并成同一个集合。  \n\n因为它支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，`MakeSet`，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。\n\n\n网络上有两篇帮助理解的博文，博主用通俗易懂的语言，图文并茂的方式将并查集生动形象得阐释了。特附上博文链接：   \n\n* [通俗易懂的诠释并查集](http://www.cnblogs.com/ACShiryu/archive/2011/11/24/unionset.html)\n* [图文并茂的解释并查集](http://www.cnblogs.com/cyjb/p/UnionFindSets.html)\n\n\n## 代码实现\n* 并查集的数据存储[==O(n)==]\n\n\t```c\n\t#define LENMAX 1000000\n\tint father[LENMAX]\n\t```\n\t虽然并查集是树型的数据结构，但是实际的存储是用数组，就跟堆排序一样。\n* 并查集的初始化`MakeSet`\n\n\t```c\n\tvoid MakeSet(){\n\t\tint i;\n\t\tfor(i=0;i<LENMAX;i++){\n\t\t\tfather[i]=i;\n\t\t}\n\t}\n\t```\n\t`MakeSet`是并查集的初始化函数，这里采用`father[i]==i`来判定该i是否是某个集合的代表。\n* 并查集的查找操作[==O(alpha(n)) alpha(n)<n==]\n\n\t```c\n\t// 查找操作--未压缩路径\n\tint Find(int x){\n\t\tif(x==father[x])\n\t\t  return x;\n\t\telse\n\t\t  return Find(father[x]);\n\t}\n\t```\n\n\t```c\n\t// 查找操作--压缩路径\n\tint Find(int x){\n\t\tif(x==father[x])\n\t\t  return x;\n\t\telse{\n\t\t\tfather[x]=Find(father[x]);\n\t\t\treturn father[x];\n\t\t}\n\t}\n\t```\n\t压缩路径可以避免重复查找，其实际的意义是将树的深度由n变成1。就是将层层的等级制度变成全部向皇帝/代表负责。\n* 并查集的合并操作[==O(alpha(n))  alpha(n)<n==]\n\n\t```c\n\t// 合并操作\n\tvoid Union(int x, int y){\n\t\tint fatherX = Find(x);\n\t\tint fatherY = Find(y);\n\n\t\t// fatherY归fatherX管了\n\t\tif(fatherX!=fatherY)\n\t\t  father[fatherY]=fatherX;\n\n\t\t/*\n\t\t// 合并的时候取小的数值\n\t\tif(fatherX<fatherY)\n\t\t\tfather[fatherY]=fatherX;\n\t\telse\n\t\t\tfather[fatherX]=fatherY;\n\t\t*/\n\t}\n\t```\n\n## 解题报告\n* HihoCoder\n\t1. 第十四周：[无间道之并查集](http://hihocoder.com/contest/hiho14/problem/1)\t|\t[源码]({{ site.baseurl }}/assets/attachs/hiho_14_main.cpp.txt)\n\n\t\t注意点：\n\t\t1. 通过map将名称转化为int标号\n\t\t2. 最后一步判定两个名称是否是同一个集合时用`Find(mapName[nameX])==Find(mapName[nameY])`,不能用`father[mapName[nameX]]==father[mapName[nameY]]`。\n\n* POJ\n\t1. 1611: [The Suspects](http://poj.org/problem?id=1611)\t|\t[源码]({{ site.baseurl }}/assets/attachs/poj_1611_main.cpp.txt)\n\n\t\t注意点:\n\t\t1.  判定i是否和0同一类必须得通过`Find`找到最高的根节点是相同[代码实现可以添加`rank[LENMAX]`来记录同集合的元素个数]\n\t2. 2524: [Ubiquitous Religions](http://poj.org/problem?id=2524)\t|\t[源码]({{ site.baseurl }}/assets/attachs/poj_2524_main.cpp.txt)\n\n\t\t注意点：\n\t\t1. 通过`i=father[i]`判断是否是根节点,也就是说是否是一个集合\n","source":"_posts/2015-06-30-ACM算法之基本并查集.md","raw":"---\nlayout:\tpost\ntitle:\tACM算法之基本并查集\ncategories:\n- TECHNOLOGY\ntags:\n- ACM\n- Algorithm\npermalink:  Explore-unionFind\ncomments:   true\n---\n并查集是一种用途广泛的数据结构，能够快速地处理集合的合并和查询问题，并且实现起来非常方便，在很多场合中都有着非常巧妙的应用。本文首先介绍并查集的定义、原理及具体实现，然后结合hihocoder以及poj上的题目做一些具体实践。\n<!-- more -->\n\n## 定义和原理\n[并查集](https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86)(Union-Find Set)是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个操作用于此数据结构：\n\n* `Find`\t\t\t确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。  \n* `Union`\t将两个子集合并成同一个集合。  \n\n因为它支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，`MakeSet`，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。\n\n\n网络上有两篇帮助理解的博文，博主用通俗易懂的语言，图文并茂的方式将并查集生动形象得阐释了。特附上博文链接：   \n\n* [通俗易懂的诠释并查集](http://www.cnblogs.com/ACShiryu/archive/2011/11/24/unionset.html)\n* [图文并茂的解释并查集](http://www.cnblogs.com/cyjb/p/UnionFindSets.html)\n\n\n## 代码实现\n* 并查集的数据存储[==O(n)==]\n\n\t```c\n\t#define LENMAX 1000000\n\tint father[LENMAX]\n\t```\n\t虽然并查集是树型的数据结构，但是实际的存储是用数组，就跟堆排序一样。\n* 并查集的初始化`MakeSet`\n\n\t```c\n\tvoid MakeSet(){\n\t\tint i;\n\t\tfor(i=0;i<LENMAX;i++){\n\t\t\tfather[i]=i;\n\t\t}\n\t}\n\t```\n\t`MakeSet`是并查集的初始化函数，这里采用`father[i]==i`来判定该i是否是某个集合的代表。\n* 并查集的查找操作[==O(alpha(n)) alpha(n)<n==]\n\n\t```c\n\t// 查找操作--未压缩路径\n\tint Find(int x){\n\t\tif(x==father[x])\n\t\t  return x;\n\t\telse\n\t\t  return Find(father[x]);\n\t}\n\t```\n\n\t```c\n\t// 查找操作--压缩路径\n\tint Find(int x){\n\t\tif(x==father[x])\n\t\t  return x;\n\t\telse{\n\t\t\tfather[x]=Find(father[x]);\n\t\t\treturn father[x];\n\t\t}\n\t}\n\t```\n\t压缩路径可以避免重复查找，其实际的意义是将树的深度由n变成1。就是将层层的等级制度变成全部向皇帝/代表负责。\n* 并查集的合并操作[==O(alpha(n))  alpha(n)<n==]\n\n\t```c\n\t// 合并操作\n\tvoid Union(int x, int y){\n\t\tint fatherX = Find(x);\n\t\tint fatherY = Find(y);\n\n\t\t// fatherY归fatherX管了\n\t\tif(fatherX!=fatherY)\n\t\t  father[fatherY]=fatherX;\n\n\t\t/*\n\t\t// 合并的时候取小的数值\n\t\tif(fatherX<fatherY)\n\t\t\tfather[fatherY]=fatherX;\n\t\telse\n\t\t\tfather[fatherX]=fatherY;\n\t\t*/\n\t}\n\t```\n\n## 解题报告\n* HihoCoder\n\t1. 第十四周：[无间道之并查集](http://hihocoder.com/contest/hiho14/problem/1)\t|\t[源码]({{ site.baseurl }}/assets/attachs/hiho_14_main.cpp.txt)\n\n\t\t注意点：\n\t\t1. 通过map将名称转化为int标号\n\t\t2. 最后一步判定两个名称是否是同一个集合时用`Find(mapName[nameX])==Find(mapName[nameY])`,不能用`father[mapName[nameX]]==father[mapName[nameY]]`。\n\n* POJ\n\t1. 1611: [The Suspects](http://poj.org/problem?id=1611)\t|\t[源码]({{ site.baseurl }}/assets/attachs/poj_1611_main.cpp.txt)\n\n\t\t注意点:\n\t\t1.  判定i是否和0同一类必须得通过`Find`找到最高的根节点是相同[代码实现可以添加`rank[LENMAX]`来记录同集合的元素个数]\n\t2. 2524: [Ubiquitous Religions](http://poj.org/problem?id=2524)\t|\t[源码]({{ site.baseurl }}/assets/attachs/poj_2524_main.cpp.txt)\n\n\t\t注意点：\n\t\t1. 通过`i=father[i]`判断是否是根节点,也就是说是否是一个集合\n","slug":"Explore-unionFind","published":1,"date":"2015-06-29T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1f0018l73yuldp58gh","content":"<p>并查集是一种用途广泛的数据结构，能够快速地处理集合的合并和查询问题，并且实现起来非常方便，在很多场合中都有着非常巧妙的应用。本文首先介绍并查集的定义、原理及具体实现，然后结合hihocoder以及poj上的题目做一些具体实践。 <a id=\"more\"></a></p>\n<h2 id=\"定义和原理\">定义和原理</h2>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86\" target=\"_blank\" rel=\"external\">并查集</a>(Union-Find Set)是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个操作用于此数据结构：</p>\n<ul>\n<li><code>Find</code> 确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。<br>\n</li>\n<li><code>Union</code> 将两个子集合并成同一个集合。</li>\n</ul>\n<p>因为它支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，<code>MakeSet</code>，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。</p>\n<p>网络上有两篇帮助理解的博文，博主用通俗易懂的语言，图文并茂的方式将并查集生动形象得阐释了。特附上博文链接：</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/ACShiryu/archive/2011/11/24/unionset.html\" target=\"_blank\" rel=\"external\">通俗易懂的诠释并查集</a></li>\n<li><a href=\"http://www.cnblogs.com/cyjb/p/UnionFindSets.html\" target=\"_blank\" rel=\"external\">图文并茂的解释并查集</a></li>\n</ul>\n<h2 id=\"代码实现\">代码实现</h2>\n<ul>\n<li><p>并查集的数据存储[==O(n)==]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LENMAX 1000000</span></div><div class=\"line\"><span class=\"keyword\">int</span> father[LENMAX]</div></pre></td></tr></table></figure>\n虽然并查集是树型的数据结构，但是实际的存储是用数组，就跟堆排序一样。</li>\n<li><p>并查集的初始化<code>MakeSet</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeSet</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;LENMAX;i++)&#123;</div><div class=\"line\">\t\tfather[i]=i;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<code>MakeSet</code>是并查集的初始化函数，这里采用<code>father[i]==i</code>来判定该i是否是某个集合的代表。</li>\n<li><p>并查集的查找操作[==O(alpha(n)) alpha(n)&lt;n==]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 查找操作--未压缩路径</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(x==father[x])</div><div class=\"line\">\t  <span class=\"keyword\">return</span> x;</div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">\t  <span class=\"keyword\">return</span> Find(father[x]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 查找操作--压缩路径</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(x==father[x])</div><div class=\"line\">\t  <span class=\"keyword\">return</span> x;</div><div class=\"line\">\t<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\tfather[x]=Find(father[x]);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> father[x];</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n压缩路径可以避免重复查找，其实际的意义是将树的深度由n变成1。就是将层层的等级制度变成全部向皇帝/代表负责。</li>\n<li><p>并查集的合并操作[==O(alpha(n)) alpha(n)&lt;n==]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 合并操作</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> fatherX = Find(x);</div><div class=\"line\">\t<span class=\"keyword\">int</span> fatherY = Find(y);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// fatherY归fatherX管了</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(fatherX!=fatherY)</div><div class=\"line\">\t  father[fatherY]=fatherX;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t// 合并的时候取小的数值</div><div class=\"line\">\tif(fatherX&lt;fatherY)</div><div class=\"line\">\t\tfather[fatherY]=fatherX;</div><div class=\"line\">\telse</div><div class=\"line\">\t\tfather[fatherX]=fatherY;</div><div class=\"line\">\t*/</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"解题报告\">解题报告</h2>\n<ul>\n<li>HihoCoder\n<ol style=\"list-style-type: decimal\">\n<li><p>第十四周：<a href=\"http://hihocoder.com/contest/hiho14/problem/1\" target=\"_blank\" rel=\"external\">无间道之并查集</a> | [源码](/assets/attachs/hiho_14_main.cpp.txt)</p>\n注意点：\n<ol style=\"list-style-type: decimal\">\n<li>通过map将名称转化为int标号</li>\n<li>最后一步判定两个名称是否是同一个集合时用<code>Find(mapName[nameX])==Find(mapName[nameY])</code>,不能用<code>father[mapName[nameX]]==father[mapName[nameY]]</code>。</li>\n</ol></li>\n</ol></li>\n<li>POJ\n<ol style=\"list-style-type: decimal\">\n<li><p>1611: <a href=\"http://poj.org/problem?id=1611\" target=\"_blank\" rel=\"external\">The Suspects</a> | [源码](/assets/attachs/poj_1611_main.cpp.txt)</p>\n注意点:\n<ol style=\"list-style-type: decimal\">\n<li>判定i是否和0同一类必须得通过<code>Find</code>找到最高的根节点是相同[代码实现可以添加<code>rank[LENMAX]</code>来记录同集合的元素个数]</li>\n</ol></li>\n<li><p>2524: <a href=\"http://poj.org/problem?id=2524\" target=\"_blank\" rel=\"external\">Ubiquitous Religions</a> | [源码](/assets/attachs/poj_2524_main.cpp.txt)</p>\n注意点：\n<ol style=\"list-style-type: decimal\">\n<li>通过<code>i=father[i]</code>判断是否是根节点,也就是说是否是一个集合</li>\n</ol></li>\n</ol></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>并查集是一种用途广泛的数据结构，能够快速地处理集合的合并和查询问题，并且实现起来非常方便，在很多场合中都有着非常巧妙的应用。本文首先介绍并查集的定义、原理及具体实现，然后结合hihocoder以及poj上的题目做一些具体实践。","more":"</p>\n<h2 id=\"定义和原理\">定义和原理</h2>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86\" target=\"_blank\" rel=\"external\">并查集</a>(Union-Find Set)是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个操作用于此数据结构：</p>\n<ul>\n<li><code>Find</code> 确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。<br>\n</li>\n<li><code>Union</code> 将两个子集合并成同一个集合。</li>\n</ul>\n<p>因为它支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，<code>MakeSet</code>，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。</p>\n<p>网络上有两篇帮助理解的博文，博主用通俗易懂的语言，图文并茂的方式将并查集生动形象得阐释了。特附上博文链接：</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/ACShiryu/archive/2011/11/24/unionset.html\" target=\"_blank\" rel=\"external\">通俗易懂的诠释并查集</a></li>\n<li><a href=\"http://www.cnblogs.com/cyjb/p/UnionFindSets.html\" target=\"_blank\" rel=\"external\">图文并茂的解释并查集</a></li>\n</ul>\n<h2 id=\"代码实现\">代码实现</h2>\n<ul>\n<li><p>并查集的数据存储[==O(n)==]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LENMAX 1000000</span></div><div class=\"line\"><span class=\"keyword\">int</span> father[LENMAX]</div></pre></td></tr></table></figure>\n虽然并查集是树型的数据结构，但是实际的存储是用数组，就跟堆排序一样。</li>\n<li><p>并查集的初始化<code>MakeSet</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeSet</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;LENMAX;i++)&#123;</div><div class=\"line\">\t\tfather[i]=i;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<code>MakeSet</code>是并查集的初始化函数，这里采用<code>father[i]==i</code>来判定该i是否是某个集合的代表。</li>\n<li><p>并查集的查找操作[==O(alpha(n)) alpha(n)&lt;n==]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 查找操作--未压缩路径</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(x==father[x])</div><div class=\"line\">\t  <span class=\"keyword\">return</span> x;</div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">\t  <span class=\"keyword\">return</span> Find(father[x]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 查找操作--压缩路径</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(x==father[x])</div><div class=\"line\">\t  <span class=\"keyword\">return</span> x;</div><div class=\"line\">\t<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\tfather[x]=Find(father[x]);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> father[x];</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n压缩路径可以避免重复查找，其实际的意义是将树的深度由n变成1。就是将层层的等级制度变成全部向皇帝/代表负责。</li>\n<li><p>并查集的合并操作[==O(alpha(n)) alpha(n)&lt;n==]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 合并操作</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> fatherX = Find(x);</div><div class=\"line\">\t<span class=\"keyword\">int</span> fatherY = Find(y);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// fatherY归fatherX管了</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(fatherX!=fatherY)</div><div class=\"line\">\t  father[fatherY]=fatherX;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/*</span></div><div class=\"line\">\t// 合并的时候取小的数值</div><div class=\"line\">\tif(fatherX&lt;fatherY)</div><div class=\"line\">\t\tfather[fatherY]=fatherX;</div><div class=\"line\">\telse</div><div class=\"line\">\t\tfather[fatherX]=fatherY;</div><div class=\"line\">\t*/</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"解题报告\">解题报告</h2>\n<ul>\n<li>HihoCoder\n<ol style=\"list-style-type: decimal\">\n<li><p>第十四周：<a href=\"http://hihocoder.com/contest/hiho14/problem/1\" target=\"_blank\" rel=\"external\">无间道之并查集</a> | [源码](/assets/attachs/hiho_14_main.cpp.txt)</p>\n注意点：\n<ol style=\"list-style-type: decimal\">\n<li>通过map将名称转化为int标号</li>\n<li>最后一步判定两个名称是否是同一个集合时用<code>Find(mapName[nameX])==Find(mapName[nameY])</code>,不能用<code>father[mapName[nameX]]==father[mapName[nameY]]</code>。</li>\n</ol></li>\n</ol></li>\n<li>POJ\n<ol style=\"list-style-type: decimal\">\n<li><p>1611: <a href=\"http://poj.org/problem?id=1611\" target=\"_blank\" rel=\"external\">The Suspects</a> | [源码](/assets/attachs/poj_1611_main.cpp.txt)</p>\n注意点:\n<ol style=\"list-style-type: decimal\">\n<li>判定i是否和0同一类必须得通过<code>Find</code>找到最高的根节点是相同[代码实现可以添加<code>rank[LENMAX]</code>来记录同集合的元素个数]</li>\n</ol></li>\n<li><p>2524: <a href=\"http://poj.org/problem?id=2524\" target=\"_blank\" rel=\"external\">Ubiquitous Religions</a> | [源码](/assets/attachs/poj_2524_main.cpp.txt)</p>\n注意点：\n<ol style=\"list-style-type: decimal\">\n<li>通过<code>i=father[i]</code>判断是否是根节点,也就是说是否是一个集合</li>\n</ol></li>\n</ol></li>\n</ul>"},{"layout":"post","title":"ACM解题报告之最大约数个数","comments":1,"_content":"本题的解法是在{% post_link Explore-numOfDivisor  约数个数原理 %}的基础上对问题进行优化，从而大大降低算法的时间复杂度。而解题的思路是从结果去想它满足什么样的条件，从而获得优化问题的方法。\n<!-- more -->\n\n## 题目\n题目来自微软2016年校招探星夏令营第二题[Divisor](http://hihocoder.com/contest/mstest2015july1/problem/2)，并在[HiHoCoder](http://hihocoder.com)上进行编程笔试，题目大意是：\n> 给一个数n，$n < 10^{16}$，输出在$1 \\sim n$之间约数最多的数，如果有多个相同最大约数个数的数，就输出最小的数\n\n## 思路\n1. 暴力求解  \n根据{% post_link Explore-numOfDivisor  约数个数原理 %}，我们可以很快的计算出给定的数n的约数个数。不过显然其时间复杂度是很大的。提交的结果是超时。\n\n2. 枚举优化  \n假定n以内的所有质数为$ p _1, \\cdots , p _k $,那么对于n有$$ n = \\prod _{i=1}^k p _i^{a _i} = p _1^{a _1} * \\cdots * p _k^{a _k} $$,其中$ a _i \\in [ 0, \\lfloor \\log _{p _i} n \\rfloor ] $，这个就是约数个数原理。通过对这k个$ a _i $的自由组合我们能够**枚举**n以内所有的数。\n而本题要求的是正整数n的约数个数最多并且n尽量小。该目的就是我们**优化**或**剪枝**$ a _i $组合的出发点。\n\t* 约数个数最多  \n\t对于正整数n的约数个数$ f(n)= \\prod _{i=1}^k (a _i+1) $,而要使$ f(n)$更大，那么$a _i$值要大并且$ a _i == 0 $的数目要少，这样乘积才会更大，当然此时n也会更大，这里$ a _i $是质数$ p _i $的指数。这里的冲突点在于当要给某个$ a _i $增加值时，是给小的$p _i$增加个大值还是给大的$p _i$增加个小值。简单的例子如下：对于4这个整数，乘上19和2^4得到的$f(76)=6,f(64)=7$，而对于8这个整数，乘上19和2^4得到的$f(152)=8,f(128)=8$，再对于16这个整数，乘上19和2^4得到的$f(304)=10,f(256)=9$。该冲突让我们考虑到底要用哪些$p _i$来构成这个约数个数最多的数。经过计算质数$[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]$依次相乘为$1.3 \\times 10^{16}$。显然对于正整数$N < 10^{16}$以内约数个数最多的数n一定是由上面的14个质数组成。\n\n\t\t> **剪枝条件1：**  \n\t\t> 对于正整数$N < 10^{16}$以内约数个数最多的数n一定是由这[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]14个质数组成。\n\t\t>> **简要证明**  \n\t\t>> 假设最终的n中有约数大于43的质数$p _k$，其中$n<N$,那么上面的质数组里必定有一个质数$p _j$的指数为0,不然n一定会超出N。那么此时用$p _j$代替$p _k$一定会获得比n更小的值$n'$，那么n并不是最终的n，这和假设矛盾。  \n\t* n尽量小  \n\t当约数个数相同的时候，会取n最小的那个正整数。这也就意味着此时k个$a _i$的取值已经确定了，但是每个$a _i$对应的质数$p _j$还没有确定（$i,j \\in [0,k]$），不同的组合会构成不同的数，但是最小的正整数只能有一种组合，那就是最大的$a _i$对应最小的$p _j$。所以我们获得了另一个剪枝的条件。\n\n\t\t> **剪枝条件2：**  \n\t\t> 最终求解的拥有最大约数个数的数n一定满足：  \n\t\t> 若$p _1 < p _2 < \\cdots < p _k$，则$a _1 > a _2 > \\cdots > a _k$。\n\n## 算法说明\n1. 剪枝条件1的应用\n定义静态常量数组，用来存放这14个质数\n\n\t```c\n\tstatic const int little_prime[] = {\n\t2,3,5,7,11,13,17,19,23,29,\n\t31,37,41,43};\n\t```\n\n2. 递归函数的声明\n函数功能是当第len位质数加入后，寻找约数个数最多的最小正整数\n，其参数如下:  \n\t* N\t-- \t输入要寻找的N范围内\n\t* n\t--\t求解的n\n\t* counts\t--\t约数的个数\n\t* len\t--\t第len个质数\n\t* maxTimes\t--\t第len个质数的最大指数\n\n\t```c\n\tvoid FindMinN(long long N, long long n, int counts, int len, int maxTimes);\n\t```\n\n3. 函数内部解析\n\t* numOfMinN\t--\t全局变量，用来存储当前所找数中约数最多的值\n\t* minN\t--\t全局变量，用来存储当前所有数中最小的n\n\n\t```c\n\t// 当第len位质数加入后，寻找约数个数最多的最小正整数\n\tvoid FindMinN(long long N, long long n, int counts, int len, int maxTimes){\n\t    // 当找到约数个数更多或者约数个数相同但数更小的直接更新\n\t\t// update\n\t    if(counts > numOfMinN || (counts == numOfMinN && minN > N)){\n\t        numOfMinN = counts;\n\t        minN = n;\n\t    }\n\n\t\t// find\n\t\tint i;\n\t\t// 遍历第len位质数，其指数为1,2，。。。，maxTimes\n\t\tfor(i=1; i<=maxTimes; i++){\n\t\t\tn = n * little_prime[len];\n\t\t\tif(ans > N)\n\t\t\t\tbreak;\n\t\t\t// 遍历第len+1位质数，其指数的最大值为i -- 剪枝条件2\n\t\t\tFindMinN(N, n, counts*(i+1), len+1, i);\n\t\t}\n\t}\n\t```\n\n4.  {% asset_link hiho_divisors.cpp.txt hiho_divisors完整代码 %}\n\n## 举一反三\n1. k维数组的遍历  \n对本题的另一种解读是n维数组的遍历。这里每个$p _i$算一个维度，在每个维度上有$a _i+1$个可能的值。对这k个维度的遍历就是对比N小的正整数的依次判别。  \n\t* 代码说明  \n\n\t\t```c\n\t\t// 每个维度取值个数\n\t\tint varMax[]={\n\t\t10,9,8,7,6,\n\t\t5,4,3,2,1};\n\t\t// 第ind维度取值的情况\n\t\tvoid TraversalByRecu(int dim, int ind, int max, int var[]){\n\t\t\t// 取完dim个维度打印输出\n\t\t\tif(ind>=dim){\n\t\t\t\tfor(int j=0; j<dim; j++){\n\t\t\t\t\tprintf(\"%d\\t\",var[j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\treturn;\n\t\t\t}   \n\t\t    int i;\n\t\t\t// 第ind维度取完所有可能的取值\n\t\t\tfor(i=1;i<=max;i++){\n\t\t\t\tvar[ind]=i;\n\t\t\t\t// 取第ind+1维度，并设定第ind+1维度取值个数\n\t\t\t\tTraversalByRecu(dim,ind+1,varMax[ind+1],var);\n\t\t\t}   \n\t\t}\n\t\t```\n\t* {% asset_link hiho_divisors_travel.cpp.txt hiho_divisors_travel完整代码 %}\n\n2. 区间里约数个数最大的尽量小的数\n对于这个问题，其实和N以内很类似，唯一的区别可能就是在更新的时候要判断当前的n在不在区间范围内。  \n\t* 代码说明\n\n\t\t```c\n\t\tvoid FindMinN(long long low, long long high, long long n, int counts, int len, int maxTimes){\n\t\t    // update\n\t\t\tif(n<=high && n>=low){\n\t\t\t\tif(counts > numOfMinN || (counts == numOfMinN && minN > n)){\n\t\t\t\t\tnumOfMinN = counts;\n\t\t\t\t\tminN = n;\n\t\t\t\t}\n\t\t\t}   \n\t\t    // find\n\t\t    int i;\n\t\t    for(i=1; i<=maxTimes; i++){\n\t\t\t    n = n * little_prime[len];\n\t\t\t    if(n > high)\n\t\t\t\t    break;\n\t\t\t\t    FindMinN(low, high, n, counts*(i+1), len+1, i);\n\t\t\t}   \n\t\t}\n\t\t```\n\t* {% asset_link hiho_divisors_depart.cpp.txt hiho_divisors_depart完整代码 %}\n","source":"_posts/2015-07-23-ACM解题报告之最大约数个数.md","raw":"---\nlayout:\tpost\ntitle:\tACM解题报告之最大约数个数\ncategories:\n- TECHNOLOGY\ntags:\n- ACM\n- HiHoCoder\n- Report\npermalink:  Solve-numOfMaxDivisor-ACM\ncomments:\ttrue\n---\n本题的解法是在{% post_link Explore-numOfDivisor  约数个数原理 %}的基础上对问题进行优化，从而大大降低算法的时间复杂度。而解题的思路是从结果去想它满足什么样的条件，从而获得优化问题的方法。\n<!-- more -->\n\n## 题目\n题目来自微软2016年校招探星夏令营第二题[Divisor](http://hihocoder.com/contest/mstest2015july1/problem/2)，并在[HiHoCoder](http://hihocoder.com)上进行编程笔试，题目大意是：\n> 给一个数n，$n < 10^{16}$，输出在$1 \\sim n$之间约数最多的数，如果有多个相同最大约数个数的数，就输出最小的数\n\n## 思路\n1. 暴力求解  \n根据{% post_link Explore-numOfDivisor  约数个数原理 %}，我们可以很快的计算出给定的数n的约数个数。不过显然其时间复杂度是很大的。提交的结果是超时。\n\n2. 枚举优化  \n假定n以内的所有质数为$ p _1, \\cdots , p _k $,那么对于n有$$ n = \\prod _{i=1}^k p _i^{a _i} = p _1^{a _1} * \\cdots * p _k^{a _k} $$,其中$ a _i \\in [ 0, \\lfloor \\log _{p _i} n \\rfloor ] $，这个就是约数个数原理。通过对这k个$ a _i $的自由组合我们能够**枚举**n以内所有的数。\n而本题要求的是正整数n的约数个数最多并且n尽量小。该目的就是我们**优化**或**剪枝**$ a _i $组合的出发点。\n\t* 约数个数最多  \n\t对于正整数n的约数个数$ f(n)= \\prod _{i=1}^k (a _i+1) $,而要使$ f(n)$更大，那么$a _i$值要大并且$ a _i == 0 $的数目要少，这样乘积才会更大，当然此时n也会更大，这里$ a _i $是质数$ p _i $的指数。这里的冲突点在于当要给某个$ a _i $增加值时，是给小的$p _i$增加个大值还是给大的$p _i$增加个小值。简单的例子如下：对于4这个整数，乘上19和2^4得到的$f(76)=6,f(64)=7$，而对于8这个整数，乘上19和2^4得到的$f(152)=8,f(128)=8$，再对于16这个整数，乘上19和2^4得到的$f(304)=10,f(256)=9$。该冲突让我们考虑到底要用哪些$p _i$来构成这个约数个数最多的数。经过计算质数$[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]$依次相乘为$1.3 \\times 10^{16}$。显然对于正整数$N < 10^{16}$以内约数个数最多的数n一定是由上面的14个质数组成。\n\n\t\t> **剪枝条件1：**  \n\t\t> 对于正整数$N < 10^{16}$以内约数个数最多的数n一定是由这[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]14个质数组成。\n\t\t>> **简要证明**  \n\t\t>> 假设最终的n中有约数大于43的质数$p _k$，其中$n<N$,那么上面的质数组里必定有一个质数$p _j$的指数为0,不然n一定会超出N。那么此时用$p _j$代替$p _k$一定会获得比n更小的值$n'$，那么n并不是最终的n，这和假设矛盾。  \n\t* n尽量小  \n\t当约数个数相同的时候，会取n最小的那个正整数。这也就意味着此时k个$a _i$的取值已经确定了，但是每个$a _i$对应的质数$p _j$还没有确定（$i,j \\in [0,k]$），不同的组合会构成不同的数，但是最小的正整数只能有一种组合，那就是最大的$a _i$对应最小的$p _j$。所以我们获得了另一个剪枝的条件。\n\n\t\t> **剪枝条件2：**  \n\t\t> 最终求解的拥有最大约数个数的数n一定满足：  \n\t\t> 若$p _1 < p _2 < \\cdots < p _k$，则$a _1 > a _2 > \\cdots > a _k$。\n\n## 算法说明\n1. 剪枝条件1的应用\n定义静态常量数组，用来存放这14个质数\n\n\t```c\n\tstatic const int little_prime[] = {\n\t2,3,5,7,11,13,17,19,23,29,\n\t31,37,41,43};\n\t```\n\n2. 递归函数的声明\n函数功能是当第len位质数加入后，寻找约数个数最多的最小正整数\n，其参数如下:  \n\t* N\t-- \t输入要寻找的N范围内\n\t* n\t--\t求解的n\n\t* counts\t--\t约数的个数\n\t* len\t--\t第len个质数\n\t* maxTimes\t--\t第len个质数的最大指数\n\n\t```c\n\tvoid FindMinN(long long N, long long n, int counts, int len, int maxTimes);\n\t```\n\n3. 函数内部解析\n\t* numOfMinN\t--\t全局变量，用来存储当前所找数中约数最多的值\n\t* minN\t--\t全局变量，用来存储当前所有数中最小的n\n\n\t```c\n\t// 当第len位质数加入后，寻找约数个数最多的最小正整数\n\tvoid FindMinN(long long N, long long n, int counts, int len, int maxTimes){\n\t    // 当找到约数个数更多或者约数个数相同但数更小的直接更新\n\t\t// update\n\t    if(counts > numOfMinN || (counts == numOfMinN && minN > N)){\n\t        numOfMinN = counts;\n\t        minN = n;\n\t    }\n\n\t\t// find\n\t\tint i;\n\t\t// 遍历第len位质数，其指数为1,2，。。。，maxTimes\n\t\tfor(i=1; i<=maxTimes; i++){\n\t\t\tn = n * little_prime[len];\n\t\t\tif(ans > N)\n\t\t\t\tbreak;\n\t\t\t// 遍历第len+1位质数，其指数的最大值为i -- 剪枝条件2\n\t\t\tFindMinN(N, n, counts*(i+1), len+1, i);\n\t\t}\n\t}\n\t```\n\n4.  {% asset_link hiho_divisors.cpp.txt hiho_divisors完整代码 %}\n\n## 举一反三\n1. k维数组的遍历  \n对本题的另一种解读是n维数组的遍历。这里每个$p _i$算一个维度，在每个维度上有$a _i+1$个可能的值。对这k个维度的遍历就是对比N小的正整数的依次判别。  \n\t* 代码说明  \n\n\t\t```c\n\t\t// 每个维度取值个数\n\t\tint varMax[]={\n\t\t10,9,8,7,6,\n\t\t5,4,3,2,1};\n\t\t// 第ind维度取值的情况\n\t\tvoid TraversalByRecu(int dim, int ind, int max, int var[]){\n\t\t\t// 取完dim个维度打印输出\n\t\t\tif(ind>=dim){\n\t\t\t\tfor(int j=0; j<dim; j++){\n\t\t\t\t\tprintf(\"%d\\t\",var[j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\treturn;\n\t\t\t}   \n\t\t    int i;\n\t\t\t// 第ind维度取完所有可能的取值\n\t\t\tfor(i=1;i<=max;i++){\n\t\t\t\tvar[ind]=i;\n\t\t\t\t// 取第ind+1维度，并设定第ind+1维度取值个数\n\t\t\t\tTraversalByRecu(dim,ind+1,varMax[ind+1],var);\n\t\t\t}   \n\t\t}\n\t\t```\n\t* {% asset_link hiho_divisors_travel.cpp.txt hiho_divisors_travel完整代码 %}\n\n2. 区间里约数个数最大的尽量小的数\n对于这个问题，其实和N以内很类似，唯一的区别可能就是在更新的时候要判断当前的n在不在区间范围内。  \n\t* 代码说明\n\n\t\t```c\n\t\tvoid FindMinN(long long low, long long high, long long n, int counts, int len, int maxTimes){\n\t\t    // update\n\t\t\tif(n<=high && n>=low){\n\t\t\t\tif(counts > numOfMinN || (counts == numOfMinN && minN > n)){\n\t\t\t\t\tnumOfMinN = counts;\n\t\t\t\t\tminN = n;\n\t\t\t\t}\n\t\t\t}   \n\t\t    // find\n\t\t    int i;\n\t\t    for(i=1; i<=maxTimes; i++){\n\t\t\t    n = n * little_prime[len];\n\t\t\t    if(n > high)\n\t\t\t\t    break;\n\t\t\t\t    FindMinN(low, high, n, counts*(i+1), len+1, i);\n\t\t\t}   \n\t\t}\n\t\t```\n\t* {% asset_link hiho_divisors_depart.cpp.txt hiho_divisors_depart完整代码 %}\n","slug":"Solve-numOfMaxDivisor-ACM","published":1,"date":"2015-07-22T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1f0019l73yq16h9mvl","content":"<p>本题的解法是在<a href=\"/2015/07/15/Explore-numOfDivisor/\" title=\"约数个数原理\">约数个数原理</a>的基础上对问题进行优化，从而大大降低算法的时间复杂度。而解题的思路是从结果去想它满足什么样的条件，从而获得优化问题的方法。 <a id=\"more\"></a></p>\n<h2 id=\"题目\">题目</h2>\n<p>题目来自微软2016年校招探星夏令营第二题<a href=\"http://hihocoder.com/contest/mstest2015july1/problem/2\" target=\"_blank\" rel=\"external\">Divisor</a>，并在<a href=\"http://hihocoder.com\" target=\"_blank\" rel=\"external\">HiHoCoder</a>上进行编程笔试，题目大意是： &gt; 给一个数n，<span class=\"math inline\">\\(n &lt; 10^{16}\\)</span>，输出在<span class=\"math inline\">\\(1 \\sim n\\)</span>之间约数最多的数，如果有多个相同最大约数个数的数，就输出最小的数</p>\n<h2 id=\"思路\">思路</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>暴力求解<br>\n根据<a href=\"/2015/07/15/Explore-numOfDivisor/\" title=\"约数个数原理\">约数个数原理</a>，我们可以很快的计算出给定的数n的约数个数。不过显然其时间复杂度是很大的。提交的结果是超时。</p></li>\n<li><p>枚举优化<br>\n假定n以内的所有质数为$ p _1, , p <em>k <span class=\"math inline\">\\(,那么对于n有\\)</span>$ n = </em>{i=1}^k p _i^{a _i} = p _1^{a _1} *  p _k^{a _k} <span class=\"math inline\">\\($,其中\\)</span> a _i <span class=\"math inline\">\\(，这个就是约数个数原理。通过对这k个\\)</span> a _i <span class=\"math inline\">\\(的自由组合我们能够**枚举**n以内所有的数。 而本题要求的是正整数n的约数个数最多并且n尽量小。该目的就是我们**优化**或**剪枝**\\)</span> a <em>i <span class=\"math inline\">\\(组合的出发点。 * 约数个数最多 对于正整数n的约数个数\\)</span> f(n)= </em>{i=1}^k (a _i+1) <span class=\"math inline\">\\(,而要使\\)</span> f(n)<span class=\"math inline\">\\(更大，那么\\)</span>a _i<span class=\"math inline\">\\(值要大并且\\)</span> a _i == 0 <span class=\"math inline\">\\(的数目要少，这样乘积才会更大，当然此时n也会更大，这里\\)</span> a _i <span class=\"math inline\">\\(是质数\\)</span> p _i <span class=\"math inline\">\\(的指数。这里的冲突点在于当要给某个\\)</span> a _i <span class=\"math inline\">\\(增加值时，是给小的\\)</span>p _i<span class=\"math inline\">\\(增加个大值还是给大的\\)</span>p _i<span class=\"math inline\">\\(增加个小值。简单的例子如下：对于4这个整数，乘上19和2^4得到的\\)</span>f(76)=6,f(64)=7<span class=\"math inline\">\\(，而对于8这个整数，乘上19和2^4得到的\\)</span>f(152)=8,f(128)=8<span class=\"math inline\">\\(，再对于16这个整数，乘上19和2^4得到的\\)</span>f(304)=10,f(256)=9<span class=\"math inline\">\\(。该冲突让我们考虑到底要用哪些\\)</span>p _i<span class=\"math inline\">\\(来构成这个约数个数最多的数。经过计算质数\\)</span>[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]$依次相乘为<span class=\"math inline\">\\(1.3 \\times 10^{16}\\)</span>。显然对于正整数<span class=\"math inline\">\\(N &lt; 10^{16}\\)</span>以内约数个数最多的数n一定是由上面的14个质数组成。</p>\n<pre><code>&gt; **剪枝条件1：**  \n&gt; 对于正整数$N &lt; 10^{16}$以内约数个数最多的数n一定是由这[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]14个质数组成。\n&gt;&gt; **简要证明**  \n&gt;&gt; 假设最终的n中有约数大于43的质数$p _k$，其中$n&lt;N$,那么上面的质数组里必定有一个质数$p _j$的指数为0,不然n一定会超出N。那么此时用$p _j$代替$p _k$一定会获得比n更小的值$n&#39;$，那么n并不是最终的n，这和假设矛盾。  </code></pre>\n<ul>\n<li><p>n尽量小<br>\n当约数个数相同的时候，会取n最小的那个正整数。这也就意味着此时k个<span class=\"math inline\">\\(a _i\\)</span>的取值已经确定了，但是每个<span class=\"math inline\">\\(a _i\\)</span>对应的质数<span class=\"math inline\">\\(p _j\\)</span>还没有确定（<span class=\"math inline\">\\(i,j \\in [0,k]\\)</span>），不同的组合会构成不同的数，但是最小的正整数只能有一种组合，那就是最大的<span class=\"math inline\">\\(a _i\\)</span>对应最小的<span class=\"math inline\">\\(p _j\\)</span>。所以我们获得了另一个剪枝的条件。</p>\n<blockquote>\n<p><strong>剪枝条件2：</strong><br>\n最终求解的拥有最大约数个数的数n一定满足：<br>\n若<span class=\"math inline\">\\(p _1 &lt; p _2 &lt; \\cdots &lt; p _k\\)</span>，则<span class=\"math inline\">\\(a _1 &gt; a _2 &gt; \\cdots &gt; a _k\\)</span>。</p>\n</blockquote></li>\n</ul></li>\n</ol>\n<h2 id=\"算法说明\">算法说明</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>剪枝条件1的应用 定义静态常量数组，用来存放这14个质数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> little_prime[] = &#123;</div><div class=\"line\"><span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">13</span>,<span class=\"number\">17</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">29</span>,</div><div class=\"line\"><span class=\"number\">31</span>,<span class=\"number\">37</span>,<span class=\"number\">41</span>,<span class=\"number\">43</span>&#125;;</div></pre></td></tr></table></figure></li>\n<li>递归函数的声明 函数功能是当第len位质数加入后，寻找约数个数最多的最小正整数 ，其参数如下:\n<ul>\n<li>N – 输入要寻找的N范围内</li>\n<li>n – 求解的n</li>\n<li>counts – 约数的个数</li>\n<li>len – 第len个质数</li>\n<li>maxTimes – 第len个质数的最大指数</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FindMinN</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> N, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n, <span class=\"keyword\">int</span> counts, <span class=\"keyword\">int</span> len, <span class=\"keyword\">int</span> maxTimes)</span></span>;</div></pre></td></tr></table></figure></li>\n<li>函数内部解析\n<ul>\n<li>numOfMinN – 全局变量，用来存储当前所找数中约数最多的值</li>\n<li>minN – 全局变量，用来存储当前所有数中最小的n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 当第len位质数加入后，寻找约数个数最多的最小正整数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FindMinN</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> N, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n, <span class=\"keyword\">int</span> counts, <span class=\"keyword\">int</span> len, <span class=\"keyword\">int</span> maxTimes)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 当找到约数个数更多或者约数个数相同但数更小的直接更新</span></div><div class=\"line\">\t<span class=\"comment\">// update</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(counts &gt; numOfMinN || (counts == numOfMinN &amp;&amp; minN &gt; N))&#123;</div><div class=\"line\">        numOfMinN = counts;</div><div class=\"line\">        minN = n;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// find</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"comment\">// 遍历第len位质数，其指数为1,2，。。。，maxTimes</span></div><div class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=maxTimes; i++)&#123;</div><div class=\"line\">\t\tn = n * little_prime[len];</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(ans &gt; N)</div><div class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"comment\">// 遍历第len+1位质数，其指数的最大值为i -- 剪枝条件2</span></div><div class=\"line\">\t\tFindMinN(N, n, counts*(i+<span class=\"number\">1</span>), len+<span class=\"number\">1</span>, i);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><a href=\"/2015/07/23/Solve-numOfMaxDivisor-ACM/hiho_divisors.cpp.txt\" title=\"hiho_divisors完整代码\">hiho_divisors完整代码</a></li>\n</ol>\n<h2 id=\"举一反三\">举一反三</h2>\n<ol style=\"list-style-type: decimal\">\n<li>k维数组的遍历<br>\n对本题的另一种解读是n维数组的遍历。这里每个<span class=\"math inline\">\\(p _i\\)</span>算一个维度，在每个维度上有<span class=\"math inline\">\\(a _i+1\\)</span>个可能的值。对这k个维度的遍历就是对比N小的正整数的依次判别。\n<ul>\n<li><p>代码说明</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 每个维度取值个数</span></div><div class=\"line\"><span class=\"keyword\">int</span> varMax[]=&#123;</div><div class=\"line\"><span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,</div><div class=\"line\"><span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>&#125;;</div><div class=\"line\"><span class=\"comment\">// 第ind维度取值的情况</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TraversalByRecu</span><span class=\"params\">(<span class=\"keyword\">int</span> dim, <span class=\"keyword\">int</span> ind, <span class=\"keyword\">int</span> max, <span class=\"keyword\">int</span> var[])</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 取完dim个维度打印输出</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(ind&gt;=dim)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;dim; j++)&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\t\"</span>,var[j]);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t&#125;   </div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"comment\">// 第ind维度取完所有可能的取值</span></div><div class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=max;i++)&#123;</div><div class=\"line\">\t\tvar[ind]=i;</div><div class=\"line\">\t\t<span class=\"comment\">// 取第ind+1维度，并设定第ind+1维度取值个数</span></div><div class=\"line\">\t\tTraversalByRecu(dim,ind+<span class=\"number\">1</span>,varMax[ind+<span class=\"number\">1</span>],var);</div><div class=\"line\">\t&#125;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><a href=\"/2015/07/23/Solve-numOfMaxDivisor-ACM/hiho_divisors_travel.cpp.txt\" title=\"hiho_divisors_travel完整代码\">hiho_divisors_travel完整代码</a></li>\n</ul></li>\n<li>区间里约数个数最大的尽量小的数 对于这个问题，其实和N以内很类似，唯一的区别可能就是在更新的时候要判断当前的n在不在区间范围内。\n<ul>\n<li><p>代码说明</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FindMinN</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> low, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> high, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n, <span class=\"keyword\">int</span> counts, <span class=\"keyword\">int</span> len, <span class=\"keyword\">int</span> maxTimes)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// update</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(n&lt;=high &amp;&amp; n&gt;=low)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(counts &gt; numOfMinN || (counts == numOfMinN &amp;&amp; minN &gt; n))&#123;</div><div class=\"line\">\t\t\tnumOfMinN = counts;</div><div class=\"line\">\t\t\tminN = n;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;   </div><div class=\"line\">    <span class=\"comment\">// find</span></div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=maxTimes; i++)&#123;</div><div class=\"line\">\t    n = n * little_prime[len];</div><div class=\"line\">\t    <span class=\"keyword\">if</span>(n &gt; high)</div><div class=\"line\">\t\t    <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t    FindMinN(low, high, n, counts*(i+<span class=\"number\">1</span>), len+<span class=\"number\">1</span>, i);</div><div class=\"line\">\t&#125;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><a href=\"/2015/07/23/Solve-numOfMaxDivisor-ACM/hiho_divisors_depart.cpp.txt\" title=\"hiho_divisors_depart完整代码\">hiho_divisors_depart完整代码</a></li>\n</ul></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本题的解法是在<a href=\"/2015/07/15/Explore-numOfDivisor/\" title=\"约数个数原理\">约数个数原理</a>的基础上对问题进行优化，从而大大降低算法的时间复杂度。而解题的思路是从结果去想它满足什么样的条件，从而获得优化问题的方法。","more":"</p>\n<h2 id=\"题目\">题目</h2>\n<p>题目来自微软2016年校招探星夏令营第二题<a href=\"http://hihocoder.com/contest/mstest2015july1/problem/2\" target=\"_blank\" rel=\"external\">Divisor</a>，并在<a href=\"http://hihocoder.com\" target=\"_blank\" rel=\"external\">HiHoCoder</a>上进行编程笔试，题目大意是： &gt; 给一个数n，<span class=\"math inline\">\\(n &lt; 10^{16}\\)</span>，输出在<span class=\"math inline\">\\(1 \\sim n\\)</span>之间约数最多的数，如果有多个相同最大约数个数的数，就输出最小的数</p>\n<h2 id=\"思路\">思路</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>暴力求解<br>\n根据<a href=\"/2015/07/15/Explore-numOfDivisor/\" title=\"约数个数原理\">约数个数原理</a>，我们可以很快的计算出给定的数n的约数个数。不过显然其时间复杂度是很大的。提交的结果是超时。</p></li>\n<li><p>枚举优化<br>\n假定n以内的所有质数为$ p _1, , p <em>k <span class=\"math inline\">\\(,那么对于n有\\)</span>$ n = </em>{i=1}^k p _i^{a _i} = p _1^{a _1} *  p _k^{a _k} <span class=\"math inline\">\\($,其中\\)</span> a _i <span class=\"math inline\">\\(，这个就是约数个数原理。通过对这k个\\)</span> a _i <span class=\"math inline\">\\(的自由组合我们能够**枚举**n以内所有的数。 而本题要求的是正整数n的约数个数最多并且n尽量小。该目的就是我们**优化**或**剪枝**\\)</span> a <em>i <span class=\"math inline\">\\(组合的出发点。 * 约数个数最多 对于正整数n的约数个数\\)</span> f(n)= </em>{i=1}^k (a _i+1) <span class=\"math inline\">\\(,而要使\\)</span> f(n)<span class=\"math inline\">\\(更大，那么\\)</span>a _i<span class=\"math inline\">\\(值要大并且\\)</span> a _i == 0 <span class=\"math inline\">\\(的数目要少，这样乘积才会更大，当然此时n也会更大，这里\\)</span> a _i <span class=\"math inline\">\\(是质数\\)</span> p _i <span class=\"math inline\">\\(的指数。这里的冲突点在于当要给某个\\)</span> a _i <span class=\"math inline\">\\(增加值时，是给小的\\)</span>p _i<span class=\"math inline\">\\(增加个大值还是给大的\\)</span>p _i<span class=\"math inline\">\\(增加个小值。简单的例子如下：对于4这个整数，乘上19和2^4得到的\\)</span>f(76)=6,f(64)=7<span class=\"math inline\">\\(，而对于8这个整数，乘上19和2^4得到的\\)</span>f(152)=8,f(128)=8<span class=\"math inline\">\\(，再对于16这个整数，乘上19和2^4得到的\\)</span>f(304)=10,f(256)=9<span class=\"math inline\">\\(。该冲突让我们考虑到底要用哪些\\)</span>p _i<span class=\"math inline\">\\(来构成这个约数个数最多的数。经过计算质数\\)</span>[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]$依次相乘为<span class=\"math inline\">\\(1.3 \\times 10^{16}\\)</span>。显然对于正整数<span class=\"math inline\">\\(N &lt; 10^{16}\\)</span>以内约数个数最多的数n一定是由上面的14个质数组成。</p>\n<pre><code>&gt; **剪枝条件1：**  \n&gt; 对于正整数$N &lt; 10^{16}$以内约数个数最多的数n一定是由这[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]14个质数组成。\n&gt;&gt; **简要证明**  \n&gt;&gt; 假设最终的n中有约数大于43的质数$p _k$，其中$n&lt;N$,那么上面的质数组里必定有一个质数$p _j$的指数为0,不然n一定会超出N。那么此时用$p _j$代替$p _k$一定会获得比n更小的值$n&#39;$，那么n并不是最终的n，这和假设矛盾。  </code></pre>\n<ul>\n<li><p>n尽量小<br>\n当约数个数相同的时候，会取n最小的那个正整数。这也就意味着此时k个<span class=\"math inline\">\\(a _i\\)</span>的取值已经确定了，但是每个<span class=\"math inline\">\\(a _i\\)</span>对应的质数<span class=\"math inline\">\\(p _j\\)</span>还没有确定（<span class=\"math inline\">\\(i,j \\in [0,k]\\)</span>），不同的组合会构成不同的数，但是最小的正整数只能有一种组合，那就是最大的<span class=\"math inline\">\\(a _i\\)</span>对应最小的<span class=\"math inline\">\\(p _j\\)</span>。所以我们获得了另一个剪枝的条件。</p>\n<blockquote>\n<p><strong>剪枝条件2：</strong><br>\n最终求解的拥有最大约数个数的数n一定满足：<br>\n若<span class=\"math inline\">\\(p _1 &lt; p _2 &lt; \\cdots &lt; p _k\\)</span>，则<span class=\"math inline\">\\(a _1 &gt; a _2 &gt; \\cdots &gt; a _k\\)</span>。</p>\n</blockquote></li>\n</ul></li>\n</ol>\n<h2 id=\"算法说明\">算法说明</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>剪枝条件1的应用 定义静态常量数组，用来存放这14个质数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> little_prime[] = &#123;</div><div class=\"line\"><span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">13</span>,<span class=\"number\">17</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">29</span>,</div><div class=\"line\"><span class=\"number\">31</span>,<span class=\"number\">37</span>,<span class=\"number\">41</span>,<span class=\"number\">43</span>&#125;;</div></pre></td></tr></table></figure></li>\n<li>递归函数的声明 函数功能是当第len位质数加入后，寻找约数个数最多的最小正整数 ，其参数如下:\n<ul>\n<li>N – 输入要寻找的N范围内</li>\n<li>n – 求解的n</li>\n<li>counts – 约数的个数</li>\n<li>len – 第len个质数</li>\n<li>maxTimes – 第len个质数的最大指数</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FindMinN</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> N, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n, <span class=\"keyword\">int</span> counts, <span class=\"keyword\">int</span> len, <span class=\"keyword\">int</span> maxTimes)</span></span>;</div></pre></td></tr></table></figure></li>\n<li>函数内部解析\n<ul>\n<li>numOfMinN – 全局变量，用来存储当前所找数中约数最多的值</li>\n<li>minN – 全局变量，用来存储当前所有数中最小的n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 当第len位质数加入后，寻找约数个数最多的最小正整数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FindMinN</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> N, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n, <span class=\"keyword\">int</span> counts, <span class=\"keyword\">int</span> len, <span class=\"keyword\">int</span> maxTimes)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 当找到约数个数更多或者约数个数相同但数更小的直接更新</span></div><div class=\"line\">\t<span class=\"comment\">// update</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(counts &gt; numOfMinN || (counts == numOfMinN &amp;&amp; minN &gt; N))&#123;</div><div class=\"line\">        numOfMinN = counts;</div><div class=\"line\">        minN = n;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// find</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"comment\">// 遍历第len位质数，其指数为1,2，。。。，maxTimes</span></div><div class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=maxTimes; i++)&#123;</div><div class=\"line\">\t\tn = n * little_prime[len];</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(ans &gt; N)</div><div class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"comment\">// 遍历第len+1位质数，其指数的最大值为i -- 剪枝条件2</span></div><div class=\"line\">\t\tFindMinN(N, n, counts*(i+<span class=\"number\">1</span>), len+<span class=\"number\">1</span>, i);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><a href=\"/2015/07/23/Solve-numOfMaxDivisor-ACM/hiho_divisors.cpp.txt\" title=\"hiho_divisors完整代码\">hiho_divisors完整代码</a></li>\n</ol>\n<h2 id=\"举一反三\">举一反三</h2>\n<ol style=\"list-style-type: decimal\">\n<li>k维数组的遍历<br>\n对本题的另一种解读是n维数组的遍历。这里每个<span class=\"math inline\">\\(p _i\\)</span>算一个维度，在每个维度上有<span class=\"math inline\">\\(a _i+1\\)</span>个可能的值。对这k个维度的遍历就是对比N小的正整数的依次判别。\n<ul>\n<li><p>代码说明</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 每个维度取值个数</span></div><div class=\"line\"><span class=\"keyword\">int</span> varMax[]=&#123;</div><div class=\"line\"><span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,</div><div class=\"line\"><span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>&#125;;</div><div class=\"line\"><span class=\"comment\">// 第ind维度取值的情况</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TraversalByRecu</span><span class=\"params\">(<span class=\"keyword\">int</span> dim, <span class=\"keyword\">int</span> ind, <span class=\"keyword\">int</span> max, <span class=\"keyword\">int</span> var[])</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 取完dim个维度打印输出</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(ind&gt;=dim)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;dim; j++)&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\t\"</span>,var[j]);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t&#125;   </div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"comment\">// 第ind维度取完所有可能的取值</span></div><div class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=max;i++)&#123;</div><div class=\"line\">\t\tvar[ind]=i;</div><div class=\"line\">\t\t<span class=\"comment\">// 取第ind+1维度，并设定第ind+1维度取值个数</span></div><div class=\"line\">\t\tTraversalByRecu(dim,ind+<span class=\"number\">1</span>,varMax[ind+<span class=\"number\">1</span>],var);</div><div class=\"line\">\t&#125;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><a href=\"/2015/07/23/Solve-numOfMaxDivisor-ACM/hiho_divisors_travel.cpp.txt\" title=\"hiho_divisors_travel完整代码\">hiho_divisors_travel完整代码</a></li>\n</ul></li>\n<li>区间里约数个数最大的尽量小的数 对于这个问题，其实和N以内很类似，唯一的区别可能就是在更新的时候要判断当前的n在不在区间范围内。\n<ul>\n<li><p>代码说明</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FindMinN</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> low, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> high, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n, <span class=\"keyword\">int</span> counts, <span class=\"keyword\">int</span> len, <span class=\"keyword\">int</span> maxTimes)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// update</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(n&lt;=high &amp;&amp; n&gt;=low)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(counts &gt; numOfMinN || (counts == numOfMinN &amp;&amp; minN &gt; n))&#123;</div><div class=\"line\">\t\t\tnumOfMinN = counts;</div><div class=\"line\">\t\t\tminN = n;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;   </div><div class=\"line\">    <span class=\"comment\">// find</span></div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=maxTimes; i++)&#123;</div><div class=\"line\">\t    n = n * little_prime[len];</div><div class=\"line\">\t    <span class=\"keyword\">if</span>(n &gt; high)</div><div class=\"line\">\t\t    <span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t    FindMinN(low, high, n, counts*(i+<span class=\"number\">1</span>), len+<span class=\"number\">1</span>, i);</div><div class=\"line\">\t&#125;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><a href=\"/2015/07/23/Solve-numOfMaxDivisor-ACM/hiho_divisors_depart.cpp.txt\" title=\"hiho_divisors_depart完整代码\">hiho_divisors_depart完整代码</a></li>\n</ul></li>\n</ol>"},{"layout":"post","title":"ACM算法之Trie树","comments":1,"_content":"Trie树是一种用于快速检索的多叉树结构,经常用于统计和排序大量的字符串（但又不限于字符串），所以经常被搜索引擎系统用于文本词频统计。本文首先介绍Trie树的定义、原理及具体实现，然后结合hihocoder上的题目做一些具体实践。\n<!-- more -->\n\n\n## 定义和原理\n[Trie树](http://baike.baidu.com/link?url=ZbVlpuiiV_AoQ96VDfabEG1M_VazTv8HR164QVbQRWmbsXwOwORvSkUfmqAjc3SOVebmK11nUdmIPQRNKq1nuevV1Mvh_EQPGaYn6GqtqT3p6n1hOc0zpXqxV9QKBL09tPeNQm1izNCWvDW3E6cNea)又称字典树，单词查找树，是一种树形结构，是一种哈系树的变种，也是一种用于快速检索的多叉树结构。它有三个基本特征：  \n\n* 根节点不包含字符，除根节点外每个节点都只包含一个字符  \n* 从根节点到某个节点，路径上经过的字符连起来就是对应的字符串  \n* 每个节点的所有字节点所包含的字符都不相同  \n\n除此之外，Trie树一般包含两个基本操作：\n\n* `InsertTrie`\t将字符串记录到Trie树中，顺便统计词频  \n* `SearchTrie`\t查询Trie树中公共字符串出现的次数   \n\n此外还有个基本方法，`CreateNode`，用于建立Trie树的节点并初始化。有了这些方法，Trie树就可以构建成功。\n\n对于文本词频的统计，也可以对相同长度的词生成hash表，不过此时查找的复杂度要达到$O(n)$，n为词的数目。而Trie树在性能上高于哈希表，其插入和查询的复杂度是$O(N)$，N为词的长度。不过Trie树的内存消耗非常大，达到$26^N$级别（用左儿子右兄弟的方法建树可能会好点），这就是==空间换时间==的思想，换句话说是利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。\n\n\n## 代码实现\n* Trie树节点定义\n\n\t```c\n\t#define MAX 26\n\ttypedef struct Node{\n\t\tint count;\n\t\tstruct Node *next[MAX];\n\t}TrieNode;\n\t```\n\t这里的宏定义MAX代表26个字母表。\n* Trie树节点初始化`CreateNode`\n\n\t```c\n\t// 创建新节点\n\tTrieNode* CreateNode(){\n\t\tint i=0;\n\t\tTrieNode *p = (TrieNode*)malloc(sizeof(TrieNode));\n\t\tp->count=1;\n\t\tfor(i=0; i<MAX; i++){\n\t\t\tp->next[i]=NULL;\n\t\t}\n\t\treturn p;\n\t}\n\t```\n\t`CreateNode`是Trie树节点的创建初始化函数，并返回节点指针。\n* Trie树插入操作[==O(N)==]\n\n\t```c\n\t// 插入字典树\n\tvoid InsertTrie(TrieNode** pRoot, char *s){\n\t\tTrieNode *p = NULL;\n\t\t// 基本不太可能出现*pRoot为NULL，因为Trie树根节点一定存在\n\t\tif (*pRoot == NULL){\n\t\t\t*pRoot = CreateNode();\n\t\t}\n\t\tp = *pRoot;\n\t\tint i=0,index;\n\t\twhile(s[i] != '\\0'){\n\t\t\tindex = s[i++] - 'a';\n\t\t\tif(p->next[index] == NULL){\n\t\t\t\t// 新路径要创建新节点\n\t\t\t\tp->next[index] = CreateNode();\n\t\t\t}else{\n\t\t\t\t// 旧路径需要统计次数\n\t\t\t\tp->next[index]->count++;\n\t\t\t}\n\t\t\tp = p->next[index];\n\t\t}\n\t}\n\t```\n\n* Trie树的查询操作[==O(N)==]\n\n\t```c\n\t// 查找字典树\n\tint SearchTrie(TrieNode** pRoot, char *s){\n\t\tTrieNode *p = NULL;\n\t\t// 基本不太可能出现的情况\n\t\tif(*pRoot == NULL){\n\t\t\treturn 0;\n\t\t}\n\t\tp = *pRoot;\n\t\tint i=0,index;\n\t\twhile(s[i] != '\\0'){\n\t\t\tindex = s[i++] - 'a';\n\t\t\t// 未知字符说明不存在\n\t\t\tif (p->next[index] == NULL){\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tp = p->next[index];\n\t\t\t}\n\t\t}\n\t\treturn p->count;\n\t}\n\t```\n\n## 解题报告\n* HihoCoder\n\t1. 第二周：[Trie树](http://hihocoder.com/problemset/problem/1014)\t|\t[源码]({{ site.baseurl }}/assets/attachs/hiho_1014.c.txt)\n\n\t\t注意点：\n\t\t1. Trie树的根节点不包含字符，不能为空的。插入和搜索操作中的判别是为了代码的健壮性。\n","source":"_posts/2015-08-21-ACM算法之Trie树.md","raw":"---\nlayout:\tpost\ntitle:\tACM算法之Trie树\ncategories:\n- TECHNOLOGY\ntags:\n- ACM\n- Algorithm\npermalink:  Solve-trie-ACM\ncomments:   true\n---\nTrie树是一种用于快速检索的多叉树结构,经常用于统计和排序大量的字符串（但又不限于字符串），所以经常被搜索引擎系统用于文本词频统计。本文首先介绍Trie树的定义、原理及具体实现，然后结合hihocoder上的题目做一些具体实践。\n<!-- more -->\n\n\n## 定义和原理\n[Trie树](http://baike.baidu.com/link?url=ZbVlpuiiV_AoQ96VDfabEG1M_VazTv8HR164QVbQRWmbsXwOwORvSkUfmqAjc3SOVebmK11nUdmIPQRNKq1nuevV1Mvh_EQPGaYn6GqtqT3p6n1hOc0zpXqxV9QKBL09tPeNQm1izNCWvDW3E6cNea)又称字典树，单词查找树，是一种树形结构，是一种哈系树的变种，也是一种用于快速检索的多叉树结构。它有三个基本特征：  \n\n* 根节点不包含字符，除根节点外每个节点都只包含一个字符  \n* 从根节点到某个节点，路径上经过的字符连起来就是对应的字符串  \n* 每个节点的所有字节点所包含的字符都不相同  \n\n除此之外，Trie树一般包含两个基本操作：\n\n* `InsertTrie`\t将字符串记录到Trie树中，顺便统计词频  \n* `SearchTrie`\t查询Trie树中公共字符串出现的次数   \n\n此外还有个基本方法，`CreateNode`，用于建立Trie树的节点并初始化。有了这些方法，Trie树就可以构建成功。\n\n对于文本词频的统计，也可以对相同长度的词生成hash表，不过此时查找的复杂度要达到$O(n)$，n为词的数目。而Trie树在性能上高于哈希表，其插入和查询的复杂度是$O(N)$，N为词的长度。不过Trie树的内存消耗非常大，达到$26^N$级别（用左儿子右兄弟的方法建树可能会好点），这就是==空间换时间==的思想，换句话说是利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。\n\n\n## 代码实现\n* Trie树节点定义\n\n\t```c\n\t#define MAX 26\n\ttypedef struct Node{\n\t\tint count;\n\t\tstruct Node *next[MAX];\n\t}TrieNode;\n\t```\n\t这里的宏定义MAX代表26个字母表。\n* Trie树节点初始化`CreateNode`\n\n\t```c\n\t// 创建新节点\n\tTrieNode* CreateNode(){\n\t\tint i=0;\n\t\tTrieNode *p = (TrieNode*)malloc(sizeof(TrieNode));\n\t\tp->count=1;\n\t\tfor(i=0; i<MAX; i++){\n\t\t\tp->next[i]=NULL;\n\t\t}\n\t\treturn p;\n\t}\n\t```\n\t`CreateNode`是Trie树节点的创建初始化函数，并返回节点指针。\n* Trie树插入操作[==O(N)==]\n\n\t```c\n\t// 插入字典树\n\tvoid InsertTrie(TrieNode** pRoot, char *s){\n\t\tTrieNode *p = NULL;\n\t\t// 基本不太可能出现*pRoot为NULL，因为Trie树根节点一定存在\n\t\tif (*pRoot == NULL){\n\t\t\t*pRoot = CreateNode();\n\t\t}\n\t\tp = *pRoot;\n\t\tint i=0,index;\n\t\twhile(s[i] != '\\0'){\n\t\t\tindex = s[i++] - 'a';\n\t\t\tif(p->next[index] == NULL){\n\t\t\t\t// 新路径要创建新节点\n\t\t\t\tp->next[index] = CreateNode();\n\t\t\t}else{\n\t\t\t\t// 旧路径需要统计次数\n\t\t\t\tp->next[index]->count++;\n\t\t\t}\n\t\t\tp = p->next[index];\n\t\t}\n\t}\n\t```\n\n* Trie树的查询操作[==O(N)==]\n\n\t```c\n\t// 查找字典树\n\tint SearchTrie(TrieNode** pRoot, char *s){\n\t\tTrieNode *p = NULL;\n\t\t// 基本不太可能出现的情况\n\t\tif(*pRoot == NULL){\n\t\t\treturn 0;\n\t\t}\n\t\tp = *pRoot;\n\t\tint i=0,index;\n\t\twhile(s[i] != '\\0'){\n\t\t\tindex = s[i++] - 'a';\n\t\t\t// 未知字符说明不存在\n\t\t\tif (p->next[index] == NULL){\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tp = p->next[index];\n\t\t\t}\n\t\t}\n\t\treturn p->count;\n\t}\n\t```\n\n## 解题报告\n* HihoCoder\n\t1. 第二周：[Trie树](http://hihocoder.com/problemset/problem/1014)\t|\t[源码]({{ site.baseurl }}/assets/attachs/hiho_1014.c.txt)\n\n\t\t注意点：\n\t\t1. Trie树的根节点不包含字符，不能为空的。插入和搜索操作中的判别是为了代码的健壮性。\n","slug":"Solve-trie-ACM","published":1,"date":"2015-08-20T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1g001al73y2xfqiwbn","content":"<p>Trie树是一种用于快速检索的多叉树结构,经常用于统计和排序大量的字符串（但又不限于字符串），所以经常被搜索引擎系统用于文本词频统计。本文首先介绍Trie树的定义、原理及具体实现，然后结合hihocoder上的题目做一些具体实践。 <a id=\"more\"></a></p>\n<h2 id=\"定义和原理\">定义和原理</h2>\n<p><a href=\"http://baike.baidu.com/link?url=ZbVlpuiiV_AoQ96VDfabEG1M_VazTv8HR164QVbQRWmbsXwOwORvSkUfmqAjc3SOVebmK11nUdmIPQRNKq1nuevV1Mvh_EQPGaYn6GqtqT3p6n1hOc0zpXqxV9QKBL09tPeNQm1izNCWvDW3E6cNea\" target=\"_blank\" rel=\"external\">Trie树</a>又称字典树，单词查找树，是一种树形结构，是一种哈系树的变种，也是一种用于快速检索的多叉树结构。它有三个基本特征：</p>\n<ul>\n<li>根节点不包含字符，除根节点外每个节点都只包含一个字符<br>\n</li>\n<li>从根节点到某个节点，路径上经过的字符连起来就是对应的字符串<br>\n</li>\n<li>每个节点的所有字节点所包含的字符都不相同</li>\n</ul>\n<p>除此之外，Trie树一般包含两个基本操作：</p>\n<ul>\n<li><code>InsertTrie</code> 将字符串记录到Trie树中，顺便统计词频<br>\n</li>\n<li><code>SearchTrie</code> 查询Trie树中公共字符串出现的次数</li>\n</ul>\n<p>此外还有个基本方法，<code>CreateNode</code>，用于建立Trie树的节点并初始化。有了这些方法，Trie树就可以构建成功。</p>\n<p>对于文本词频的统计，也可以对相同长度的词生成hash表，不过此时查找的复杂度要达到<span class=\"math inline\">\\(O(n)\\)</span>，n为词的数目。而Trie树在性能上高于哈希表，其插入和查询的复杂度是<span class=\"math inline\">\\(O(N)\\)</span>，N为词的长度。不过Trie树的内存消耗非常大，达到<span class=\"math inline\">\\(26^N\\)</span>级别（用左儿子右兄弟的方法建树可能会好点），这就是==空间换时间==的思想，换句话说是利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>\n<h2 id=\"代码实现\">代码实现</h2>\n<ul>\n<li><p>Trie树节点定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 26</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> Node&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> count;</div><div class=\"line\">\t<span class=\"keyword\">struct</span> Node *next[MAX];</div><div class=\"line\">&#125;TrieNode;</div></pre></td></tr></table></figure>\n这里的宏定义MAX代表26个字母表。</li>\n<li><p>Trie树节点初始化<code>CreateNode</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建新节点</span></div><div class=\"line\"><span class=\"function\">TrieNode* <span class=\"title\">CreateNode</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</div><div class=\"line\">\tTrieNode *p = (TrieNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(TrieNode));</div><div class=\"line\">\tp-&gt;count=<span class=\"number\">1</span>;</div><div class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;MAX; i++)&#123;</div><div class=\"line\">\t\tp-&gt;next[i]=<span class=\"literal\">NULL</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> p;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<code>CreateNode</code>是Trie树节点的创建初始化函数，并返回节点指针。</li>\n<li><p>Trie树插入操作[==O(N)==]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 插入字典树</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertTrie</span><span class=\"params\">(TrieNode** pRoot, <span class=\"keyword\">char</span> *s)</span></span>&#123;</div><div class=\"line\">\tTrieNode *p = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"comment\">// 基本不太可能出现*pRoot为NULL，因为Trie树根节点一定存在</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (*pRoot == <span class=\"literal\">NULL</span>)&#123;</div><div class=\"line\">\t\t*pRoot = CreateNode();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tp = *pRoot;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>,index;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(s[i] != <span class=\"string\">'\\0'</span>)&#123;</div><div class=\"line\">\t\tindex = s[i++] - <span class=\"string\">'a'</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(p-&gt;next[index] == <span class=\"literal\">NULL</span>)&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 新路径要创建新节点</span></div><div class=\"line\">\t\t\tp-&gt;next[index] = CreateNode();</div><div class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 旧路径需要统计次数</span></div><div class=\"line\">\t\t\tp-&gt;next[index]-&gt;count++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tp = p-&gt;next[index];</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><p>Trie树的查询操作[==O(N)==]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 查找字典树</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SearchTrie</span><span class=\"params\">(TrieNode** pRoot, <span class=\"keyword\">char</span> *s)</span></span>&#123;</div><div class=\"line\">\tTrieNode *p = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"comment\">// 基本不太可能出现的情况</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(*pRoot == <span class=\"literal\">NULL</span>)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tp = *pRoot;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>,index;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(s[i] != <span class=\"string\">'\\0'</span>)&#123;</div><div class=\"line\">\t\tindex = s[i++] - <span class=\"string\">'a'</span>;</div><div class=\"line\">\t\t<span class=\"comment\">// 未知字符说明不存在</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (p-&gt;next[index] == <span class=\"literal\">NULL</span>)&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t\tp = p-&gt;next[index];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> p-&gt;count;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"解题报告\">解题报告</h2>\n<ul>\n<li>HihoCoder\n<ol style=\"list-style-type: decimal\">\n<li><p>第二周：<a href=\"http://hihocoder.com/problemset/problem/1014\" target=\"_blank\" rel=\"external\">Trie树</a> | [源码](/assets/attachs/hiho_1014.c.txt)</p>\n注意点：\n<ol style=\"list-style-type: decimal\">\n<li>Trie树的根节点不包含字符，不能为空的。插入和搜索操作中的判别是为了代码的健壮性。</li>\n</ol></li>\n</ol></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Trie树是一种用于快速检索的多叉树结构,经常用于统计和排序大量的字符串（但又不限于字符串），所以经常被搜索引擎系统用于文本词频统计。本文首先介绍Trie树的定义、原理及具体实现，然后结合hihocoder上的题目做一些具体实践。","more":"</p>\n<h2 id=\"定义和原理\">定义和原理</h2>\n<p><a href=\"http://baike.baidu.com/link?url=ZbVlpuiiV_AoQ96VDfabEG1M_VazTv8HR164QVbQRWmbsXwOwORvSkUfmqAjc3SOVebmK11nUdmIPQRNKq1nuevV1Mvh_EQPGaYn6GqtqT3p6n1hOc0zpXqxV9QKBL09tPeNQm1izNCWvDW3E6cNea\" target=\"_blank\" rel=\"external\">Trie树</a>又称字典树，单词查找树，是一种树形结构，是一种哈系树的变种，也是一种用于快速检索的多叉树结构。它有三个基本特征：</p>\n<ul>\n<li>根节点不包含字符，除根节点外每个节点都只包含一个字符<br>\n</li>\n<li>从根节点到某个节点，路径上经过的字符连起来就是对应的字符串<br>\n</li>\n<li>每个节点的所有字节点所包含的字符都不相同</li>\n</ul>\n<p>除此之外，Trie树一般包含两个基本操作：</p>\n<ul>\n<li><code>InsertTrie</code> 将字符串记录到Trie树中，顺便统计词频<br>\n</li>\n<li><code>SearchTrie</code> 查询Trie树中公共字符串出现的次数</li>\n</ul>\n<p>此外还有个基本方法，<code>CreateNode</code>，用于建立Trie树的节点并初始化。有了这些方法，Trie树就可以构建成功。</p>\n<p>对于文本词频的统计，也可以对相同长度的词生成hash表，不过此时查找的复杂度要达到<span class=\"math inline\">\\(O(n)\\)</span>，n为词的数目。而Trie树在性能上高于哈希表，其插入和查询的复杂度是<span class=\"math inline\">\\(O(N)\\)</span>，N为词的长度。不过Trie树的内存消耗非常大，达到<span class=\"math inline\">\\(26^N\\)</span>级别（用左儿子右兄弟的方法建树可能会好点），这就是==空间换时间==的思想，换句话说是利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>\n<h2 id=\"代码实现\">代码实现</h2>\n<ul>\n<li><p>Trie树节点定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 26</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> Node&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> count;</div><div class=\"line\">\t<span class=\"keyword\">struct</span> Node *next[MAX];</div><div class=\"line\">&#125;TrieNode;</div></pre></td></tr></table></figure>\n这里的宏定义MAX代表26个字母表。</li>\n<li><p>Trie树节点初始化<code>CreateNode</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建新节点</span></div><div class=\"line\"><span class=\"function\">TrieNode* <span class=\"title\">CreateNode</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</div><div class=\"line\">\tTrieNode *p = (TrieNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(TrieNode));</div><div class=\"line\">\tp-&gt;count=<span class=\"number\">1</span>;</div><div class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;MAX; i++)&#123;</div><div class=\"line\">\t\tp-&gt;next[i]=<span class=\"literal\">NULL</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> p;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<code>CreateNode</code>是Trie树节点的创建初始化函数，并返回节点指针。</li>\n<li><p>Trie树插入操作[==O(N)==]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 插入字典树</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertTrie</span><span class=\"params\">(TrieNode** pRoot, <span class=\"keyword\">char</span> *s)</span></span>&#123;</div><div class=\"line\">\tTrieNode *p = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"comment\">// 基本不太可能出现*pRoot为NULL，因为Trie树根节点一定存在</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (*pRoot == <span class=\"literal\">NULL</span>)&#123;</div><div class=\"line\">\t\t*pRoot = CreateNode();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tp = *pRoot;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>,index;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(s[i] != <span class=\"string\">'\\0'</span>)&#123;</div><div class=\"line\">\t\tindex = s[i++] - <span class=\"string\">'a'</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(p-&gt;next[index] == <span class=\"literal\">NULL</span>)&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 新路径要创建新节点</span></div><div class=\"line\">\t\t\tp-&gt;next[index] = CreateNode();</div><div class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 旧路径需要统计次数</span></div><div class=\"line\">\t\t\tp-&gt;next[index]-&gt;count++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tp = p-&gt;next[index];</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><p>Trie树的查询操作[==O(N)==]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 查找字典树</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SearchTrie</span><span class=\"params\">(TrieNode** pRoot, <span class=\"keyword\">char</span> *s)</span></span>&#123;</div><div class=\"line\">\tTrieNode *p = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"comment\">// 基本不太可能出现的情况</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(*pRoot == <span class=\"literal\">NULL</span>)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tp = *pRoot;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>,index;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(s[i] != <span class=\"string\">'\\0'</span>)&#123;</div><div class=\"line\">\t\tindex = s[i++] - <span class=\"string\">'a'</span>;</div><div class=\"line\">\t\t<span class=\"comment\">// 未知字符说明不存在</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (p-&gt;next[index] == <span class=\"literal\">NULL</span>)&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t\tp = p-&gt;next[index];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> p-&gt;count;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"解题报告\">解题报告</h2>\n<ul>\n<li>HihoCoder\n<ol style=\"list-style-type: decimal\">\n<li><p>第二周：<a href=\"http://hihocoder.com/problemset/problem/1014\" target=\"_blank\" rel=\"external\">Trie树</a> | [源码](/assets/attachs/hiho_1014.c.txt)</p>\n注意点：\n<ol style=\"list-style-type: decimal\">\n<li>Trie树的根节点不包含字符，不能为空的。插入和搜索操作中的判别是为了代码的健壮性。</li>\n</ol></li>\n</ol></li>\n</ul>"},{"layout":"post","title":"逃离VMWare拥抱docker","comments":1,"_content":"Docker是一个开源项目，它是基于linux容器（LXC）等技术，旨在实现轻量级的操作系统虚拟化的一个解决方案。用户操作Docker的容器就像操作虚拟机一样，但是它比虚拟机更轻量更快速。\n<!-- more -->\n\n## VMWare VS Docker\n这里VMWare只是传统虚拟化方式的一个典型代表--虚拟机。传统方式是在硬件层面实现的，就像我们有时在新建虚拟机时出现这样的错误信息：\n> **Error:**  \n> The virtual machine could not be started because the hypervisor is not running.\n\n而解决这个问题的方法就是进入BIOS里面打开Hypervisor。这里的Hypervisor是所有传统虚拟化技术的核心。它运行于物理服务器和操作系统之间的中间的的软件层，允许多个操作系统和应用共享一套基础物理硬件。\n\n相较于在硬件层面上实现的传统虚拟化技术，Docker是在操作系统层面上实现虚拟化的，它直接**复用**本地主机的操作系统。下面的两张图片能很好的诠释二者区别。  \n\n![VMWare]({{site.baseurl}}/assets/images/virtualization.png)\n![Docker]({{site.baseurl}}/assets/images/docker.png)\n\n\n\n作为一种新兴的虚拟化方式，Docker的突出的优势有如下三点：  \n1. 秒级启动  \n2. 对系统资源利用率很高，一台主机可以同时运行数千个Docker容器  \n3. 容器除了运行其中的应用外，基本不消耗额外的系统资源。原因在于Docker容器中只安装配置对应的应用，它可以用最小最基本的内核镜像，用最精简的软件依赖。\n\n总结见下表：  \n\t|   特性   | Docker       |  VMWare  |  \n\t| :----:   | :----:       | :-----:  |  \n\t|   启动   | 秒级         |  分钟级  |  \n\t| 硬盘使用 | MB级         |  GB级    |  \n\t|   性能   |接近原生      | 弱于原生 |  \n\t|系统支持量|单机支持上千个|一般十几个|  \n\n\n## Docker安装\nDocker是基于LXC等技术的，所以linux系统对其的支持是不言而喻的。这里Docker运行的环境是Ubuntu系统。\n\n1. 升级内核\nDocker需要的Ubuntu的内核版本要大于3.13。对于Ubuntu 14.04这个版本是不需要升级内核以及安装依赖软件，而之前的版本是需要升级内核的。升级脚本如下：\n\n\t```bash\n\tsudo apt-get update\n\tsudo apt-get install linux-image-generic-lts-raring linux-headers-generic-lts-raring\n\tsudo reboot\n\t```\n2. 通过源安装Docker\n\n\t```bash\n\t# 安装apt-transport-https支持\n\tsudo apt-get install apt-transport-https\n\t# 获取锁钥\n\tsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9\n\t# 添加Docker源\n\tsudo bash -c \"echo deb https://get.docker.io/ubuntu docker main > /etc/apt/sources.list.d/docker.list\"\n\t# 更新软件源仓库\n\tsudo apt-get update\n\t# 安装Docker\n\tsudo apt-get install lxc-docker -y --force-yes\n\t```\n\n## Docker配置\nDocker的配置文件是[/etc/default/docker]({{site.baseurl}}/assets/attachs/docker.txt)，里面可以设置Docker的启动路径，参数配置，代理以及临时目录设置。\n\n1. 使用代理\n\n\t```bash\n\tcat << EOF >> /etc/default/docker\n\texport http_proxy=\"http://127.0.0.1:8080\"\n\texport https_proxy=\"http://127.0.0.1:8080\"\n\tEOF\n\t```\n2. 改变docker进程监听的IP和端口\n\n\t```bash\n\tcat << EOF >> /etc/default/docker\n\tDOCKER_OPTS=\"-H unix:///var/run/docker.sock -H 0.0.0.0:4243 --insecure-regis    try 127.0.0.1:5000\"\n\tEOF\n\t```\n附：Docker一键安装配置[install_docker.sh]({{site.baseurl}}/assets/attachs/install_docker.sh.txt)\n\n## Docker使用\n1. 镜像操作\n\n\t```bash\n\t# 获取注册服务器registry.hub.docker.com上的ubuntu镜像\n\tsudo docker pull ubuntu:14.04\n\t# 列出本地镜像\n\tsudo docker images\n\t# 启动docker容器\n\tsudo docker run -it ubuntu:14.04 /bin/bash\n\t# 提交已有镜像,获得新镜像id\n\tsudo docker commit -m \"commit information\" -a \"user information\" original_docker_id repository:tag\n\t# 从当前目录下的Dockerfile中生成镜像\n\tsudo docker build -t=\"repository:tag\" .\n\t# 修改镜像标签\n\tsudo docker tag image_id repostory:new_tag\n\t# 从本地文件系统（容器快照）导入\n\tsudo cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04\n\t# 保存镜像\n\tsudo docker save -o ubuntu_14.04.tar ubuntu:14.04\n\t# 载入镜像\n\tsudo docker load < ubuntu_14.04.tar\n\t# 上传镜像\n\tsudo docker push repostory:tag\n\t# 清理所有未打过标签的本地镜像\n\tsudo docker rmi $(docker images --quiet --filter \"dangling=true\")\n\t```\n附：\n\t1. [Dockerfile]({{site.baseurl}}/assets/attachs/Dockfile.txt)\n\t2. 本地文件系统导入镜像的下载：[openvz的模板下载](http://openvz.org/Download/templates/precreated)\n\n2. 容器操作\n\n\t```bash\n\t# 容器启动\n\t## -t\t让Docker分配一个终端Terminal并绑定容器的标准输入\n\t## -i\t让容器的标准输入保持打开（交互模式）\n\t## -d\t以守护态运行\n\tsudo docker run -it ubuntu:14.04 /bin/bash\n\t# 显示容器状态\n\tsudo docker ps\n\t# 获取容器的输出信息\n\tsudo docker logs container_id\n\t# 容器快照的导出\n\tsudo docker export container_id\n\t# 清理所有处于终止状态的容器\n\tsudo docker rm $(docker ps -a -q)\n\t```\n\n3. 仓库操作\n\n\t```bash\n\t# 查找官方仓库的镜像\n\tsudo docker search ubuntu\n\t# 创建私有仓库（官方registry镜像）\n\tsudo docker run -d -p 5000:5000 registry\n\t# 上传镜像到私有仓库\n\tsudo docker push localhost:5000/image_id:tag\n\t```\n","source":"_posts/2015-08-11-逃离VMWare拥抱docker.md","raw":"---\nlayout:\tpost\ntitle:\t逃离VMWare拥抱docker\ncategories:\n- TECHNOLOGY\ntags:\n- Ubuntu\n- OPS\npermalink:  Explore-docker\ncomments:\ttrue\n---\nDocker是一个开源项目，它是基于linux容器（LXC）等技术，旨在实现轻量级的操作系统虚拟化的一个解决方案。用户操作Docker的容器就像操作虚拟机一样，但是它比虚拟机更轻量更快速。\n<!-- more -->\n\n## VMWare VS Docker\n这里VMWare只是传统虚拟化方式的一个典型代表--虚拟机。传统方式是在硬件层面实现的，就像我们有时在新建虚拟机时出现这样的错误信息：\n> **Error:**  \n> The virtual machine could not be started because the hypervisor is not running.\n\n而解决这个问题的方法就是进入BIOS里面打开Hypervisor。这里的Hypervisor是所有传统虚拟化技术的核心。它运行于物理服务器和操作系统之间的中间的的软件层，允许多个操作系统和应用共享一套基础物理硬件。\n\n相较于在硬件层面上实现的传统虚拟化技术，Docker是在操作系统层面上实现虚拟化的，它直接**复用**本地主机的操作系统。下面的两张图片能很好的诠释二者区别。  \n\n![VMWare]({{site.baseurl}}/assets/images/virtualization.png)\n![Docker]({{site.baseurl}}/assets/images/docker.png)\n\n\n\n作为一种新兴的虚拟化方式，Docker的突出的优势有如下三点：  \n1. 秒级启动  \n2. 对系统资源利用率很高，一台主机可以同时运行数千个Docker容器  \n3. 容器除了运行其中的应用外，基本不消耗额外的系统资源。原因在于Docker容器中只安装配置对应的应用，它可以用最小最基本的内核镜像，用最精简的软件依赖。\n\n总结见下表：  \n\t|   特性   | Docker       |  VMWare  |  \n\t| :----:   | :----:       | :-----:  |  \n\t|   启动   | 秒级         |  分钟级  |  \n\t| 硬盘使用 | MB级         |  GB级    |  \n\t|   性能   |接近原生      | 弱于原生 |  \n\t|系统支持量|单机支持上千个|一般十几个|  \n\n\n## Docker安装\nDocker是基于LXC等技术的，所以linux系统对其的支持是不言而喻的。这里Docker运行的环境是Ubuntu系统。\n\n1. 升级内核\nDocker需要的Ubuntu的内核版本要大于3.13。对于Ubuntu 14.04这个版本是不需要升级内核以及安装依赖软件，而之前的版本是需要升级内核的。升级脚本如下：\n\n\t```bash\n\tsudo apt-get update\n\tsudo apt-get install linux-image-generic-lts-raring linux-headers-generic-lts-raring\n\tsudo reboot\n\t```\n2. 通过源安装Docker\n\n\t```bash\n\t# 安装apt-transport-https支持\n\tsudo apt-get install apt-transport-https\n\t# 获取锁钥\n\tsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9\n\t# 添加Docker源\n\tsudo bash -c \"echo deb https://get.docker.io/ubuntu docker main > /etc/apt/sources.list.d/docker.list\"\n\t# 更新软件源仓库\n\tsudo apt-get update\n\t# 安装Docker\n\tsudo apt-get install lxc-docker -y --force-yes\n\t```\n\n## Docker配置\nDocker的配置文件是[/etc/default/docker]({{site.baseurl}}/assets/attachs/docker.txt)，里面可以设置Docker的启动路径，参数配置，代理以及临时目录设置。\n\n1. 使用代理\n\n\t```bash\n\tcat << EOF >> /etc/default/docker\n\texport http_proxy=\"http://127.0.0.1:8080\"\n\texport https_proxy=\"http://127.0.0.1:8080\"\n\tEOF\n\t```\n2. 改变docker进程监听的IP和端口\n\n\t```bash\n\tcat << EOF >> /etc/default/docker\n\tDOCKER_OPTS=\"-H unix:///var/run/docker.sock -H 0.0.0.0:4243 --insecure-regis    try 127.0.0.1:5000\"\n\tEOF\n\t```\n附：Docker一键安装配置[install_docker.sh]({{site.baseurl}}/assets/attachs/install_docker.sh.txt)\n\n## Docker使用\n1. 镜像操作\n\n\t```bash\n\t# 获取注册服务器registry.hub.docker.com上的ubuntu镜像\n\tsudo docker pull ubuntu:14.04\n\t# 列出本地镜像\n\tsudo docker images\n\t# 启动docker容器\n\tsudo docker run -it ubuntu:14.04 /bin/bash\n\t# 提交已有镜像,获得新镜像id\n\tsudo docker commit -m \"commit information\" -a \"user information\" original_docker_id repository:tag\n\t# 从当前目录下的Dockerfile中生成镜像\n\tsudo docker build -t=\"repository:tag\" .\n\t# 修改镜像标签\n\tsudo docker tag image_id repostory:new_tag\n\t# 从本地文件系统（容器快照）导入\n\tsudo cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04\n\t# 保存镜像\n\tsudo docker save -o ubuntu_14.04.tar ubuntu:14.04\n\t# 载入镜像\n\tsudo docker load < ubuntu_14.04.tar\n\t# 上传镜像\n\tsudo docker push repostory:tag\n\t# 清理所有未打过标签的本地镜像\n\tsudo docker rmi $(docker images --quiet --filter \"dangling=true\")\n\t```\n附：\n\t1. [Dockerfile]({{site.baseurl}}/assets/attachs/Dockfile.txt)\n\t2. 本地文件系统导入镜像的下载：[openvz的模板下载](http://openvz.org/Download/templates/precreated)\n\n2. 容器操作\n\n\t```bash\n\t# 容器启动\n\t## -t\t让Docker分配一个终端Terminal并绑定容器的标准输入\n\t## -i\t让容器的标准输入保持打开（交互模式）\n\t## -d\t以守护态运行\n\tsudo docker run -it ubuntu:14.04 /bin/bash\n\t# 显示容器状态\n\tsudo docker ps\n\t# 获取容器的输出信息\n\tsudo docker logs container_id\n\t# 容器快照的导出\n\tsudo docker export container_id\n\t# 清理所有处于终止状态的容器\n\tsudo docker rm $(docker ps -a -q)\n\t```\n\n3. 仓库操作\n\n\t```bash\n\t# 查找官方仓库的镜像\n\tsudo docker search ubuntu\n\t# 创建私有仓库（官方registry镜像）\n\tsudo docker run -d -p 5000:5000 registry\n\t# 上传镜像到私有仓库\n\tsudo docker push localhost:5000/image_id:tag\n\t```\n","slug":"Explore-docker","published":1,"date":"2015-08-10T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1g001bl73yxjbqukwh","content":"<p>Docker是一个开源项目，它是基于linux容器（LXC）等技术，旨在实现轻量级的操作系统虚拟化的一个解决方案。用户操作Docker的容器就像操作虚拟机一样，但是它比虚拟机更轻量更快速。 <a id=\"more\"></a></p>\n<h2 id=\"vmware-vs-docker\">VMWare VS Docker</h2>\n<p>这里VMWare只是传统虚拟化方式的一个典型代表–虚拟机。传统方式是在硬件层面实现的，就像我们有时在新建虚拟机时出现这样的错误信息： &gt; <strong>Error:</strong><br>\n&gt; The virtual machine could not be started because the hypervisor is not running.</p>\n<p>而解决这个问题的方法就是进入BIOS里面打开Hypervisor。这里的Hypervisor是所有传统虚拟化技术的核心。它运行于物理服务器和操作系统之间的中间的的软件层，允许多个操作系统和应用共享一套基础物理硬件。</p>\n<p>相较于在硬件层面上实现的传统虚拟化技术，Docker是在操作系统层面上实现虚拟化的，它直接<strong>复用</strong>本地主机的操作系统。下面的两张图片能很好的诠释二者区别。</p>\n<p>[VMWare](/assets/images/virtualization.png) [Docker](/assets/images/docker.png)</p>\n<p>作为一种新兴的虚拟化方式，Docker的突出的优势有如下三点：<br>\n1. 秒级启动<br>\n2. 对系统资源利用率很高，一台主机可以同时运行数千个Docker容器<br>\n3. 容器除了运行其中的应用外，基本不消耗额外的系统资源。原因在于Docker容器中只安装配置对应的应用，它可以用最小最基本的内核镜像，用最精简的软件依赖。</p>\n<p>总结见下表：<br>\n| 特性 | Docker | VMWare |<br>\n| :—-: | :—-: | :—–: |<br>\n| 启动 | 秒级 | 分钟级 |<br>\n| 硬盘使用 | MB级 | GB级 |<br>\n| 性能 |接近原生 | 弱于原生 |<br>\n|系统支持量|单机支持上千个|一般十几个|</p>\n<h2 id=\"docker安装\">Docker安装</h2>\n<p>Docker是基于LXC等技术的，所以linux系统对其的支持是不言而喻的。这里Docker运行的环境是Ubuntu系统。</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>升级内核 Docker需要的Ubuntu的内核版本要大于3.13。对于Ubuntu 14.04这个版本是不需要升级内核以及安装依赖软件，而之前的版本是需要升级内核的。升级脚本如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install linux-image-generic-lts-raring linux-headers-generic-lts-raring</div><div class=\"line\">sudo reboot</div></pre></td></tr></table></figure></li>\n<li><p>通过源安装Docker</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装apt-transport-https支持</span></div><div class=\"line\">sudo apt-get install apt-transport-https</div><div class=\"line\"><span class=\"comment\"># 获取锁钥</span></div><div class=\"line\">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9</div><div class=\"line\"><span class=\"comment\"># 添加Docker源</span></div><div class=\"line\">sudo bash -c <span class=\"string\">\"echo deb https://get.docker.io/ubuntu docker main &gt; /etc/apt/sources.list.d/docker.list\"</span></div><div class=\"line\"><span class=\"comment\"># 更新软件源仓库</span></div><div class=\"line\">sudo apt-get update</div><div class=\"line\"><span class=\"comment\"># 安装Docker</span></div><div class=\"line\">sudo apt-get install lxc-docker -y --force-yes</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"docker配置\">Docker配置</h2>\n<p>Docker的配置文件是[/etc/default/docker](/assets/attachs/docker.txt)，里面可以设置Docker的启动路径，参数配置，代理以及临时目录设置。</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>使用代理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat &lt;&lt; EOF &gt;&gt; /etc/default/docker</div><div class=\"line\"><span class=\"built_in\">export</span> http_proxy=<span class=\"string\">\"http://127.0.0.1:8080\"</span></div><div class=\"line\"><span class=\"built_in\">export</span> https_proxy=<span class=\"string\">\"http://127.0.0.1:8080\"</span></div><div class=\"line\">EOF</div></pre></td></tr></table></figure></li>\n<li><p>改变docker进程监听的IP和端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat &lt;&lt; EOF &gt;&gt; /etc/default/docker</div><div class=\"line\">DOCKER_OPTS=<span class=\"string\">\"-H unix:///var/run/docker.sock -H 0.0.0.0:4243 --insecure-regis    try 127.0.0.1:5000\"</span></div><div class=\"line\">EOF</div></pre></td></tr></table></figure></li>\n</ol>\n<p>附：Docker一键安装配置[install_docker.sh](/assets/attachs/install_docker.sh.txt)</p>\n<h2 id=\"docker使用\">Docker使用</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>镜像操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 获取注册服务器registry.hub.docker.com上的ubuntu镜像</span></div><div class=\"line\">sudo docker pull ubuntu:14.04</div><div class=\"line\"><span class=\"comment\"># 列出本地镜像</span></div><div class=\"line\">sudo docker images</div><div class=\"line\"><span class=\"comment\"># 启动docker容器</span></div><div class=\"line\">sudo docker run -it ubuntu:14.04 /bin/bash</div><div class=\"line\"><span class=\"comment\"># 提交已有镜像,获得新镜像id</span></div><div class=\"line\">sudo docker commit -m <span class=\"string\">\"commit information\"</span> <span class=\"_\">-a</span> <span class=\"string\">\"user information\"</span> original_docker_id repository:tag</div><div class=\"line\"><span class=\"comment\"># 从当前目录下的Dockerfile中生成镜像</span></div><div class=\"line\">sudo docker build -t=<span class=\"string\">\"repository:tag\"</span> .</div><div class=\"line\"><span class=\"comment\"># 修改镜像标签</span></div><div class=\"line\">sudo docker tag image_id repostory:new_tag</div><div class=\"line\"><span class=\"comment\"># 从本地文件系统（容器快照）导入</span></div><div class=\"line\">sudo cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04</div><div class=\"line\"><span class=\"comment\"># 保存镜像</span></div><div class=\"line\">sudo docker save -o ubuntu_14.04.tar ubuntu:14.04</div><div class=\"line\"><span class=\"comment\"># 载入镜像</span></div><div class=\"line\">sudo docker load &lt; ubuntu_14.04.tar</div><div class=\"line\"><span class=\"comment\"># 上传镜像</span></div><div class=\"line\">sudo docker push repostory:tag</div><div class=\"line\"><span class=\"comment\"># 清理所有未打过标签的本地镜像</span></div><div class=\"line\">sudo docker rmi $(docker images --quiet --filter <span class=\"string\">\"dangling=true\"</span>)</div></pre></td></tr></table></figure></li>\n</ol>\n<p>附： 1. [Dockerfile](/assets/attachs/Dockfile.txt) 2. 本地文件系统导入镜像的下载：<a href=\"http://openvz.org/Download/templates/precreated\" target=\"_blank\" rel=\"external\">openvz的模板下载</a></p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li><p>容器操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 容器启动</span></div><div class=\"line\"><span class=\"comment\">## -t\t让Docker分配一个终端Terminal并绑定容器的标准输入</span></div><div class=\"line\"><span class=\"comment\">## -i\t让容器的标准输入保持打开（交互模式）</span></div><div class=\"line\"><span class=\"comment\">## -d\t以守护态运行</span></div><div class=\"line\">sudo docker run -it ubuntu:14.04 /bin/bash</div><div class=\"line\"><span class=\"comment\"># 显示容器状态</span></div><div class=\"line\">sudo docker ps</div><div class=\"line\"><span class=\"comment\"># 获取容器的输出信息</span></div><div class=\"line\">sudo docker logs container_id</div><div class=\"line\"><span class=\"comment\"># 容器快照的导出</span></div><div class=\"line\">sudo docker <span class=\"built_in\">export</span> container_id</div><div class=\"line\"><span class=\"comment\"># 清理所有处于终止状态的容器</span></div><div class=\"line\">sudo docker rm $(docker ps <span class=\"_\">-a</span> -q)</div></pre></td></tr></table></figure></li>\n<li><p>仓库操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 查找官方仓库的镜像</span></div><div class=\"line\">sudo docker search ubuntu</div><div class=\"line\"><span class=\"comment\"># 创建私有仓库（官方registry镜像）</span></div><div class=\"line\">sudo docker run <span class=\"_\">-d</span> -p 5000:5000 registry</div><div class=\"line\"><span class=\"comment\"># 上传镜像到私有仓库</span></div><div class=\"line\">sudo docker push localhost:5000/image_id:tag</div></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Docker是一个开源项目，它是基于linux容器（LXC）等技术，旨在实现轻量级的操作系统虚拟化的一个解决方案。用户操作Docker的容器就像操作虚拟机一样，但是它比虚拟机更轻量更快速。","more":"</p>\n<h2 id=\"vmware-vs-docker\">VMWare VS Docker</h2>\n<p>这里VMWare只是传统虚拟化方式的一个典型代表–虚拟机。传统方式是在硬件层面实现的，就像我们有时在新建虚拟机时出现这样的错误信息： &gt; <strong>Error:</strong><br>\n&gt; The virtual machine could not be started because the hypervisor is not running.</p>\n<p>而解决这个问题的方法就是进入BIOS里面打开Hypervisor。这里的Hypervisor是所有传统虚拟化技术的核心。它运行于物理服务器和操作系统之间的中间的的软件层，允许多个操作系统和应用共享一套基础物理硬件。</p>\n<p>相较于在硬件层面上实现的传统虚拟化技术，Docker是在操作系统层面上实现虚拟化的，它直接<strong>复用</strong>本地主机的操作系统。下面的两张图片能很好的诠释二者区别。</p>\n<p>[VMWare](/assets/images/virtualization.png) [Docker](/assets/images/docker.png)</p>\n<p>作为一种新兴的虚拟化方式，Docker的突出的优势有如下三点：<br>\n1. 秒级启动<br>\n2. 对系统资源利用率很高，一台主机可以同时运行数千个Docker容器<br>\n3. 容器除了运行其中的应用外，基本不消耗额外的系统资源。原因在于Docker容器中只安装配置对应的应用，它可以用最小最基本的内核镜像，用最精简的软件依赖。</p>\n<p>总结见下表：<br>\n| 特性 | Docker | VMWare |<br>\n| :—-: | :—-: | :—–: |<br>\n| 启动 | 秒级 | 分钟级 |<br>\n| 硬盘使用 | MB级 | GB级 |<br>\n| 性能 |接近原生 | 弱于原生 |<br>\n|系统支持量|单机支持上千个|一般十几个|</p>\n<h2 id=\"docker安装\">Docker安装</h2>\n<p>Docker是基于LXC等技术的，所以linux系统对其的支持是不言而喻的。这里Docker运行的环境是Ubuntu系统。</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>升级内核 Docker需要的Ubuntu的内核版本要大于3.13。对于Ubuntu 14.04这个版本是不需要升级内核以及安装依赖软件，而之前的版本是需要升级内核的。升级脚本如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install linux-image-generic-lts-raring linux-headers-generic-lts-raring</div><div class=\"line\">sudo reboot</div></pre></td></tr></table></figure></li>\n<li><p>通过源安装Docker</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装apt-transport-https支持</span></div><div class=\"line\">sudo apt-get install apt-transport-https</div><div class=\"line\"><span class=\"comment\"># 获取锁钥</span></div><div class=\"line\">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9</div><div class=\"line\"><span class=\"comment\"># 添加Docker源</span></div><div class=\"line\">sudo bash -c <span class=\"string\">\"echo deb https://get.docker.io/ubuntu docker main &gt; /etc/apt/sources.list.d/docker.list\"</span></div><div class=\"line\"><span class=\"comment\"># 更新软件源仓库</span></div><div class=\"line\">sudo apt-get update</div><div class=\"line\"><span class=\"comment\"># 安装Docker</span></div><div class=\"line\">sudo apt-get install lxc-docker -y --force-yes</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"docker配置\">Docker配置</h2>\n<p>Docker的配置文件是[/etc/default/docker](/assets/attachs/docker.txt)，里面可以设置Docker的启动路径，参数配置，代理以及临时目录设置。</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>使用代理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat &lt;&lt; EOF &gt;&gt; /etc/default/docker</div><div class=\"line\"><span class=\"built_in\">export</span> http_proxy=<span class=\"string\">\"http://127.0.0.1:8080\"</span></div><div class=\"line\"><span class=\"built_in\">export</span> https_proxy=<span class=\"string\">\"http://127.0.0.1:8080\"</span></div><div class=\"line\">EOF</div></pre></td></tr></table></figure></li>\n<li><p>改变docker进程监听的IP和端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat &lt;&lt; EOF &gt;&gt; /etc/default/docker</div><div class=\"line\">DOCKER_OPTS=<span class=\"string\">\"-H unix:///var/run/docker.sock -H 0.0.0.0:4243 --insecure-regis    try 127.0.0.1:5000\"</span></div><div class=\"line\">EOF</div></pre></td></tr></table></figure></li>\n</ol>\n<p>附：Docker一键安装配置[install_docker.sh](/assets/attachs/install_docker.sh.txt)</p>\n<h2 id=\"docker使用\">Docker使用</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>镜像操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 获取注册服务器registry.hub.docker.com上的ubuntu镜像</span></div><div class=\"line\">sudo docker pull ubuntu:14.04</div><div class=\"line\"><span class=\"comment\"># 列出本地镜像</span></div><div class=\"line\">sudo docker images</div><div class=\"line\"><span class=\"comment\"># 启动docker容器</span></div><div class=\"line\">sudo docker run -it ubuntu:14.04 /bin/bash</div><div class=\"line\"><span class=\"comment\"># 提交已有镜像,获得新镜像id</span></div><div class=\"line\">sudo docker commit -m <span class=\"string\">\"commit information\"</span> <span class=\"_\">-a</span> <span class=\"string\">\"user information\"</span> original_docker_id repository:tag</div><div class=\"line\"><span class=\"comment\"># 从当前目录下的Dockerfile中生成镜像</span></div><div class=\"line\">sudo docker build -t=<span class=\"string\">\"repository:tag\"</span> .</div><div class=\"line\"><span class=\"comment\"># 修改镜像标签</span></div><div class=\"line\">sudo docker tag image_id repostory:new_tag</div><div class=\"line\"><span class=\"comment\"># 从本地文件系统（容器快照）导入</span></div><div class=\"line\">sudo cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04</div><div class=\"line\"><span class=\"comment\"># 保存镜像</span></div><div class=\"line\">sudo docker save -o ubuntu_14.04.tar ubuntu:14.04</div><div class=\"line\"><span class=\"comment\"># 载入镜像</span></div><div class=\"line\">sudo docker load &lt; ubuntu_14.04.tar</div><div class=\"line\"><span class=\"comment\"># 上传镜像</span></div><div class=\"line\">sudo docker push repostory:tag</div><div class=\"line\"><span class=\"comment\"># 清理所有未打过标签的本地镜像</span></div><div class=\"line\">sudo docker rmi $(docker images --quiet --filter <span class=\"string\">\"dangling=true\"</span>)</div></pre></td></tr></table></figure></li>\n</ol>\n<p>附： 1. [Dockerfile](/assets/attachs/Dockfile.txt) 2. 本地文件系统导入镜像的下载：<a href=\"http://openvz.org/Download/templates/precreated\" target=\"_blank\" rel=\"external\">openvz的模板下载</a></p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li><p>容器操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 容器启动</span></div><div class=\"line\"><span class=\"comment\">## -t\t让Docker分配一个终端Terminal并绑定容器的标准输入</span></div><div class=\"line\"><span class=\"comment\">## -i\t让容器的标准输入保持打开（交互模式）</span></div><div class=\"line\"><span class=\"comment\">## -d\t以守护态运行</span></div><div class=\"line\">sudo docker run -it ubuntu:14.04 /bin/bash</div><div class=\"line\"><span class=\"comment\"># 显示容器状态</span></div><div class=\"line\">sudo docker ps</div><div class=\"line\"><span class=\"comment\"># 获取容器的输出信息</span></div><div class=\"line\">sudo docker logs container_id</div><div class=\"line\"><span class=\"comment\"># 容器快照的导出</span></div><div class=\"line\">sudo docker <span class=\"built_in\">export</span> container_id</div><div class=\"line\"><span class=\"comment\"># 清理所有处于终止状态的容器</span></div><div class=\"line\">sudo docker rm $(docker ps <span class=\"_\">-a</span> -q)</div></pre></td></tr></table></figure></li>\n<li><p>仓库操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 查找官方仓库的镜像</span></div><div class=\"line\">sudo docker search ubuntu</div><div class=\"line\"><span class=\"comment\"># 创建私有仓库（官方registry镜像）</span></div><div class=\"line\">sudo docker run <span class=\"_\">-d</span> -p 5000:5000 registry</div><div class=\"line\"><span class=\"comment\"># 上传镜像到私有仓库</span></div><div class=\"line\">sudo docker push localhost:5000/image_id:tag</div></pre></td></tr></table></figure></li>\n</ol>"},{"layout":"post","title":"快速部署日志分析系统ELK","category":["Ubuntu","OPS"],"comments":1,"_content":"日志分析系统ELK是三个开源软件的缩写，分别是Elasticsearch，Logstash，Kibana。其中Elasticsearch是用来实现索引和搜索功能的目的，Logstash是一个很灵活的日志收集和处理工具。Kibana是和Elasticsearch配套的图形展示界面，用于方便的展示数据和分析数据。本文对整个套件的安装配置过程作了记录，并写了一键安装配置的脚本。\n<!-- more -->\n\n## 环境信息\n* 操作系统 Ubuntu 14.04 64bit\n* 依赖环境\n\t1. java环境\n\n\t\t```bash\n\t\tsudo apt-get install openjdk-7-jdk\n\t\t```\n\t2. redis[==单机时不用安装,CS模式中充当缓存队列==]\n\n\t\t```bash\n\t\tsudo apt-get install redis-server\n\t\t```\n\n## Elasticsearch安装\n1. 导入GPG key\n\n\t```bash\n\twget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | sudo apt-key add -\n\t```\n2. 添加elasticsearch到源（source list）中\n\n\t```bash\n\techo 'deb http://packages.elasticsearch.org/elasticsearch/1.4/debian stable main' | sudo tee /etc/apt/sources.list.d/elasticsearch.list\n\t```\n3. 更新软件包数据库\n\n\t```bash\n\tsudo apt-get update\n\t```\n4. 安装elasticsearch\n\n\t```bash\n\tsudo apt-get -y install elasticsearch=1.4.4\n\t```\n5. 配置elasticsearch[/etc/elasticsearch/elasticsearch.yml]\n\t....\n\n6. 启动elasticsearch服务\n\n\t```bash\n\tsudo service elasticsearch restart\n\t```\n7. 设置elasticsearch开机启动\n\n\t```bash\n\tsudo update-rc.d elasticsearch defaults 95 10\n\t```\n\n## Logstash的安装\n1. 添加logstash到源中\n\n\t```bash\n\techo 'deb http://packages.elasticsearch.org/logstash/1.5/debian stable main' | sudo tee /etc/apt/sources.list.d/logstash.list\n\t```\n2. 更新软件包数据库\n\n\t```bash\n\tsudo apt-get update\n\t```\n3. 安装logstash\n\n\t```bash\n\tsudo apt-get install logstash\n\t```\n4. 配置logstash[向/etc/logstash/conf.d/文件夹中添加配置文件]\n\t* 单机配置[single.conf]({{site.baseurl}}/assets/attachs/single.conf.txt)\n\t* 服务器端配置[indexer.conf]({{site.baseurl}}/assets/attachs/indexer.conf.txt)\n\t* 客户端配置[shipper.conf]({{site.baseurl}}/assets/attachs/shipper.conf.txt)\n\t* 其他配置 [inputs.conf]({{site.baseurl}}/assets/attachs/inputs.conf.txt) | [filters.conf]({{site.baseurl}}/assets/attachs/filters.conf.txt) | [outputs.conf]({{site.baseurl}}/assets/attachs/outputs.conf.txt) | [nginxlog_json.conf]({{site.baseurl}}/assets/attachs/nginxlog_json.conf.txt) & [ifo_nginx.conf]({{site.baseurl}}/assets/attachs/ifo_nginx.conf.txt) | [ifo_collectd.conf]({{site.baseurl}}/assets/attachs/ifo_collectd.conf.txt) | [ifo_syslog.conf]({{site.baseurl}}/assets/attachs/ifo_syslog.conf.txt)\n\n\t```bash\n\t# 单机配置\n\tsudo cp ./single.conf /etc/logstash/conf.d\n\t# 服务端配置\n\tsudo cp ./shipper.conf /etc/logstach/conf.d\n\t# 客户端配置\n\tsudo cp ./shipper.conf /etc/logstash/conf.d\n\t```\n5. 启动logstash服务\n\n\t```bash\n\tsudo service logstash restart\n\t```\n6. 设置logstash开机启动，比elasticsearch启动快，关闭慢\n\n\t```bash\n\tsudo update-rc.d logstash defaults 94 11\n\t```\n\n## 安装Kabana\n1. 下载kibana软件\n\n\t```bash\n\twget -O /tmp/kibana.tar.gz https://download.elasticsearch.org/kibana/kibana/    kibana-4.0.1-linux-x64.tar.gz\n\t```\n2. 解压到/opt/kibana\n\n\t```bash\n\tsudo tar xvf /tmp/kibana.tar.gz -C /opt/\n\tsudo mv /opt/kibana-4.0.1-linux-x64 /opt/kibana\n\t```\n3. 配置kibana[向/opt/kibana/config中添加配置文件]\n\n\t```bash\n\tsudo cp ./kibana.yml /opt/kibana/config/\n\tsudo cp ./kibana4 /etc/init.d/\n\t```\n4. 启动kibana服务器\n\n\t```bash\n\tsudo service kibana4 restart\n\t```\n5. 设置kibana4开机启动，比elasticsearch启动慢，关闭快\n\n\t```bash\n\tsudo update-rc.d kibana4 defaults 96 9\n\t```\n\n## 反向代理工具Nginx\n1. 安装nginx和apache2-utils[有apache的web服务器内置工具，如htpasswd]\n\n\t```bash\n\tsudo apt-get -y install nginx apache2-utils\n\t```\n2. 创建kibanaadmin用户来访问kibana网络接口，密码为kibanaadmin\n\n\t```bash\n\tsudo htpasswd -bc /etc/nginx/htpasswd.users kibanaadmin kibanaadmin\n\t```\n3. 配置nginx[/etc/nginx/sites-available/default]\n\n\t```bash\n\tsudo cp ./default /etc/nginx/sites-available/\n\t```\n4. 重启nginx服务\n\n\t```bash\n\tsudo service nginx restart\n\t```\n\n## 构建SSL证书\n目前还没有走通。\n\n\n## 一键安装脚本\n1. 多台机器协作\n\t* 服务端脚本[indexer.sh]({{site.baseurl}}/assets/attachs/indexer.sh.txt)\n\t* 客户端脚本[shipper.sh]({{site.baseurl}}/assets/attachs/shipper.sh.txt)\n2. 单机独立运行\n\t* 独立脚本[single.sh]({{site.baseurl}}/assets/attachs/single.sh.txt)\n","source":"_posts/2015-08-04-搭建日志分析系统ELK.md","raw":"---\nlayout:\tpost\ntitle:\t快速部署日志分析系统ELK\ncategories:\n- TECHNOLOGY\ntags:\n- Ubuntu\n- OPS\npermalink:  Explore-ELK\ncategory:\t[Ubuntu, OPS]\ncomments:\ttrue\n---\n日志分析系统ELK是三个开源软件的缩写，分别是Elasticsearch，Logstash，Kibana。其中Elasticsearch是用来实现索引和搜索功能的目的，Logstash是一个很灵活的日志收集和处理工具。Kibana是和Elasticsearch配套的图形展示界面，用于方便的展示数据和分析数据。本文对整个套件的安装配置过程作了记录，并写了一键安装配置的脚本。\n<!-- more -->\n\n## 环境信息\n* 操作系统 Ubuntu 14.04 64bit\n* 依赖环境\n\t1. java环境\n\n\t\t```bash\n\t\tsudo apt-get install openjdk-7-jdk\n\t\t```\n\t2. redis[==单机时不用安装,CS模式中充当缓存队列==]\n\n\t\t```bash\n\t\tsudo apt-get install redis-server\n\t\t```\n\n## Elasticsearch安装\n1. 导入GPG key\n\n\t```bash\n\twget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | sudo apt-key add -\n\t```\n2. 添加elasticsearch到源（source list）中\n\n\t```bash\n\techo 'deb http://packages.elasticsearch.org/elasticsearch/1.4/debian stable main' | sudo tee /etc/apt/sources.list.d/elasticsearch.list\n\t```\n3. 更新软件包数据库\n\n\t```bash\n\tsudo apt-get update\n\t```\n4. 安装elasticsearch\n\n\t```bash\n\tsudo apt-get -y install elasticsearch=1.4.4\n\t```\n5. 配置elasticsearch[/etc/elasticsearch/elasticsearch.yml]\n\t....\n\n6. 启动elasticsearch服务\n\n\t```bash\n\tsudo service elasticsearch restart\n\t```\n7. 设置elasticsearch开机启动\n\n\t```bash\n\tsudo update-rc.d elasticsearch defaults 95 10\n\t```\n\n## Logstash的安装\n1. 添加logstash到源中\n\n\t```bash\n\techo 'deb http://packages.elasticsearch.org/logstash/1.5/debian stable main' | sudo tee /etc/apt/sources.list.d/logstash.list\n\t```\n2. 更新软件包数据库\n\n\t```bash\n\tsudo apt-get update\n\t```\n3. 安装logstash\n\n\t```bash\n\tsudo apt-get install logstash\n\t```\n4. 配置logstash[向/etc/logstash/conf.d/文件夹中添加配置文件]\n\t* 单机配置[single.conf]({{site.baseurl}}/assets/attachs/single.conf.txt)\n\t* 服务器端配置[indexer.conf]({{site.baseurl}}/assets/attachs/indexer.conf.txt)\n\t* 客户端配置[shipper.conf]({{site.baseurl}}/assets/attachs/shipper.conf.txt)\n\t* 其他配置 [inputs.conf]({{site.baseurl}}/assets/attachs/inputs.conf.txt) | [filters.conf]({{site.baseurl}}/assets/attachs/filters.conf.txt) | [outputs.conf]({{site.baseurl}}/assets/attachs/outputs.conf.txt) | [nginxlog_json.conf]({{site.baseurl}}/assets/attachs/nginxlog_json.conf.txt) & [ifo_nginx.conf]({{site.baseurl}}/assets/attachs/ifo_nginx.conf.txt) | [ifo_collectd.conf]({{site.baseurl}}/assets/attachs/ifo_collectd.conf.txt) | [ifo_syslog.conf]({{site.baseurl}}/assets/attachs/ifo_syslog.conf.txt)\n\n\t```bash\n\t# 单机配置\n\tsudo cp ./single.conf /etc/logstash/conf.d\n\t# 服务端配置\n\tsudo cp ./shipper.conf /etc/logstach/conf.d\n\t# 客户端配置\n\tsudo cp ./shipper.conf /etc/logstash/conf.d\n\t```\n5. 启动logstash服务\n\n\t```bash\n\tsudo service logstash restart\n\t```\n6. 设置logstash开机启动，比elasticsearch启动快，关闭慢\n\n\t```bash\n\tsudo update-rc.d logstash defaults 94 11\n\t```\n\n## 安装Kabana\n1. 下载kibana软件\n\n\t```bash\n\twget -O /tmp/kibana.tar.gz https://download.elasticsearch.org/kibana/kibana/    kibana-4.0.1-linux-x64.tar.gz\n\t```\n2. 解压到/opt/kibana\n\n\t```bash\n\tsudo tar xvf /tmp/kibana.tar.gz -C /opt/\n\tsudo mv /opt/kibana-4.0.1-linux-x64 /opt/kibana\n\t```\n3. 配置kibana[向/opt/kibana/config中添加配置文件]\n\n\t```bash\n\tsudo cp ./kibana.yml /opt/kibana/config/\n\tsudo cp ./kibana4 /etc/init.d/\n\t```\n4. 启动kibana服务器\n\n\t```bash\n\tsudo service kibana4 restart\n\t```\n5. 设置kibana4开机启动，比elasticsearch启动慢，关闭快\n\n\t```bash\n\tsudo update-rc.d kibana4 defaults 96 9\n\t```\n\n## 反向代理工具Nginx\n1. 安装nginx和apache2-utils[有apache的web服务器内置工具，如htpasswd]\n\n\t```bash\n\tsudo apt-get -y install nginx apache2-utils\n\t```\n2. 创建kibanaadmin用户来访问kibana网络接口，密码为kibanaadmin\n\n\t```bash\n\tsudo htpasswd -bc /etc/nginx/htpasswd.users kibanaadmin kibanaadmin\n\t```\n3. 配置nginx[/etc/nginx/sites-available/default]\n\n\t```bash\n\tsudo cp ./default /etc/nginx/sites-available/\n\t```\n4. 重启nginx服务\n\n\t```bash\n\tsudo service nginx restart\n\t```\n\n## 构建SSL证书\n目前还没有走通。\n\n\n## 一键安装脚本\n1. 多台机器协作\n\t* 服务端脚本[indexer.sh]({{site.baseurl}}/assets/attachs/indexer.sh.txt)\n\t* 客户端脚本[shipper.sh]({{site.baseurl}}/assets/attachs/shipper.sh.txt)\n2. 单机独立运行\n\t* 独立脚本[single.sh]({{site.baseurl}}/assets/attachs/single.sh.txt)\n","slug":"Explore-ELK","published":1,"date":"2015-08-03T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1g001cl73yjeqqjyqt","content":"<p>日志分析系统ELK是三个开源软件的缩写，分别是Elasticsearch，Logstash，Kibana。其中Elasticsearch是用来实现索引和搜索功能的目的，Logstash是一个很灵活的日志收集和处理工具。Kibana是和Elasticsearch配套的图形展示界面，用于方便的展示数据和分析数据。本文对整个套件的安装配置过程作了记录，并写了一键安装配置的脚本。 <a id=\"more\"></a></p>\n<h2 id=\"环境信息\">环境信息</h2>\n<ul>\n<li>操作系统 Ubuntu 14.04 64bit</li>\n<li>依赖环境\n<ol style=\"list-style-type: decimal\">\n<li><p>java环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install openjdk-7-jdk</div></pre></td></tr></table></figure></li>\n<li><p>redis[==单机时不用安装,CS模式中充当缓存队列==]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install redis-server</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ul>\n<h2 id=\"elasticsearch安装\">Elasticsearch安装</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>导入GPG key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | sudo apt-key add -</div></pre></td></tr></table></figure></li>\n<li><p>添加elasticsearch到源（source list）中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'deb http://packages.elasticsearch.org/elasticsearch/1.4/debian stable main'</span> | sudo tee /etc/apt/sources.list.d/elasticsearch.list</div></pre></td></tr></table></figure></li>\n<li><p>更新软件包数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update</div></pre></td></tr></table></figure></li>\n<li><p>安装elasticsearch</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get -y install elasticsearch=1.4.4</div></pre></td></tr></table></figure></li>\n<li><p>配置elasticsearch[/etc/elasticsearch/elasticsearch.yml] ….</p></li>\n<li><p>启动elasticsearch服务</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo service elasticsearch restart</div></pre></td></tr></table></figure></li>\n<li><p>设置elasticsearch开机启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo update-rc.d elasticsearch defaults 95 10</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"logstash的安装\">Logstash的安装</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>添加logstash到源中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'deb http://packages.elasticsearch.org/logstash/1.5/debian stable main'</span> | sudo tee /etc/apt/sources.list.d/logstash.list</div></pre></td></tr></table></figure></li>\n<li><p>更新软件包数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update</div></pre></td></tr></table></figure></li>\n<li><p>安装logstash</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install logstash</div></pre></td></tr></table></figure></li>\n<li>配置logstash[向/etc/logstash/conf.d/文件夹中添加配置文件]\n<ul>\n<li>单机配置[single.conf](/assets/attachs/single.conf.txt)</li>\n<li>服务器端配置[indexer.conf](/assets/attachs/indexer.conf.txt)</li>\n<li>客户端配置[shipper.conf](/assets/attachs/shipper.conf.txt)</li>\n<li>其他配置 [inputs.conf](/assets/attachs/inputs.conf.txt) | [filters.conf](/assets/attachs/filters.conf.txt) | [outputs.conf](/assets/attachs/outputs.conf.txt) | [nginxlog_json.conf](/assets/attachs/nginxlog_json.conf.txt) &amp; [ifo_nginx.conf](/assets/attachs/ifo_nginx.conf.txt) | [ifo_collectd.conf](/assets/attachs/ifo_collectd.conf.txt) | [ifo_syslog.conf](/assets/attachs/ifo_syslog.conf.txt)</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 单机配置</span></div><div class=\"line\">sudo cp ./single.conf /etc/logstash/conf.d</div><div class=\"line\"><span class=\"comment\"># 服务端配置</span></div><div class=\"line\">sudo cp ./shipper.conf /etc/logstach/conf.d</div><div class=\"line\"><span class=\"comment\"># 客户端配置</span></div><div class=\"line\">sudo cp ./shipper.conf /etc/logstash/conf.d</div></pre></td></tr></table></figure></li>\n<li><p>启动logstash服务</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo service logstash restart</div></pre></td></tr></table></figure></li>\n<li><p>设置logstash开机启动，比elasticsearch启动快，关闭慢</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo update-rc.d logstash defaults 94 11</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"安装kabana\">安装Kabana</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>下载kibana软件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget -O /tmp/kibana.tar.gz https://download.elasticsearch.org/kibana/kibana/    kibana-4.0.1-linux-x64.tar.gz</div></pre></td></tr></table></figure></li>\n<li><p>解压到/opt/kibana</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo tar xvf /tmp/kibana.tar.gz -C /opt/</div><div class=\"line\">sudo mv /opt/kibana-4.0.1-linux-x64 /opt/kibana</div></pre></td></tr></table></figure></li>\n<li><p>配置kibana[向/opt/kibana/config中添加配置文件]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo cp ./kibana.yml /opt/kibana/config/</div><div class=\"line\">sudo cp ./kibana4 /etc/init.d/</div></pre></td></tr></table></figure></li>\n<li><p>启动kibana服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo service kibana4 restart</div></pre></td></tr></table></figure></li>\n<li><p>设置kibana4开机启动，比elasticsearch启动慢，关闭快</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo update-rc.d kibana4 defaults 96 9</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"反向代理工具nginx\">反向代理工具Nginx</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>安装nginx和apache2-utils[有apache的web服务器内置工具，如htpasswd]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get -y install nginx apache2-utils</div></pre></td></tr></table></figure></li>\n<li><p>创建kibanaadmin用户来访问kibana网络接口，密码为kibanaadmin</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo htpasswd -bc /etc/nginx/htpasswd.users kibanaadmin kibanaadmin</div></pre></td></tr></table></figure></li>\n<li><p>配置nginx[/etc/nginx/sites-available/default]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo cp ./default /etc/nginx/sites-available/</div></pre></td></tr></table></figure></li>\n<li><p>重启nginx服务</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo service nginx restart</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"构建ssl证书\">构建SSL证书</h2>\n<p>目前还没有走通。</p>\n<h2 id=\"一键安装脚本\">一键安装脚本</h2>\n<ol style=\"list-style-type: decimal\">\n<li>多台机器协作\n<ul>\n<li>服务端脚本[indexer.sh](/assets/attachs/indexer.sh.txt)</li>\n<li>客户端脚本[shipper.sh](/assets/attachs/shipper.sh.txt)</li>\n</ul></li>\n<li>单机独立运行\n<ul>\n<li>独立脚本[single.sh](/assets/attachs/single.sh.txt)</li>\n</ul></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>日志分析系统ELK是三个开源软件的缩写，分别是Elasticsearch，Logstash，Kibana。其中Elasticsearch是用来实现索引和搜索功能的目的，Logstash是一个很灵活的日志收集和处理工具。Kibana是和Elasticsearch配套的图形展示界面，用于方便的展示数据和分析数据。本文对整个套件的安装配置过程作了记录，并写了一键安装配置的脚本。","more":"</p>\n<h2 id=\"环境信息\">环境信息</h2>\n<ul>\n<li>操作系统 Ubuntu 14.04 64bit</li>\n<li>依赖环境\n<ol style=\"list-style-type: decimal\">\n<li><p>java环境</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install openjdk-7-jdk</div></pre></td></tr></table></figure></li>\n<li><p>redis[==单机时不用安装,CS模式中充当缓存队列==]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install redis-server</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ul>\n<h2 id=\"elasticsearch安装\">Elasticsearch安装</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>导入GPG key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | sudo apt-key add -</div></pre></td></tr></table></figure></li>\n<li><p>添加elasticsearch到源（source list）中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'deb http://packages.elasticsearch.org/elasticsearch/1.4/debian stable main'</span> | sudo tee /etc/apt/sources.list.d/elasticsearch.list</div></pre></td></tr></table></figure></li>\n<li><p>更新软件包数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update</div></pre></td></tr></table></figure></li>\n<li><p>安装elasticsearch</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get -y install elasticsearch=1.4.4</div></pre></td></tr></table></figure></li>\n<li><p>配置elasticsearch[/etc/elasticsearch/elasticsearch.yml] ….</p></li>\n<li><p>启动elasticsearch服务</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo service elasticsearch restart</div></pre></td></tr></table></figure></li>\n<li><p>设置elasticsearch开机启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo update-rc.d elasticsearch defaults 95 10</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"logstash的安装\">Logstash的安装</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>添加logstash到源中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'deb http://packages.elasticsearch.org/logstash/1.5/debian stable main'</span> | sudo tee /etc/apt/sources.list.d/logstash.list</div></pre></td></tr></table></figure></li>\n<li><p>更新软件包数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update</div></pre></td></tr></table></figure></li>\n<li><p>安装logstash</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install logstash</div></pre></td></tr></table></figure></li>\n<li>配置logstash[向/etc/logstash/conf.d/文件夹中添加配置文件]\n<ul>\n<li>单机配置[single.conf](/assets/attachs/single.conf.txt)</li>\n<li>服务器端配置[indexer.conf](/assets/attachs/indexer.conf.txt)</li>\n<li>客户端配置[shipper.conf](/assets/attachs/shipper.conf.txt)</li>\n<li>其他配置 [inputs.conf](/assets/attachs/inputs.conf.txt) | [filters.conf](/assets/attachs/filters.conf.txt) | [outputs.conf](/assets/attachs/outputs.conf.txt) | [nginxlog_json.conf](/assets/attachs/nginxlog_json.conf.txt) &amp; [ifo_nginx.conf](/assets/attachs/ifo_nginx.conf.txt) | [ifo_collectd.conf](/assets/attachs/ifo_collectd.conf.txt) | [ifo_syslog.conf](/assets/attachs/ifo_syslog.conf.txt)</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 单机配置</span></div><div class=\"line\">sudo cp ./single.conf /etc/logstash/conf.d</div><div class=\"line\"><span class=\"comment\"># 服务端配置</span></div><div class=\"line\">sudo cp ./shipper.conf /etc/logstach/conf.d</div><div class=\"line\"><span class=\"comment\"># 客户端配置</span></div><div class=\"line\">sudo cp ./shipper.conf /etc/logstash/conf.d</div></pre></td></tr></table></figure></li>\n<li><p>启动logstash服务</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo service logstash restart</div></pre></td></tr></table></figure></li>\n<li><p>设置logstash开机启动，比elasticsearch启动快，关闭慢</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo update-rc.d logstash defaults 94 11</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"安装kabana\">安装Kabana</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>下载kibana软件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget -O /tmp/kibana.tar.gz https://download.elasticsearch.org/kibana/kibana/    kibana-4.0.1-linux-x64.tar.gz</div></pre></td></tr></table></figure></li>\n<li><p>解压到/opt/kibana</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo tar xvf /tmp/kibana.tar.gz -C /opt/</div><div class=\"line\">sudo mv /opt/kibana-4.0.1-linux-x64 /opt/kibana</div></pre></td></tr></table></figure></li>\n<li><p>配置kibana[向/opt/kibana/config中添加配置文件]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo cp ./kibana.yml /opt/kibana/config/</div><div class=\"line\">sudo cp ./kibana4 /etc/init.d/</div></pre></td></tr></table></figure></li>\n<li><p>启动kibana服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo service kibana4 restart</div></pre></td></tr></table></figure></li>\n<li><p>设置kibana4开机启动，比elasticsearch启动慢，关闭快</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo update-rc.d kibana4 defaults 96 9</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"反向代理工具nginx\">反向代理工具Nginx</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>安装nginx和apache2-utils[有apache的web服务器内置工具，如htpasswd]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get -y install nginx apache2-utils</div></pre></td></tr></table></figure></li>\n<li><p>创建kibanaadmin用户来访问kibana网络接口，密码为kibanaadmin</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo htpasswd -bc /etc/nginx/htpasswd.users kibanaadmin kibanaadmin</div></pre></td></tr></table></figure></li>\n<li><p>配置nginx[/etc/nginx/sites-available/default]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo cp ./default /etc/nginx/sites-available/</div></pre></td></tr></table></figure></li>\n<li><p>重启nginx服务</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo service nginx restart</div></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"构建ssl证书\">构建SSL证书</h2>\n<p>目前还没有走通。</p>\n<h2 id=\"一键安装脚本\">一键安装脚本</h2>\n<ol style=\"list-style-type: decimal\">\n<li>多台机器协作\n<ul>\n<li>服务端脚本[indexer.sh](/assets/attachs/indexer.sh.txt)</li>\n<li>客户端脚本[shipper.sh](/assets/attachs/shipper.sh.txt)</li>\n</ul></li>\n<li>单机独立运行\n<ul>\n<li>独立脚本[single.sh](/assets/attachs/single.sh.txt)</li>\n</ul></li>\n</ol>"},{"layout":"post","title":"集成开发工具Eclipse的配置","comments":1,"_content":"Eclipse是个强大的集成工具，写JAVA程序的人基本都会首选该工具，然而它的强大并不仅仅体现在对JAVA的支持上，实际上用Eclipse可以写C/C++程序以及Python代码等。当然这一切都需要安装一些插件并进行一些配置。这里就对其配置进行一些记录。\n<!-- more -->\n\n\n## 基础配置\n### 使用代理\n现在很多公司都是在局域网中工作，要访问Internet需要使用代理，或者是需要使用代理来进行“翻墙”操作，以此来方便员工掌握更多的网络资源，所以给Eclipse配置代理是必不可少的操作，该操作可以方便后面的软件更新，插件安装等。\n\n* 手动设置\n\t1. 操作路径\n\twindow -> preferences -> general -> network connections,看到如下界面：  \n\t![set_proxy]({{site.baseurl}}/assets/images/set_proxy.png)\n\t2. 设置代理  \n\tActive Provider选中Manual，并在下面的proxy entries里面进行代理的设置\n\n* 命令设置  \n\t以下面的命令启动Eclipse，或者将以下的命令配置到快捷方式的命令里\n\n\t```bash\n\teclipse.exe -vmargs -DproxySet=true -DproxyHost=aProxyAddress -DproxyPort=aProxyPort\n\t```\n\n## python插件\nEclipse支持Python代码编写的插件叫PyDev。安装需要通过添加仓库的方式。\n\n1. 安装  \n\t1. 操作路径  \n\tHelp -> Install New Software,看到如下界面：  \n\t![add_reposity]({{site.baseurl}}/assets/images/add_repository.png)\n\t2. 添加仓库  \n\tName随便填写，建议用PyDev。Location填http://pydev.org/updates ，后面安装PyDev就OK了。\n2. 配置  \n\t1. 操作路径  \n\tWindow -> Preferences -> Pydev -> Interpreter-Python,看到如下界面：  \n\t![python_config]({{site.baseurl}}/assets/images/python_config.png)\n\t2. 配置  \n\t\t* Auto Config -- 会自动搜索路径，查找python的安装路径\n\t\t* New -- 自己手动添加python的安装路径\n","source":"_posts/2015-08-13-集成开发工具Eclipse的配置.md","raw":"---\nlayout:\tpost\ntitle:\t集成开发工具Eclipse的配置\ncategories:\n- TECHNOLOGY\ntags:\n- Ubuntu\n- Software\npermalink:  Record-configure-Eclipse\ncomments:\ttrue\n---\nEclipse是个强大的集成工具，写JAVA程序的人基本都会首选该工具，然而它的强大并不仅仅体现在对JAVA的支持上，实际上用Eclipse可以写C/C++程序以及Python代码等。当然这一切都需要安装一些插件并进行一些配置。这里就对其配置进行一些记录。\n<!-- more -->\n\n\n## 基础配置\n### 使用代理\n现在很多公司都是在局域网中工作，要访问Internet需要使用代理，或者是需要使用代理来进行“翻墙”操作，以此来方便员工掌握更多的网络资源，所以给Eclipse配置代理是必不可少的操作，该操作可以方便后面的软件更新，插件安装等。\n\n* 手动设置\n\t1. 操作路径\n\twindow -> preferences -> general -> network connections,看到如下界面：  \n\t![set_proxy]({{site.baseurl}}/assets/images/set_proxy.png)\n\t2. 设置代理  \n\tActive Provider选中Manual，并在下面的proxy entries里面进行代理的设置\n\n* 命令设置  \n\t以下面的命令启动Eclipse，或者将以下的命令配置到快捷方式的命令里\n\n\t```bash\n\teclipse.exe -vmargs -DproxySet=true -DproxyHost=aProxyAddress -DproxyPort=aProxyPort\n\t```\n\n## python插件\nEclipse支持Python代码编写的插件叫PyDev。安装需要通过添加仓库的方式。\n\n1. 安装  \n\t1. 操作路径  \n\tHelp -> Install New Software,看到如下界面：  \n\t![add_reposity]({{site.baseurl}}/assets/images/add_repository.png)\n\t2. 添加仓库  \n\tName随便填写，建议用PyDev。Location填http://pydev.org/updates ，后面安装PyDev就OK了。\n2. 配置  \n\t1. 操作路径  \n\tWindow -> Preferences -> Pydev -> Interpreter-Python,看到如下界面：  \n\t![python_config]({{site.baseurl}}/assets/images/python_config.png)\n\t2. 配置  \n\t\t* Auto Config -- 会自动搜索路径，查找python的安装路径\n\t\t* New -- 自己手动添加python的安装路径\n","slug":"Record-configure-Eclipse","published":1,"date":"2015-08-12T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1h001dl73yrmq61ozo","content":"<p>Eclipse是个强大的集成工具，写JAVA程序的人基本都会首选该工具，然而它的强大并不仅仅体现在对JAVA的支持上，实际上用Eclipse可以写C/C++程序以及Python代码等。当然这一切都需要安装一些插件并进行一些配置。这里就对其配置进行一些记录。 <a id=\"more\"></a></p>\n<h2 id=\"基础配置\">基础配置</h2>\n<h3 id=\"使用代理\">使用代理</h3>\n<p>现在很多公司都是在局域网中工作，要访问Internet需要使用代理，或者是需要使用代理来进行“翻墙”操作，以此来方便员工掌握更多的网络资源，所以给Eclipse配置代理是必不可少的操作，该操作可以方便后面的软件更新，插件安装等。</p>\n<ul>\n<li>手动设置\n<ol style=\"list-style-type: decimal\">\n<li>操作路径 window -&gt; preferences -&gt; general -&gt; network connections,看到如下界面：<br>\n[set_proxy](/assets/images/set_proxy.png)</li>\n<li>设置代理<br>\nActive Provider选中Manual，并在下面的proxy entries里面进行代理的设置</li>\n</ol></li>\n<li><p>命令设置<br>\n以下面的命令启动Eclipse，或者将以下的命令配置到快捷方式的命令里</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">eclipse.exe -vmargs -DproxySet=<span class=\"literal\">true</span> -DproxyHost=aProxyAddress -DproxyPort=aProxyPort</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"python插件\">python插件</h2>\n<p>Eclipse支持Python代码编写的插件叫PyDev。安装需要通过添加仓库的方式。</p>\n<ol style=\"list-style-type: decimal\">\n<li>安装\n<ol style=\"list-style-type: decimal\">\n<li>操作路径<br>\nHelp -&gt; Install New Software,看到如下界面：<br>\n[add_reposity](/assets/images/add_repository.png)</li>\n<li>添加仓库<br>\nName随便填写，建议用PyDev。Location填http://pydev.org/updates ，后面安装PyDev就OK了。</li>\n</ol></li>\n<li>配置\n<ol style=\"list-style-type: decimal\">\n<li>操作路径<br>\nWindow -&gt; Preferences -&gt; Pydev -&gt; Interpreter-Python,看到如下界面：<br>\n[python_config](/assets/images/python_config.png)</li>\n<li>配置\n<ul>\n<li>Auto Config – 会自动搜索路径，查找python的安装路径</li>\n<li>New – 自己手动添加python的安装路径</li>\n</ul></li>\n</ol></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Eclipse是个强大的集成工具，写JAVA程序的人基本都会首选该工具，然而它的强大并不仅仅体现在对JAVA的支持上，实际上用Eclipse可以写C/C++程序以及Python代码等。当然这一切都需要安装一些插件并进行一些配置。这里就对其配置进行一些记录。","more":"</p>\n<h2 id=\"基础配置\">基础配置</h2>\n<h3 id=\"使用代理\">使用代理</h3>\n<p>现在很多公司都是在局域网中工作，要访问Internet需要使用代理，或者是需要使用代理来进行“翻墙”操作，以此来方便员工掌握更多的网络资源，所以给Eclipse配置代理是必不可少的操作，该操作可以方便后面的软件更新，插件安装等。</p>\n<ul>\n<li>手动设置\n<ol style=\"list-style-type: decimal\">\n<li>操作路径 window -&gt; preferences -&gt; general -&gt; network connections,看到如下界面：<br>\n[set_proxy](/assets/images/set_proxy.png)</li>\n<li>设置代理<br>\nActive Provider选中Manual，并在下面的proxy entries里面进行代理的设置</li>\n</ol></li>\n<li><p>命令设置<br>\n以下面的命令启动Eclipse，或者将以下的命令配置到快捷方式的命令里</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">eclipse.exe -vmargs -DproxySet=<span class=\"literal\">true</span> -DproxyHost=aProxyAddress -DproxyPort=aProxyPort</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"python插件\">python插件</h2>\n<p>Eclipse支持Python代码编写的插件叫PyDev。安装需要通过添加仓库的方式。</p>\n<ol style=\"list-style-type: decimal\">\n<li>安装\n<ol style=\"list-style-type: decimal\">\n<li>操作路径<br>\nHelp -&gt; Install New Software,看到如下界面：<br>\n[add_reposity](/assets/images/add_repository.png)</li>\n<li>添加仓库<br>\nName随便填写，建议用PyDev。Location填http://pydev.org/updates ，后面安装PyDev就OK了。</li>\n</ol></li>\n<li>配置\n<ol style=\"list-style-type: decimal\">\n<li>操作路径<br>\nWindow -&gt; Preferences -&gt; Pydev -&gt; Interpreter-Python,看到如下界面：<br>\n[python_config](/assets/images/python_config.png)</li>\n<li>配置\n<ul>\n<li>Auto Config – 会自动搜索路径，查找python的安装路径</li>\n<li>New – 自己手动添加python的安装路径</li>\n</ul></li>\n</ol></li>\n</ol>"},{"layout":"post","title":"C语言编程之常见错误","comments":1,"_content":"在ACM编程过程中，经常会碰到一些千奇百怪的编译错误。本篇博文就是对这些比较隐晦的编译错误做一下记录，以方便在今后的编程中少走些弯路。\n<!-- more -->\n\n## 函数无返回值\n1. 情景描述  \n在C/C++程序的编写中，有时会忘了给带返回值的函数写return语句。例如在主函数`int main()`结尾不加`return 0;`语句。不过gcc/g++编译也没有报错。不过一旦在非主函数的函数中不加返回值语句，那么程序是有问题的。\n\n2. 解决方案  \n编译命令中加入`-Wall`参数。\n![no_return]({{site.baseurl}}/assets/images/no_return.png)\n由上图中可以看出不加`-Wall`能编译通过1014.c文件，但是加上`-Wall`后，该问题将会以warning的提示给出。其实这是个大问题。\n","source":"_posts/2015-08-22-C语言编程之常见错误.md","raw":"---\nlayout:\tpost\ntitle:\tC语言编程之常见错误\ncategories:\n- TECHNOLOGY\ntags:\n- C\n- Coding\npermalink:  Explore-commonError-C\ncomments:\ttrue\n---\n在ACM编程过程中，经常会碰到一些千奇百怪的编译错误。本篇博文就是对这些比较隐晦的编译错误做一下记录，以方便在今后的编程中少走些弯路。\n<!-- more -->\n\n## 函数无返回值\n1. 情景描述  \n在C/C++程序的编写中，有时会忘了给带返回值的函数写return语句。例如在主函数`int main()`结尾不加`return 0;`语句。不过gcc/g++编译也没有报错。不过一旦在非主函数的函数中不加返回值语句，那么程序是有问题的。\n\n2. 解决方案  \n编译命令中加入`-Wall`参数。\n![no_return]({{site.baseurl}}/assets/images/no_return.png)\n由上图中可以看出不加`-Wall`能编译通过1014.c文件，但是加上`-Wall`后，该问题将会以warning的提示给出。其实这是个大问题。\n","slug":"Explore-commonError-C","published":1,"date":"2015-08-21T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1h001el73ynji20pun","content":"<p>在ACM编程过程中，经常会碰到一些千奇百怪的编译错误。本篇博文就是对这些比较隐晦的编译错误做一下记录，以方便在今后的编程中少走些弯路。 <a id=\"more\"></a></p>\n<h2 id=\"函数无返回值\">函数无返回值</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>情景描述<br>\n在C/C++程序的编写中，有时会忘了给带返回值的函数写return语句。例如在主函数<code>int main()</code>结尾不加<code>return 0;</code>语句。不过gcc/g++编译也没有报错。不过一旦在非主函数的函数中不加返回值语句，那么程序是有问题的。</p></li>\n<li><p>解决方案<br>\n编译命令中加入<code>-Wall</code>参数。 [no_return](/assets/images/no_return.png) 由上图中可以看出不加<code>-Wall</code>能编译通过1014.c文件，但是加上<code>-Wall</code>后，该问题将会以warning的提示给出。其实这是个大问题。</p></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在ACM编程过程中，经常会碰到一些千奇百怪的编译错误。本篇博文就是对这些比较隐晦的编译错误做一下记录，以方便在今后的编程中少走些弯路。","more":"</p>\n<h2 id=\"函数无返回值\">函数无返回值</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>情景描述<br>\n在C/C++程序的编写中，有时会忘了给带返回值的函数写return语句。例如在主函数<code>int main()</code>结尾不加<code>return 0;</code>语句。不过gcc/g++编译也没有报错。不过一旦在非主函数的函数中不加返回值语句，那么程序是有问题的。</p></li>\n<li><p>解决方案<br>\n编译命令中加入<code>-Wall</code>参数。 [no_return](/assets/images/no_return.png) 由上图中可以看出不加<code>-Wall</code>能编译通过1014.c文件，但是加上<code>-Wall</code>后，该问题将会以warning的提示给出。其实这是个大问题。</p></li>\n</ol>"},{"layout":"post","title":"Vim配置之入门篇","comments":1,"_content":"正所谓“工欲善其事，必先利其器”，而作为一个专业的码农，怎么能不好好对待自己编程的利器--VIM编辑器呢！可能读者会说编程的利器不应该是各种语言的集成工具么？像编写C/C++程序的VS，Codeblock（跨平台）软件，像编写Java程序的Eclipse（现在已经有支持C/C++/Python的插件），像编写Python程序的PyCharm等。这些人性化的开发集成环境功能强大，使用方便。不过成也在此，败也在此。本文将详细介绍Vim编辑器以及其基本入门级配置。\n<!-- more -->\n\n## 简介\n正所谓“工欲善其事，必先利其器”，而作为一个专业的码农，怎么能不好好对待自己的编程利器--VIM编辑器呢！可能读者会说编程的利器不应该是各种语言的集成工具么？像编写C/C++程序的VS，Codeblock（跨平台）软件，像编写Java程序的Eclipse（现在已经有支持C/C++/Python的插件），像编写Python程序的PyCharm等。这些人性化的开发集成环境功能强大，使用方便。不过我觉得成也在此，败也在此。\n\n1. 功能冗余  \n现在编程的集成环境工具非常强大，但是很多功能我们都用不到，反而每次开启都花费很长时间。所以集成环境并不适合专业的码农。我们经常说适合自己的才是最好的，编程利器更是如此，毕竟它每天不离手。\n2. 定制化太低   \n基本上每个集成开发工具都没有留太多的定制空间给用户，而用户只能习惯软件供应商提供的大众化用法。对于熟悉多种语言的用户而言，它得掌握多种开发集成环境，还不如用Vim解决所有。\n3. 鼠标和键盘的混合使用  \n其实这一点仁者见仁，智者见智吧。个人觉得高效编程还是需要手不离键盘的，要熟练掌握一些基本的快捷键的使用。\n\n\n基本的Vim说白了就是一个文本编辑器，不过它的强大之处在于它庞大的插件。这些插件可以让Vim能够干很多牛x的事，这跟google浏览器有点像。像代码补全，错误跳转，高亮显示等等，Vim都有相应的插件来处理，用户可以自行了解，自由组合。所以Vim的入门门坎还是蛮高的，主要是开始学得命令比较多，这里有推荐个[玩游戏记命令的网址][vim_adventures]以及[Vim学习指南][vim_progressively]。此外打造一个适合自己的vim环境将会大大节约时间，是磨刀不误砍柴工的。下面就来看看基础入门级的[Vim插件配置][vim_plugin]。\n\n## 基本配置\n1. 安装vim,scripts,doc\n\n    ```sh\n    sudo apt-get install vim vim-scripts vim-doc\n    ```\n\n    > **Tips:**\n    > * vim         vim软件，安装目录是/usr/share/vim\n    > * vim-scripts vim的基本插件，包括语法高亮等，安装目录是/usr/share/vim-scripts\n    > * vim-doc     vim帮助文件，不过是英文版本的\n\n2. 中文帮助文档\n    1. 下载[最新版本](http://sourceforge.net/projects/vimcdoc/files/vimcdoc/)的vim中文帮助文档\n    2. 解压doc文件夹到~/.vim目录下\n\n3. 配置~/.vimrc文件\n\n    配置个性化的[.vimrc](.vimrc)（不懂的命令可以用`:help command`查看中文帮助文档）\n\n\n## 实用插件\nvim的插件很多，而且功能很强大，非常强大。官网的插件地址在[这里](http://www.vim.org/scripts/script_search_results.php?order_by=creation_date&direction=descending)，不过它的很多[插件][vim_script]都转移到github上。\n\n* ctags  \nctags可以建立源码树的标签索引（标签就是一个标识符被定义的地方，如函数定义），使程序员在编程时能迅速定位函数、变量、宏定义等位置去查看原形。\n    1. 安装exuberant-ctags工具\n\n        ```sh\n        sudo apt-get install exuberant-ctags\n        ```\n    2. 创建C++代码库索引\n        1. 下载[libstdc++](http://www.vim.org/scripts/download_script.php?src_id=9178)头文件,包含c++中STL，streams等。\n        2. 解压到~/.vim/tags目录后执行ctags命令\n\n            ```sh\n            ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_src\n            mv tags ~/.vim/tags/cpptag\n            ```\n        3. 在.vimrc中设置\n\n            ```vim\n            set tags+=~/.vim/tags/cpptag\n            ```\n    3. 创建gcc代码库索引\n        1. ubuntu中安装完build-essential后，会在/usr/include/c++目录下有C/C++的头文件。\n\n            ```sh\n            sudo apt-get install build-essential\n            ```\n        2. 拷贝/usr/include/c++/4.8里的文件到~/.vim/tags/gcc文件夹里后执行ctags命令\n\n            ```sh\n            cp -R /usr/include/c++/4.8 ~/.vim/tags/gcc\n            ctags -R --c++-kinds=+p --fields=+iaS --extra=+q gcc\n            mv tags ~/.vim/tags/gcctag\n            ```\n        3. 在.vimrc中设置\n\n            ```vim\n            set tags+=~/.vim/tags/gcctag\n            ```\n\n* taglist  \n在屏幕右侧出现的就是taglist窗口，从中可以看到文件中定义的所有tag：宏、定义、变量、函数等；通过单击某个tag，可以跳到该tag定义的位置；也可以把某一类的tag折叠起来，方便查看。\n    1. 安装taglist\n\n        ```sh\n        vim-addon-manager install taglist\n        ```\n    2. 在.vimrc中配置\n\n        ```vim\n        \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 标签列表的设置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 启动vim后，自动打开taglist窗口\n\t\tlet Tlist_Auto_Open=1  \n\t\t\" 高亮显示当前标签列表中的标签\n\t\tlet Tlist_Auto_Highlight_Tag=1\n\t\t\" 添加新文件后，标签列表将自动更新\n\t\tlet Tlist_Auto_Update=1\n\t\t\" 显示标签域--类\n\t\tlet Tlist_Display_Tag_Scope=1\n\t\t\" 如果taglist窗口是最后一个窗口，则退出vim\n\t\tlet Tlist_Exit_OnlyWindow=1\n\t\t\" Taglist窗口里可折叠\n\t\tlet Tlist_Enable_Fold_Column=1\n\t\t\" 只显示当前文件的标签，折叠其他文件的标签\n\t\tlet Tlist_File_Fold_Auto_Close=1\n\t\t\" 多个文件间切换时，标签列表也更新为当前文件\n\t\tlet Tlist_Show_One_File=1\n\t\t\" 标签列表显示在Buffer区的右边\n\t\t\"let Tlist_Use_Right_Window=1\n\t\t\" 单击标签列表中的标签将定位到标签定义处\n\t\tlet Tlist_Use_SingleClick=1\n        ```\n    3. 自定义快捷键说明\n        * `<F10>`     打开/关闭标签列表\n\n* winmanager  \nWinManager用于管理文件浏览器和缓冲区（buffer）。2.0以上版本的WinManager还可以管理其他IDE类型插件，不过要用户在插件中增加一些辅助变量和hook来支持WinManager（帮助文档有相关说明）。\n    1. 安装winmanager\n\n        ```sh\n        vim-addon-manager install winmanager\n        ```\n    2. 在.vimrc中配置\n\n        ```vim\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 文件管理器\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 进入vim后自动打开winmanager\n\t\tlet g:AutoOpenWinManager =1\n\t\t\" 设置要管理的插件\n\t\tlet g:winManagerWindowLayout='FileExplorer|TagList'\n\t\t\" 如果所有编辑文件都关闭了，退出vim\n\t\t\"let g:persistentBehaviour=0\n\t\t\" <F9>打开/关闭文件管理器\n\t\tnnoremap <silent> <F9> :WMToggle<CR>\n        ```\n    3. 自定义快捷键说明\n        * `<F9>`     打开/关闭文件浏览器\n\n* minibufexplorer  \nMiniBufferExplorer用于浏览和管理buffer，如果只打开一个文件，是不会显示在屏幕上的，而打开多个文件之后，会自动出现在屏幕上。vim也有自带的buffer管理工具，不过只有:ls, :bnext, :bdelete 等的命令, 既不好用, 又不直观.\n    1. 安装minibufexplorer\n\n        ```sh\n        vim-addon-manager install minibufexplorer\n        ```\n    2. 在.vimrc中配置\n\n        ```vim\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 缓冲区管理\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 用<C-h/j/k/l>切换到上下左右窗口\n\t\tlet g:miniBufExplMapWindowNavVim = 1\n\t\t\" 用Ctrl+箭头切换到上下左右窗口\n\t\tlet g:miniBufExplMapWindowNavArrows = 1\n\t\t\"let g:bufExplorerMaxHeight=30\n\t\t\" 只有一个buffer，MiniBufExplorer这栏也会出现\n\t\t\"let g:miniBufExplorerMoreThanOne=0\n\t\t\" normal模式下<Tab>移动到下一个buffer，<C-Tab>上一个\n\t\tnnoremap <silent> <Tab> :bn<CR>\n\t\tnnoremap <silent> <C-Tab> :bp<CR>\n\t\t\" 不要在不可编辑内容的窗口（如TagList）中打开选中的buffer\n\t\tlet g:miniBufExplModSelTarget = 1\"\n        ```\n    3. 自定义快捷键说明\n        * `<Tab>`     移动到下一个buffer\n        * `<C-Tab>`   移动到上一个buffer\n\n* quickfix  \n通过quickfix命令集，你可在 Vim 内编译程序并直接跳转到出错位置进行修正。你可以接着重新编译并做修正，直到不再出错为止。因为quickfix已经在vim里集成了，只要配置就好了。\n    1. 在.vimrc中配置\n\n        ```vim\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" QuickFix设置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 按下<F2>，执行make\n\t\tnnoremap <F2> :TlistToggle<CR> :make<CR><CR><CR> :copen<CR> :TlistToggle<CR>\n\t\t\" 按下<F12>，执行make clean\n\t\tnnoremap <F12> :make clean<CR><CR><CR> :cclose<CR>\n\t\t\" 按下<F3>，光标移到上一个错误所在的行\n\t\tnnoremap <F3> :cp<CR>\n\t\t\" 按下<F4>，光标移到下一个错误所在的行\n\t\tnnoremap <F4> :cn<CR>\n        ```\n    2. 自定义快捷键说明\n        * `<F2>`     make当前程序\n        * `<F10>`    make clean当前程序\n        * `<F3>`     光标移动到上一个错误所在行\n        * `<F4>`     光标移动到下一个错误所在行\n\n\n## 参考文献\n1. [有趣的vim游戏][vim_adventures]\n2. [Vim学习指南][vim_progressively]\n3. [vim plugin][vim_plugin]\n3. [Vim Script][vim_script]\n\n\n[vim_adventures]:\thttp://vim-adventures.com/\n[vim_progressively]:\thttp://www.oschina.net/translate/learn-vim-progressively\n[vim_plugin]:\t\thttp://my.oschina.net/swuly302/blog/156784\n[vim_script]:\t\thttp://vim-scripts.org/vim/scripts.html\n","source":"_posts/2015-08-31-VIM配置之入门篇.md","raw":"---\nlayout: post\ntitle:  Vim配置之入门篇\ncategories:\n- TECHNOLOGY\ntags:\n- Vim\n- Ubuntu\npermalink:  Explore-primary-vim\ncomments:   true\n---\n正所谓“工欲善其事，必先利其器”，而作为一个专业的码农，怎么能不好好对待自己编程的利器--VIM编辑器呢！可能读者会说编程的利器不应该是各种语言的集成工具么？像编写C/C++程序的VS，Codeblock（跨平台）软件，像编写Java程序的Eclipse（现在已经有支持C/C++/Python的插件），像编写Python程序的PyCharm等。这些人性化的开发集成环境功能强大，使用方便。不过成也在此，败也在此。本文将详细介绍Vim编辑器以及其基本入门级配置。\n<!-- more -->\n\n## 简介\n正所谓“工欲善其事，必先利其器”，而作为一个专业的码农，怎么能不好好对待自己的编程利器--VIM编辑器呢！可能读者会说编程的利器不应该是各种语言的集成工具么？像编写C/C++程序的VS，Codeblock（跨平台）软件，像编写Java程序的Eclipse（现在已经有支持C/C++/Python的插件），像编写Python程序的PyCharm等。这些人性化的开发集成环境功能强大，使用方便。不过我觉得成也在此，败也在此。\n\n1. 功能冗余  \n现在编程的集成环境工具非常强大，但是很多功能我们都用不到，反而每次开启都花费很长时间。所以集成环境并不适合专业的码农。我们经常说适合自己的才是最好的，编程利器更是如此，毕竟它每天不离手。\n2. 定制化太低   \n基本上每个集成开发工具都没有留太多的定制空间给用户，而用户只能习惯软件供应商提供的大众化用法。对于熟悉多种语言的用户而言，它得掌握多种开发集成环境，还不如用Vim解决所有。\n3. 鼠标和键盘的混合使用  \n其实这一点仁者见仁，智者见智吧。个人觉得高效编程还是需要手不离键盘的，要熟练掌握一些基本的快捷键的使用。\n\n\n基本的Vim说白了就是一个文本编辑器，不过它的强大之处在于它庞大的插件。这些插件可以让Vim能够干很多牛x的事，这跟google浏览器有点像。像代码补全，错误跳转，高亮显示等等，Vim都有相应的插件来处理，用户可以自行了解，自由组合。所以Vim的入门门坎还是蛮高的，主要是开始学得命令比较多，这里有推荐个[玩游戏记命令的网址][vim_adventures]以及[Vim学习指南][vim_progressively]。此外打造一个适合自己的vim环境将会大大节约时间，是磨刀不误砍柴工的。下面就来看看基础入门级的[Vim插件配置][vim_plugin]。\n\n## 基本配置\n1. 安装vim,scripts,doc\n\n    ```sh\n    sudo apt-get install vim vim-scripts vim-doc\n    ```\n\n    > **Tips:**\n    > * vim         vim软件，安装目录是/usr/share/vim\n    > * vim-scripts vim的基本插件，包括语法高亮等，安装目录是/usr/share/vim-scripts\n    > * vim-doc     vim帮助文件，不过是英文版本的\n\n2. 中文帮助文档\n    1. 下载[最新版本](http://sourceforge.net/projects/vimcdoc/files/vimcdoc/)的vim中文帮助文档\n    2. 解压doc文件夹到~/.vim目录下\n\n3. 配置~/.vimrc文件\n\n    配置个性化的[.vimrc](.vimrc)（不懂的命令可以用`:help command`查看中文帮助文档）\n\n\n## 实用插件\nvim的插件很多，而且功能很强大，非常强大。官网的插件地址在[这里](http://www.vim.org/scripts/script_search_results.php?order_by=creation_date&direction=descending)，不过它的很多[插件][vim_script]都转移到github上。\n\n* ctags  \nctags可以建立源码树的标签索引（标签就是一个标识符被定义的地方，如函数定义），使程序员在编程时能迅速定位函数、变量、宏定义等位置去查看原形。\n    1. 安装exuberant-ctags工具\n\n        ```sh\n        sudo apt-get install exuberant-ctags\n        ```\n    2. 创建C++代码库索引\n        1. 下载[libstdc++](http://www.vim.org/scripts/download_script.php?src_id=9178)头文件,包含c++中STL，streams等。\n        2. 解压到~/.vim/tags目录后执行ctags命令\n\n            ```sh\n            ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_src\n            mv tags ~/.vim/tags/cpptag\n            ```\n        3. 在.vimrc中设置\n\n            ```vim\n            set tags+=~/.vim/tags/cpptag\n            ```\n    3. 创建gcc代码库索引\n        1. ubuntu中安装完build-essential后，会在/usr/include/c++目录下有C/C++的头文件。\n\n            ```sh\n            sudo apt-get install build-essential\n            ```\n        2. 拷贝/usr/include/c++/4.8里的文件到~/.vim/tags/gcc文件夹里后执行ctags命令\n\n            ```sh\n            cp -R /usr/include/c++/4.8 ~/.vim/tags/gcc\n            ctags -R --c++-kinds=+p --fields=+iaS --extra=+q gcc\n            mv tags ~/.vim/tags/gcctag\n            ```\n        3. 在.vimrc中设置\n\n            ```vim\n            set tags+=~/.vim/tags/gcctag\n            ```\n\n* taglist  \n在屏幕右侧出现的就是taglist窗口，从中可以看到文件中定义的所有tag：宏、定义、变量、函数等；通过单击某个tag，可以跳到该tag定义的位置；也可以把某一类的tag折叠起来，方便查看。\n    1. 安装taglist\n\n        ```sh\n        vim-addon-manager install taglist\n        ```\n    2. 在.vimrc中配置\n\n        ```vim\n        \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 标签列表的设置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 启动vim后，自动打开taglist窗口\n\t\tlet Tlist_Auto_Open=1  \n\t\t\" 高亮显示当前标签列表中的标签\n\t\tlet Tlist_Auto_Highlight_Tag=1\n\t\t\" 添加新文件后，标签列表将自动更新\n\t\tlet Tlist_Auto_Update=1\n\t\t\" 显示标签域--类\n\t\tlet Tlist_Display_Tag_Scope=1\n\t\t\" 如果taglist窗口是最后一个窗口，则退出vim\n\t\tlet Tlist_Exit_OnlyWindow=1\n\t\t\" Taglist窗口里可折叠\n\t\tlet Tlist_Enable_Fold_Column=1\n\t\t\" 只显示当前文件的标签，折叠其他文件的标签\n\t\tlet Tlist_File_Fold_Auto_Close=1\n\t\t\" 多个文件间切换时，标签列表也更新为当前文件\n\t\tlet Tlist_Show_One_File=1\n\t\t\" 标签列表显示在Buffer区的右边\n\t\t\"let Tlist_Use_Right_Window=1\n\t\t\" 单击标签列表中的标签将定位到标签定义处\n\t\tlet Tlist_Use_SingleClick=1\n        ```\n    3. 自定义快捷键说明\n        * `<F10>`     打开/关闭标签列表\n\n* winmanager  \nWinManager用于管理文件浏览器和缓冲区（buffer）。2.0以上版本的WinManager还可以管理其他IDE类型插件，不过要用户在插件中增加一些辅助变量和hook来支持WinManager（帮助文档有相关说明）。\n    1. 安装winmanager\n\n        ```sh\n        vim-addon-manager install winmanager\n        ```\n    2. 在.vimrc中配置\n\n        ```vim\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 文件管理器\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 进入vim后自动打开winmanager\n\t\tlet g:AutoOpenWinManager =1\n\t\t\" 设置要管理的插件\n\t\tlet g:winManagerWindowLayout='FileExplorer|TagList'\n\t\t\" 如果所有编辑文件都关闭了，退出vim\n\t\t\"let g:persistentBehaviour=0\n\t\t\" <F9>打开/关闭文件管理器\n\t\tnnoremap <silent> <F9> :WMToggle<CR>\n        ```\n    3. 自定义快捷键说明\n        * `<F9>`     打开/关闭文件浏览器\n\n* minibufexplorer  \nMiniBufferExplorer用于浏览和管理buffer，如果只打开一个文件，是不会显示在屏幕上的，而打开多个文件之后，会自动出现在屏幕上。vim也有自带的buffer管理工具，不过只有:ls, :bnext, :bdelete 等的命令, 既不好用, 又不直观.\n    1. 安装minibufexplorer\n\n        ```sh\n        vim-addon-manager install minibufexplorer\n        ```\n    2. 在.vimrc中配置\n\n        ```vim\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 缓冲区管理\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 用<C-h/j/k/l>切换到上下左右窗口\n\t\tlet g:miniBufExplMapWindowNavVim = 1\n\t\t\" 用Ctrl+箭头切换到上下左右窗口\n\t\tlet g:miniBufExplMapWindowNavArrows = 1\n\t\t\"let g:bufExplorerMaxHeight=30\n\t\t\" 只有一个buffer，MiniBufExplorer这栏也会出现\n\t\t\"let g:miniBufExplorerMoreThanOne=0\n\t\t\" normal模式下<Tab>移动到下一个buffer，<C-Tab>上一个\n\t\tnnoremap <silent> <Tab> :bn<CR>\n\t\tnnoremap <silent> <C-Tab> :bp<CR>\n\t\t\" 不要在不可编辑内容的窗口（如TagList）中打开选中的buffer\n\t\tlet g:miniBufExplModSelTarget = 1\"\n        ```\n    3. 自定义快捷键说明\n        * `<Tab>`     移动到下一个buffer\n        * `<C-Tab>`   移动到上一个buffer\n\n* quickfix  \n通过quickfix命令集，你可在 Vim 内编译程序并直接跳转到出错位置进行修正。你可以接着重新编译并做修正，直到不再出错为止。因为quickfix已经在vim里集成了，只要配置就好了。\n    1. 在.vimrc中配置\n\n        ```vim\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" QuickFix设置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 按下<F2>，执行make\n\t\tnnoremap <F2> :TlistToggle<CR> :make<CR><CR><CR> :copen<CR> :TlistToggle<CR>\n\t\t\" 按下<F12>，执行make clean\n\t\tnnoremap <F12> :make clean<CR><CR><CR> :cclose<CR>\n\t\t\" 按下<F3>，光标移到上一个错误所在的行\n\t\tnnoremap <F3> :cp<CR>\n\t\t\" 按下<F4>，光标移到下一个错误所在的行\n\t\tnnoremap <F4> :cn<CR>\n        ```\n    2. 自定义快捷键说明\n        * `<F2>`     make当前程序\n        * `<F10>`    make clean当前程序\n        * `<F3>`     光标移动到上一个错误所在行\n        * `<F4>`     光标移动到下一个错误所在行\n\n\n## 参考文献\n1. [有趣的vim游戏][vim_adventures]\n2. [Vim学习指南][vim_progressively]\n3. [vim plugin][vim_plugin]\n3. [Vim Script][vim_script]\n\n\n[vim_adventures]:\thttp://vim-adventures.com/\n[vim_progressively]:\thttp://www.oschina.net/translate/learn-vim-progressively\n[vim_plugin]:\t\thttp://my.oschina.net/swuly302/blog/156784\n[vim_script]:\t\thttp://vim-scripts.org/vim/scripts.html\n","slug":"Explore-primary-vim","published":1,"date":"2015-08-30T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1i001fl73ylgtike89","content":"<p>正所谓“工欲善其事，必先利其器”，而作为一个专业的码农，怎么能不好好对待自己编程的利器–VIM编辑器呢！可能读者会说编程的利器不应该是各种语言的集成工具么？像编写C/C++程序的VS，Codeblock（跨平台）软件，像编写Java程序的Eclipse（现在已经有支持C/C++/Python的插件），像编写Python程序的PyCharm等。这些人性化的开发集成环境功能强大，使用方便。不过成也在此，败也在此。本文将详细介绍Vim编辑器以及其基本入门级配置。 <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p>正所谓“工欲善其事，必先利其器”，而作为一个专业的码农，怎么能不好好对待自己的编程利器–VIM编辑器呢！可能读者会说编程的利器不应该是各种语言的集成工具么？像编写C/C++程序的VS，Codeblock（跨平台）软件，像编写Java程序的Eclipse（现在已经有支持C/C++/Python的插件），像编写Python程序的PyCharm等。这些人性化的开发集成环境功能强大，使用方便。不过我觉得成也在此，败也在此。</p>\n<ol style=\"list-style-type: decimal\">\n<li>功能冗余<br>\n现在编程的集成环境工具非常强大，但是很多功能我们都用不到，反而每次开启都花费很长时间。所以集成环境并不适合专业的码农。我们经常说适合自己的才是最好的，编程利器更是如此，毕竟它每天不离手。</li>\n<li>定制化太低<br>\n基本上每个集成开发工具都没有留太多的定制空间给用户，而用户只能习惯软件供应商提供的大众化用法。对于熟悉多种语言的用户而言，它得掌握多种开发集成环境，还不如用Vim解决所有。</li>\n<li>鼠标和键盘的混合使用<br>\n其实这一点仁者见仁，智者见智吧。个人觉得高效编程还是需要手不离键盘的，要熟练掌握一些基本的快捷键的使用。</li>\n</ol>\n<p>基本的Vim说白了就是一个文本编辑器，不过它的强大之处在于它庞大的插件。这些插件可以让Vim能够干很多牛x的事，这跟google浏览器有点像。像代码补全，错误跳转，高亮显示等等，Vim都有相应的插件来处理，用户可以自行了解，自由组合。所以Vim的入门门坎还是蛮高的，主要是开始学得命令比较多，这里有推荐个<a href=\"http://vim-adventures.com/\" target=\"_blank\" rel=\"external\">玩游戏记命令的网址</a>以及<a href=\"http://www.oschina.net/translate/learn-vim-progressively\" target=\"_blank\" rel=\"external\">Vim学习指南</a>。此外打造一个适合自己的vim环境将会大大节约时间，是磨刀不误砍柴工的。下面就来看看基础入门级的<a href=\"http://my.oschina.net/swuly302/blog/156784\" target=\"_blank\" rel=\"external\">Vim插件配置</a>。</p>\n<h2 id=\"基本配置\">基本配置</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>安装vim,scripts,doc</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install vim vim-scripts vim-doc</div></pre></td></tr></table></figure>\n<blockquote>\n<strong>Tips:</strong>\n<ul>\n<li>vim vim软件，安装目录是/usr/share/vim</li>\n<li>vim-scripts vim的基本插件，包括语法高亮等，安装目录是/usr/share/vim-scripts</li>\n<li>vim-doc vim帮助文件，不过是英文版本的</li>\n</ul>\n</blockquote></li>\n<li>中文帮助文档\n<ol style=\"list-style-type: decimal\">\n<li>下载<a href=\"http://sourceforge.net/projects/vimcdoc/files/vimcdoc/\" target=\"_blank\" rel=\"external\">最新版本</a>的vim中文帮助文档</li>\n<li>解压doc文件夹到~/.vim目录下</li>\n</ol></li>\n<li><p>配置~/.vimrc文件</p>\n<p>配置个性化的<a href=\".vimrc\" class=\"uri\">.vimrc</a>（不懂的命令可以用<code>:help command</code>查看中文帮助文档）</p></li>\n</ol>\n<h2 id=\"实用插件\">实用插件</h2>\n<p>vim的插件很多，而且功能很强大，非常强大。官网的插件地址在<a href=\"http://www.vim.org/scripts/script_search_results.php?order_by=creation_date&amp;direction=descending\" target=\"_blank\" rel=\"external\">这里</a>，不过它的很多<a href=\"http://vim-scripts.org/vim/scripts.html\" target=\"_blank\" rel=\"external\">插件</a>都转移到github上。</p>\n<ul>\n<li>ctags<br>\nctags可以建立源码树的标签索引（标签就是一个标识符被定义的地方，如函数定义），使程序员在编程时能迅速定位函数、变量、宏定义等位置去查看原形。\n<ol style=\"list-style-type: decimal\">\n<li><p>安装exuberant-ctags工具</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install exuberant-ctags</div></pre></td></tr></table></figure></li>\n<li>创建C++代码库索引\n<ol style=\"list-style-type: decimal\">\n<li>下载<a href=\"http://www.vim.org/scripts/download_script.php?src_id=9178\" target=\"_blank\" rel=\"external\">libstdc++</a>头文件,包含c++中STL，streams等。</li>\n<li><p>解压到~/.vim/tags目录后执行ctags命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_src</div><div class=\"line\">mv tags ~/.vim/tags/cpptag</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中设置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">tags</span>+=~/.<span class=\"keyword\">vim</span>/<span class=\"keyword\">tags</span>/cpptag</div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>创建gcc代码库索引\n<ol style=\"list-style-type: decimal\">\n<li><p>ubuntu中安装完build-essential后，会在/usr/include/c++目录下有C/C++的头文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install build-essential</div></pre></td></tr></table></figure></li>\n<li><p>拷贝/usr/include/c++/4.8里的文件到~/.vim/tags/gcc文件夹里后执行ctags命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cp -R /usr/include/c++/4.8 ~/.vim/tags/gcc</div><div class=\"line\">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q gcc</div><div class=\"line\">mv tags ~/.vim/tags/gcctag</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中设置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">tags</span>+=~/.<span class=\"keyword\">vim</span>/<span class=\"keyword\">tags</span>/gcctag</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ol></li>\n<li>taglist<br>\n在屏幕右侧出现的就是taglist窗口，从中可以看到文件中定义的所有tag：宏、定义、变量、函数等；通过单击某个tag，可以跳到该tag定义的位置；也可以把某一类的tag折叠起来，方便查看。\n<ol style=\"list-style-type: decimal\">\n<li><p>安装taglist</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim-addon-manager install taglist</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">      <span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 标签列表的设置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 启动vim后，自动打开taglist窗口</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Auto_Open=<span class=\"number\">1</span>  </div><div class=\"line\"><span class=\"comment\">\" 高亮显示当前标签列表中的标签</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Auto_Highlight_Tag=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 添加新文件后，标签列表将自动更新</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Auto_Update=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 显示标签域--类</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Display_Tag_Scope=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 如果taglist窗口是最后一个窗口，则退出vim</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Exit_OnlyWindow=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" Taglist窗口里可折叠</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Enable_Fold_Column=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 只显示当前文件的标签，折叠其他文件的标签</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_File_Fold_Auto_Close=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 多个文件间切换时，标签列表也更新为当前文件</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Show_One_File=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 标签列表显示在Buffer区的右边</span></div><div class=\"line\"><span class=\"comment\">\"let Tlist_Use_Right_Window=1</span></div><div class=\"line\"><span class=\"comment\">\" 单击标签列表中的标签将定位到标签定义处</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Use_SingleClick=<span class=\"number\">1</span></div></pre></td></tr></table></figure></li>\n<li>自定义快捷键说明\n<ul>\n<li><code>&lt;F10&gt;</code> 打开/关闭标签列表</li>\n</ul></li>\n</ol></li>\n<li>winmanager<br>\nWinManager用于管理文件浏览器和缓冲区（buffer）。2.0以上版本的WinManager还可以管理其他IDE类型插件，不过要用户在插件中增加一些辅助变量和hook来支持WinManager（帮助文档有相关说明）。\n<ol style=\"list-style-type: decimal\">\n<li><p>安装winmanager</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim-addon-manager install winmanager</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 文件管理器</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 进入vim后自动打开winmanager</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:AutoOpenWinManager</span> =<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 设置要管理的插件</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:winManagerWindowLayout</span>=<span class=\"string\">'FileExplorer|TagList'</span></div><div class=\"line\"><span class=\"comment\">\" 如果所有编辑文件都关闭了，退出vim</span></div><div class=\"line\"><span class=\"comment\">\"let g:persistentBehaviour=0</span></div><div class=\"line\"><span class=\"comment\">\" &lt;F9&gt;打开/关闭文件管理器</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;silent&gt;</span> <span class=\"symbol\">&lt;F9&gt;</span> :WMToggle<span class=\"symbol\">&lt;CR&gt;</span></div></pre></td></tr></table></figure></li>\n<li>自定义快捷键说明\n<ul>\n<li><code>&lt;F9&gt;</code> 打开/关闭文件浏览器</li>\n</ul></li>\n</ol></li>\n<li>minibufexplorer<br>\nMiniBufferExplorer用于浏览和管理buffer，如果只打开一个文件，是不会显示在屏幕上的，而打开多个文件之后，会自动出现在屏幕上。vim也有自带的buffer管理工具，不过只有:ls, :bnext, :bdelete 等的命令, 既不好用, 又不直观.\n<ol style=\"list-style-type: decimal\">\n<li><p>安装minibufexplorer</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim-addon-manager install minibufexplorer</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 缓冲区管理</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 用&lt;C-h/j/k/l&gt;切换到上下左右窗口</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:miniBufExplMapWindowNavVim</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 用Ctrl+箭头切换到上下左右窗口</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:miniBufExplMapWindowNavArrows</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\"let g:bufExplorerMaxHeight=30</span></div><div class=\"line\"><span class=\"comment\">\" 只有一个buffer，MiniBufExplorer这栏也会出现</span></div><div class=\"line\"><span class=\"comment\">\"let g:miniBufExplorerMoreThanOne=0</span></div><div class=\"line\"><span class=\"comment\">\" normal模式下&lt;Tab&gt;移动到下一个buffer，&lt;C-Tab&gt;上一个</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;silent&gt;</span> <span class=\"symbol\">&lt;Tab&gt;</span> :<span class=\"keyword\">bn</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;silent&gt;</span> <span class=\"symbol\">&lt;C-Tab&gt;</span> :<span class=\"keyword\">bp</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\" 不要在不可编辑内容的窗口（如TagList）中打开选中的buffer</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:miniBufExplModSelTarget</span> = <span class=\"number\">1</span><span class=\"comment\">\"</span></div></pre></td></tr></table></figure></li>\n<li>自定义快捷键说明\n<ul>\n<li><code>&lt;Tab&gt;</code> 移动到下一个buffer</li>\n<li><code>&lt;C-Tab&gt;</code> 移动到上一个buffer</li>\n</ul></li>\n</ol></li>\n<li>quickfix<br>\n通过quickfix命令集，你可在 Vim 内编译程序并直接跳转到出错位置进行修正。你可以接着重新编译并做修正，直到不再出错为止。因为quickfix已经在vim里集成了，只要配置就好了。\n<ol style=\"list-style-type: decimal\">\n<li><p>在.vimrc中配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" QuickFix设置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 按下&lt;F2&gt;，执行make</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;F2&gt;</span> :TlistToggle<span class=\"symbol\">&lt;CR&gt;</span> :<span class=\"keyword\">make</span><span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span> :<span class=\"keyword\">copen</span><span class=\"symbol\">&lt;CR&gt;</span> :TlistToggle<span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\" 按下&lt;F12&gt;，执行make clean</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;F12&gt;</span> :<span class=\"keyword\">make</span> clean<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span> :<span class=\"keyword\">cclose</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\" 按下&lt;F3&gt;，光标移到上一个错误所在的行</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;F3&gt;</span> :<span class=\"keyword\">cp</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\" 按下&lt;F4&gt;，光标移到下一个错误所在的行</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;F4&gt;</span> :<span class=\"keyword\">cn</span><span class=\"symbol\">&lt;CR&gt;</span></div></pre></td></tr></table></figure></li>\n<li>自定义快捷键说明\n<ul>\n<li><code>&lt;F2&gt;</code> make当前程序</li>\n<li><code>&lt;F10&gt;</code> make clean当前程序</li>\n<li><code>&lt;F3&gt;</code> 光标移动到上一个错误所在行</li>\n<li><code>&lt;F4&gt;</code> 光标移动到下一个错误所在行</li>\n</ul></li>\n</ol></li>\n</ul>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://vim-adventures.com/\" target=\"_blank\" rel=\"external\">有趣的vim游戏</a></li>\n<li><a href=\"http://www.oschina.net/translate/learn-vim-progressively\" target=\"_blank\" rel=\"external\">Vim学习指南</a></li>\n<li><a href=\"http://my.oschina.net/swuly302/blog/156784\" target=\"_blank\" rel=\"external\">vim plugin</a></li>\n<li><a href=\"http://vim-scripts.org/vim/scripts.html\" target=\"_blank\" rel=\"external\">Vim Script</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>正所谓“工欲善其事，必先利其器”，而作为一个专业的码农，怎么能不好好对待自己编程的利器–VIM编辑器呢！可能读者会说编程的利器不应该是各种语言的集成工具么？像编写C/C++程序的VS，Codeblock（跨平台）软件，像编写Java程序的Eclipse（现在已经有支持C/C++/Python的插件），像编写Python程序的PyCharm等。这些人性化的开发集成环境功能强大，使用方便。不过成也在此，败也在此。本文将详细介绍Vim编辑器以及其基本入门级配置。","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p>正所谓“工欲善其事，必先利其器”，而作为一个专业的码农，怎么能不好好对待自己的编程利器–VIM编辑器呢！可能读者会说编程的利器不应该是各种语言的集成工具么？像编写C/C++程序的VS，Codeblock（跨平台）软件，像编写Java程序的Eclipse（现在已经有支持C/C++/Python的插件），像编写Python程序的PyCharm等。这些人性化的开发集成环境功能强大，使用方便。不过我觉得成也在此，败也在此。</p>\n<ol style=\"list-style-type: decimal\">\n<li>功能冗余<br>\n现在编程的集成环境工具非常强大，但是很多功能我们都用不到，反而每次开启都花费很长时间。所以集成环境并不适合专业的码农。我们经常说适合自己的才是最好的，编程利器更是如此，毕竟它每天不离手。</li>\n<li>定制化太低<br>\n基本上每个集成开发工具都没有留太多的定制空间给用户，而用户只能习惯软件供应商提供的大众化用法。对于熟悉多种语言的用户而言，它得掌握多种开发集成环境，还不如用Vim解决所有。</li>\n<li>鼠标和键盘的混合使用<br>\n其实这一点仁者见仁，智者见智吧。个人觉得高效编程还是需要手不离键盘的，要熟练掌握一些基本的快捷键的使用。</li>\n</ol>\n<p>基本的Vim说白了就是一个文本编辑器，不过它的强大之处在于它庞大的插件。这些插件可以让Vim能够干很多牛x的事，这跟google浏览器有点像。像代码补全，错误跳转，高亮显示等等，Vim都有相应的插件来处理，用户可以自行了解，自由组合。所以Vim的入门门坎还是蛮高的，主要是开始学得命令比较多，这里有推荐个<a href=\"http://vim-adventures.com/\" target=\"_blank\" rel=\"external\">玩游戏记命令的网址</a>以及<a href=\"http://www.oschina.net/translate/learn-vim-progressively\" target=\"_blank\" rel=\"external\">Vim学习指南</a>。此外打造一个适合自己的vim环境将会大大节约时间，是磨刀不误砍柴工的。下面就来看看基础入门级的<a href=\"http://my.oschina.net/swuly302/blog/156784\" target=\"_blank\" rel=\"external\">Vim插件配置</a>。</p>\n<h2 id=\"基本配置\">基本配置</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>安装vim,scripts,doc</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install vim vim-scripts vim-doc</div></pre></td></tr></table></figure>\n<blockquote>\n<strong>Tips:</strong>\n<ul>\n<li>vim vim软件，安装目录是/usr/share/vim</li>\n<li>vim-scripts vim的基本插件，包括语法高亮等，安装目录是/usr/share/vim-scripts</li>\n<li>vim-doc vim帮助文件，不过是英文版本的</li>\n</ul>\n</blockquote></li>\n<li>中文帮助文档\n<ol style=\"list-style-type: decimal\">\n<li>下载<a href=\"http://sourceforge.net/projects/vimcdoc/files/vimcdoc/\" target=\"_blank\" rel=\"external\">最新版本</a>的vim中文帮助文档</li>\n<li>解压doc文件夹到~/.vim目录下</li>\n</ol></li>\n<li><p>配置~/.vimrc文件</p>\n<p>配置个性化的<a href=\".vimrc\" class=\"uri\">.vimrc</a>（不懂的命令可以用<code>:help command</code>查看中文帮助文档）</p></li>\n</ol>\n<h2 id=\"实用插件\">实用插件</h2>\n<p>vim的插件很多，而且功能很强大，非常强大。官网的插件地址在<a href=\"http://www.vim.org/scripts/script_search_results.php?order_by=creation_date&amp;direction=descending\" target=\"_blank\" rel=\"external\">这里</a>，不过它的很多<a href=\"http://vim-scripts.org/vim/scripts.html\" target=\"_blank\" rel=\"external\">插件</a>都转移到github上。</p>\n<ul>\n<li>ctags<br>\nctags可以建立源码树的标签索引（标签就是一个标识符被定义的地方，如函数定义），使程序员在编程时能迅速定位函数、变量、宏定义等位置去查看原形。\n<ol style=\"list-style-type: decimal\">\n<li><p>安装exuberant-ctags工具</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install exuberant-ctags</div></pre></td></tr></table></figure></li>\n<li>创建C++代码库索引\n<ol style=\"list-style-type: decimal\">\n<li>下载<a href=\"http://www.vim.org/scripts/download_script.php?src_id=9178\" target=\"_blank\" rel=\"external\">libstdc++</a>头文件,包含c++中STL，streams等。</li>\n<li><p>解压到~/.vim/tags目录后执行ctags命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_src</div><div class=\"line\">mv tags ~/.vim/tags/cpptag</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中设置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">tags</span>+=~/.<span class=\"keyword\">vim</span>/<span class=\"keyword\">tags</span>/cpptag</div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>创建gcc代码库索引\n<ol style=\"list-style-type: decimal\">\n<li><p>ubuntu中安装完build-essential后，会在/usr/include/c++目录下有C/C++的头文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install build-essential</div></pre></td></tr></table></figure></li>\n<li><p>拷贝/usr/include/c++/4.8里的文件到~/.vim/tags/gcc文件夹里后执行ctags命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cp -R /usr/include/c++/4.8 ~/.vim/tags/gcc</div><div class=\"line\">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q gcc</div><div class=\"line\">mv tags ~/.vim/tags/gcctag</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中设置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">tags</span>+=~/.<span class=\"keyword\">vim</span>/<span class=\"keyword\">tags</span>/gcctag</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ol></li>\n<li>taglist<br>\n在屏幕右侧出现的就是taglist窗口，从中可以看到文件中定义的所有tag：宏、定义、变量、函数等；通过单击某个tag，可以跳到该tag定义的位置；也可以把某一类的tag折叠起来，方便查看。\n<ol style=\"list-style-type: decimal\">\n<li><p>安装taglist</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim-addon-manager install taglist</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">      <span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 标签列表的设置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 启动vim后，自动打开taglist窗口</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Auto_Open=<span class=\"number\">1</span>  </div><div class=\"line\"><span class=\"comment\">\" 高亮显示当前标签列表中的标签</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Auto_Highlight_Tag=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 添加新文件后，标签列表将自动更新</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Auto_Update=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 显示标签域--类</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Display_Tag_Scope=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 如果taglist窗口是最后一个窗口，则退出vim</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Exit_OnlyWindow=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" Taglist窗口里可折叠</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Enable_Fold_Column=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 只显示当前文件的标签，折叠其他文件的标签</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_File_Fold_Auto_Close=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 多个文件间切换时，标签列表也更新为当前文件</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Show_One_File=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 标签列表显示在Buffer区的右边</span></div><div class=\"line\"><span class=\"comment\">\"let Tlist_Use_Right_Window=1</span></div><div class=\"line\"><span class=\"comment\">\" 单击标签列表中的标签将定位到标签定义处</span></div><div class=\"line\"><span class=\"keyword\">let</span> Tlist_Use_SingleClick=<span class=\"number\">1</span></div></pre></td></tr></table></figure></li>\n<li>自定义快捷键说明\n<ul>\n<li><code>&lt;F10&gt;</code> 打开/关闭标签列表</li>\n</ul></li>\n</ol></li>\n<li>winmanager<br>\nWinManager用于管理文件浏览器和缓冲区（buffer）。2.0以上版本的WinManager还可以管理其他IDE类型插件，不过要用户在插件中增加一些辅助变量和hook来支持WinManager（帮助文档有相关说明）。\n<ol style=\"list-style-type: decimal\">\n<li><p>安装winmanager</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim-addon-manager install winmanager</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 文件管理器</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 进入vim后自动打开winmanager</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:AutoOpenWinManager</span> =<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 设置要管理的插件</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:winManagerWindowLayout</span>=<span class=\"string\">'FileExplorer|TagList'</span></div><div class=\"line\"><span class=\"comment\">\" 如果所有编辑文件都关闭了，退出vim</span></div><div class=\"line\"><span class=\"comment\">\"let g:persistentBehaviour=0</span></div><div class=\"line\"><span class=\"comment\">\" &lt;F9&gt;打开/关闭文件管理器</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;silent&gt;</span> <span class=\"symbol\">&lt;F9&gt;</span> :WMToggle<span class=\"symbol\">&lt;CR&gt;</span></div></pre></td></tr></table></figure></li>\n<li>自定义快捷键说明\n<ul>\n<li><code>&lt;F9&gt;</code> 打开/关闭文件浏览器</li>\n</ul></li>\n</ol></li>\n<li>minibufexplorer<br>\nMiniBufferExplorer用于浏览和管理buffer，如果只打开一个文件，是不会显示在屏幕上的，而打开多个文件之后，会自动出现在屏幕上。vim也有自带的buffer管理工具，不过只有:ls, :bnext, :bdelete 等的命令, 既不好用, 又不直观.\n<ol style=\"list-style-type: decimal\">\n<li><p>安装minibufexplorer</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim-addon-manager install minibufexplorer</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 缓冲区管理</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 用&lt;C-h/j/k/l&gt;切换到上下左右窗口</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:miniBufExplMapWindowNavVim</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 用Ctrl+箭头切换到上下左右窗口</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:miniBufExplMapWindowNavArrows</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\"let g:bufExplorerMaxHeight=30</span></div><div class=\"line\"><span class=\"comment\">\" 只有一个buffer，MiniBufExplorer这栏也会出现</span></div><div class=\"line\"><span class=\"comment\">\"let g:miniBufExplorerMoreThanOne=0</span></div><div class=\"line\"><span class=\"comment\">\" normal模式下&lt;Tab&gt;移动到下一个buffer，&lt;C-Tab&gt;上一个</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;silent&gt;</span> <span class=\"symbol\">&lt;Tab&gt;</span> :<span class=\"keyword\">bn</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;silent&gt;</span> <span class=\"symbol\">&lt;C-Tab&gt;</span> :<span class=\"keyword\">bp</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\" 不要在不可编辑内容的窗口（如TagList）中打开选中的buffer</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:miniBufExplModSelTarget</span> = <span class=\"number\">1</span><span class=\"comment\">\"</span></div></pre></td></tr></table></figure></li>\n<li>自定义快捷键说明\n<ul>\n<li><code>&lt;Tab&gt;</code> 移动到下一个buffer</li>\n<li><code>&lt;C-Tab&gt;</code> 移动到上一个buffer</li>\n</ul></li>\n</ol></li>\n<li>quickfix<br>\n通过quickfix命令集，你可在 Vim 内编译程序并直接跳转到出错位置进行修正。你可以接着重新编译并做修正，直到不再出错为止。因为quickfix已经在vim里集成了，只要配置就好了。\n<ol style=\"list-style-type: decimal\">\n<li><p>在.vimrc中配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" QuickFix设置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 按下&lt;F2&gt;，执行make</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;F2&gt;</span> :TlistToggle<span class=\"symbol\">&lt;CR&gt;</span> :<span class=\"keyword\">make</span><span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span> :<span class=\"keyword\">copen</span><span class=\"symbol\">&lt;CR&gt;</span> :TlistToggle<span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\" 按下&lt;F12&gt;，执行make clean</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;F12&gt;</span> :<span class=\"keyword\">make</span> clean<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span> :<span class=\"keyword\">cclose</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\" 按下&lt;F3&gt;，光标移到上一个错误所在的行</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;F3&gt;</span> :<span class=\"keyword\">cp</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\" 按下&lt;F4&gt;，光标移到下一个错误所在的行</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;F4&gt;</span> :<span class=\"keyword\">cn</span><span class=\"symbol\">&lt;CR&gt;</span></div></pre></td></tr></table></figure></li>\n<li>自定义快捷键说明\n<ul>\n<li><code>&lt;F2&gt;</code> make当前程序</li>\n<li><code>&lt;F10&gt;</code> make clean当前程序</li>\n<li><code>&lt;F3&gt;</code> 光标移动到上一个错误所在行</li>\n<li><code>&lt;F4&gt;</code> 光标移动到下一个错误所在行</li>\n</ul></li>\n</ol></li>\n</ul>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://vim-adventures.com/\" target=\"_blank\" rel=\"external\">有趣的vim游戏</a></li>\n<li><a href=\"http://www.oschina.net/translate/learn-vim-progressively\" target=\"_blank\" rel=\"external\">Vim学习指南</a></li>\n<li><a href=\"http://my.oschina.net/swuly302/blog/156784\" target=\"_blank\" rel=\"external\">vim plugin</a></li>\n<li><a href=\"http://vim-scripts.org/vim/scripts.html\" target=\"_blank\" rel=\"external\">Vim Script</a></li>\n</ol>"},{"layout":"post","title":"shell运行环境之环境变量","comments":1,"_content":"在windows系统中，我们经常需要设置环境变量，特别是安装玩JAVA JDk之后。而在linux里面也是需要对一些环境变量进行设置，比如PATH（执行文件的路径），http_proxy（http代理）等。本篇博文主要介绍三种环境变量--临时变量，用户变量和系统变量，并对其作用的先后做一点验证。\n<!-- more -->\n\n\n## 简介\n[环境变量][define]一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。它相当于给系统或用户应用程序设置的一些参数，具体起什么作用这和具体的环境变量相关。\n\n在windows系统里面，经常会遇到[设置环境变量][set_env]的问题，特别是安装完Java JDK之后。我们很少在黑漆漆的命令行窗口中执行命令`set path=%path%;D:\\jdk\\bin`,因为这样设置的变量是临时环境变量，它只能在这个命令窗口中被识别，知道`java`命令在D:\\jdk\\bin目录里，但当重新打开一个命令窗口（shell外壳）后那个窗口将无法识别。也就是说该path只对执行那个命令的shell有效。还有两种方法是设置用户变量或系统变量。二者的区别就在于系统变量对所有用户有效，而用户变量只对当前用户有效。经试验，win8系统中二者都无需重启就可以起作用。\n\n## Linux 环境变量设置  \n其实，linux里面对环境变量的设置和windows是共通的。它也有三种方式  \n\n* 临时变量  \n在shell外壳中执行命令`PATH=$PATH':/home/hjy/program/jdk/bin'`,同样java命令只能在当前窗口中识别，重开一个外壳`java`命令将无效。\n* 用户变量  \nLinux里面关于用户变量的设置是在两个文件中，一个是/etc/profile，另一个是~/.profile。profile是配置的意思，是某个用户唯一用来设置环境变量的地方。针对不同的用户习惯，使用不同的shell（像bash，sh，zsh等），针对不同的功能或不同的应用，加载不同的环境变量文件。这部分将在[shell的运行环境之环境配置文件]({{site.baseurl}}/2015/09/09/shell运行环境之环境配置文件.html)里详细说明。\n* 系统变量  \nLinux里面关于系统变量的设置是在/etc/environment文件中。该环境变量的设置不需要加`export`，直接赋值即可。\n\n## 验证作用域\n易知临时变量的作用域只在当前的外壳中，出了当前外壳将失效。而对于用户变量和系统变量，我们这里做两个小的试验，其中一个是[网上][environment]的，关键是讲解中又是疑问又是否定的，没搞明白作者啥意思，所以这里亲自验证一下。\n\n* 图形界面登录  \n经试验发现，自己的电脑环境和网上博主还是有些区别的。主要在[本地化语言环境设定上的区别][wiki_locale]，在安装好中文和英文的语言包后，系统的本地语言环境如图：\n![ori_locale]({{site.baseurl}}/assets/images/ori_locale.jpg)   \n但是由这篇博文--[locale的设定中LANG、LC_ALL、LANGUAGE环境变量的区别][locale]知道，`LC_ALL > LC_* >LANG`，所以在本机上配置LANG将会被LC\\_*所取代，而导致无论怎么设置都是英文环境。所以实际实验是设定LC\\_ALL变量。   \n\t* 试验步骤  \n\t\t1. 将`export LC_ALL=zh_CN.UTF-8`加入/etc/profile，退出系统重新登录，登录界面和locale变量如下图所示：  \n\t\t\t![eprofile]({{site.baseurl}}/assets/images/eprofile.jpg)  \n\t\t\t![pro_locale]({{site.baseurl}}/assets/images/pro_locale.jpg)  \n\t\t2.  删除/etc/profile中的`export LC_ALL=zh_CN.UTF-8`，并将其加入到/etc/envirionment，退出系统重新登录，登录界面和locale变量如下图所示：\n\t\t\t![environment]({{site.baseurl}}/assets/images/environment.jpg)  \n\t\t\t![env_locale]({{site.baseurl}}/assets/images/env_locale.jpg)\n\t* 结论：    \n\t\t1. 在登录界面时（还没有用户登录系统），系统执行了/etc/environment，仅此而已。而对于是否执行/etc/profile以及这两个文件谁先谁后的问题无法得出结论。对于这个问题，后面会做一下讨论。\n\n\t> **结论：**\n\t> 用户登录系统前，即刚进入登录界面，此时/etc/environment已经被执行。\n\n* 用户登录后进入shell后  \n\t* 试验步骤  \n\t\t1. 在/etc/profile文件中加入如下变量：\n\n\t\t\t```sh\n\t\t\texport eprofile=‘I am in /etc/profile’\n\t\t\texport epro_env=‘I am in /etc/profile’\n\t\t\texport epro_pro=‘I am in /etc/profile’\n\t\t\t```\n\t\t2. 在/etc/environment文件中加入如下变量：\n\n\t\t\t```sh\n\t\t\tenvironment=‘I am in /etc/environment’\n\t\t\tepro_env=‘I am in /etc/environment’\n\t\t\tenv_pro=‘I am in /etc/environment’\n\t\t\t```\n\t\t3. 在~/.profile文件中加入如下变量：\n\n\t\t\t```sh\n\t\t\texport profile=‘I am in ~/.profile’\n\t\t\texport epro_pro=‘I am in ~/.profile’\n\t\t\texport env_pro=‘I am in ~/.profile’\n\t\t\t```\n\t\t4. 重启系统后查看profile，environment，homepro，pro_env,pro_env_pro这五个变量的值，结果如下图所示：\n\t\t\t![login]({{site.baseurl}}/assets/images/login.jpg)  \n\n\t* 结论：  \n\t\t1. 三个环境配置文件都被执行了  \n\t\t变量environment，eprofile，profile都有值\n\t\t2. /etc/environment 优先于 /etc/profile  \n\t\t变量epro_env是/etc/profile里面的值，结合第一个结论，可得/etc/environment 优先于 /etc/profile\n\t\t3. /etc/profile 优先于 ~/.profile  \n\t\t变量epro_pro是~/.profile里面的值，结合第一个结论，可得/etc/profile 优先于 ~/.profile\n\n\t> **结论：**\n\t> 用户登录系统打开shell后，/etc/environment，/etc/profile和~/.profile执行顺序是：\n\t> /etc/environment => /etc/profile => ~/.profile\n\n## 问题讨论\n1. 关于第一个试验中只能得出/etc/environment在登录界面前将被执行，而对于是否执行/etc/profile以及这两个文件谁先谁后的问题无法得出结论。  \n从两幅登录界面发现在/etc/environment设定的LC\\_ALL起作用了，但是/etc/profile中的不起作用可能是被后面的覆盖掉，也有可能==该文件还没有被执行==，至于后面locale变量的比较，是在我们登录进系统后打开shell后看到的。在下一篇博文[shell的运行环境之环境配置文件]({{site.baseurl}}/2015/09/09/shell运行环境之环境配置文件.html)中我们会得出打开shell后会执行/etc/profile和~/.profile文件，所以无法判定在登录界面之前/etc/profile是否被执行，更不谈谁先谁后。\n个人倾向的解释是登录界面之前只是执行/etc/environment，不会执行/etc/profile，当输入用户和密码后才会以登录模式进入系统，此时/etc/profile和～/.profile才会被执行。\n\n\n## 参考文献\n1. [环境变量定义][define]\n1. [如何设置或更改PATH系统变量][set_env]\n3. [etc/profile和/etc/environment的比较][environment]\n4. [本地化环境变量LANG、LC_ALL、LANGUAGE的区别][locale]\n5. [wiki locale][wiki_locale]\n\n\n[define]:\thttp://baike.baidu.com/link?url=3Gg85PddfEhNPdztYJ_eXTlskslQrMUiD3rgR707cgNQtc9TEQhNksaqD-pX-kd0s2xN4nSS4Y6_CVynCguHLK\n[set_env]:  https://www.java.com/zh_CN/download/help/path.xml\n[environment]:\thttp://andy136566.iteye.com/blog/1025338\n[locale]:\thttp://my.oschina.net/luan/blog/79875\n[wiki_locale]:\thttp://wiki.ubuntu.org.cn/%E4%BF%AE%E6%94%B9locale\n","source":"_posts/2015-09-08-shell运行环境之环境变量.md","raw":"---\nlayout:\tpost\ntitle:\tshell运行环境之环境变量\ncategories:\n- TECHNOLOGY\ntags:\n- Ubuntu\n- Shell\npermalink:  Explore-environment-Shell\ncomments:\ttrue\n---\n在windows系统中，我们经常需要设置环境变量，特别是安装玩JAVA JDk之后。而在linux里面也是需要对一些环境变量进行设置，比如PATH（执行文件的路径），http_proxy（http代理）等。本篇博文主要介绍三种环境变量--临时变量，用户变量和系统变量，并对其作用的先后做一点验证。\n<!-- more -->\n\n\n## 简介\n[环境变量][define]一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。它相当于给系统或用户应用程序设置的一些参数，具体起什么作用这和具体的环境变量相关。\n\n在windows系统里面，经常会遇到[设置环境变量][set_env]的问题，特别是安装完Java JDK之后。我们很少在黑漆漆的命令行窗口中执行命令`set path=%path%;D:\\jdk\\bin`,因为这样设置的变量是临时环境变量，它只能在这个命令窗口中被识别，知道`java`命令在D:\\jdk\\bin目录里，但当重新打开一个命令窗口（shell外壳）后那个窗口将无法识别。也就是说该path只对执行那个命令的shell有效。还有两种方法是设置用户变量或系统变量。二者的区别就在于系统变量对所有用户有效，而用户变量只对当前用户有效。经试验，win8系统中二者都无需重启就可以起作用。\n\n## Linux 环境变量设置  \n其实，linux里面对环境变量的设置和windows是共通的。它也有三种方式  \n\n* 临时变量  \n在shell外壳中执行命令`PATH=$PATH':/home/hjy/program/jdk/bin'`,同样java命令只能在当前窗口中识别，重开一个外壳`java`命令将无效。\n* 用户变量  \nLinux里面关于用户变量的设置是在两个文件中，一个是/etc/profile，另一个是~/.profile。profile是配置的意思，是某个用户唯一用来设置环境变量的地方。针对不同的用户习惯，使用不同的shell（像bash，sh，zsh等），针对不同的功能或不同的应用，加载不同的环境变量文件。这部分将在[shell的运行环境之环境配置文件]({{site.baseurl}}/2015/09/09/shell运行环境之环境配置文件.html)里详细说明。\n* 系统变量  \nLinux里面关于系统变量的设置是在/etc/environment文件中。该环境变量的设置不需要加`export`，直接赋值即可。\n\n## 验证作用域\n易知临时变量的作用域只在当前的外壳中，出了当前外壳将失效。而对于用户变量和系统变量，我们这里做两个小的试验，其中一个是[网上][environment]的，关键是讲解中又是疑问又是否定的，没搞明白作者啥意思，所以这里亲自验证一下。\n\n* 图形界面登录  \n经试验发现，自己的电脑环境和网上博主还是有些区别的。主要在[本地化语言环境设定上的区别][wiki_locale]，在安装好中文和英文的语言包后，系统的本地语言环境如图：\n![ori_locale]({{site.baseurl}}/assets/images/ori_locale.jpg)   \n但是由这篇博文--[locale的设定中LANG、LC_ALL、LANGUAGE环境变量的区别][locale]知道，`LC_ALL > LC_* >LANG`，所以在本机上配置LANG将会被LC\\_*所取代，而导致无论怎么设置都是英文环境。所以实际实验是设定LC\\_ALL变量。   \n\t* 试验步骤  \n\t\t1. 将`export LC_ALL=zh_CN.UTF-8`加入/etc/profile，退出系统重新登录，登录界面和locale变量如下图所示：  \n\t\t\t![eprofile]({{site.baseurl}}/assets/images/eprofile.jpg)  \n\t\t\t![pro_locale]({{site.baseurl}}/assets/images/pro_locale.jpg)  \n\t\t2.  删除/etc/profile中的`export LC_ALL=zh_CN.UTF-8`，并将其加入到/etc/envirionment，退出系统重新登录，登录界面和locale变量如下图所示：\n\t\t\t![environment]({{site.baseurl}}/assets/images/environment.jpg)  \n\t\t\t![env_locale]({{site.baseurl}}/assets/images/env_locale.jpg)\n\t* 结论：    \n\t\t1. 在登录界面时（还没有用户登录系统），系统执行了/etc/environment，仅此而已。而对于是否执行/etc/profile以及这两个文件谁先谁后的问题无法得出结论。对于这个问题，后面会做一下讨论。\n\n\t> **结论：**\n\t> 用户登录系统前，即刚进入登录界面，此时/etc/environment已经被执行。\n\n* 用户登录后进入shell后  \n\t* 试验步骤  \n\t\t1. 在/etc/profile文件中加入如下变量：\n\n\t\t\t```sh\n\t\t\texport eprofile=‘I am in /etc/profile’\n\t\t\texport epro_env=‘I am in /etc/profile’\n\t\t\texport epro_pro=‘I am in /etc/profile’\n\t\t\t```\n\t\t2. 在/etc/environment文件中加入如下变量：\n\n\t\t\t```sh\n\t\t\tenvironment=‘I am in /etc/environment’\n\t\t\tepro_env=‘I am in /etc/environment’\n\t\t\tenv_pro=‘I am in /etc/environment’\n\t\t\t```\n\t\t3. 在~/.profile文件中加入如下变量：\n\n\t\t\t```sh\n\t\t\texport profile=‘I am in ~/.profile’\n\t\t\texport epro_pro=‘I am in ~/.profile’\n\t\t\texport env_pro=‘I am in ~/.profile’\n\t\t\t```\n\t\t4. 重启系统后查看profile，environment，homepro，pro_env,pro_env_pro这五个变量的值，结果如下图所示：\n\t\t\t![login]({{site.baseurl}}/assets/images/login.jpg)  \n\n\t* 结论：  \n\t\t1. 三个环境配置文件都被执行了  \n\t\t变量environment，eprofile，profile都有值\n\t\t2. /etc/environment 优先于 /etc/profile  \n\t\t变量epro_env是/etc/profile里面的值，结合第一个结论，可得/etc/environment 优先于 /etc/profile\n\t\t3. /etc/profile 优先于 ~/.profile  \n\t\t变量epro_pro是~/.profile里面的值，结合第一个结论，可得/etc/profile 优先于 ~/.profile\n\n\t> **结论：**\n\t> 用户登录系统打开shell后，/etc/environment，/etc/profile和~/.profile执行顺序是：\n\t> /etc/environment => /etc/profile => ~/.profile\n\n## 问题讨论\n1. 关于第一个试验中只能得出/etc/environment在登录界面前将被执行，而对于是否执行/etc/profile以及这两个文件谁先谁后的问题无法得出结论。  \n从两幅登录界面发现在/etc/environment设定的LC\\_ALL起作用了，但是/etc/profile中的不起作用可能是被后面的覆盖掉，也有可能==该文件还没有被执行==，至于后面locale变量的比较，是在我们登录进系统后打开shell后看到的。在下一篇博文[shell的运行环境之环境配置文件]({{site.baseurl}}/2015/09/09/shell运行环境之环境配置文件.html)中我们会得出打开shell后会执行/etc/profile和~/.profile文件，所以无法判定在登录界面之前/etc/profile是否被执行，更不谈谁先谁后。\n个人倾向的解释是登录界面之前只是执行/etc/environment，不会执行/etc/profile，当输入用户和密码后才会以登录模式进入系统，此时/etc/profile和～/.profile才会被执行。\n\n\n## 参考文献\n1. [环境变量定义][define]\n1. [如何设置或更改PATH系统变量][set_env]\n3. [etc/profile和/etc/environment的比较][environment]\n4. [本地化环境变量LANG、LC_ALL、LANGUAGE的区别][locale]\n5. [wiki locale][wiki_locale]\n\n\n[define]:\thttp://baike.baidu.com/link?url=3Gg85PddfEhNPdztYJ_eXTlskslQrMUiD3rgR707cgNQtc9TEQhNksaqD-pX-kd0s2xN4nSS4Y6_CVynCguHLK\n[set_env]:  https://www.java.com/zh_CN/download/help/path.xml\n[environment]:\thttp://andy136566.iteye.com/blog/1025338\n[locale]:\thttp://my.oschina.net/luan/blog/79875\n[wiki_locale]:\thttp://wiki.ubuntu.org.cn/%E4%BF%AE%E6%94%B9locale\n","slug":"Explore-environment-Shell","published":1,"date":"2015-09-07T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1i001gl73ykwbm9bn9","content":"<p>在windows系统中，我们经常需要设置环境变量，特别是安装玩JAVA JDk之后。而在linux里面也是需要对一些环境变量进行设置，比如PATH（执行文件的路径），http_proxy（http代理）等。本篇博文主要介绍三种环境变量–临时变量，用户变量和系统变量，并对其作用的先后做一点验证。 <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p><a href=\"http://baike.baidu.com/link?url=3Gg85PddfEhNPdztYJ_eXTlskslQrMUiD3rgR707cgNQtc9TEQhNksaqD-pX-kd0s2xN4nSS4Y6_CVynCguHLK\" target=\"_blank\" rel=\"external\">环境变量</a>一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。它相当于给系统或用户应用程序设置的一些参数，具体起什么作用这和具体的环境变量相关。</p>\n<p>在windows系统里面，经常会遇到<a href=\"https://www.java.com/zh_CN/download/help/path.xml\" target=\"_blank\" rel=\"external\">设置环境变量</a>的问题，特别是安装完Java JDK之后。我们很少在黑漆漆的命令行窗口中执行命令<code>set path=%path%;D:\\jdk\\bin</code>,因为这样设置的变量是临时环境变量，它只能在这个命令窗口中被识别，知道<code>java</code>命令在D:，但当重新打开一个命令窗口（shell外壳）后那个窗口将无法识别。也就是说该path只对执行那个命令的shell有效。还有两种方法是设置用户变量或系统变量。二者的区别就在于系统变量对所有用户有效，而用户变量只对当前用户有效。经试验，win8系统中二者都无需重启就可以起作用。</p>\n<h2 id=\"linux-环境变量设置\">Linux 环境变量设置</h2>\n<p>其实，linux里面对环境变量的设置和windows是共通的。它也有三种方式</p>\n<ul>\n<li>临时变量<br>\n在shell外壳中执行命令<code>PATH=$PATH':/home/hjy/program/jdk/bin'</code>,同样java命令只能在当前窗口中识别，重开一个外壳<code>java</code>命令将无效。</li>\n<li>用户变量<br>\nLinux里面关于用户变量的设置是在两个文件中，一个是/etc/profile，另一个是~/.profile。profile是配置的意思，是某个用户唯一用来设置环境变量的地方。针对不同的用户习惯，使用不同的shell（像bash，sh，zsh等），针对不同的功能或不同的应用，加载不同的环境变量文件。这部分将在[shell的运行环境之环境配置文件](/2015/09/09/shell运行环境之环境配置文件.html)里详细说明。</li>\n<li>系统变量<br>\nLinux里面关于系统变量的设置是在/etc/environment文件中。该环境变量的设置不需要加<code>export</code>，直接赋值即可。</li>\n</ul>\n<h2 id=\"验证作用域\">验证作用域</h2>\n<p>易知临时变量的作用域只在当前的外壳中，出了当前外壳将失效。而对于用户变量和系统变量，我们这里做两个小的试验，其中一个是<a href=\"http://andy136566.iteye.com/blog/1025338\" target=\"_blank\" rel=\"external\">网上</a>的，关键是讲解中又是疑问又是否定的，没搞明白作者啥意思，所以这里亲自验证一下。</p>\n<ul>\n<li>图形界面登录<br>\n经试验发现，自己的电脑环境和网上博主还是有些区别的。主要在<a href=\"http://wiki.ubuntu.org.cn/%E4%BF%AE%E6%94%B9locale\" target=\"_blank\" rel=\"external\">本地化语言环境设定上的区别</a>，在安装好中文和英文的语言包后，系统的本地语言环境如图： [ori_locale](/assets/images/ori_locale.jpg)<br>\n但是由这篇博文–<a href=\"http://my.oschina.net/luan/blog/79875\" target=\"_blank\" rel=\"external\">locale的设定中LANG、LC_ALL、LANGUAGE环境变量的区别</a>知道，<code>LC_ALL &gt; LC_* &gt;LANG</code>，所以在本机上配置LANG将会被LC_*所取代，而导致无论怎么设置都是英文环境。所以实际实验是设定LC_ALL变量。\n<ul>\n<li>试验步骤\n<ol style=\"list-style-type: decimal\">\n<li>将<code>export LC_ALL=zh_CN.UTF-8</code>加入/etc/profile，退出系统重新登录，登录界面和locale变量如下图所示：<br>\n[eprofile](/assets/images/eprofile.jpg)<br>\n[pro_locale](/assets/images/pro_locale.jpg)<br>\n</li>\n<li>删除/etc/profile中的<code>export LC_ALL=zh_CN.UTF-8</code>，并将其加入到/etc/envirionment，退出系统重新登录，登录界面和locale变量如下图所示： <img src=\"http://andy136566.iteye.com/blog/1025338\" alt=\"environment\">(/assets/images/environment.jpg)<br>\n[env_locale](/assets/images/env_locale.jpg)</li>\n</ol></li>\n<li>结论：\n<ol style=\"list-style-type: decimal\">\n<li>在登录界面时（还没有用户登录系统），系统执行了/etc/environment，仅此而已。而对于是否执行/etc/profile以及这两个文件谁先谁后的问题无法得出结论。对于这个问题，后面会做一下讨论。</li>\n</ol></li>\n</ul>\n<blockquote>\n<p><strong>结论：</strong> 用户登录系统前，即刚进入登录界面，此时/etc/environment已经被执行。</p>\n</blockquote></li>\n<li>用户登录后进入shell后\n<ul>\n<li>试验步骤\n<ol style=\"list-style-type: decimal\">\n<li><p>在/etc/profile文件中加入如下变量：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">export</span> eprofile=‘I am <span class=\"keyword\">in</span> /etc/profile’</div><div class=\"line\"><span class=\"built_in\">export</span> epro_env=‘I am <span class=\"keyword\">in</span> /etc/profile’</div><div class=\"line\"><span class=\"built_in\">export</span> epro_pro=‘I am <span class=\"keyword\">in</span> /etc/profile’</div></pre></td></tr></table></figure></li>\n<li><p>在/etc/environment文件中加入如下变量：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">environment=‘I am <span class=\"keyword\">in</span> /etc/environment’</div><div class=\"line\">epro_env=‘I am <span class=\"keyword\">in</span> /etc/environment’</div><div class=\"line\">env_pro=‘I am <span class=\"keyword\">in</span> /etc/environment’</div></pre></td></tr></table></figure></li>\n<li><p>在~/.profile文件中加入如下变量：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">export</span> profile=‘I am <span class=\"keyword\">in</span> ~/.profile’</div><div class=\"line\"><span class=\"built_in\">export</span> epro_pro=‘I am <span class=\"keyword\">in</span> ~/.profile’</div><div class=\"line\"><span class=\"built_in\">export</span> env_pro=‘I am <span class=\"keyword\">in</span> ~/.profile’</div></pre></td></tr></table></figure></li>\n<li><p>重启系统后查看profile，environment，homepro，pro_env,pro_env_pro这五个变量的值，结果如下图所示： [login](/assets/images/login.jpg)</p></li>\n</ol></li>\n<li>结论：\n<ol style=\"list-style-type: decimal\">\n<li>三个环境配置文件都被执行了<br>\n变量environment，eprofile，profile都有值</li>\n<li>/etc/environment 优先于 /etc/profile<br>\n变量epro_env是/etc/profile里面的值，结合第一个结论，可得/etc/environment 优先于 /etc/profile</li>\n<li>/etc/profile 优先于 ~/.profile<br>\n变量epro_pro是~/.profile里面的值，结合第一个结论，可得/etc/profile 优先于 ~/.profile</li>\n</ol></li>\n</ul>\n<blockquote>\n<p><strong>结论：</strong> 用户登录系统打开shell后，/etc/environment，/etc/profile和~/.profile执行顺序是： /etc/environment =&gt; /etc/profile =&gt; ~/.profile</p>\n</blockquote></li>\n</ul>\n<h2 id=\"问题讨论\">问题讨论</h2>\n<ol style=\"list-style-type: decimal\">\n<li>关于第一个试验中只能得出/etc/environment在登录界面前将被执行，而对于是否执行/etc/profile以及这两个文件谁先谁后的问题无法得出结论。<br>\n从两幅登录界面发现在/etc/environment设定的LC_ALL起作用了，但是/etc/profile中的不起作用可能是被后面的覆盖掉，也有可能==该文件还没有被执行==，至于后面locale变量的比较，是在我们登录进系统后打开shell后看到的。在下一篇博文[shell的运行环境之环境配置文件](/2015/09/09/shell运行环境之环境配置文件.html)中我们会得出打开shell后会执行/etc/profile和~/.profile文件，所以无法判定在登录界面之前/etc/profile是否被执行，更不谈谁先谁后。 个人倾向的解释是登录界面之前只是执行/etc/environment，不会执行/etc/profile，当输入用户和密码后才会以登录模式进入系统，此时/etc/profile和～/.profile才会被执行。</li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://baike.baidu.com/link?url=3Gg85PddfEhNPdztYJ_eXTlskslQrMUiD3rgR707cgNQtc9TEQhNksaqD-pX-kd0s2xN4nSS4Y6_CVynCguHLK\" target=\"_blank\" rel=\"external\">环境变量定义</a></li>\n<li><a href=\"https://www.java.com/zh_CN/download/help/path.xml\" target=\"_blank\" rel=\"external\">如何设置或更改PATH系统变量</a></li>\n<li><a href=\"http://andy136566.iteye.com/blog/1025338\" target=\"_blank\" rel=\"external\">etc/profile和/etc/environment的比较</a></li>\n<li><a href=\"http://my.oschina.net/luan/blog/79875\" target=\"_blank\" rel=\"external\">本地化环境变量LANG、LC_ALL、LANGUAGE的区别</a></li>\n<li><a href=\"http://wiki.ubuntu.org.cn/%E4%BF%AE%E6%94%B9locale\" target=\"_blank\" rel=\"external\">wiki locale</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在windows系统中，我们经常需要设置环境变量，特别是安装玩JAVA JDk之后。而在linux里面也是需要对一些环境变量进行设置，比如PATH（执行文件的路径），http_proxy（http代理）等。本篇博文主要介绍三种环境变量–临时变量，用户变量和系统变量，并对其作用的先后做一点验证。","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p><a href=\"http://baike.baidu.com/link?url=3Gg85PddfEhNPdztYJ_eXTlskslQrMUiD3rgR707cgNQtc9TEQhNksaqD-pX-kd0s2xN4nSS4Y6_CVynCguHLK\" target=\"_blank\" rel=\"external\">环境变量</a>一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。它相当于给系统或用户应用程序设置的一些参数，具体起什么作用这和具体的环境变量相关。</p>\n<p>在windows系统里面，经常会遇到<a href=\"https://www.java.com/zh_CN/download/help/path.xml\" target=\"_blank\" rel=\"external\">设置环境变量</a>的问题，特别是安装完Java JDK之后。我们很少在黑漆漆的命令行窗口中执行命令<code>set path=%path%;D:\\jdk\\bin</code>,因为这样设置的变量是临时环境变量，它只能在这个命令窗口中被识别，知道<code>java</code>命令在D:，但当重新打开一个命令窗口（shell外壳）后那个窗口将无法识别。也就是说该path只对执行那个命令的shell有效。还有两种方法是设置用户变量或系统变量。二者的区别就在于系统变量对所有用户有效，而用户变量只对当前用户有效。经试验，win8系统中二者都无需重启就可以起作用。</p>\n<h2 id=\"linux-环境变量设置\">Linux 环境变量设置</h2>\n<p>其实，linux里面对环境变量的设置和windows是共通的。它也有三种方式</p>\n<ul>\n<li>临时变量<br>\n在shell外壳中执行命令<code>PATH=$PATH':/home/hjy/program/jdk/bin'</code>,同样java命令只能在当前窗口中识别，重开一个外壳<code>java</code>命令将无效。</li>\n<li>用户变量<br>\nLinux里面关于用户变量的设置是在两个文件中，一个是/etc/profile，另一个是~/.profile。profile是配置的意思，是某个用户唯一用来设置环境变量的地方。针对不同的用户习惯，使用不同的shell（像bash，sh，zsh等），针对不同的功能或不同的应用，加载不同的环境变量文件。这部分将在[shell的运行环境之环境配置文件](/2015/09/09/shell运行环境之环境配置文件.html)里详细说明。</li>\n<li>系统变量<br>\nLinux里面关于系统变量的设置是在/etc/environment文件中。该环境变量的设置不需要加<code>export</code>，直接赋值即可。</li>\n</ul>\n<h2 id=\"验证作用域\">验证作用域</h2>\n<p>易知临时变量的作用域只在当前的外壳中，出了当前外壳将失效。而对于用户变量和系统变量，我们这里做两个小的试验，其中一个是<a href=\"http://andy136566.iteye.com/blog/1025338\" target=\"_blank\" rel=\"external\">网上</a>的，关键是讲解中又是疑问又是否定的，没搞明白作者啥意思，所以这里亲自验证一下。</p>\n<ul>\n<li>图形界面登录<br>\n经试验发现，自己的电脑环境和网上博主还是有些区别的。主要在<a href=\"http://wiki.ubuntu.org.cn/%E4%BF%AE%E6%94%B9locale\" target=\"_blank\" rel=\"external\">本地化语言环境设定上的区别</a>，在安装好中文和英文的语言包后，系统的本地语言环境如图： [ori_locale](/assets/images/ori_locale.jpg)<br>\n但是由这篇博文–<a href=\"http://my.oschina.net/luan/blog/79875\" target=\"_blank\" rel=\"external\">locale的设定中LANG、LC_ALL、LANGUAGE环境变量的区别</a>知道，<code>LC_ALL &gt; LC_* &gt;LANG</code>，所以在本机上配置LANG将会被LC_*所取代，而导致无论怎么设置都是英文环境。所以实际实验是设定LC_ALL变量。\n<ul>\n<li>试验步骤\n<ol style=\"list-style-type: decimal\">\n<li>将<code>export LC_ALL=zh_CN.UTF-8</code>加入/etc/profile，退出系统重新登录，登录界面和locale变量如下图所示：<br>\n[eprofile](/assets/images/eprofile.jpg)<br>\n[pro_locale](/assets/images/pro_locale.jpg)<br>\n</li>\n<li>删除/etc/profile中的<code>export LC_ALL=zh_CN.UTF-8</code>，并将其加入到/etc/envirionment，退出系统重新登录，登录界面和locale变量如下图所示： <img src=\"http://andy136566.iteye.com/blog/1025338\" alt=\"environment\">(/assets/images/environment.jpg)<br>\n[env_locale](/assets/images/env_locale.jpg)</li>\n</ol></li>\n<li>结论：\n<ol style=\"list-style-type: decimal\">\n<li>在登录界面时（还没有用户登录系统），系统执行了/etc/environment，仅此而已。而对于是否执行/etc/profile以及这两个文件谁先谁后的问题无法得出结论。对于这个问题，后面会做一下讨论。</li>\n</ol></li>\n</ul>\n<blockquote>\n<p><strong>结论：</strong> 用户登录系统前，即刚进入登录界面，此时/etc/environment已经被执行。</p>\n</blockquote></li>\n<li>用户登录后进入shell后\n<ul>\n<li>试验步骤\n<ol style=\"list-style-type: decimal\">\n<li><p>在/etc/profile文件中加入如下变量：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">export</span> eprofile=‘I am <span class=\"keyword\">in</span> /etc/profile’</div><div class=\"line\"><span class=\"built_in\">export</span> epro_env=‘I am <span class=\"keyword\">in</span> /etc/profile’</div><div class=\"line\"><span class=\"built_in\">export</span> epro_pro=‘I am <span class=\"keyword\">in</span> /etc/profile’</div></pre></td></tr></table></figure></li>\n<li><p>在/etc/environment文件中加入如下变量：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">environment=‘I am <span class=\"keyword\">in</span> /etc/environment’</div><div class=\"line\">epro_env=‘I am <span class=\"keyword\">in</span> /etc/environment’</div><div class=\"line\">env_pro=‘I am <span class=\"keyword\">in</span> /etc/environment’</div></pre></td></tr></table></figure></li>\n<li><p>在~/.profile文件中加入如下变量：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">export</span> profile=‘I am <span class=\"keyword\">in</span> ~/.profile’</div><div class=\"line\"><span class=\"built_in\">export</span> epro_pro=‘I am <span class=\"keyword\">in</span> ~/.profile’</div><div class=\"line\"><span class=\"built_in\">export</span> env_pro=‘I am <span class=\"keyword\">in</span> ~/.profile’</div></pre></td></tr></table></figure></li>\n<li><p>重启系统后查看profile，environment，homepro，pro_env,pro_env_pro这五个变量的值，结果如下图所示： [login](/assets/images/login.jpg)</p></li>\n</ol></li>\n<li>结论：\n<ol style=\"list-style-type: decimal\">\n<li>三个环境配置文件都被执行了<br>\n变量environment，eprofile，profile都有值</li>\n<li>/etc/environment 优先于 /etc/profile<br>\n变量epro_env是/etc/profile里面的值，结合第一个结论，可得/etc/environment 优先于 /etc/profile</li>\n<li>/etc/profile 优先于 ~/.profile<br>\n变量epro_pro是~/.profile里面的值，结合第一个结论，可得/etc/profile 优先于 ~/.profile</li>\n</ol></li>\n</ul>\n<blockquote>\n<p><strong>结论：</strong> 用户登录系统打开shell后，/etc/environment，/etc/profile和~/.profile执行顺序是： /etc/environment =&gt; /etc/profile =&gt; ~/.profile</p>\n</blockquote></li>\n</ul>\n<h2 id=\"问题讨论\">问题讨论</h2>\n<ol style=\"list-style-type: decimal\">\n<li>关于第一个试验中只能得出/etc/environment在登录界面前将被执行，而对于是否执行/etc/profile以及这两个文件谁先谁后的问题无法得出结论。<br>\n从两幅登录界面发现在/etc/environment设定的LC_ALL起作用了，但是/etc/profile中的不起作用可能是被后面的覆盖掉，也有可能==该文件还没有被执行==，至于后面locale变量的比较，是在我们登录进系统后打开shell后看到的。在下一篇博文[shell的运行环境之环境配置文件](/2015/09/09/shell运行环境之环境配置文件.html)中我们会得出打开shell后会执行/etc/profile和~/.profile文件，所以无法判定在登录界面之前/etc/profile是否被执行，更不谈谁先谁后。 个人倾向的解释是登录界面之前只是执行/etc/environment，不会执行/etc/profile，当输入用户和密码后才会以登录模式进入系统，此时/etc/profile和～/.profile才会被执行。</li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://baike.baidu.com/link?url=3Gg85PddfEhNPdztYJ_eXTlskslQrMUiD3rgR707cgNQtc9TEQhNksaqD-pX-kd0s2xN4nSS4Y6_CVynCguHLK\" target=\"_blank\" rel=\"external\">环境变量定义</a></li>\n<li><a href=\"https://www.java.com/zh_CN/download/help/path.xml\" target=\"_blank\" rel=\"external\">如何设置或更改PATH系统变量</a></li>\n<li><a href=\"http://andy136566.iteye.com/blog/1025338\" target=\"_blank\" rel=\"external\">etc/profile和/etc/environment的比较</a></li>\n<li><a href=\"http://my.oschina.net/luan/blog/79875\" target=\"_blank\" rel=\"external\">本地化环境变量LANG、LC_ALL、LANGUAGE的区别</a></li>\n<li><a href=\"http://wiki.ubuntu.org.cn/%E4%BF%AE%E6%94%B9locale\" target=\"_blank\" rel=\"external\">wiki locale</a></li>\n</ol>"},{"layout":"post","title":"ACM解题报告之最长回文子串","comments":1,"_content":"题目很简单，就是求解一个字符串中最长的回文子串，回文字符串是指颠倒之后的字符串和原来的字符串完全一样。网上很多人的博文，像[kangroger](http://blog.csdn.net/kangroger/article/details/37742639),还有把最牛b的Manacher算法说得很清晰的[pi9nc](http://blog.csdn.net/pi9nc/article/details/9251455)和[yzl_rex](http://blog.csdn.net/yzl_rex/article/details/7908259)，介绍了四种解法：分别是暴力法（$O(n^3)$），动态规划（$O(n^2)$），中心扩展（$O(n^2)$）和Manache法（$O(n)$）。本博文只是对这四种方法的自我实现。\n<!-- more -->\n\n## 题目\n题目来自HiHoCoder上第一周的题目[最长回文子串](http://hihocoder.com/contest/hiho1/problem/1)，题目大意是：\n> 给定一个字符串，求解这个字符串中最长的回文子串。而回文字符串是指颠倒之后的字符串和原来的字符串完全一样。\n\n\n## 思路\n1. 暴力求解  \n暴力求解的方法分两步，第一步是得到字符串所有的子串（$n\\times(n+1)/2$个），第二步是判断每一个子串是否是回文子串（$n/2$比较操作），如果是则记录下长度，不是则舍弃。所以暴力求解方法的时间复杂度为$O(n^3)$。\n\n2. 动态优化  \n这里的动态优化说白了就是一种空间换时间的解法。其具体的做法就是在一个二维数组dp中记录下i到j是否是回文，即dp[i][j]=1/0,那么要判断dp[m][n]是否是回文就得看$ dp[m-1][n-1] = 1 \\&\\& buf[m] = [n] $。由于要填充这样$n^2$的二维数组，所以动态优化解法的时间复杂度$O(n^2)$。\n\n3. 中心扩展  \n中心扩展的思路很简单，就是以字符串中某个字符为中心，然后向两边对称扩展，判断最边缘字符是否相等，以此来统计回文子串的长度。不过这里面要注意回文子串的长度可能为偶数，也就是说它以两个字符的中间为对称中心。所以要分两种情况考虑，总的来说，中心扩展方法的时间复杂度为$O(n^2)$。\n\n4. Manacher算法  \n你猜测的没，该算法就是这个叫Manacher的人想出的算法，用于解决最长回文子串问题，其时间复杂度能达到$O(n)$。该算法的核心思想是充分利用回文字符串的对称性，即利用前面已经算得的对称半径减少或直接求取当前要求的对称半径。下个部分将详细解释该算法。\n\n## 算法说明\n这里主要说明动态规划算法和Manacher算法。重点在Mancher算法，而动态规划算法只是提一下其中二维数组的动态申请。\n### 动态规划算法\n1. 二维数组的动态申请用c实现的步骤：\n    1. 申请一个长度为len的指针数组(int **)dp，用来存放二维数组每行的首地址。\n    2. 给dp[0]申请一个len*len的数组，用于存放具体数据。\n    3. 给dp[i]赋上二维数组每行首地址。\n    4. $\\cdots$\n    5. 释放数组dp[0]\n    6. 释放指针数组dp\n2. 代码演示\n\n    ```c\n    // 动态申请二位数组并初始化\n    int **dp = (int **)malloc(sizeof(int *) * len);\n    dp[0] = (int *)malloc(sizeof(int) * len * len);\n    for(i=1; i<len; i++)\n        dp[i] = dp[i-1] + len;\n\n    // 释放申请的二位数组\n    free(dp[0]);\n    free(dp);\n    ```\n\n### Mancher算法\n1. 假设  \n为解释清楚Manacher算法，作如下假定：  \n    * 所有的回文子串的数目都是奇数（通过向字符首尾和字符间插入特殊字符集'#'实现）\n    * 辅助数组radius用来存储对称半径。即radius[i]表示以第i个字符为中心构成的回文子串的半径。像字符串“#a#”的回文半径为1。\n2. 符号说明  \n如下图所示，我们要根据回文字符串buf和radius[0]～radius[i-1]来求取radius[i]。\n![manacher]({{site.baseurl}}/assets/images/manacher.png)  \n图中符号说明如下：  \n    * id表示以前i个字符中第id个字符为中心构成的回文子串最右边字符的索引值最大，即$id = argmax(radius[k]+k),k<i$。易知$ id<i $。\n    * mx表示以第id个字符为中心构成的回文子串最右边字符的索引值，即$mx = radius[id]+id, id<i $。\n    * j是i关于id的对称点，即$ j = 2 * id - i $。\n\n3. 分情况讨论  \n    1. ==$ mx < i$==  \n    此时radius的前i个值不起任何作用，就像初始时根据radius[0]=0求解radius[1]，此时id=0,mx=0。\n\n        ```c\n        if(mx<i){\n            k=1;\n            // 以i为中心，回文子串的半径\n            while(newbuf[i-k]==newbuf[i+k]&&i-k>=0&&i+k<len)\n                k++;\n            radius[i]=k-1;\n        }\n        ```\n    2. ==$ mx > i $==  \n        1. ==$ mx-i >= radius[j] $==  \n        $mx-i$代表i到mx的距离，而radius[j]就是图中绿线的一半距离。如果$mx-i > radius[j]$说明$radius[i]=radius[j]$，因为$[2*id-mx,mx]是关于id对称的，而i和j也是关于id对称的。\n\n            ```c\n            if(mx-i >= radius[j])\n                radius[i]=radius[j];\n            ```\n        2. ==$ mx-i < radius[j]$==  \n        此时我们根据对称性，能够获得$radius[i]>=radius[j]$的。所以我们直接从mx+1开始判断$buf[mx+t]\\==buf[2*i-mx-t],t=1,2,\\cdots$。\n\n            ```c\n            if(mx-i<radius[j]){\n                k=mx-i+1;\n                // 以i为中心，回文子串的半径从mx-i+1开始验证\n                while(newbuf[i-k]==newbuf[i+k]&&i-k>=0&&i+k<len)\n                    k++;\n                radius[i]=k-1;\n            }\n            ```\n4. 情况融合  \n仔细思考一下，发现第二种情况里面的两种情况可以融合，说白点就是取图中i到mx的距离和图中一半绿线距离中的最小值，即$radius[i]=min(radius[j],mx-i)$。然后再进行向外扩展，看radius[i]能否更大。\n\n    ```c\n    radius[0]=0;\n    for(i=1; i<len; i++){\n        if(mx>i){\n            if(radius[j]<mx-i)\n                radius[i]=radius[j];\n            else\n                radius[i]=mx-i;\n        }else{\n            radius[i]=1;\n        }\n        for(;newbuf[i+radius[i]]==newbuf[i-radius[i]]&&i+radius[i]<len&&i-radius[i]>=0;radius[i]++);\n        // 更新id，mx\n        if(radius[i]+i>mx){\n            id=i;\n            mx=radius[i]+i;\n        }\n    }\n    ```\n\n\n4. [完整代码]({{site.baseurl}}/assets/attachs/1032.c.txt)\n\n## 举一反三\n无\n","source":"_posts/2015-08-25-ACM解题报告之最长回文子串.md","raw":"---\nlayout:\tpost\ntitle:\tACM解题报告之最长回文子串\ncategories:\n- TECHNOLOGY\ntags:\n- ACM\n- HiHoCoder\n- Report\npermalink:  Solve-longestPalindrome-ACM\ncomments:\ttrue\n---\n题目很简单，就是求解一个字符串中最长的回文子串，回文字符串是指颠倒之后的字符串和原来的字符串完全一样。网上很多人的博文，像[kangroger](http://blog.csdn.net/kangroger/article/details/37742639),还有把最牛b的Manacher算法说得很清晰的[pi9nc](http://blog.csdn.net/pi9nc/article/details/9251455)和[yzl_rex](http://blog.csdn.net/yzl_rex/article/details/7908259)，介绍了四种解法：分别是暴力法（$O(n^3)$），动态规划（$O(n^2)$），中心扩展（$O(n^2)$）和Manache法（$O(n)$）。本博文只是对这四种方法的自我实现。\n<!-- more -->\n\n## 题目\n题目来自HiHoCoder上第一周的题目[最长回文子串](http://hihocoder.com/contest/hiho1/problem/1)，题目大意是：\n> 给定一个字符串，求解这个字符串中最长的回文子串。而回文字符串是指颠倒之后的字符串和原来的字符串完全一样。\n\n\n## 思路\n1. 暴力求解  \n暴力求解的方法分两步，第一步是得到字符串所有的子串（$n\\times(n+1)/2$个），第二步是判断每一个子串是否是回文子串（$n/2$比较操作），如果是则记录下长度，不是则舍弃。所以暴力求解方法的时间复杂度为$O(n^3)$。\n\n2. 动态优化  \n这里的动态优化说白了就是一种空间换时间的解法。其具体的做法就是在一个二维数组dp中记录下i到j是否是回文，即dp[i][j]=1/0,那么要判断dp[m][n]是否是回文就得看$ dp[m-1][n-1] = 1 \\&\\& buf[m] = [n] $。由于要填充这样$n^2$的二维数组，所以动态优化解法的时间复杂度$O(n^2)$。\n\n3. 中心扩展  \n中心扩展的思路很简单，就是以字符串中某个字符为中心，然后向两边对称扩展，判断最边缘字符是否相等，以此来统计回文子串的长度。不过这里面要注意回文子串的长度可能为偶数，也就是说它以两个字符的中间为对称中心。所以要分两种情况考虑，总的来说，中心扩展方法的时间复杂度为$O(n^2)$。\n\n4. Manacher算法  \n你猜测的没，该算法就是这个叫Manacher的人想出的算法，用于解决最长回文子串问题，其时间复杂度能达到$O(n)$。该算法的核心思想是充分利用回文字符串的对称性，即利用前面已经算得的对称半径减少或直接求取当前要求的对称半径。下个部分将详细解释该算法。\n\n## 算法说明\n这里主要说明动态规划算法和Manacher算法。重点在Mancher算法，而动态规划算法只是提一下其中二维数组的动态申请。\n### 动态规划算法\n1. 二维数组的动态申请用c实现的步骤：\n    1. 申请一个长度为len的指针数组(int **)dp，用来存放二维数组每行的首地址。\n    2. 给dp[0]申请一个len*len的数组，用于存放具体数据。\n    3. 给dp[i]赋上二维数组每行首地址。\n    4. $\\cdots$\n    5. 释放数组dp[0]\n    6. 释放指针数组dp\n2. 代码演示\n\n    ```c\n    // 动态申请二位数组并初始化\n    int **dp = (int **)malloc(sizeof(int *) * len);\n    dp[0] = (int *)malloc(sizeof(int) * len * len);\n    for(i=1; i<len; i++)\n        dp[i] = dp[i-1] + len;\n\n    // 释放申请的二位数组\n    free(dp[0]);\n    free(dp);\n    ```\n\n### Mancher算法\n1. 假设  \n为解释清楚Manacher算法，作如下假定：  \n    * 所有的回文子串的数目都是奇数（通过向字符首尾和字符间插入特殊字符集'#'实现）\n    * 辅助数组radius用来存储对称半径。即radius[i]表示以第i个字符为中心构成的回文子串的半径。像字符串“#a#”的回文半径为1。\n2. 符号说明  \n如下图所示，我们要根据回文字符串buf和radius[0]～radius[i-1]来求取radius[i]。\n![manacher]({{site.baseurl}}/assets/images/manacher.png)  \n图中符号说明如下：  \n    * id表示以前i个字符中第id个字符为中心构成的回文子串最右边字符的索引值最大，即$id = argmax(radius[k]+k),k<i$。易知$ id<i $。\n    * mx表示以第id个字符为中心构成的回文子串最右边字符的索引值，即$mx = radius[id]+id, id<i $。\n    * j是i关于id的对称点，即$ j = 2 * id - i $。\n\n3. 分情况讨论  \n    1. ==$ mx < i$==  \n    此时radius的前i个值不起任何作用，就像初始时根据radius[0]=0求解radius[1]，此时id=0,mx=0。\n\n        ```c\n        if(mx<i){\n            k=1;\n            // 以i为中心，回文子串的半径\n            while(newbuf[i-k]==newbuf[i+k]&&i-k>=0&&i+k<len)\n                k++;\n            radius[i]=k-1;\n        }\n        ```\n    2. ==$ mx > i $==  \n        1. ==$ mx-i >= radius[j] $==  \n        $mx-i$代表i到mx的距离，而radius[j]就是图中绿线的一半距离。如果$mx-i > radius[j]$说明$radius[i]=radius[j]$，因为$[2*id-mx,mx]是关于id对称的，而i和j也是关于id对称的。\n\n            ```c\n            if(mx-i >= radius[j])\n                radius[i]=radius[j];\n            ```\n        2. ==$ mx-i < radius[j]$==  \n        此时我们根据对称性，能够获得$radius[i]>=radius[j]$的。所以我们直接从mx+1开始判断$buf[mx+t]\\==buf[2*i-mx-t],t=1,2,\\cdots$。\n\n            ```c\n            if(mx-i<radius[j]){\n                k=mx-i+1;\n                // 以i为中心，回文子串的半径从mx-i+1开始验证\n                while(newbuf[i-k]==newbuf[i+k]&&i-k>=0&&i+k<len)\n                    k++;\n                radius[i]=k-1;\n            }\n            ```\n4. 情况融合  \n仔细思考一下，发现第二种情况里面的两种情况可以融合，说白点就是取图中i到mx的距离和图中一半绿线距离中的最小值，即$radius[i]=min(radius[j],mx-i)$。然后再进行向外扩展，看radius[i]能否更大。\n\n    ```c\n    radius[0]=0;\n    for(i=1; i<len; i++){\n        if(mx>i){\n            if(radius[j]<mx-i)\n                radius[i]=radius[j];\n            else\n                radius[i]=mx-i;\n        }else{\n            radius[i]=1;\n        }\n        for(;newbuf[i+radius[i]]==newbuf[i-radius[i]]&&i+radius[i]<len&&i-radius[i]>=0;radius[i]++);\n        // 更新id，mx\n        if(radius[i]+i>mx){\n            id=i;\n            mx=radius[i]+i;\n        }\n    }\n    ```\n\n\n4. [完整代码]({{site.baseurl}}/assets/attachs/1032.c.txt)\n\n## 举一反三\n无\n","slug":"Solve-longestPalindrome-ACM","published":1,"date":"2015-08-24T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1i001hl73ybchf9tef","content":"<p>题目很简单，就是求解一个字符串中最长的回文子串，回文字符串是指颠倒之后的字符串和原来的字符串完全一样。网上很多人的博文，像<a href=\"http://blog.csdn.net/kangroger/article/details/37742639\" target=\"_blank\" rel=\"external\">kangroger</a>,还有把最牛b的Manacher算法说得很清晰的<a href=\"http://blog.csdn.net/pi9nc/article/details/9251455\" target=\"_blank\" rel=\"external\">pi9nc</a>和<a href=\"http://blog.csdn.net/yzl_rex/article/details/7908259\" target=\"_blank\" rel=\"external\">yzl_rex</a>，介绍了四种解法：分别是暴力法（<span class=\"math inline\">\\(O(n^3)\\)</span>），动态规划（<span class=\"math inline\">\\(O(n^2)\\)</span>），中心扩展（<span class=\"math inline\">\\(O(n^2)\\)</span>）和Manache法（<span class=\"math inline\">\\(O(n)\\)</span>）。本博文只是对这四种方法的自我实现。 <a id=\"more\"></a></p>\n<h2 id=\"题目\">题目</h2>\n<p>题目来自HiHoCoder上第一周的题目<a href=\"http://hihocoder.com/contest/hiho1/problem/1\" target=\"_blank\" rel=\"external\">最长回文子串</a>，题目大意是： &gt; 给定一个字符串，求解这个字符串中最长的回文子串。而回文字符串是指颠倒之后的字符串和原来的字符串完全一样。</p>\n<h2 id=\"思路\">思路</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>暴力求解<br>\n暴力求解的方法分两步，第一步是得到字符串所有的子串（<span class=\"math inline\">\\(n\\times(n+1)/2\\)</span>个），第二步是判断每一个子串是否是回文子串（<span class=\"math inline\">\\(n/2\\)</span>比较操作），如果是则记录下长度，不是则舍弃。所以暴力求解方法的时间复杂度为<span class=\"math inline\">\\(O(n^3)\\)</span>。</p></li>\n<li><p>动态优化<br>\n这里的动态优化说白了就是一种空间换时间的解法。其具体的做法就是在一个二维数组dp中记录下i到j是否是回文，即dp[i][j]=1/0,那么要判断dp[m][n]是否是回文就得看$ dp[m-1][n-1] = 1 &amp;&amp; buf[m] = [n] <span class=\"math inline\">\\(。由于要填充这样\\)</span>n<sup>2<span class=\"math inline\">\\(的二维数组，所以动态优化解法的时间复杂度\\)</span>O(n</sup>2)$。</p></li>\n<li><p>中心扩展<br>\n中心扩展的思路很简单，就是以字符串中某个字符为中心，然后向两边对称扩展，判断最边缘字符是否相等，以此来统计回文子串的长度。不过这里面要注意回文子串的长度可能为偶数，也就是说它以两个字符的中间为对称中心。所以要分两种情况考虑，总的来说，中心扩展方法的时间复杂度为<span class=\"math inline\">\\(O(n^2)\\)</span>。</p></li>\n<li><p>Manacher算法<br>\n你猜测的没，该算法就是这个叫Manacher的人想出的算法，用于解决最长回文子串问题，其时间复杂度能达到<span class=\"math inline\">\\(O(n)\\)</span>。该算法的核心思想是充分利用回文字符串的对称性，即利用前面已经算得的对称半径减少或直接求取当前要求的对称半径。下个部分将详细解释该算法。</p></li>\n</ol>\n<h2 id=\"算法说明\">算法说明</h2>\n<p>这里主要说明动态规划算法和Manacher算法。重点在Mancher算法，而动态规划算法只是提一下其中二维数组的动态申请。 ### 动态规划算法 1. 二维数组的动态申请用c实现的步骤： 1. 申请一个长度为len的指针数组(int **)dp，用来存放二维数组每行的首地址。 2. 给dp[0]申请一个len*len的数组，用于存放具体数据。 3. 给dp[i]赋上二维数组每行首地址。 4. <span class=\"math inline\">\\(\\cdots\\)</span> 5. 释放数组dp[0] 6. 释放指针数组dp 2. 代码演示</p>\n<pre><code><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 动态申请二位数组并初始化</span></div><div class=\"line\"><span class=\"keyword\">int</span> **dp = (<span class=\"keyword\">int</span> **)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span> *) * len);</div><div class=\"line\">dp[<span class=\"number\">0</span>] = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * len * len);</div><div class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;len; i++)</div><div class=\"line\">    dp[i] = dp[i<span class=\"number\">-1</span>] + len;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 释放申请的二位数组</span></div><div class=\"line\"><span class=\"built_in\">free</span>(dp[<span class=\"number\">0</span>]);</div><div class=\"line\"><span class=\"built_in\">free</span>(dp);</div></pre></td></tr></table></figure></code></pre>\n<h3 id=\"mancher算法\">Mancher算法</h3>\n<ol style=\"list-style-type: decimal\">\n<li>假设<br>\n为解释清楚Manacher算法，作如下假定：\n<ul>\n<li>所有的回文子串的数目都是奇数（通过向字符首尾和字符间插入特殊字符集’#’实现）</li>\n<li>辅助数组radius用来存储对称半径。即radius[i]表示以第i个字符为中心构成的回文子串的半径。像字符串“#a#”的回文半径为1。</li>\n</ul></li>\n<li>符号说明<br>\n如下图所示，我们要根据回文字符串buf和radius[0]～radius[i-1]来求取radius[i]。 [manacher]({{site.baseurl}}/assets/images/manacher.png)<br>\n图中符号说明如下：\n<ul>\n<li>id表示以前i个字符中第id个字符为中心构成的回文子串最右边字符的索引值最大，即<span class=\"math inline\">\\(id = argmax(radius[k]+k),k&lt;i\\)</span>。易知$ id&lt;i $。</li>\n<li>mx表示以第id个字符为中心构成的回文子串最右边字符的索引值，即$mx = radius[id]+id, id&lt;i $。</li>\n<li>j是i关于id的对称点，即$ j = 2 * id - i $。</li>\n</ul></li>\n<li>分情况讨论\n<ol style=\"list-style-type: decimal\">\n<li><p>==$ mx &lt; i$==<br>\n此时radius的前i个值不起任何作用，就像初始时根据radius[0]=0求解radius[1]，此时id=0,mx=0。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(mx&lt;i)&#123;</div><div class=\"line\">    k=<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"comment\">// 以i为中心，回文子串的半径</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(newbuf[i-k]==newbuf[i+k]&amp;&amp;i-k&gt;=<span class=\"number\">0</span>&amp;&amp;i+k&lt;len)</div><div class=\"line\">        k++;</div><div class=\"line\">    radius[i]=k<span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><p>==$ mx &gt; i <span class=\"math inline\">\\(== 1. ==\\)</span> mx-i &gt;= radius[j] $==<br>\n<span class=\"math inline\">\\(mx-i\\)</span>代表i到mx的距离，而radius[j]就是图中绿线的一半距离。如果<span class=\"math inline\">\\(mx-i &gt; radius[j]\\)</span>说明<span class=\"math inline\">\\(radius[i]=radius[j]\\)</span>，因为$[2*id-mx,mx]是关于id对称的，而i和j也是关于id对称的。</p>\n<pre><code><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(mx-i &gt;= radius[j])</div><div class=\"line\">    radius[i]=radius[j];</div></pre></td></tr></table></figure></code></pre>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li><p>==$ mx-i &lt; radius[j]<span class=\"math inline\">\\(== 此时我们根据对称性，能够获得\\)</span>radius[i]&gt;=radius[j]<span class=\"math inline\">\\(的。所以我们直接从mx+1开始判断\\)</span>buf[mx+t]==buf[2*i-mx-t],t=1,2,$。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(mx-i&lt;radius[j])&#123;</div><div class=\"line\">    k=mx-i+<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"comment\">// 以i为中心，回文子串的半径从mx-i+1开始验证</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(newbuf[i-k]==newbuf[i+k]&amp;&amp;i-k&gt;=<span class=\"number\">0</span>&amp;&amp;i+k&lt;len)</div><div class=\"line\">        k++;</div><div class=\"line\">    radius[i]=k<span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ol></li>\n<li><p>情况融合<br>\n仔细思考一下，发现第二种情况里面的两种情况可以融合，说白点就是取图中i到mx的距离和图中一半绿线距离中的最小值，即<span class=\"math inline\">\\(radius[i]=min(radius[j],mx-i)\\)</span>。然后再进行向外扩展，看radius[i]能否更大。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">radius[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;len; i++)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(mx&gt;i)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(radius[j]&lt;mx-i)</div><div class=\"line\">            radius[i]=radius[j];</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            radius[i]=mx-i;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        radius[i]=<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(;newbuf[i+radius[i]]==newbuf[i-radius[i]]&amp;&amp;i+radius[i]&lt;len&amp;&amp;i-radius[i]&gt;=<span class=\"number\">0</span>;radius[i]++);</div><div class=\"line\">    <span class=\"comment\">// 更新id，mx</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(radius[i]+i&gt;mx)&#123;</div><div class=\"line\">        id=i;</div><div class=\"line\">        mx=radius[i]+i;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><p>[完整代码](/assets/attachs/1032.c.txt)</p></li>\n</ol>\n<h2 id=\"举一反三\">举一反三</h2>\n<p>无</p>\n","site":{"data":{}},"excerpt":"<p>题目很简单，就是求解一个字符串中最长的回文子串，回文字符串是指颠倒之后的字符串和原来的字符串完全一样。网上很多人的博文，像<a href=\"http://blog.csdn.net/kangroger/article/details/37742639\" target=\"_blank\" rel=\"external\">kangroger</a>,还有把最牛b的Manacher算法说得很清晰的<a href=\"http://blog.csdn.net/pi9nc/article/details/9251455\" target=\"_blank\" rel=\"external\">pi9nc</a>和<a href=\"http://blog.csdn.net/yzl_rex/article/details/7908259\" target=\"_blank\" rel=\"external\">yzl_rex</a>，介绍了四种解法：分别是暴力法（<span class=\"math inline\">\\(O(n^3)\\)</span>），动态规划（<span class=\"math inline\">\\(O(n^2)\\)</span>），中心扩展（<span class=\"math inline\">\\(O(n^2)\\)</span>）和Manache法（<span class=\"math inline\">\\(O(n)\\)</span>）。本博文只是对这四种方法的自我实现。","more":"</p>\n<h2 id=\"题目\">题目</h2>\n<p>题目来自HiHoCoder上第一周的题目<a href=\"http://hihocoder.com/contest/hiho1/problem/1\" target=\"_blank\" rel=\"external\">最长回文子串</a>，题目大意是： &gt; 给定一个字符串，求解这个字符串中最长的回文子串。而回文字符串是指颠倒之后的字符串和原来的字符串完全一样。</p>\n<h2 id=\"思路\">思路</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>暴力求解<br>\n暴力求解的方法分两步，第一步是得到字符串所有的子串（<span class=\"math inline\">\\(n\\times(n+1)/2\\)</span>个），第二步是判断每一个子串是否是回文子串（<span class=\"math inline\">\\(n/2\\)</span>比较操作），如果是则记录下长度，不是则舍弃。所以暴力求解方法的时间复杂度为<span class=\"math inline\">\\(O(n^3)\\)</span>。</p></li>\n<li><p>动态优化<br>\n这里的动态优化说白了就是一种空间换时间的解法。其具体的做法就是在一个二维数组dp中记录下i到j是否是回文，即dp[i][j]=1/0,那么要判断dp[m][n]是否是回文就得看$ dp[m-1][n-1] = 1 &amp;&amp; buf[m] = [n] <span class=\"math inline\">\\(。由于要填充这样\\)</span>n<sup>2<span class=\"math inline\">\\(的二维数组，所以动态优化解法的时间复杂度\\)</span>O(n</sup>2)$。</p></li>\n<li><p>中心扩展<br>\n中心扩展的思路很简单，就是以字符串中某个字符为中心，然后向两边对称扩展，判断最边缘字符是否相等，以此来统计回文子串的长度。不过这里面要注意回文子串的长度可能为偶数，也就是说它以两个字符的中间为对称中心。所以要分两种情况考虑，总的来说，中心扩展方法的时间复杂度为<span class=\"math inline\">\\(O(n^2)\\)</span>。</p></li>\n<li><p>Manacher算法<br>\n你猜测的没，该算法就是这个叫Manacher的人想出的算法，用于解决最长回文子串问题，其时间复杂度能达到<span class=\"math inline\">\\(O(n)\\)</span>。该算法的核心思想是充分利用回文字符串的对称性，即利用前面已经算得的对称半径减少或直接求取当前要求的对称半径。下个部分将详细解释该算法。</p></li>\n</ol>\n<h2 id=\"算法说明\">算法说明</h2>\n<p>这里主要说明动态规划算法和Manacher算法。重点在Mancher算法，而动态规划算法只是提一下其中二维数组的动态申请。 ### 动态规划算法 1. 二维数组的动态申请用c实现的步骤： 1. 申请一个长度为len的指针数组(int **)dp，用来存放二维数组每行的首地址。 2. 给dp[0]申请一个len*len的数组，用于存放具体数据。 3. 给dp[i]赋上二维数组每行首地址。 4. <span class=\"math inline\">\\(\\cdots\\)</span> 5. 释放数组dp[0] 6. 释放指针数组dp 2. 代码演示</p>\n<pre><code><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 动态申请二位数组并初始化</span></div><div class=\"line\"><span class=\"keyword\">int</span> **dp = (<span class=\"keyword\">int</span> **)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span> *) * len);</div><div class=\"line\">dp[<span class=\"number\">0</span>] = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * len * len);</div><div class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;len; i++)</div><div class=\"line\">    dp[i] = dp[i<span class=\"number\">-1</span>] + len;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 释放申请的二位数组</span></div><div class=\"line\"><span class=\"built_in\">free</span>(dp[<span class=\"number\">0</span>]);</div><div class=\"line\"><span class=\"built_in\">free</span>(dp);</div></pre></td></tr></table></figure></code></pre>\n<h3 id=\"mancher算法\">Mancher算法</h3>\n<ol style=\"list-style-type: decimal\">\n<li>假设<br>\n为解释清楚Manacher算法，作如下假定：\n<ul>\n<li>所有的回文子串的数目都是奇数（通过向字符首尾和字符间插入特殊字符集’#’实现）</li>\n<li>辅助数组radius用来存储对称半径。即radius[i]表示以第i个字符为中心构成的回文子串的半径。像字符串“#a#”的回文半径为1。</li>\n</ul></li>\n<li>符号说明<br>\n如下图所示，我们要根据回文字符串buf和radius[0]～radius[i-1]来求取radius[i]。 [manacher]({{site.baseurl}}/assets/images/manacher.png)<br>\n图中符号说明如下：\n<ul>\n<li>id表示以前i个字符中第id个字符为中心构成的回文子串最右边字符的索引值最大，即<span class=\"math inline\">\\(id = argmax(radius[k]+k),k&lt;i\\)</span>。易知$ id&lt;i $。</li>\n<li>mx表示以第id个字符为中心构成的回文子串最右边字符的索引值，即$mx = radius[id]+id, id&lt;i $。</li>\n<li>j是i关于id的对称点，即$ j = 2 * id - i $。</li>\n</ul></li>\n<li>分情况讨论\n<ol style=\"list-style-type: decimal\">\n<li><p>==$ mx &lt; i$==<br>\n此时radius的前i个值不起任何作用，就像初始时根据radius[0]=0求解radius[1]，此时id=0,mx=0。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(mx&lt;i)&#123;</div><div class=\"line\">    k=<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"comment\">// 以i为中心，回文子串的半径</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(newbuf[i-k]==newbuf[i+k]&amp;&amp;i-k&gt;=<span class=\"number\">0</span>&amp;&amp;i+k&lt;len)</div><div class=\"line\">        k++;</div><div class=\"line\">    radius[i]=k<span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><p>==$ mx &gt; i <span class=\"math inline\">\\(== 1. ==\\)</span> mx-i &gt;= radius[j] $==<br>\n<span class=\"math inline\">\\(mx-i\\)</span>代表i到mx的距离，而radius[j]就是图中绿线的一半距离。如果<span class=\"math inline\">\\(mx-i &gt; radius[j]\\)</span>说明<span class=\"math inline\">\\(radius[i]=radius[j]\\)</span>，因为$[2*id-mx,mx]是关于id对称的，而i和j也是关于id对称的。</p>\n<pre><code><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(mx-i &gt;= radius[j])</div><div class=\"line\">    radius[i]=radius[j];</div></pre></td></tr></table></figure></code></pre>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li><p>==$ mx-i &lt; radius[j]<span class=\"math inline\">\\(== 此时我们根据对称性，能够获得\\)</span>radius[i]&gt;=radius[j]<span class=\"math inline\">\\(的。所以我们直接从mx+1开始判断\\)</span>buf[mx+t]==buf[2*i-mx-t],t=1,2,$。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(mx-i&lt;radius[j])&#123;</div><div class=\"line\">    k=mx-i+<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"comment\">// 以i为中心，回文子串的半径从mx-i+1开始验证</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(newbuf[i-k]==newbuf[i+k]&amp;&amp;i-k&gt;=<span class=\"number\">0</span>&amp;&amp;i+k&lt;len)</div><div class=\"line\">        k++;</div><div class=\"line\">    radius[i]=k<span class=\"number\">-1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ol></li>\n<li><p>情况融合<br>\n仔细思考一下，发现第二种情况里面的两种情况可以融合，说白点就是取图中i到mx的距离和图中一半绿线距离中的最小值，即<span class=\"math inline\">\\(radius[i]=min(radius[j],mx-i)\\)</span>。然后再进行向外扩展，看radius[i]能否更大。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">radius[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;len; i++)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(mx&gt;i)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(radius[j]&lt;mx-i)</div><div class=\"line\">            radius[i]=radius[j];</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            radius[i]=mx-i;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        radius[i]=<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(;newbuf[i+radius[i]]==newbuf[i-radius[i]]&amp;&amp;i+radius[i]&lt;len&amp;&amp;i-radius[i]&gt;=<span class=\"number\">0</span>;radius[i]++);</div><div class=\"line\">    <span class=\"comment\">// 更新id，mx</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(radius[i]+i&gt;mx)&#123;</div><div class=\"line\">        id=i;</div><div class=\"line\">        mx=radius[i]+i;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n<li><p>[完整代码](/assets/attachs/1032.c.txt)</p></li>\n</ol>\n<h2 id=\"举一反三\">举一反三</h2>\n<p>无</p>"},{"layout":"post","title":"ACM解题报告之格雷码","comments":1,"_content":"**格雷码**（Gray Code）是指在一组数的编码中，任意两个相邻的代码只有一位二进制数不同，则称这种代码为格雷码。另外由于最大数和最小数之间也仅有一位数不同，即“首尾相连”，因此又称为**循环码***或***反射码**。这篇博文主要介绍怎样用递归的方式构造格雷码以及格雷码与8421码之间的转换。\n<!-- more -->\n\n\n## 简介\n在数字系统中，通常要求代码按一定顺序变化。例如，按自然数递增计数，若采用8421码，则数0111变到1000时四位均需要变化，而在实际电路中，四位的变化不可能绝对同时发生，则计数中可能出现短暂的其他编码（1100,1111等），在特定情况下可能导致电路状态或输出错误。而使用格雷码可以避免这种错误。这也是**格雷码**叫**循环码**的原因。而叫它**反射码**的原因在于常见的编码生成方式是反射或镜像。\n\n## 题目\n题目的来源有两个，一个是最近腾讯笔试的编程题：给定一个编码位数n，用递归的方式输出这串n位格雷码，而另一题目是[LeetCode](https://leetcode.com/problems/gray-code/)上的第87题，就是给出一个编码位数n，以十进制的方式输出这串n位格雷码。\n\n## 思路\n1. 反射或镜像\n之所以称**格雷码**叫**反射码**，是因为通过反射可以构造**格雷码**。下面这附图通过n的增大来体现何为**反射码**.\n![gray.png]({{site.baseurl}}/assets/images/gray.png)\n\n图中的虚线就是反射的反射面，也是镜像的镜面。而由n变化到n+1,只需将n的格雷码镜像翻转后，上面的镜像前面添0,下面的镜像前面添1。除此之外，还可以发现以下的规律：\n\n    > 假定正常顺序是先出现0再出现1，那么：\n    > 如果第i位前面出现偶数个1,那么第i位就是正常顺序;\n    > 如果第i位前面出现奇数个1,那么第i位就是不正常顺序。\n\n2. 格雷码和8421码的转换\n其实格雷码和我们经常使用的8421码之间是可以直接转换的，也就是说给定一个数值为k的8421码可以直接得出第k个格雷码。当然给定一个格雷码也可以直接获得这个格雷码对应的8421码。那么这就需要知道格雷码和8421码之间的对应关系。下图将给个详细的解释。\n![8421.png]({{site.baseurl}}/assets/images/8421.png)\n\n图中第一个矩形表示的是格雷码和8421码的对应关系。\n\n    > **Tips:**  \n    > 对于格雷码的序列有多种，这里采用的是最常见的一种方式。\n图中第二个矩形表示的是格雷码和8421码之间的转换关系。由图中可以看出由格雷码转换到8421码时，有如下的对应关系：\n$$\n    8421[0]=Gray[0];            i=0\n$$$$\n    8421[i]=Gray[i] \\wedge Gray[i-1];  i>0\n$$\n同理我们可以得到8421码到格雷码的转换，转换关系如下：\n$$\n    Gray[0]=8421[0];            i=0\n$$$$\n    Gray[i]=\\backsim (8421[i] \\wedge 8421[i-1]);  i>0\n$$\n\n## 算法说明\n1. 通过递归的方式构造格雷码\n\n    ```c\n    // bin[]    存放二进制编码\n    // ind      确定第ind的编码\n    // sum      前ind位有多少个1\n    // num      编码的位数\n    void GrayCode(int bin[], int ind, int sum, int num){\n        int i;\n        if(ind==num){\n            // 输出显示\n            for(i=0; i<num; i++)\n                printf(\"%d \",bin[i]);\n            printf(\"\\n\");\n            return;\n        }else {\n            if(sum%2==0){\n                // 前ind位有偶数个1，正常顺序\n                bin[ind]=0;\n                GrayCode(bin,ind+1,sum,num);\n                bin[ind]=1;\n                GrayCode(bin,ind+1,sum+1,num);\n            }else{\n                // 前ind位有奇数个1,不正常顺序\n                bin[ind]=1;\n                GrayCode(bin,ind+1,sum+1,num);\n                bin[ind]=0;\n                GrayCode(bin,ind+1,sum,num);\n            }\n        }\n    }\n    ```\n    [源码]({{site.baseurl}}/assets/attachs/gray.c.txt)\n2. 8421码转换到格雷码\n\n    ```c\n    // n        编码位数\n    // returnSize   存放返回8421码数组的长度\n    // return   8421码数组\n    int* GrayCode(int n, int* returnSize) {\n        int i;\n        // 数组长度\n        *returnSize = 1<<n;\n        int* gray=malloc((*returnSize)*sizeof(int));\n        for(i=0; i<*returnSize; i++){\n            // 格雷码转换为8421码，一步到位\n            gray[i]=i^(i>>1);\n        }\n\n        return gray;\n    }\n    ```\n    [源码]({{site.baseurl}}/assets/attachs/89.c.txt)\n\n## 举一反三\n格雷码转换到8421码也可以用位运算一步解决：\n$$\n    8421=～(Gray \\wedge (Gray>>1));\n$$\n","source":"_posts/2015-09-07-ACM解题报告之格雷码.md","raw":"---\nlayout:\tpost\ntitle:\tACM解题报告之格雷码\ncategories:\n- TECHNOLOGY\ntags:\n- ACM\n- LeetCode\n- Report\npermalink:  Solve-gray-ACM\ncomments:\ttrue\n---\n**格雷码**（Gray Code）是指在一组数的编码中，任意两个相邻的代码只有一位二进制数不同，则称这种代码为格雷码。另外由于最大数和最小数之间也仅有一位数不同，即“首尾相连”，因此又称为**循环码***或***反射码**。这篇博文主要介绍怎样用递归的方式构造格雷码以及格雷码与8421码之间的转换。\n<!-- more -->\n\n\n## 简介\n在数字系统中，通常要求代码按一定顺序变化。例如，按自然数递增计数，若采用8421码，则数0111变到1000时四位均需要变化，而在实际电路中，四位的变化不可能绝对同时发生，则计数中可能出现短暂的其他编码（1100,1111等），在特定情况下可能导致电路状态或输出错误。而使用格雷码可以避免这种错误。这也是**格雷码**叫**循环码**的原因。而叫它**反射码**的原因在于常见的编码生成方式是反射或镜像。\n\n## 题目\n题目的来源有两个，一个是最近腾讯笔试的编程题：给定一个编码位数n，用递归的方式输出这串n位格雷码，而另一题目是[LeetCode](https://leetcode.com/problems/gray-code/)上的第87题，就是给出一个编码位数n，以十进制的方式输出这串n位格雷码。\n\n## 思路\n1. 反射或镜像\n之所以称**格雷码**叫**反射码**，是因为通过反射可以构造**格雷码**。下面这附图通过n的增大来体现何为**反射码**.\n![gray.png]({{site.baseurl}}/assets/images/gray.png)\n\n图中的虚线就是反射的反射面，也是镜像的镜面。而由n变化到n+1,只需将n的格雷码镜像翻转后，上面的镜像前面添0,下面的镜像前面添1。除此之外，还可以发现以下的规律：\n\n    > 假定正常顺序是先出现0再出现1，那么：\n    > 如果第i位前面出现偶数个1,那么第i位就是正常顺序;\n    > 如果第i位前面出现奇数个1,那么第i位就是不正常顺序。\n\n2. 格雷码和8421码的转换\n其实格雷码和我们经常使用的8421码之间是可以直接转换的，也就是说给定一个数值为k的8421码可以直接得出第k个格雷码。当然给定一个格雷码也可以直接获得这个格雷码对应的8421码。那么这就需要知道格雷码和8421码之间的对应关系。下图将给个详细的解释。\n![8421.png]({{site.baseurl}}/assets/images/8421.png)\n\n图中第一个矩形表示的是格雷码和8421码的对应关系。\n\n    > **Tips:**  \n    > 对于格雷码的序列有多种，这里采用的是最常见的一种方式。\n图中第二个矩形表示的是格雷码和8421码之间的转换关系。由图中可以看出由格雷码转换到8421码时，有如下的对应关系：\n$$\n    8421[0]=Gray[0];            i=0\n$$$$\n    8421[i]=Gray[i] \\wedge Gray[i-1];  i>0\n$$\n同理我们可以得到8421码到格雷码的转换，转换关系如下：\n$$\n    Gray[0]=8421[0];            i=0\n$$$$\n    Gray[i]=\\backsim (8421[i] \\wedge 8421[i-1]);  i>0\n$$\n\n## 算法说明\n1. 通过递归的方式构造格雷码\n\n    ```c\n    // bin[]    存放二进制编码\n    // ind      确定第ind的编码\n    // sum      前ind位有多少个1\n    // num      编码的位数\n    void GrayCode(int bin[], int ind, int sum, int num){\n        int i;\n        if(ind==num){\n            // 输出显示\n            for(i=0; i<num; i++)\n                printf(\"%d \",bin[i]);\n            printf(\"\\n\");\n            return;\n        }else {\n            if(sum%2==0){\n                // 前ind位有偶数个1，正常顺序\n                bin[ind]=0;\n                GrayCode(bin,ind+1,sum,num);\n                bin[ind]=1;\n                GrayCode(bin,ind+1,sum+1,num);\n            }else{\n                // 前ind位有奇数个1,不正常顺序\n                bin[ind]=1;\n                GrayCode(bin,ind+1,sum+1,num);\n                bin[ind]=0;\n                GrayCode(bin,ind+1,sum,num);\n            }\n        }\n    }\n    ```\n    [源码]({{site.baseurl}}/assets/attachs/gray.c.txt)\n2. 8421码转换到格雷码\n\n    ```c\n    // n        编码位数\n    // returnSize   存放返回8421码数组的长度\n    // return   8421码数组\n    int* GrayCode(int n, int* returnSize) {\n        int i;\n        // 数组长度\n        *returnSize = 1<<n;\n        int* gray=malloc((*returnSize)*sizeof(int));\n        for(i=0; i<*returnSize; i++){\n            // 格雷码转换为8421码，一步到位\n            gray[i]=i^(i>>1);\n        }\n\n        return gray;\n    }\n    ```\n    [源码]({{site.baseurl}}/assets/attachs/89.c.txt)\n\n## 举一反三\n格雷码转换到8421码也可以用位运算一步解决：\n$$\n    8421=～(Gray \\wedge (Gray>>1));\n$$\n","slug":"Solve-gray-ACM","published":1,"date":"2015-09-06T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1j001il73y3wcjizwq","content":"<p><strong>格雷码</strong>（Gray Code）是指在一组数的编码中，任意两个相邻的代码只有一位二进制数不同，则称这种代码为格雷码。另外由于最大数和最小数之间也仅有一位数不同，即“首尾相连”，因此又称为<strong>循环码</strong><em>或</em><strong>反射码</strong>。这篇博文主要介绍怎样用递归的方式构造格雷码以及格雷码与8421码之间的转换。 <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p>在数字系统中，通常要求代码按一定顺序变化。例如，按自然数递增计数，若采用8421码，则数0111变到1000时四位均需要变化，而在实际电路中，四位的变化不可能绝对同时发生，则计数中可能出现短暂的其他编码（1100,1111等），在特定情况下可能导致电路状态或输出错误。而使用格雷码可以避免这种错误。这也是<strong>格雷码</strong>叫<strong>循环码</strong>的原因。而叫它<strong>反射码</strong>的原因在于常见的编码生成方式是反射或镜像。</p>\n<h2 id=\"题目\">题目</h2>\n<p>题目的来源有两个，一个是最近腾讯笔试的编程题：给定一个编码位数n，用递归的方式输出这串n位格雷码，而另一题目是<a href=\"https://leetcode.com/problems/gray-code/\" target=\"_blank\" rel=\"external\">LeetCode</a>上的第87题，就是给出一个编码位数n，以十进制的方式输出这串n位格雷码。</p>\n<h2 id=\"思路\">思路</h2>\n<ol style=\"list-style-type: decimal\">\n<li>反射或镜像 之所以称<strong>格雷码</strong>叫<strong>反射码</strong>，是因为通过反射可以构造<strong>格雷码</strong>。下面这附图通过n的增大来体现何为<strong>反射码</strong>. [gray.png](/assets/images/gray.png)</li>\n</ol>\n<p>图中的虚线就是反射的反射面，也是镜像的镜面。而由n变化到n+1,只需将n的格雷码镜像翻转后，上面的镜像前面添0,下面的镜像前面添1。除此之外，还可以发现以下的规律：</p>\n<pre><code>&gt; 假定正常顺序是先出现0再出现1，那么：\n&gt; 如果第i位前面出现偶数个1,那么第i位就是正常顺序;\n&gt; 如果第i位前面出现奇数个1,那么第i位就是不正常顺序。</code></pre>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>格雷码和8421码的转换 其实格雷码和我们经常使用的8421码之间是可以直接转换的，也就是说给定一个数值为k的8421码可以直接得出第k个格雷码。当然给定一个格雷码也可以直接获得这个格雷码对应的8421码。那么这就需要知道格雷码和8421码之间的对应关系。下图将给个详细的解释。 [8421.png](/assets/images/8421.png)</li>\n</ol>\n<p>图中第一个矩形表示的是格雷码和8421码的对应关系。</p>\n<pre><code>&gt; **Tips:**  \n&gt; 对于格雷码的序列有多种，这里采用的是最常见的一种方式。</code></pre>\n<p>图中第二个矩形表示的是格雷码和8421码之间的转换关系。由图中可以看出由格雷码转换到8421码时，有如下的对应关系： <span class=\"math display\">\\[\n    8421[0]=Gray[0];            i=0\n\\]</span><span class=\"math display\">\\[\n    8421[i]=Gray[i] \\wedge Gray[i-1];  i&gt;0\n\\]</span> 同理我们可以得到8421码到格雷码的转换，转换关系如下： <span class=\"math display\">\\[\n    Gray[0]=8421[0];            i=0\n\\]</span><span class=\"math display\">\\[\n    Gray[i]=\\backsim (8421[i] \\wedge 8421[i-1]);  i&gt;0\n\\]</span></p>\n<h2 id=\"算法说明\">算法说明</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>通过递归的方式构造格雷码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bin[]    存放二进制编码</span></div><div class=\"line\"><span class=\"comment\">// ind      确定第ind的编码</span></div><div class=\"line\"><span class=\"comment\">// sum      前ind位有多少个1</span></div><div class=\"line\"><span class=\"comment\">// num      编码的位数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GrayCode</span><span class=\"params\">(<span class=\"keyword\">int</span> bin[], <span class=\"keyword\">int</span> ind, <span class=\"keyword\">int</span> sum, <span class=\"keyword\">int</span> num)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ind==num)&#123;</div><div class=\"line\">        <span class=\"comment\">// 输出显示</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;num; i++)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,bin[i]);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(sum%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</div><div class=\"line\">            <span class=\"comment\">// 前ind位有偶数个1，正常顺序</span></div><div class=\"line\">            bin[ind]=<span class=\"number\">0</span>;</div><div class=\"line\">            GrayCode(bin,ind+<span class=\"number\">1</span>,sum,num);</div><div class=\"line\">            bin[ind]=<span class=\"number\">1</span>;</div><div class=\"line\">            GrayCode(bin,ind+<span class=\"number\">1</span>,sum+<span class=\"number\">1</span>,num);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 前ind位有奇数个1,不正常顺序</span></div><div class=\"line\">            bin[ind]=<span class=\"number\">1</span>;</div><div class=\"line\">            GrayCode(bin,ind+<span class=\"number\">1</span>,sum+<span class=\"number\">1</span>,num);</div><div class=\"line\">            bin[ind]=<span class=\"number\">0</span>;</div><div class=\"line\">            GrayCode(bin,ind+<span class=\"number\">1</span>,sum,num);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n[源码](/assets/attachs/gray.c.txt)</li>\n<li><p>8421码转换到格雷码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// n        编码位数</span></div><div class=\"line\"><span class=\"comment\">// returnSize   存放返回8421码数组的长度</span></div><div class=\"line\"><span class=\"comment\">// return   8421码数组</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">GrayCode</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    <span class=\"comment\">// 数组长度</span></div><div class=\"line\">    *returnSize = <span class=\"number\">1</span>&lt;&lt;n;</div><div class=\"line\">    <span class=\"keyword\">int</span>* gray=<span class=\"built_in\">malloc</span>((*returnSize)*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</div><div class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;*returnSize; i++)&#123;</div><div class=\"line\">        <span class=\"comment\">// 格雷码转换为8421码，一步到位</span></div><div class=\"line\">        gray[i]=i^(i&gt;&gt;<span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> gray;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>[源码](/assets/attachs/89.c.txt)</p></li>\n</ol>\n<h2 id=\"举一反三\">举一反三</h2>\n<p>格雷码转换到8421码也可以用位运算一步解决： <span class=\"math display\">\\[\n    8421=～(Gray \\wedge (Gray&gt;&gt;1));\n\\]</span></p>\n","site":{"data":{}},"excerpt":"<p><strong>格雷码</strong>（Gray Code）是指在一组数的编码中，任意两个相邻的代码只有一位二进制数不同，则称这种代码为格雷码。另外由于最大数和最小数之间也仅有一位数不同，即“首尾相连”，因此又称为<strong>循环码</strong><em>或</em><strong>反射码</strong>。这篇博文主要介绍怎样用递归的方式构造格雷码以及格雷码与8421码之间的转换。","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p>在数字系统中，通常要求代码按一定顺序变化。例如，按自然数递增计数，若采用8421码，则数0111变到1000时四位均需要变化，而在实际电路中，四位的变化不可能绝对同时发生，则计数中可能出现短暂的其他编码（1100,1111等），在特定情况下可能导致电路状态或输出错误。而使用格雷码可以避免这种错误。这也是<strong>格雷码</strong>叫<strong>循环码</strong>的原因。而叫它<strong>反射码</strong>的原因在于常见的编码生成方式是反射或镜像。</p>\n<h2 id=\"题目\">题目</h2>\n<p>题目的来源有两个，一个是最近腾讯笔试的编程题：给定一个编码位数n，用递归的方式输出这串n位格雷码，而另一题目是<a href=\"https://leetcode.com/problems/gray-code/\" target=\"_blank\" rel=\"external\">LeetCode</a>上的第87题，就是给出一个编码位数n，以十进制的方式输出这串n位格雷码。</p>\n<h2 id=\"思路\">思路</h2>\n<ol style=\"list-style-type: decimal\">\n<li>反射或镜像 之所以称<strong>格雷码</strong>叫<strong>反射码</strong>，是因为通过反射可以构造<strong>格雷码</strong>。下面这附图通过n的增大来体现何为<strong>反射码</strong>. [gray.png](/assets/images/gray.png)</li>\n</ol>\n<p>图中的虚线就是反射的反射面，也是镜像的镜面。而由n变化到n+1,只需将n的格雷码镜像翻转后，上面的镜像前面添0,下面的镜像前面添1。除此之外，还可以发现以下的规律：</p>\n<pre><code>&gt; 假定正常顺序是先出现0再出现1，那么：\n&gt; 如果第i位前面出现偶数个1,那么第i位就是正常顺序;\n&gt; 如果第i位前面出现奇数个1,那么第i位就是不正常顺序。</code></pre>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>格雷码和8421码的转换 其实格雷码和我们经常使用的8421码之间是可以直接转换的，也就是说给定一个数值为k的8421码可以直接得出第k个格雷码。当然给定一个格雷码也可以直接获得这个格雷码对应的8421码。那么这就需要知道格雷码和8421码之间的对应关系。下图将给个详细的解释。 [8421.png](/assets/images/8421.png)</li>\n</ol>\n<p>图中第一个矩形表示的是格雷码和8421码的对应关系。</p>\n<pre><code>&gt; **Tips:**  \n&gt; 对于格雷码的序列有多种，这里采用的是最常见的一种方式。</code></pre>\n<p>图中第二个矩形表示的是格雷码和8421码之间的转换关系。由图中可以看出由格雷码转换到8421码时，有如下的对应关系： <span class=\"math display\">\\[\n    8421[0]=Gray[0];            i=0\n\\]</span><span class=\"math display\">\\[\n    8421[i]=Gray[i] \\wedge Gray[i-1];  i&gt;0\n\\]</span> 同理我们可以得到8421码到格雷码的转换，转换关系如下： <span class=\"math display\">\\[\n    Gray[0]=8421[0];            i=0\n\\]</span><span class=\"math display\">\\[\n    Gray[i]=\\backsim (8421[i] \\wedge 8421[i-1]);  i&gt;0\n\\]</span></p>\n<h2 id=\"算法说明\">算法说明</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>通过递归的方式构造格雷码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bin[]    存放二进制编码</span></div><div class=\"line\"><span class=\"comment\">// ind      确定第ind的编码</span></div><div class=\"line\"><span class=\"comment\">// sum      前ind位有多少个1</span></div><div class=\"line\"><span class=\"comment\">// num      编码的位数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GrayCode</span><span class=\"params\">(<span class=\"keyword\">int</span> bin[], <span class=\"keyword\">int</span> ind, <span class=\"keyword\">int</span> sum, <span class=\"keyword\">int</span> num)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ind==num)&#123;</div><div class=\"line\">        <span class=\"comment\">// 输出显示</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;num; i++)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,bin[i]);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(sum%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</div><div class=\"line\">            <span class=\"comment\">// 前ind位有偶数个1，正常顺序</span></div><div class=\"line\">            bin[ind]=<span class=\"number\">0</span>;</div><div class=\"line\">            GrayCode(bin,ind+<span class=\"number\">1</span>,sum,num);</div><div class=\"line\">            bin[ind]=<span class=\"number\">1</span>;</div><div class=\"line\">            GrayCode(bin,ind+<span class=\"number\">1</span>,sum+<span class=\"number\">1</span>,num);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 前ind位有奇数个1,不正常顺序</span></div><div class=\"line\">            bin[ind]=<span class=\"number\">1</span>;</div><div class=\"line\">            GrayCode(bin,ind+<span class=\"number\">1</span>,sum+<span class=\"number\">1</span>,num);</div><div class=\"line\">            bin[ind]=<span class=\"number\">0</span>;</div><div class=\"line\">            GrayCode(bin,ind+<span class=\"number\">1</span>,sum,num);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n[源码](/assets/attachs/gray.c.txt)</li>\n<li><p>8421码转换到格雷码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// n        编码位数</span></div><div class=\"line\"><span class=\"comment\">// returnSize   存放返回8421码数组的长度</span></div><div class=\"line\"><span class=\"comment\">// return   8421码数组</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">GrayCode</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    <span class=\"comment\">// 数组长度</span></div><div class=\"line\">    *returnSize = <span class=\"number\">1</span>&lt;&lt;n;</div><div class=\"line\">    <span class=\"keyword\">int</span>* gray=<span class=\"built_in\">malloc</span>((*returnSize)*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</div><div class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;*returnSize; i++)&#123;</div><div class=\"line\">        <span class=\"comment\">// 格雷码转换为8421码，一步到位</span></div><div class=\"line\">        gray[i]=i^(i&gt;&gt;<span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> gray;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>[源码](/assets/attachs/89.c.txt)</p></li>\n</ol>\n<h2 id=\"举一反三\">举一反三</h2>\n<p>格雷码转换到8421码也可以用位运算一步解决： <span class=\"math display\">\\[\n    8421=～(Gray \\wedge (Gray&gt;&gt;1));\n\\]</span></p>"},{"layout":"post","title":"刨根问底之shell里的运行环境","comments":1,"_content":"在Ubuntu里，我们经常在终端中使用`sudo`来提权--以普通用户的身份去行使管理员的权限（前提是知道管理员用户的密码），这样减少了root用户的登录次数和管理时间，也提高了系统的安全性。不过有时候我们会直接用`su`切换到管理员进行一系列操作。本篇博文就是总结`sudo`，`su`对bash运行环境的影响。明白了这点，你将明白在公司里怎样使用代理。\n<!-- more -->\n\n\n## 起因\n今天在公司准备使用命令行`sudo /opt/logstash/bin/plugin install logstash-output-webhdfs`给logstash安装logstash-output-webhdfs插件，以实现将logstash收集的日志信息存储到Hadoop文件系统这一目的。但是却一直提示如下错误：\n\n> Unable to download data from https://rubygems.org/ - 连接被对端重置 (https://rubygems.global.ssl.fastly.net/latest_specs.4.8.gz)  \n> ERROR: Installation aborted, verification failed for logstash-output-webhdfs\n\n这里公司上网环境是使用了代理。本人在~/.bashrc中添加了`export http_proxy=xxx`和`export https_proxy=xxx`。接下来按照网上的解决方法作了如下尝试，均已失败告终。  \n\n1. 用Google搜索错误提示[Unable to download data from https://rubygems.org][unable]\n2. [手动安装插件logstash-output-webhdfs][manual]\n\n## 必备知识\n1. Windows & Linux 环境变量设置  \n在windows系统里面，经常会遇到[设置环境变量][set_env]的问题，特别是安装完Java JDK之后。我们很少在黑漆漆的命令行窗口中执行命令`set path=%path%;D:\\jdk\\bin`,因为这样设置只会在这个命令窗口中能识别`java`命令在D:\\jdk\\bin目录里，重新打开一个命令窗口后将无法识别。也就是说该path只对执行那个命令的shell有效。还有两种方法是设置系统变量或用户变量。二者的区别就在于系统变量对所有用户有效，而用户变量只对当前用户有效。经试验，win8系统中二者都无需重启就可以起作用。同理，linux里面对环境变量的设置和windows是共通的。它也有三种方式\n    * 终端中设置\n    执行命令`PATH=$PATH':/home/hjy/program/jdk/bin'`,同样java命令只能在当前窗口中识别，重开一个窗口java命令将无效。\n    * 设置用户变量\n    linux里面关于用户变量的设置是在两个文件中，一个是/etc/profile，另一个是~/.profile。\n    * 设置系统变量\n    linux里面关于系统变量的设置是在/etc/environment文件中。\n\n2. bashrc VS profile  \n我们知道bashrc和profile都是linux系统里面设置环境变量的地方，但是二者也是有区别的。\n    * profile -- 配置shell  \n    profile是配置的意思，是某个用户唯一用来设置环境变量的地方，但是用户可用的shell有多个，像bash，sh，zsh之类的，但像环境变量这种只需要在统一的一个地方初始化就可以了，而这就是profile。而Ubuntu中[/etc/profile]({{site.baseurl}}/assets/attachs/etc_profile.txt)将在用户**第一次**登录（可以是图形也可以是终端）时被执行，其只做两件事。\n        1. 设置shell使用bash（主要执行/etc/bash.bashrc）\n        2. 查看/etc/profile.d中是否有相应的环境变量要设置（该文件夹中每个sh文件都是针对某个应用设置的环境变量，这个叫[可插拔功能][pam]）。\n    而[~/.profile]({{site.baseurl}}/assets/attachs/home.profile.txt)也是在用户**第一次**登录时被执行，其也是做两件事。\n        1. 设置shell使用bash（主要执行~/.bashrc）\n        2. 设置路径包含用户私有的执行文件目录（如果存在）\n    * bashrc -- 配置bash  \n    bashrc看名字就知道，是专门用来给bash做初始化的。像初始化bash的设置，代码补全，别名，颜色等。同理，还会有shrc，zshrc这样的文件存在，只是bash太常用了。在Ubuntu系统中，每次打开bash，[/etc/bash.bashrc]({{site.baseurl}}/assets/attachs/etc_bash.bashrc.txt)就会被执行，进行如下设置。\n        0. ==非交互模式则不进行下面的操作==\n        1. 窗口可调整\n        2. 增强$PS1\n        3. 设置xterm（注释掉了）\n        4. 交互模式中开启命令补全（注释掉了）\n        5. 在bash中使用sudo\n        6. 安装command-not-found包后bash的变化\n    而[~/.bashrc]({{site.baseurl}}/assets/attachs/home.bashrc.txt)中设置的就比较多了，具体可以看文档注释。\n\n3. 四种不同的[shell模式][bash]\n    * 登录模式  \n    进入登录模式的shell需要一个特定的用户名和密码，就像我们按`Ctrl + Alt + F1`进入tty1后输入用户名和密码后成功登录系统的情况。  \n\n        > **Tips:**  \n        > 该模式下，shell会自动执行/etc/profile和~/.profile文件，但不会执行任何bashrc文件，但是在这两个profile里面会手动去执行bashrc文件`. *.bashrc`.  \n    * 非登录模式  \n    非登录模式是指不用登录直接进入shell，它需要在特定用户登录状态下才能进入。就像在终端下直接输入`bash`或`bash -c ‘CMD’`。\n        > **Tips:**  \n        > 该模式下，shell不会自动执行profile文件。\n    * 交互模式  \n    在交互模式的shell中，标准输入，输出和错误都显示在终端上，此时变量`$PS1`一定会被设置。像以`bash`，`bash -i`命令启动。\n        > **Tips:**  \n        > 该模式下（未login），shell会去执行/etc/bash.bashrc和~/.bashrc文件。\n    * 非交互模式  \n    非交互模式就是指shell里面没有交互，像执行命令`bash -c ‘CMD’`，像运行shell脚本等。\n        > **Tips:**  \n        > 该模式下，shell不会执行任何bashrc文件。\n\n4. su VS sudo  \nsu和sudo虽然不是具有相似功能的命令，但是它们的目的大部分情况是为了获取root权限。\n    * su命令是switch user的简写，是用来切换用户的。当不加任何参数时，它将切换到root用户。它需要你想切换到的用户的密码，在输入密码后，你将切换到那个用户的运行环境。\n    * [sudo][sudo]命令是superuser do的简写，能够以root的权限取执行命令，但是它需要的是当前用户的密码，而不是像su需要的是想要切换到的用户的密码。这样需要执行一些需要root权限的命令时就不需要频繁输入root用户的密码，当然前提是当前用户的信息是存档在特殊的文件（/etc/sudoers）中。默认情况下，系统将记住当前用户的密码一段时间，以方便用户不用经常输入密码。\n\n下面我们来讨论一下[sudo和su命令对运行环境的影响][su&sudo]：\n    * sudo\n    * sudo su  \n    bash将以一个交互非登录模式运行，所以只有两个bashrc文件将被执行。所以当用户切换成root后，我们还在当前的工作的目录，而非/root目录。\n    * sudo su -  \n    bash将以登录模式运行的，此时/etc/profile，~/.profile将会被执行，隐形的/etc/bash.bashrc和~/.bashrc也将会被执行。此时，我们的当前目录是/root。\n    * sudo -i\n    -i是--login的简写，所以和sudo su -一样的情况\n    * sudo /bin/bash\n    bash将以非登录模式运行，上面四个文件将不会被执行。\n## 问题关键\n上面提供的\n\n\n## 待解决的问题\n1. /etc/profile文件中首先判断是否存在变量$PS1。该变量是什么时候被创建的？\n\n## 参考文献\n1. [如何设置或更改PATH系统变量][set_env]\n2. [如何更换rubygem镜像的源][unable]\n3. [如何手动安装logstash插件logstash-output-elasticsearch-shield][manual]\n4. [可插拔认证模块][pam]\n5. [维基百科sudo][sudo]\n6. [shell的四种模式][bash]\n7. [su和sudo对运行环境的影响][su&sudo]\n\n[set_env]:  https://www.java.com/zh_CN/download/help/path.xml\n[unable]:   http://www.sjsjw.com/kf_jiagou/article/027841ABA028365.asp\n[manual]:  https://discuss.elastic.co/t/shield-w-logstash-offline-install/25072\n[pam]:      http://baike.baidu.com/link?url=Y8DhEJDs3JgwVb0Cntn8psCW__SPphjQYg2o_iSPF8zQfSm_Gi0w8Squu2jDTt5MoekofzEJ0KxBRcBqd2CPBuRJdxwpa7i7fO3OcnpqQqu\n[sudo]:     https://zh.wikipedia.org/zh/Sudo\n[bash]:    https://wiki.archlinux.org/index.php/Bash_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BC.A0.E7.BB.9F.E6.A8.A1.E5.BC.8F\n[su&sudo]:  http://askubuntu.com/questions/376199/sudo-su-vs-sudo-i-vs-sudo-bin-bash-when-does-it-matter-which-is-used\n","source":"_posts/2015-09-08-刨根问底之shell里的运行环境.md","raw":"---\nlayout:\tpost\ntitle:\t刨根问底之shell里的运行环境\ncategories:\n- TECHNOLOGY\ntags:\n- Ubuntu\n- Shell\npermalink:  Explore-runtime-Shell\ncomments:\ttrue\n---\n在Ubuntu里，我们经常在终端中使用`sudo`来提权--以普通用户的身份去行使管理员的权限（前提是知道管理员用户的密码），这样减少了root用户的登录次数和管理时间，也提高了系统的安全性。不过有时候我们会直接用`su`切换到管理员进行一系列操作。本篇博文就是总结`sudo`，`su`对bash运行环境的影响。明白了这点，你将明白在公司里怎样使用代理。\n<!-- more -->\n\n\n## 起因\n今天在公司准备使用命令行`sudo /opt/logstash/bin/plugin install logstash-output-webhdfs`给logstash安装logstash-output-webhdfs插件，以实现将logstash收集的日志信息存储到Hadoop文件系统这一目的。但是却一直提示如下错误：\n\n> Unable to download data from https://rubygems.org/ - 连接被对端重置 (https://rubygems.global.ssl.fastly.net/latest_specs.4.8.gz)  \n> ERROR: Installation aborted, verification failed for logstash-output-webhdfs\n\n这里公司上网环境是使用了代理。本人在~/.bashrc中添加了`export http_proxy=xxx`和`export https_proxy=xxx`。接下来按照网上的解决方法作了如下尝试，均已失败告终。  \n\n1. 用Google搜索错误提示[Unable to download data from https://rubygems.org][unable]\n2. [手动安装插件logstash-output-webhdfs][manual]\n\n## 必备知识\n1. Windows & Linux 环境变量设置  \n在windows系统里面，经常会遇到[设置环境变量][set_env]的问题，特别是安装完Java JDK之后。我们很少在黑漆漆的命令行窗口中执行命令`set path=%path%;D:\\jdk\\bin`,因为这样设置只会在这个命令窗口中能识别`java`命令在D:\\jdk\\bin目录里，重新打开一个命令窗口后将无法识别。也就是说该path只对执行那个命令的shell有效。还有两种方法是设置系统变量或用户变量。二者的区别就在于系统变量对所有用户有效，而用户变量只对当前用户有效。经试验，win8系统中二者都无需重启就可以起作用。同理，linux里面对环境变量的设置和windows是共通的。它也有三种方式\n    * 终端中设置\n    执行命令`PATH=$PATH':/home/hjy/program/jdk/bin'`,同样java命令只能在当前窗口中识别，重开一个窗口java命令将无效。\n    * 设置用户变量\n    linux里面关于用户变量的设置是在两个文件中，一个是/etc/profile，另一个是~/.profile。\n    * 设置系统变量\n    linux里面关于系统变量的设置是在/etc/environment文件中。\n\n2. bashrc VS profile  \n我们知道bashrc和profile都是linux系统里面设置环境变量的地方，但是二者也是有区别的。\n    * profile -- 配置shell  \n    profile是配置的意思，是某个用户唯一用来设置环境变量的地方，但是用户可用的shell有多个，像bash，sh，zsh之类的，但像环境变量这种只需要在统一的一个地方初始化就可以了，而这就是profile。而Ubuntu中[/etc/profile]({{site.baseurl}}/assets/attachs/etc_profile.txt)将在用户**第一次**登录（可以是图形也可以是终端）时被执行，其只做两件事。\n        1. 设置shell使用bash（主要执行/etc/bash.bashrc）\n        2. 查看/etc/profile.d中是否有相应的环境变量要设置（该文件夹中每个sh文件都是针对某个应用设置的环境变量，这个叫[可插拔功能][pam]）。\n    而[~/.profile]({{site.baseurl}}/assets/attachs/home.profile.txt)也是在用户**第一次**登录时被执行，其也是做两件事。\n        1. 设置shell使用bash（主要执行~/.bashrc）\n        2. 设置路径包含用户私有的执行文件目录（如果存在）\n    * bashrc -- 配置bash  \n    bashrc看名字就知道，是专门用来给bash做初始化的。像初始化bash的设置，代码补全，别名，颜色等。同理，还会有shrc，zshrc这样的文件存在，只是bash太常用了。在Ubuntu系统中，每次打开bash，[/etc/bash.bashrc]({{site.baseurl}}/assets/attachs/etc_bash.bashrc.txt)就会被执行，进行如下设置。\n        0. ==非交互模式则不进行下面的操作==\n        1. 窗口可调整\n        2. 增强$PS1\n        3. 设置xterm（注释掉了）\n        4. 交互模式中开启命令补全（注释掉了）\n        5. 在bash中使用sudo\n        6. 安装command-not-found包后bash的变化\n    而[~/.bashrc]({{site.baseurl}}/assets/attachs/home.bashrc.txt)中设置的就比较多了，具体可以看文档注释。\n\n3. 四种不同的[shell模式][bash]\n    * 登录模式  \n    进入登录模式的shell需要一个特定的用户名和密码，就像我们按`Ctrl + Alt + F1`进入tty1后输入用户名和密码后成功登录系统的情况。  \n\n        > **Tips:**  \n        > 该模式下，shell会自动执行/etc/profile和~/.profile文件，但不会执行任何bashrc文件，但是在这两个profile里面会手动去执行bashrc文件`. *.bashrc`.  \n    * 非登录模式  \n    非登录模式是指不用登录直接进入shell，它需要在特定用户登录状态下才能进入。就像在终端下直接输入`bash`或`bash -c ‘CMD’`。\n        > **Tips:**  \n        > 该模式下，shell不会自动执行profile文件。\n    * 交互模式  \n    在交互模式的shell中，标准输入，输出和错误都显示在终端上，此时变量`$PS1`一定会被设置。像以`bash`，`bash -i`命令启动。\n        > **Tips:**  \n        > 该模式下（未login），shell会去执行/etc/bash.bashrc和~/.bashrc文件。\n    * 非交互模式  \n    非交互模式就是指shell里面没有交互，像执行命令`bash -c ‘CMD’`，像运行shell脚本等。\n        > **Tips:**  \n        > 该模式下，shell不会执行任何bashrc文件。\n\n4. su VS sudo  \nsu和sudo虽然不是具有相似功能的命令，但是它们的目的大部分情况是为了获取root权限。\n    * su命令是switch user的简写，是用来切换用户的。当不加任何参数时，它将切换到root用户。它需要你想切换到的用户的密码，在输入密码后，你将切换到那个用户的运行环境。\n    * [sudo][sudo]命令是superuser do的简写，能够以root的权限取执行命令，但是它需要的是当前用户的密码，而不是像su需要的是想要切换到的用户的密码。这样需要执行一些需要root权限的命令时就不需要频繁输入root用户的密码，当然前提是当前用户的信息是存档在特殊的文件（/etc/sudoers）中。默认情况下，系统将记住当前用户的密码一段时间，以方便用户不用经常输入密码。\n\n下面我们来讨论一下[sudo和su命令对运行环境的影响][su&sudo]：\n    * sudo\n    * sudo su  \n    bash将以一个交互非登录模式运行，所以只有两个bashrc文件将被执行。所以当用户切换成root后，我们还在当前的工作的目录，而非/root目录。\n    * sudo su -  \n    bash将以登录模式运行的，此时/etc/profile，~/.profile将会被执行，隐形的/etc/bash.bashrc和~/.bashrc也将会被执行。此时，我们的当前目录是/root。\n    * sudo -i\n    -i是--login的简写，所以和sudo su -一样的情况\n    * sudo /bin/bash\n    bash将以非登录模式运行，上面四个文件将不会被执行。\n## 问题关键\n上面提供的\n\n\n## 待解决的问题\n1. /etc/profile文件中首先判断是否存在变量$PS1。该变量是什么时候被创建的？\n\n## 参考文献\n1. [如何设置或更改PATH系统变量][set_env]\n2. [如何更换rubygem镜像的源][unable]\n3. [如何手动安装logstash插件logstash-output-elasticsearch-shield][manual]\n4. [可插拔认证模块][pam]\n5. [维基百科sudo][sudo]\n6. [shell的四种模式][bash]\n7. [su和sudo对运行环境的影响][su&sudo]\n\n[set_env]:  https://www.java.com/zh_CN/download/help/path.xml\n[unable]:   http://www.sjsjw.com/kf_jiagou/article/027841ABA028365.asp\n[manual]:  https://discuss.elastic.co/t/shield-w-logstash-offline-install/25072\n[pam]:      http://baike.baidu.com/link?url=Y8DhEJDs3JgwVb0Cntn8psCW__SPphjQYg2o_iSPF8zQfSm_Gi0w8Squu2jDTt5MoekofzEJ0KxBRcBqd2CPBuRJdxwpa7i7fO3OcnpqQqu\n[sudo]:     https://zh.wikipedia.org/zh/Sudo\n[bash]:    https://wiki.archlinux.org/index.php/Bash_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BC.A0.E7.BB.9F.E6.A8.A1.E5.BC.8F\n[su&sudo]:  http://askubuntu.com/questions/376199/sudo-su-vs-sudo-i-vs-sudo-bin-bash-when-does-it-matter-which-is-used\n","slug":"Explore-runtime-Shell","published":1,"date":"2015-09-07T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1j001jl73yfvj5q872","content":"<p>在Ubuntu里，我们经常在终端中使用<code>sudo</code>来提权–以普通用户的身份去行使管理员的权限（前提是知道管理员用户的密码），这样减少了root用户的登录次数和管理时间，也提高了系统的安全性。不过有时候我们会直接用<code>su</code>切换到管理员进行一系列操作。本篇博文就是总结<code>sudo</code>，<code>su</code>对bash运行环境的影响。明白了这点，你将明白在公司里怎样使用代理。 <a id=\"more\"></a></p>\n<h2 id=\"起因\">起因</h2>\n<p>今天在公司准备使用命令行<code>sudo /opt/logstash/bin/plugin install logstash-output-webhdfs</code>给logstash安装logstash-output-webhdfs插件，以实现将logstash收集的日志信息存储到Hadoop文件系统这一目的。但是却一直提示如下错误：</p>\n<blockquote>\n<p>Unable to download data from https://rubygems.org/ - 连接被对端重置 (https://rubygems.global.ssl.fastly.net/latest_specs.4.8.gz)<br>\nERROR: Installation aborted, verification failed for logstash-output-webhdfs</p>\n</blockquote>\n<p>这里公司上网环境是使用了代理。本人在~/.bashrc中添加了<code>export http_proxy=xxx</code>和<code>export https_proxy=xxx</code>。接下来按照网上的解决方法作了如下尝试，均已失败告终。</p>\n<ol style=\"list-style-type: decimal\">\n<li>用Google搜索错误提示<a href=\"http://www.sjsjw.com/kf_jiagou/article/027841ABA028365.asp\" target=\"_blank\" rel=\"external\">Unable to download data from https://rubygems.org</a></li>\n<li><a href=\"https://discuss.elastic.co/t/shield-w-logstash-offline-install/25072\" target=\"_blank\" rel=\"external\">手动安装插件logstash-output-webhdfs</a></li>\n</ol>\n<h2 id=\"必备知识\">必备知识</h2>\n<ol style=\"list-style-type: decimal\">\n<li>Windows &amp; Linux 环境变量设置<br>\n在windows系统里面，经常会遇到<a href=\"https://www.java.com/zh_CN/download/help/path.xml\" target=\"_blank\" rel=\"external\">设置环境变量</a>的问题，特别是安装完Java JDK之后。我们很少在黑漆漆的命令行窗口中执行命令<code>set path=%path%;D:\\jdk\\bin</code>,因为这样设置只会在这个命令窗口中能识别<code>java</code>命令在D:，重新打开一个命令窗口后将无法识别。也就是说该path只对执行那个命令的shell有效。还有两种方法是设置系统变量或用户变量。二者的区别就在于系统变量对所有用户有效，而用户变量只对当前用户有效。经试验，win8系统中二者都无需重启就可以起作用。同理，linux里面对环境变量的设置和windows是共通的。它也有三种方式\n<ul>\n<li>终端中设置 执行命令<code>PATH=$PATH':/home/hjy/program/jdk/bin'</code>,同样java命令只能在当前窗口中识别，重开一个窗口java命令将无效。</li>\n<li>设置用户变量 linux里面关于用户变量的设置是在两个文件中，一个是/etc/profile，另一个是~/.profile。</li>\n<li>设置系统变量 linux里面关于系统变量的设置是在/etc/environment文件中。</li>\n</ul></li>\n<li>bashrc VS profile<br>\n我们知道bashrc和profile都是linux系统里面设置环境变量的地方，但是二者也是有区别的。\n<ul>\n<li>profile – 配置shell<br>\nprofile是配置的意思，是某个用户唯一用来设置环境变量的地方，但是用户可用的shell有多个，像bash，sh，zsh之类的，但像环境变量这种只需要在统一的一个地方初始化就可以了，而这就是profile。而Ubuntu中[/etc/profile](/assets/attachs/etc_profile.txt)将在用户<strong>第一次</strong>登录（可以是图形也可以是终端）时被执行，其只做两件事。\n<ol style=\"list-style-type: decimal\">\n<li>设置shell使用bash（主要执行/etc/bash.bashrc）</li>\n<li>查看/etc/profile.d中是否有相应的环境变量要设置（该文件夹中每个sh文件都是针对某个应用设置的环境变量，这个叫<a href=\"http://baike.baidu.com/link?url=Y8DhEJDs3JgwVb0Cntn8psCW__SPphjQYg2o_iSPF8zQfSm_Gi0w8Squu2jDTt5MoekofzEJ0KxBRcBqd2CPBuRJdxwpa7i7fO3OcnpqQqu\" target=\"_blank\" rel=\"external\">可插拔功能</a>）。 而[~/.profile](/assets/attachs/home.profile.txt)也是在用户<strong>第一次</strong>登录时被执行，其也是做两件事。</li>\n<li>设置shell使用bash（主要执行~/.bashrc）</li>\n<li>设置路径包含用户私有的执行文件目录（如果存在）</li>\n</ol></li>\n<li>bashrc – 配置bash<br>\nbashrc看名字就知道，是专门用来给bash做初始化的。像初始化bash的设置，代码补全，别名，颜色等。同理，还会有shrc，zshrc这样的文件存在，只是bash太常用了。在Ubuntu系统中，每次打开bash，[/etc/bash.bashrc](/assets/attachs/etc_bash.bashrc.txt)就会被执行，进行如下设置。\n<ol start=\"0\" style=\"list-style-type: decimal\">\n<li>==非交互模式则不进行下面的操作==</li>\n<li>窗口可调整</li>\n<li>增强$PS1</li>\n<li>设置xterm（注释掉了）</li>\n<li>交互模式中开启命令补全（注释掉了）</li>\n<li>在bash中使用sudo</li>\n<li>安装command-not-found包后bash的变化 而[~/.bashrc](/assets/attachs/home.bashrc.txt)中设置的就比较多了，具体可以看文档注释。</li>\n</ol></li>\n</ul></li>\n<li>四种不同的<a href=\"https://wiki.archlinux.org/index.php/Bash_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BC.A0.E7.BB.9F.E6.A8.A1.E5.BC.8F\" target=\"_blank\" rel=\"external\">shell模式</a>\n<ul>\n<li><p>登录模式<br>\n进入登录模式的shell需要一个特定的用户名和密码，就像我们按<code>Ctrl + Alt + F1</code>进入tty1后输入用户名和密码后成功登录系统的情况。</p>\n<blockquote>\n<p><strong>Tips:</strong><br>\n该模式下，shell会自动执行/etc/profile和~/.profile文件，但不会执行任何bashrc文件，但是在这两个profile里面会手动去执行bashrc文件<code>. *.bashrc</code>.</p>\n</blockquote></li>\n<li>非登录模式<br>\n非登录模式是指不用登录直接进入shell，它需要在特定用户登录状态下才能进入。就像在终端下直接输入<code>bash</code>或<code>bash -c ‘CMD’</code>。 &gt; <strong>Tips:</strong><br>\n&gt; 该模式下，shell不会自动执行profile文件。</li>\n<li>交互模式<br>\n在交互模式的shell中，标准输入，输出和错误都显示在终端上，此时变量<code>$PS1</code>一定会被设置。像以<code>bash</code>，<code>bash -i</code>命令启动。 &gt; <strong>Tips:</strong><br>\n&gt; 该模式下（未login），shell会去执行/etc/bash.bashrc和~/.bashrc文件。</li>\n<li><p>非交互模式<br>\n非交互模式就是指shell里面没有交互，像执行命令<code>bash -c ‘CMD’</code>，像运行shell脚本等。 &gt; <strong>Tips:</strong><br>\n&gt; 该模式下，shell不会执行任何bashrc文件。</p></li>\n</ul></li>\n<li>su VS sudo<br>\nsu和sudo虽然不是具有相似功能的命令，但是它们的目的大部分情况是为了获取root权限。\n<ul>\n<li>su命令是switch user的简写，是用来切换用户的。当不加任何参数时，它将切换到root用户。它需要你想切换到的用户的密码，在输入密码后，你将切换到那个用户的运行环境。</li>\n<li><a href=\"https://zh.wikipedia.org/zh/Sudo\" target=\"_blank\" rel=\"external\">sudo</a>命令是superuser do的简写，能够以root的权限取执行命令，但是它需要的是当前用户的密码，而不是像su需要的是想要切换到的用户的密码。这样需要执行一些需要root权限的命令时就不需要频繁输入root用户的密码，当然前提是当前用户的信息是存档在特殊的文件（/etc/sudoers）中。默认情况下，系统将记住当前用户的密码一段时间，以方便用户不用经常输入密码。</li>\n</ul></li>\n</ol>\n<p>下面我们来讨论一下<a href=\"http://askubuntu.com/questions/376199/sudo-su-vs-sudo-i-vs-sudo-bin-bash-when-does-it-matter-which-is-used\" target=\"_blank\" rel=\"external\">sudo和su命令对运行环境的影响</a>： * sudo * sudo su<br>\nbash将以一个交互非登录模式运行，所以只有两个bashrc文件将被执行。所以当用户切换成root后，我们还在当前的工作的目录，而非/root目录。 * sudo su -<br>\nbash将以登录模式运行的，此时/etc/profile，<sub>/.profile将会被执行，隐形的/etc/bash.bashrc和</sub>/.bashrc也将会被执行。此时，我们的当前目录是/root。 * sudo -i -i是–login的简写，所以和sudo su -一样的情况 * sudo /bin/bash bash将以非登录模式运行，上面四个文件将不会被执行。 ## 问题关键 上面提供的</p>\n<h2 id=\"待解决的问题\">待解决的问题</h2>\n<ol style=\"list-style-type: decimal\">\n<li>/etc/profile文件中首先判断是否存在变量$PS1。该变量是什么时候被创建的？</li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://www.java.com/zh_CN/download/help/path.xml\" target=\"_blank\" rel=\"external\">如何设置或更改PATH系统变量</a></li>\n<li><a href=\"http://www.sjsjw.com/kf_jiagou/article/027841ABA028365.asp\" target=\"_blank\" rel=\"external\">如何更换rubygem镜像的源</a></li>\n<li><a href=\"https://discuss.elastic.co/t/shield-w-logstash-offline-install/25072\" target=\"_blank\" rel=\"external\">如何手动安装logstash插件logstash-output-elasticsearch-shield</a></li>\n<li><a href=\"http://baike.baidu.com/link?url=Y8DhEJDs3JgwVb0Cntn8psCW__SPphjQYg2o_iSPF8zQfSm_Gi0w8Squu2jDTt5MoekofzEJ0KxBRcBqd2CPBuRJdxwpa7i7fO3OcnpqQqu\" target=\"_blank\" rel=\"external\">可插拔认证模块</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh/Sudo\" target=\"_blank\" rel=\"external\">维基百科sudo</a></li>\n<li><a href=\"https://wiki.archlinux.org/index.php/Bash_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BC.A0.E7.BB.9F.E6.A8.A1.E5.BC.8F\" target=\"_blank\" rel=\"external\">shell的四种模式</a></li>\n<li><a href=\"http://askubuntu.com/questions/376199/sudo-su-vs-sudo-i-vs-sudo-bin-bash-when-does-it-matter-which-is-used\" target=\"_blank\" rel=\"external\">su和sudo对运行环境的影响</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在Ubuntu里，我们经常在终端中使用<code>sudo</code>来提权–以普通用户的身份去行使管理员的权限（前提是知道管理员用户的密码），这样减少了root用户的登录次数和管理时间，也提高了系统的安全性。不过有时候我们会直接用<code>su</code>切换到管理员进行一系列操作。本篇博文就是总结<code>sudo</code>，<code>su</code>对bash运行环境的影响。明白了这点，你将明白在公司里怎样使用代理。","more":"</p>\n<h2 id=\"起因\">起因</h2>\n<p>今天在公司准备使用命令行<code>sudo /opt/logstash/bin/plugin install logstash-output-webhdfs</code>给logstash安装logstash-output-webhdfs插件，以实现将logstash收集的日志信息存储到Hadoop文件系统这一目的。但是却一直提示如下错误：</p>\n<blockquote>\n<p>Unable to download data from https://rubygems.org/ - 连接被对端重置 (https://rubygems.global.ssl.fastly.net/latest_specs.4.8.gz)<br>\nERROR: Installation aborted, verification failed for logstash-output-webhdfs</p>\n</blockquote>\n<p>这里公司上网环境是使用了代理。本人在~/.bashrc中添加了<code>export http_proxy=xxx</code>和<code>export https_proxy=xxx</code>。接下来按照网上的解决方法作了如下尝试，均已失败告终。</p>\n<ol style=\"list-style-type: decimal\">\n<li>用Google搜索错误提示<a href=\"http://www.sjsjw.com/kf_jiagou/article/027841ABA028365.asp\" target=\"_blank\" rel=\"external\">Unable to download data from https://rubygems.org</a></li>\n<li><a href=\"https://discuss.elastic.co/t/shield-w-logstash-offline-install/25072\" target=\"_blank\" rel=\"external\">手动安装插件logstash-output-webhdfs</a></li>\n</ol>\n<h2 id=\"必备知识\">必备知识</h2>\n<ol style=\"list-style-type: decimal\">\n<li>Windows &amp; Linux 环境变量设置<br>\n在windows系统里面，经常会遇到<a href=\"https://www.java.com/zh_CN/download/help/path.xml\" target=\"_blank\" rel=\"external\">设置环境变量</a>的问题，特别是安装完Java JDK之后。我们很少在黑漆漆的命令行窗口中执行命令<code>set path=%path%;D:\\jdk\\bin</code>,因为这样设置只会在这个命令窗口中能识别<code>java</code>命令在D:，重新打开一个命令窗口后将无法识别。也就是说该path只对执行那个命令的shell有效。还有两种方法是设置系统变量或用户变量。二者的区别就在于系统变量对所有用户有效，而用户变量只对当前用户有效。经试验，win8系统中二者都无需重启就可以起作用。同理，linux里面对环境变量的设置和windows是共通的。它也有三种方式\n<ul>\n<li>终端中设置 执行命令<code>PATH=$PATH':/home/hjy/program/jdk/bin'</code>,同样java命令只能在当前窗口中识别，重开一个窗口java命令将无效。</li>\n<li>设置用户变量 linux里面关于用户变量的设置是在两个文件中，一个是/etc/profile，另一个是~/.profile。</li>\n<li>设置系统变量 linux里面关于系统变量的设置是在/etc/environment文件中。</li>\n</ul></li>\n<li>bashrc VS profile<br>\n我们知道bashrc和profile都是linux系统里面设置环境变量的地方，但是二者也是有区别的。\n<ul>\n<li>profile – 配置shell<br>\nprofile是配置的意思，是某个用户唯一用来设置环境变量的地方，但是用户可用的shell有多个，像bash，sh，zsh之类的，但像环境变量这种只需要在统一的一个地方初始化就可以了，而这就是profile。而Ubuntu中[/etc/profile](/assets/attachs/etc_profile.txt)将在用户<strong>第一次</strong>登录（可以是图形也可以是终端）时被执行，其只做两件事。\n<ol style=\"list-style-type: decimal\">\n<li>设置shell使用bash（主要执行/etc/bash.bashrc）</li>\n<li>查看/etc/profile.d中是否有相应的环境变量要设置（该文件夹中每个sh文件都是针对某个应用设置的环境变量，这个叫<a href=\"http://baike.baidu.com/link?url=Y8DhEJDs3JgwVb0Cntn8psCW__SPphjQYg2o_iSPF8zQfSm_Gi0w8Squu2jDTt5MoekofzEJ0KxBRcBqd2CPBuRJdxwpa7i7fO3OcnpqQqu\" target=\"_blank\" rel=\"external\">可插拔功能</a>）。 而[~/.profile](/assets/attachs/home.profile.txt)也是在用户<strong>第一次</strong>登录时被执行，其也是做两件事。</li>\n<li>设置shell使用bash（主要执行~/.bashrc）</li>\n<li>设置路径包含用户私有的执行文件目录（如果存在）</li>\n</ol></li>\n<li>bashrc – 配置bash<br>\nbashrc看名字就知道，是专门用来给bash做初始化的。像初始化bash的设置，代码补全，别名，颜色等。同理，还会有shrc，zshrc这样的文件存在，只是bash太常用了。在Ubuntu系统中，每次打开bash，[/etc/bash.bashrc](/assets/attachs/etc_bash.bashrc.txt)就会被执行，进行如下设置。\n<ol start=\"0\" style=\"list-style-type: decimal\">\n<li>==非交互模式则不进行下面的操作==</li>\n<li>窗口可调整</li>\n<li>增强$PS1</li>\n<li>设置xterm（注释掉了）</li>\n<li>交互模式中开启命令补全（注释掉了）</li>\n<li>在bash中使用sudo</li>\n<li>安装command-not-found包后bash的变化 而[~/.bashrc](/assets/attachs/home.bashrc.txt)中设置的就比较多了，具体可以看文档注释。</li>\n</ol></li>\n</ul></li>\n<li>四种不同的<a href=\"https://wiki.archlinux.org/index.php/Bash_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BC.A0.E7.BB.9F.E6.A8.A1.E5.BC.8F\" target=\"_blank\" rel=\"external\">shell模式</a>\n<ul>\n<li><p>登录模式<br>\n进入登录模式的shell需要一个特定的用户名和密码，就像我们按<code>Ctrl + Alt + F1</code>进入tty1后输入用户名和密码后成功登录系统的情况。</p>\n<blockquote>\n<p><strong>Tips:</strong><br>\n该模式下，shell会自动执行/etc/profile和~/.profile文件，但不会执行任何bashrc文件，但是在这两个profile里面会手动去执行bashrc文件<code>. *.bashrc</code>.</p>\n</blockquote></li>\n<li>非登录模式<br>\n非登录模式是指不用登录直接进入shell，它需要在特定用户登录状态下才能进入。就像在终端下直接输入<code>bash</code>或<code>bash -c ‘CMD’</code>。 &gt; <strong>Tips:</strong><br>\n&gt; 该模式下，shell不会自动执行profile文件。</li>\n<li>交互模式<br>\n在交互模式的shell中，标准输入，输出和错误都显示在终端上，此时变量<code>$PS1</code>一定会被设置。像以<code>bash</code>，<code>bash -i</code>命令启动。 &gt; <strong>Tips:</strong><br>\n&gt; 该模式下（未login），shell会去执行/etc/bash.bashrc和~/.bashrc文件。</li>\n<li><p>非交互模式<br>\n非交互模式就是指shell里面没有交互，像执行命令<code>bash -c ‘CMD’</code>，像运行shell脚本等。 &gt; <strong>Tips:</strong><br>\n&gt; 该模式下，shell不会执行任何bashrc文件。</p></li>\n</ul></li>\n<li>su VS sudo<br>\nsu和sudo虽然不是具有相似功能的命令，但是它们的目的大部分情况是为了获取root权限。\n<ul>\n<li>su命令是switch user的简写，是用来切换用户的。当不加任何参数时，它将切换到root用户。它需要你想切换到的用户的密码，在输入密码后，你将切换到那个用户的运行环境。</li>\n<li><a href=\"https://zh.wikipedia.org/zh/Sudo\" target=\"_blank\" rel=\"external\">sudo</a>命令是superuser do的简写，能够以root的权限取执行命令，但是它需要的是当前用户的密码，而不是像su需要的是想要切换到的用户的密码。这样需要执行一些需要root权限的命令时就不需要频繁输入root用户的密码，当然前提是当前用户的信息是存档在特殊的文件（/etc/sudoers）中。默认情况下，系统将记住当前用户的密码一段时间，以方便用户不用经常输入密码。</li>\n</ul></li>\n</ol>\n<p>下面我们来讨论一下<a href=\"http://askubuntu.com/questions/376199/sudo-su-vs-sudo-i-vs-sudo-bin-bash-when-does-it-matter-which-is-used\" target=\"_blank\" rel=\"external\">sudo和su命令对运行环境的影响</a>： * sudo * sudo su<br>\nbash将以一个交互非登录模式运行，所以只有两个bashrc文件将被执行。所以当用户切换成root后，我们还在当前的工作的目录，而非/root目录。 * sudo su -<br>\nbash将以登录模式运行的，此时/etc/profile，<sub>/.profile将会被执行，隐形的/etc/bash.bashrc和</sub>/.bashrc也将会被执行。此时，我们的当前目录是/root。 * sudo -i -i是–login的简写，所以和sudo su -一样的情况 * sudo /bin/bash bash将以非登录模式运行，上面四个文件将不会被执行。 ## 问题关键 上面提供的</p>\n<h2 id=\"待解决的问题\">待解决的问题</h2>\n<ol style=\"list-style-type: decimal\">\n<li>/etc/profile文件中首先判断是否存在变量$PS1。该变量是什么时候被创建的？</li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://www.java.com/zh_CN/download/help/path.xml\" target=\"_blank\" rel=\"external\">如何设置或更改PATH系统变量</a></li>\n<li><a href=\"http://www.sjsjw.com/kf_jiagou/article/027841ABA028365.asp\" target=\"_blank\" rel=\"external\">如何更换rubygem镜像的源</a></li>\n<li><a href=\"https://discuss.elastic.co/t/shield-w-logstash-offline-install/25072\" target=\"_blank\" rel=\"external\">如何手动安装logstash插件logstash-output-elasticsearch-shield</a></li>\n<li><a href=\"http://baike.baidu.com/link?url=Y8DhEJDs3JgwVb0Cntn8psCW__SPphjQYg2o_iSPF8zQfSm_Gi0w8Squu2jDTt5MoekofzEJ0KxBRcBqd2CPBuRJdxwpa7i7fO3OcnpqQqu\" target=\"_blank\" rel=\"external\">可插拔认证模块</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh/Sudo\" target=\"_blank\" rel=\"external\">维基百科sudo</a></li>\n<li><a href=\"https://wiki.archlinux.org/index.php/Bash_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BC.A0.E7.BB.9F.E6.A8.A1.E5.BC.8F\" target=\"_blank\" rel=\"external\">shell的四种模式</a></li>\n<li><a href=\"http://askubuntu.com/questions/376199/sudo-su-vs-sudo-i-vs-sudo-bin-bash-when-does-it-matter-which-is-used\" target=\"_blank\" rel=\"external\">su和sudo对运行环境的影响</a></li>\n</ol>"},{"layout":"post","title":"shell运行环境之环境配置文件","comments":1,"_content":"[上一篇博文]({{site.baseurl}}/2015/09/08/shell运行环境之环境变量.html)介绍了shell运行环境中三种不同的环境变量--临时变量，用户变量和系统变量，除此之外还有/etc/environment，/etc/profile和～/.profile作用域。这篇文章将主要围绕bash这个shell来讲解[环境配置文件][bash_pro]，并结合shell的四种模式来说明这些配置文件的作用域。\n<!-- more -->\n\n## 简介\n我们知道linux系统中有很多shell，像最常用的bash，不常用的sh，zsh等。而对于它们公共的变量我们不可能为每个shell重复设置，所以这些公共变量我们将会保存在profile中，而对于每个shell个性化的配置将会放在各自的配置文件中，像bashrc，shrc和zshrc。而ubuntu默认用的是bash，所以只有bashrc而没有其他吧。\n\n## profile配置文件\nprofile是配置的意思，是某个用户唯一用来设置环境变量的地方，而用户可用的shell有多个，像bash，sh，zsh之类的，但像环境变量这种只需要在统一的一个地方初始化就可以了，这就需要profile。在Ubuntu中[/etc/profile]({{site.baseurl}}/assets/attachs/etc_profile.txt)将在用户**第一次**登录（可以是图形也可以是终端）时被执行，其只做两件事。  \n\n1. 设置shell使用bash（主要执行/etc/bash.bashrc）  \n2. 查看/etc/profile.d中是否有相应的环境变量要设置（该文件夹中每个sh文件都是针对某个应用设置的环境变量，这个叫[可插拔功能][pam]）。\n\n而[~/.profile]({{site.baseurl}}/assets/attachs/home.profile.txt)也是在用户**第一次**登录时被执行，其也是做两件事。\n\n1. 设置shell使用bash（主要执行~/.bashrc）\n2. 设置路径包含用户私有的执行文件目录（如果存在）\n\n## bashrc配置文件\nbashrc看名字就知道，是专门用来给bash做初始化的。像初始化bash的设置，代码补全，别名，颜色等。同理，还会有shrc，zshrc这样的文件存在，只是bash太常用了。在Ubuntu系统中，每次打开bash，[/etc/bash.bashrc]({{site.baseurl}}/assets/attachs/etc_bash.bashrc.txt)就会被执行，进行如下设置。\n\n0. ==非交互模式则不进行下面的操作==\n1. 窗口可调整\n2. 增强$PS1\n3. 设置xterm（注释掉了）\n4. 交互模式中开启命令补全（注释掉了）\n5. 在bash中使用sudo\n6. 安装command-not-found包后bash的变化\n\n而[~/.bashrc]({{site.baseurl}}/assets/attachs/home.bashrc.txt)中设置的就比较多了，具体可以看文档注释。\n\n## 四种不同的[shell模式][bash]\n* 登录模式  \n进入登录模式的shell需要一个特定的用户名和密码，就像我们按`Ctrl + Alt + F1`进入tty1后输入用户名和密码后成功登录系统的情况。  \n\n\t> **Tips:**  \n\t> 该模式下，shell会自动执行/etc/profile和~/.profile文件，但不会执行任何bashrc文件，但是在这两个profile里面会手动去执行bashrc文件`. *.bashrc`.  \n* 非登录模式  \n非登录模式是指不用登录直接进入shell，它需要在特定用户登录状态下才能进入。就像在终端下直接输入`bash`或`bash -c ‘CMD’`。\n\t> **Tips:**  \n\t> 该模式下，shell不会自动执行profile文件。\n* 交互模式  \n在交互模式的shell中，标准输入，输出和错误都显示在终端上，此时变量`$PS1`一定会被设置。像以`bash`，`bash -i`命令启动。\n\t> **Tips:**  \n\t> 该模式下（未login），shell会去执行/etc/bash.bashrc和~/.bashrc文件。\n* 非交互模式  \n非交互模式就是指shell里面没有交互，像执行命令`bash -c ‘CMD’`，像运行shell脚本等。\n\t> **Tips:**  \n\t> 该模式下，shell不会执行任何bashrc文件。\n\n## 试验\n* 验证四种模式中配置文件的作用域  \n当我们在终端中执行bash命令的时候，它其实在终端中又开了一个外壳，所以我们需要`exit`两次才能退出。所以我们在第一层外壳中设置四个配置文件中变量。设置如下：\n\n\t```sh\n\t# /etc/profile\n\texport epro='I am in /etc/profile'\n\texport epro_ebash='I am in /etc/profile'\n\texport epro_pro='I am in /etc/profile'\n\texport epro_bash='I am in /etc/profile'\n\n\t# /etc/bash.bashrc\n\texport ebash='I am in /etc/bash.bashrc'\n\texport epro_ebash='I am in /etc/bash.bashrc'\n\texport ebash_pro='I am in /etc/bash.bashrc'\n\texport ebash_bash='I am in /etc/bash.bashrc'\n\n\t# ~/.profile\n\texport pro='I am in ~/.profile'\n\texport epro_pro='I am in ~/.profile'\n\texport ebash_pro='I am in ~/.profile'\n\texport pro_bash='I am in ~/.profile'\n\n\t# ~/.bashrc\n\texport bash='I am in ~/.bashrc'\n\texport epro_bash='I am in ~/.bashrc'\n\texport ebash_bash='I am in ~/.bashrc'\n\texport pro_bash='I am in ~/.bashrc'\n\t```\n\t> **Tips:**  \n\t> 上面的变量声明位置要放在各个配置文件前面，但是要放在判别交互和登录模式之后  \n\t> /etc/profile \t\t最前面  \n\t> /etc/bash.bashrc\t前面，但要在判断交互模式之后  \n\t> ~/.profile\t\t最前面  \n\t> ~/.bashrc\t\t\t前面，但要在判断交互模式之后\n\n\t* 试验步骤\n\t\t1. 登录模式  \n\t\t在终端中设置完上面的变量之后，以`bash -l`进入另一个bash，并显示上面的变量值\n\t\t![login]({{site.baseurl}}/assets/images/bash_login.png)  \n\t\t3. 交互模式  \n\t\t在终端中设置完上面的变量之后，以`bash -i`进入另一个bash，并显示上面的变量\n\t\t![inter]({{site.baseurl}}/assets/images/bash_inter.png)\n\t\t4. 打开terminal时，进入的模式  \n\t\t在一个终端中设置完上面的变量后，打开另一个终端，显示上面的变量值\n\t\t![terminal]({{site.baseurl}}/assets/images/terminal.png)  \n\t* 结论\n\t\t1. 登录模式中，四个文件都被执行了，执行的顺序是/etc/profile > /etc/bash.bashrc > ~/.profile > ~/.bashrc\n\t\tepro，pro，ebash，bash都有值，说明四个文件都被执行了。epro_ebash说明/etc/profile先于/etc/bash.bashrc;\n\t\tebash_pro说明/etc/bash.bashrc先于~/.profile;pro_bash说明~/.profile先于~/.bashrc\n\t\t3. 交互模式中，两个profile文件没有被执行，两个bash文件都被执行了，并且/etc/bash.bashrc比~/.bashrc先执行\n\t\tebash，bash都有值，说明bash两个文件都被执行了。ebash_bash说明~/.profile先于~/.bashrc\n\t\t4. 打开terminal时，进入交互模式\n\t\t两个profile文件没有被执行，两个bash文件都被执行了，并且/etc/bash.bashrc比~/.bashrc先执行。此状态和交互模式的状态一致。\n\n\n## 待解决的问题\n1. 非登录模式如何确定？\n2. 之前的所有试验其实都包含了交互模式。非交互模式又如何确定？\n\n## 参考文献\n6. [shell的四种模式][bash]\n1. [理解 bashrc 和 profile][bash_pro]\n2. [Choosing between .bashrc, .profile, .bash_profile, etc][profile]\n\n\n[bash]:\t\thttps://wiki.archlinux.org/index.php/Bash_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BC.A0.E7.BB.9F.E6.A8.A1.E5.BC.8F\n[bash_pro]:\thttps://wido.me/sunteya/understand-bashrc-and-profile\n[profile]:\thttp://superuser.com/questions/789448/choosing-between-bashrc-profile-bash-profile-etc\n","source":"_posts/2015-09-09-shell运行环境之环境配置文件.md","raw":"---\nlayout:\tpost\ntitle:\tshell运行环境之环境配置文件\ncategories:\n- TECHNOLOGY\ntags:\n- Ubuntu\n- Shell\npermalink:  Explore-configure-Shell\ncomments:\ttrue\n---\n[上一篇博文]({{site.baseurl}}/2015/09/08/shell运行环境之环境变量.html)介绍了shell运行环境中三种不同的环境变量--临时变量，用户变量和系统变量，除此之外还有/etc/environment，/etc/profile和～/.profile作用域。这篇文章将主要围绕bash这个shell来讲解[环境配置文件][bash_pro]，并结合shell的四种模式来说明这些配置文件的作用域。\n<!-- more -->\n\n## 简介\n我们知道linux系统中有很多shell，像最常用的bash，不常用的sh，zsh等。而对于它们公共的变量我们不可能为每个shell重复设置，所以这些公共变量我们将会保存在profile中，而对于每个shell个性化的配置将会放在各自的配置文件中，像bashrc，shrc和zshrc。而ubuntu默认用的是bash，所以只有bashrc而没有其他吧。\n\n## profile配置文件\nprofile是配置的意思，是某个用户唯一用来设置环境变量的地方，而用户可用的shell有多个，像bash，sh，zsh之类的，但像环境变量这种只需要在统一的一个地方初始化就可以了，这就需要profile。在Ubuntu中[/etc/profile]({{site.baseurl}}/assets/attachs/etc_profile.txt)将在用户**第一次**登录（可以是图形也可以是终端）时被执行，其只做两件事。  \n\n1. 设置shell使用bash（主要执行/etc/bash.bashrc）  \n2. 查看/etc/profile.d中是否有相应的环境变量要设置（该文件夹中每个sh文件都是针对某个应用设置的环境变量，这个叫[可插拔功能][pam]）。\n\n而[~/.profile]({{site.baseurl}}/assets/attachs/home.profile.txt)也是在用户**第一次**登录时被执行，其也是做两件事。\n\n1. 设置shell使用bash（主要执行~/.bashrc）\n2. 设置路径包含用户私有的执行文件目录（如果存在）\n\n## bashrc配置文件\nbashrc看名字就知道，是专门用来给bash做初始化的。像初始化bash的设置，代码补全，别名，颜色等。同理，还会有shrc，zshrc这样的文件存在，只是bash太常用了。在Ubuntu系统中，每次打开bash，[/etc/bash.bashrc]({{site.baseurl}}/assets/attachs/etc_bash.bashrc.txt)就会被执行，进行如下设置。\n\n0. ==非交互模式则不进行下面的操作==\n1. 窗口可调整\n2. 增强$PS1\n3. 设置xterm（注释掉了）\n4. 交互模式中开启命令补全（注释掉了）\n5. 在bash中使用sudo\n6. 安装command-not-found包后bash的变化\n\n而[~/.bashrc]({{site.baseurl}}/assets/attachs/home.bashrc.txt)中设置的就比较多了，具体可以看文档注释。\n\n## 四种不同的[shell模式][bash]\n* 登录模式  \n进入登录模式的shell需要一个特定的用户名和密码，就像我们按`Ctrl + Alt + F1`进入tty1后输入用户名和密码后成功登录系统的情况。  \n\n\t> **Tips:**  \n\t> 该模式下，shell会自动执行/etc/profile和~/.profile文件，但不会执行任何bashrc文件，但是在这两个profile里面会手动去执行bashrc文件`. *.bashrc`.  \n* 非登录模式  \n非登录模式是指不用登录直接进入shell，它需要在特定用户登录状态下才能进入。就像在终端下直接输入`bash`或`bash -c ‘CMD’`。\n\t> **Tips:**  \n\t> 该模式下，shell不会自动执行profile文件。\n* 交互模式  \n在交互模式的shell中，标准输入，输出和错误都显示在终端上，此时变量`$PS1`一定会被设置。像以`bash`，`bash -i`命令启动。\n\t> **Tips:**  \n\t> 该模式下（未login），shell会去执行/etc/bash.bashrc和~/.bashrc文件。\n* 非交互模式  \n非交互模式就是指shell里面没有交互，像执行命令`bash -c ‘CMD’`，像运行shell脚本等。\n\t> **Tips:**  \n\t> 该模式下，shell不会执行任何bashrc文件。\n\n## 试验\n* 验证四种模式中配置文件的作用域  \n当我们在终端中执行bash命令的时候，它其实在终端中又开了一个外壳，所以我们需要`exit`两次才能退出。所以我们在第一层外壳中设置四个配置文件中变量。设置如下：\n\n\t```sh\n\t# /etc/profile\n\texport epro='I am in /etc/profile'\n\texport epro_ebash='I am in /etc/profile'\n\texport epro_pro='I am in /etc/profile'\n\texport epro_bash='I am in /etc/profile'\n\n\t# /etc/bash.bashrc\n\texport ebash='I am in /etc/bash.bashrc'\n\texport epro_ebash='I am in /etc/bash.bashrc'\n\texport ebash_pro='I am in /etc/bash.bashrc'\n\texport ebash_bash='I am in /etc/bash.bashrc'\n\n\t# ~/.profile\n\texport pro='I am in ~/.profile'\n\texport epro_pro='I am in ~/.profile'\n\texport ebash_pro='I am in ~/.profile'\n\texport pro_bash='I am in ~/.profile'\n\n\t# ~/.bashrc\n\texport bash='I am in ~/.bashrc'\n\texport epro_bash='I am in ~/.bashrc'\n\texport ebash_bash='I am in ~/.bashrc'\n\texport pro_bash='I am in ~/.bashrc'\n\t```\n\t> **Tips:**  \n\t> 上面的变量声明位置要放在各个配置文件前面，但是要放在判别交互和登录模式之后  \n\t> /etc/profile \t\t最前面  \n\t> /etc/bash.bashrc\t前面，但要在判断交互模式之后  \n\t> ~/.profile\t\t最前面  \n\t> ~/.bashrc\t\t\t前面，但要在判断交互模式之后\n\n\t* 试验步骤\n\t\t1. 登录模式  \n\t\t在终端中设置完上面的变量之后，以`bash -l`进入另一个bash，并显示上面的变量值\n\t\t![login]({{site.baseurl}}/assets/images/bash_login.png)  \n\t\t3. 交互模式  \n\t\t在终端中设置完上面的变量之后，以`bash -i`进入另一个bash，并显示上面的变量\n\t\t![inter]({{site.baseurl}}/assets/images/bash_inter.png)\n\t\t4. 打开terminal时，进入的模式  \n\t\t在一个终端中设置完上面的变量后，打开另一个终端，显示上面的变量值\n\t\t![terminal]({{site.baseurl}}/assets/images/terminal.png)  \n\t* 结论\n\t\t1. 登录模式中，四个文件都被执行了，执行的顺序是/etc/profile > /etc/bash.bashrc > ~/.profile > ~/.bashrc\n\t\tepro，pro，ebash，bash都有值，说明四个文件都被执行了。epro_ebash说明/etc/profile先于/etc/bash.bashrc;\n\t\tebash_pro说明/etc/bash.bashrc先于~/.profile;pro_bash说明~/.profile先于~/.bashrc\n\t\t3. 交互模式中，两个profile文件没有被执行，两个bash文件都被执行了，并且/etc/bash.bashrc比~/.bashrc先执行\n\t\tebash，bash都有值，说明bash两个文件都被执行了。ebash_bash说明~/.profile先于~/.bashrc\n\t\t4. 打开terminal时，进入交互模式\n\t\t两个profile文件没有被执行，两个bash文件都被执行了，并且/etc/bash.bashrc比~/.bashrc先执行。此状态和交互模式的状态一致。\n\n\n## 待解决的问题\n1. 非登录模式如何确定？\n2. 之前的所有试验其实都包含了交互模式。非交互模式又如何确定？\n\n## 参考文献\n6. [shell的四种模式][bash]\n1. [理解 bashrc 和 profile][bash_pro]\n2. [Choosing between .bashrc, .profile, .bash_profile, etc][profile]\n\n\n[bash]:\t\thttps://wiki.archlinux.org/index.php/Bash_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BC.A0.E7.BB.9F.E6.A8.A1.E5.BC.8F\n[bash_pro]:\thttps://wido.me/sunteya/understand-bashrc-and-profile\n[profile]:\thttp://superuser.com/questions/789448/choosing-between-bashrc-profile-bash-profile-etc\n","slug":"Explore-configure-Shell","published":1,"date":"2015-09-08T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1k001kl73ymk75zmrt","content":"<p>[上一篇博文](/2015/09/08/shell运行环境之环境变量.html)介绍了shell运行环境中三种不同的环境变量–临时变量，用户变量和系统变量，除此之外还有/etc/environment，/etc/profile和～/.profile作用域。这篇文章将主要围绕bash这个shell来讲解<a href=\"https://wido.me/sunteya/understand-bashrc-and-profile\" target=\"_blank\" rel=\"external\">环境配置文件</a>，并结合shell的四种模式来说明这些配置文件的作用域。 <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p>我们知道linux系统中有很多shell，像最常用的bash，不常用的sh，zsh等。而对于它们公共的变量我们不可能为每个shell重复设置，所以这些公共变量我们将会保存在profile中，而对于每个shell个性化的配置将会放在各自的配置文件中，像bashrc，shrc和zshrc。而ubuntu默认用的是bash，所以只有bashrc而没有其他吧。</p>\n<h2 id=\"profile配置文件\">profile配置文件</h2>\n<p>profile是配置的意思，是某个用户唯一用来设置环境变量的地方，而用户可用的shell有多个，像bash，sh，zsh之类的，但像环境变量这种只需要在统一的一个地方初始化就可以了，这就需要profile。在Ubuntu中[/etc/profile](/assets/attachs/etc_profile.txt)将在用户<strong>第一次</strong>登录（可以是图形也可以是终端）时被执行，其只做两件事。</p>\n<ol style=\"list-style-type: decimal\">\n<li>设置shell使用bash（主要执行/etc/bash.bashrc）<br>\n</li>\n<li>查看/etc/profile.d中是否有相应的环境变量要设置（该文件夹中每个sh文件都是针对某个应用设置的环境变量，这个叫[可插拔功能][pam]）。</li>\n</ol>\n<p>而[~/.profile](/assets/attachs/home.profile.txt)也是在用户<strong>第一次</strong>登录时被执行，其也是做两件事。</p>\n<ol style=\"list-style-type: decimal\">\n<li>设置shell使用bash（主要执行~/.bashrc）</li>\n<li>设置路径包含用户私有的执行文件目录（如果存在）</li>\n</ol>\n<h2 id=\"bashrc配置文件\">bashrc配置文件</h2>\n<p>bashrc看名字就知道，是专门用来给bash做初始化的。像初始化bash的设置，代码补全，别名，颜色等。同理，还会有shrc，zshrc这样的文件存在，只是bash太常用了。在Ubuntu系统中，每次打开bash，[/etc/bash.bashrc](/assets/attachs/etc_bash.bashrc.txt)就会被执行，进行如下设置。</p>\n<ol start=\"0\" style=\"list-style-type: decimal\">\n<li>==非交互模式则不进行下面的操作==</li>\n<li>窗口可调整</li>\n<li>增强$PS1</li>\n<li>设置xterm（注释掉了）</li>\n<li>交互模式中开启命令补全（注释掉了）</li>\n<li>在bash中使用sudo</li>\n<li>安装command-not-found包后bash的变化</li>\n</ol>\n<p>而[~/.bashrc](/assets/attachs/home.bashrc.txt)中设置的就比较多了，具体可以看文档注释。</p>\n<h2 id=\"四种不同的shell模式bash\">四种不同的<a href=\"https://wiki.archlinux.org/index.php/Bash_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BC.A0.E7.BB.9F.E6.A8.A1.E5.BC.8F\" target=\"_blank\" rel=\"external\">shell模式</a></h2>\n<ul>\n<li><p>登录模式<br>\n进入登录模式的shell需要一个特定的用户名和密码，就像我们按<code>Ctrl + Alt + F1</code>进入tty1后输入用户名和密码后成功登录系统的情况。</p>\n<blockquote>\n<p><strong>Tips:</strong><br>\n该模式下，shell会自动执行/etc/profile和~/.profile文件，但不会执行任何bashrc文件，但是在这两个profile里面会手动去执行bashrc文件<code>. *.bashrc</code>.</p>\n</blockquote></li>\n<li>非登录模式<br>\n非登录模式是指不用登录直接进入shell，它需要在特定用户登录状态下才能进入。就像在终端下直接输入<code>bash</code>或<code>bash -c ‘CMD’</code>。 &gt; <strong>Tips:</strong><br>\n&gt; 该模式下，shell不会自动执行profile文件。</li>\n<li>交互模式<br>\n在交互模式的shell中，标准输入，输出和错误都显示在终端上，此时变量<code>$PS1</code>一定会被设置。像以<code>bash</code>，<code>bash -i</code>命令启动。 &gt; <strong>Tips:</strong><br>\n&gt; 该模式下（未login），shell会去执行/etc/bash.bashrc和~/.bashrc文件。</li>\n<li><p>非交互模式<br>\n非交互模式就是指shell里面没有交互，像执行命令<code>bash -c ‘CMD’</code>，像运行shell脚本等。 &gt; <strong>Tips:</strong><br>\n&gt; 该模式下，shell不会执行任何bashrc文件。</p></li>\n</ul>\n<h2 id=\"试验\">试验</h2>\n<ul>\n<li><p>验证四种模式中配置文件的作用域<br>\n当我们在终端中执行bash命令的时候，它其实在终端中又开了一个外壳，所以我们需要<code>exit</code>两次才能退出。所以我们在第一层外壳中设置四个配置文件中变量。设置如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># /etc/profile</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro=<span class=\"string\">'I am in /etc/profile'</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro_ebash=<span class=\"string\">'I am in /etc/profile'</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro_pro=<span class=\"string\">'I am in /etc/profile'</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro_bash=<span class=\"string\">'I am in /etc/profile'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># /etc/bash.bashrc</span></div><div class=\"line\"><span class=\"built_in\">export</span> ebash=<span class=\"string\">'I am in /etc/bash.bashrc'</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro_ebash=<span class=\"string\">'I am in /etc/bash.bashrc'</span></div><div class=\"line\"><span class=\"built_in\">export</span> ebash_pro=<span class=\"string\">'I am in /etc/bash.bashrc'</span></div><div class=\"line\"><span class=\"built_in\">export</span> ebash_bash=<span class=\"string\">'I am in /etc/bash.bashrc'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># ~/.profile</span></div><div class=\"line\"><span class=\"built_in\">export</span> pro=<span class=\"string\">'I am in ~/.profile'</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro_pro=<span class=\"string\">'I am in ~/.profile'</span></div><div class=\"line\"><span class=\"built_in\">export</span> ebash_pro=<span class=\"string\">'I am in ~/.profile'</span></div><div class=\"line\"><span class=\"built_in\">export</span> pro_bash=<span class=\"string\">'I am in ~/.profile'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># ~/.bashrc</span></div><div class=\"line\"><span class=\"built_in\">export</span> bash=<span class=\"string\">'I am in ~/.bashrc'</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro_bash=<span class=\"string\">'I am in ~/.bashrc'</span></div><div class=\"line\"><span class=\"built_in\">export</span> ebash_bash=<span class=\"string\">'I am in ~/.bashrc'</span></div><div class=\"line\"><span class=\"built_in\">export</span> pro_bash=<span class=\"string\">'I am in ~/.bashrc'</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Tips:</strong><br>\n上面的变量声明位置要放在各个配置文件前面，但是要放在判别交互和登录模式之后<br>\n/etc/profile 最前面<br>\n/etc/bash.bashrc 前面，但要在判断交互模式之后<br>\n~/.profile 最前面<br>\n~/.bashrc 前面，但要在判断交互模式之后</p>\n</blockquote>\n<ul>\n<li>试验步骤\n<ol style=\"list-style-type: decimal\">\n<li>登录模式<br>\n在终端中设置完上面的变量之后，以<code>bash -l</code>进入另一个bash，并显示上面的变量值 [login](/assets/images/bash_login.png)<br>\n</li>\n<li>交互模式<br>\n在终端中设置完上面的变量之后，以<code>bash -i</code>进入另一个bash，并显示上面的变量 [inter](/assets/images/bash_inter.png)</li>\n<li>打开terminal时，进入的模式<br>\n在一个终端中设置完上面的变量后，打开另一个终端，显示上面的变量值 [terminal](/assets/images/terminal.png)<br>\n</li>\n</ol></li>\n<li>结论\n<ol style=\"list-style-type: decimal\">\n<li>登录模式中，四个文件都被执行了，执行的顺序是/etc/profile &gt; /etc/bash.bashrc &gt; ~/.profile &gt; <sub>/.bashrc epro，pro，ebash，bash都有值，说明四个文件都被执行了。epro_ebash说明/etc/profile先于/etc/bash.bashrc; ebash_pro说明/etc/bash.bashrc先于</sub>/.profile;pro_bash说明<sub>/.profile先于</sub>/.bashrc</li>\n<li>交互模式中，两个profile文件没有被执行，两个bash文件都被执行了，并且/etc/bash.bashrc比<sub>/.bashrc先执行 ebash，bash都有值，说明bash两个文件都被执行了。ebash_bash说明</sub>/.profile先于~/.bashrc</li>\n<li>打开terminal时，进入交互模式 两个profile文件没有被执行，两个bash文件都被执行了，并且/etc/bash.bashrc比~/.bashrc先执行。此状态和交互模式的状态一致。</li>\n</ol></li>\n</ul></li>\n</ul>\n<h2 id=\"待解决的问题\">待解决的问题</h2>\n<ol style=\"list-style-type: decimal\">\n<li>非登录模式如何确定？</li>\n<li>之前的所有试验其实都包含了交互模式。非交互模式又如何确定？</li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol start=\"6\" style=\"list-style-type: decimal\">\n<li><a href=\"https://wiki.archlinux.org/index.php/Bash_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BC.A0.E7.BB.9F.E6.A8.A1.E5.BC.8F\" target=\"_blank\" rel=\"external\">shell的四种模式</a></li>\n<li><a href=\"https://wido.me/sunteya/understand-bashrc-and-profile\" target=\"_blank\" rel=\"external\">理解 bashrc 和 profile</a></li>\n<li><a href=\"http://superuser.com/questions/789448/choosing-between-bashrc-profile-bash-profile-etc\" target=\"_blank\" rel=\"external\">Choosing between .bashrc, .profile, .bash_profile, etc</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>[上一篇博文](/2015/09/08/shell运行环境之环境变量.html)介绍了shell运行环境中三种不同的环境变量–临时变量，用户变量和系统变量，除此之外还有/etc/environment，/etc/profile和～/.profile作用域。这篇文章将主要围绕bash这个shell来讲解<a href=\"https://wido.me/sunteya/understand-bashrc-and-profile\" target=\"_blank\" rel=\"external\">环境配置文件</a>，并结合shell的四种模式来说明这些配置文件的作用域。","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p>我们知道linux系统中有很多shell，像最常用的bash，不常用的sh，zsh等。而对于它们公共的变量我们不可能为每个shell重复设置，所以这些公共变量我们将会保存在profile中，而对于每个shell个性化的配置将会放在各自的配置文件中，像bashrc，shrc和zshrc。而ubuntu默认用的是bash，所以只有bashrc而没有其他吧。</p>\n<h2 id=\"profile配置文件\">profile配置文件</h2>\n<p>profile是配置的意思，是某个用户唯一用来设置环境变量的地方，而用户可用的shell有多个，像bash，sh，zsh之类的，但像环境变量这种只需要在统一的一个地方初始化就可以了，这就需要profile。在Ubuntu中[/etc/profile](/assets/attachs/etc_profile.txt)将在用户<strong>第一次</strong>登录（可以是图形也可以是终端）时被执行，其只做两件事。</p>\n<ol style=\"list-style-type: decimal\">\n<li>设置shell使用bash（主要执行/etc/bash.bashrc）<br>\n</li>\n<li>查看/etc/profile.d中是否有相应的环境变量要设置（该文件夹中每个sh文件都是针对某个应用设置的环境变量，这个叫[可插拔功能][pam]）。</li>\n</ol>\n<p>而[~/.profile](/assets/attachs/home.profile.txt)也是在用户<strong>第一次</strong>登录时被执行，其也是做两件事。</p>\n<ol style=\"list-style-type: decimal\">\n<li>设置shell使用bash（主要执行~/.bashrc）</li>\n<li>设置路径包含用户私有的执行文件目录（如果存在）</li>\n</ol>\n<h2 id=\"bashrc配置文件\">bashrc配置文件</h2>\n<p>bashrc看名字就知道，是专门用来给bash做初始化的。像初始化bash的设置，代码补全，别名，颜色等。同理，还会有shrc，zshrc这样的文件存在，只是bash太常用了。在Ubuntu系统中，每次打开bash，[/etc/bash.bashrc](/assets/attachs/etc_bash.bashrc.txt)就会被执行，进行如下设置。</p>\n<ol start=\"0\" style=\"list-style-type: decimal\">\n<li>==非交互模式则不进行下面的操作==</li>\n<li>窗口可调整</li>\n<li>增强$PS1</li>\n<li>设置xterm（注释掉了）</li>\n<li>交互模式中开启命令补全（注释掉了）</li>\n<li>在bash中使用sudo</li>\n<li>安装command-not-found包后bash的变化</li>\n</ol>\n<p>而[~/.bashrc](/assets/attachs/home.bashrc.txt)中设置的就比较多了，具体可以看文档注释。</p>\n<h2 id=\"四种不同的shell模式bash\">四种不同的<a href=\"https://wiki.archlinux.org/index.php/Bash_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BC.A0.E7.BB.9F.E6.A8.A1.E5.BC.8F\" target=\"_blank\" rel=\"external\">shell模式</a></h2>\n<ul>\n<li><p>登录模式<br>\n进入登录模式的shell需要一个特定的用户名和密码，就像我们按<code>Ctrl + Alt + F1</code>进入tty1后输入用户名和密码后成功登录系统的情况。</p>\n<blockquote>\n<p><strong>Tips:</strong><br>\n该模式下，shell会自动执行/etc/profile和~/.profile文件，但不会执行任何bashrc文件，但是在这两个profile里面会手动去执行bashrc文件<code>. *.bashrc</code>.</p>\n</blockquote></li>\n<li>非登录模式<br>\n非登录模式是指不用登录直接进入shell，它需要在特定用户登录状态下才能进入。就像在终端下直接输入<code>bash</code>或<code>bash -c ‘CMD’</code>。 &gt; <strong>Tips:</strong><br>\n&gt; 该模式下，shell不会自动执行profile文件。</li>\n<li>交互模式<br>\n在交互模式的shell中，标准输入，输出和错误都显示在终端上，此时变量<code>$PS1</code>一定会被设置。像以<code>bash</code>，<code>bash -i</code>命令启动。 &gt; <strong>Tips:</strong><br>\n&gt; 该模式下（未login），shell会去执行/etc/bash.bashrc和~/.bashrc文件。</li>\n<li><p>非交互模式<br>\n非交互模式就是指shell里面没有交互，像执行命令<code>bash -c ‘CMD’</code>，像运行shell脚本等。 &gt; <strong>Tips:</strong><br>\n&gt; 该模式下，shell不会执行任何bashrc文件。</p></li>\n</ul>\n<h2 id=\"试验\">试验</h2>\n<ul>\n<li><p>验证四种模式中配置文件的作用域<br>\n当我们在终端中执行bash命令的时候，它其实在终端中又开了一个外壳，所以我们需要<code>exit</code>两次才能退出。所以我们在第一层外壳中设置四个配置文件中变量。设置如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># /etc/profile</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro=<span class=\"string\">'I am in /etc/profile'</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro_ebash=<span class=\"string\">'I am in /etc/profile'</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro_pro=<span class=\"string\">'I am in /etc/profile'</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro_bash=<span class=\"string\">'I am in /etc/profile'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># /etc/bash.bashrc</span></div><div class=\"line\"><span class=\"built_in\">export</span> ebash=<span class=\"string\">'I am in /etc/bash.bashrc'</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro_ebash=<span class=\"string\">'I am in /etc/bash.bashrc'</span></div><div class=\"line\"><span class=\"built_in\">export</span> ebash_pro=<span class=\"string\">'I am in /etc/bash.bashrc'</span></div><div class=\"line\"><span class=\"built_in\">export</span> ebash_bash=<span class=\"string\">'I am in /etc/bash.bashrc'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># ~/.profile</span></div><div class=\"line\"><span class=\"built_in\">export</span> pro=<span class=\"string\">'I am in ~/.profile'</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro_pro=<span class=\"string\">'I am in ~/.profile'</span></div><div class=\"line\"><span class=\"built_in\">export</span> ebash_pro=<span class=\"string\">'I am in ~/.profile'</span></div><div class=\"line\"><span class=\"built_in\">export</span> pro_bash=<span class=\"string\">'I am in ~/.profile'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># ~/.bashrc</span></div><div class=\"line\"><span class=\"built_in\">export</span> bash=<span class=\"string\">'I am in ~/.bashrc'</span></div><div class=\"line\"><span class=\"built_in\">export</span> epro_bash=<span class=\"string\">'I am in ~/.bashrc'</span></div><div class=\"line\"><span class=\"built_in\">export</span> ebash_bash=<span class=\"string\">'I am in ~/.bashrc'</span></div><div class=\"line\"><span class=\"built_in\">export</span> pro_bash=<span class=\"string\">'I am in ~/.bashrc'</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Tips:</strong><br>\n上面的变量声明位置要放在各个配置文件前面，但是要放在判别交互和登录模式之后<br>\n/etc/profile 最前面<br>\n/etc/bash.bashrc 前面，但要在判断交互模式之后<br>\n~/.profile 最前面<br>\n~/.bashrc 前面，但要在判断交互模式之后</p>\n</blockquote>\n<ul>\n<li>试验步骤\n<ol style=\"list-style-type: decimal\">\n<li>登录模式<br>\n在终端中设置完上面的变量之后，以<code>bash -l</code>进入另一个bash，并显示上面的变量值 [login](/assets/images/bash_login.png)<br>\n</li>\n<li>交互模式<br>\n在终端中设置完上面的变量之后，以<code>bash -i</code>进入另一个bash，并显示上面的变量 [inter](/assets/images/bash_inter.png)</li>\n<li>打开terminal时，进入的模式<br>\n在一个终端中设置完上面的变量后，打开另一个终端，显示上面的变量值 [terminal](/assets/images/terminal.png)<br>\n</li>\n</ol></li>\n<li>结论\n<ol style=\"list-style-type: decimal\">\n<li>登录模式中，四个文件都被执行了，执行的顺序是/etc/profile &gt; /etc/bash.bashrc &gt; ~/.profile &gt; <sub>/.bashrc epro，pro，ebash，bash都有值，说明四个文件都被执行了。epro_ebash说明/etc/profile先于/etc/bash.bashrc; ebash_pro说明/etc/bash.bashrc先于</sub>/.profile;pro_bash说明<sub>/.profile先于</sub>/.bashrc</li>\n<li>交互模式中，两个profile文件没有被执行，两个bash文件都被执行了，并且/etc/bash.bashrc比<sub>/.bashrc先执行 ebash，bash都有值，说明bash两个文件都被执行了。ebash_bash说明</sub>/.profile先于~/.bashrc</li>\n<li>打开terminal时，进入交互模式 两个profile文件没有被执行，两个bash文件都被执行了，并且/etc/bash.bashrc比~/.bashrc先执行。此状态和交互模式的状态一致。</li>\n</ol></li>\n</ul></li>\n</ul>\n<h2 id=\"待解决的问题\">待解决的问题</h2>\n<ol style=\"list-style-type: decimal\">\n<li>非登录模式如何确定？</li>\n<li>之前的所有试验其实都包含了交互模式。非交互模式又如何确定？</li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol start=\"6\" style=\"list-style-type: decimal\">\n<li><a href=\"https://wiki.archlinux.org/index.php/Bash_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.BC.A0.E7.BB.9F.E6.A8.A1.E5.BC.8F\" target=\"_blank\" rel=\"external\">shell的四种模式</a></li>\n<li><a href=\"https://wido.me/sunteya/understand-bashrc-and-profile\" target=\"_blank\" rel=\"external\">理解 bashrc 和 profile</a></li>\n<li><a href=\"http://superuser.com/questions/789448/choosing-between-bashrc-profile-bash-profile-etc\" target=\"_blank\" rel=\"external\">Choosing between .bashrc, .profile, .bash_profile, etc</a></li>\n</ol>"},{"layout":"post","title":"shell运行环境之sudo的环境","comments":1,"_content":"上篇[博文]({{site.baseurl}}/2015/09/09/shell运行环境之环境配置文件.html)讲解了shell里面四个配置文件的作用域以及shell的四种常用模式。在此基础上，我们进一步探究一下在用户切换过程中，运行环境的变化。在Ubuntu里，我们通常使用`sudo`来提权，使用`su`来切换用户，而这两种操作都会对bash运行环境产生影响。搞明白运行环境的变化，你将明白在公司怎样使用代理。\n<!-- more -->\n\n\n## 简介\n我们经常在终端中使用`sudo`来提权--以普通用户的身份去行使管理员的权限（前提是知道管理员用户的密码），这样减少了root用户的登录次数和管理时间，也提高了系统的安全性。不过有时候我们会直接用`su`切换到管理员进行一系列操作。`su`和`sudo`虽然不是具有相似功能的命令，但是它们的目的大部分情况是为了获取root权限。  \n\n* su命令  \nsu命令是switch user的简写，是用来切换用户的。当不加任何参数时，它将切换到root用户。它需要你想**切换到的用户**的密码，在输入密码后，你将切换到那个用户的运行环境。\n* [sudo][sudo]命令  \n该命令是superuser do的简写，能够以root的权限取执行命令，但是它需要的是**当前用户**的密码，而不是像su需要的是想要切换到的用户的密码。这样需要执行一些需要root权限的命令时就不需要频繁输入root用户的密码，当然前提是当前用户的信息是存档在特殊的文件（/etc/sudoers）中。默认情况下，系统将记住当前用户的密码一段时间，以方便用户不用经常输入密码。\n\n## [运行环境的变化][su&sudo]\n\n* sudo\n根据man的说明，sudoers提供了两种方法来限制sudo从用户环境中继承的变量。默认是env_reset变量是enabled，此时将会执行一个新的，最小的环境/etc/environment。另一种是设置env_reset变量是disabled，此时env_check和env_delete充当白列表的作用，因此不建议第二种情况。\n* sudo su  \nbash将以一个交互非登录模式运行，所以只有两个bashrc文件将被执行。所以当用户切换成root后，我们还在当前的工作的目录，而非/root目录。\n* sudo su -  \nbash将以登录模式运行的，此时/etc/profile，~/.profile将会被执行，隐形的/etc/bash.bashrc和~/.bashrc也将会被执行。此时，我们的当前目录是/root。\n* sudo -i将\n-i是--login的简写，所以接近sudo su -的情况\n* sudo /bin/bash\nbash将以非登录模式运行，上面四个文件将不会被执行。\n\n\n## 试验\n\n* 问题  \n今天在公司准备使用命令行`sudo /opt/logstash/bin/plugin install logstash-output-webhdfs`给logstash安装logstash-output-webhdfs插件，以实现将logstash收集的日志信息存储到Hadoop文件系统这一目的。但是却一直提示如下错误：\n\n\t> Unable to download data from https://rubygems.org/ - 连接被对端重置 (https://rubygems.global.ssl.fastly.net/latest_specs.4.8.gz)  \n\t> ERROR: Installation aborted, verification failed for logstash-output-webhdfs\n\n这里公司上网环境是使用了代理。本人在~/.bashrc中添加了`export http_proxy=xxx`和`export https_proxy=xxx`。接下来按照网上的解决方法作了如下尝试，均已失败告终。    \n\n1. 用Google搜索错误提示[Unable to download data from https://rubygems.org][unable]  \n2. [手动安装插件logstash-output-webhdfs][manual]  \n\n* 解决方案\n\n1. [设置sudo的运行环境][sudo_change]\n使用`sudo visudo`对/etc/sudoers文件进行如下修改：\n\n\t```sh\n\tDefaults env_keep = \"http_proxy https_proxy\"\n\tDefaults        env_reset\n\t```\n通过保留当前用户的http_proxy和https_proxy变量，使得sudo情况下也能使用代理。具体参考[这里][sudo_env]。\n\n2. 进入root用户，并设定http_proxy和https_proxy代理。\n\n## 参考文献\n2. [如何更换rubygem镜像的源][unable]\n3. [如何手动安装logstash插件logstash-output-elasticsearch-shield][manual]\n5. [维基百科sudo][sudo]\n7. [su和sudo对运行环境的影响][su&sudo]\n1. [sudo使用代理][sudo_change]\n2. [sudo环境设置][sudo_env]\n\n\n[unable]:   http://www.sjsjw.com/kf_jiagou/article/027841ABA028365.asp\n[manual]:  https://discuss.elastic.co/t/shield-w-logstash-offline-install/25072\n[sudo]:     https://zh.wikipedia.org/zh/Sudo\n[su&sudo]:  http://askubuntu.com/questions/376199/sudo-su-vs-sudo-i-vs-sudo-bin-bash-when-does-it-matter-which-is-used\n[sudo_change]:\thttps://getpocket.com/a/read/149876899\n[sudo_env]:\t\t\thttp://my.oschina.net/alphajay/blog/28811\n","source":"_posts/2015-09-13-shell运行环境之sudo的环境.md","raw":"---\nlayout:\tpost\ntitle:\tshell运行环境之sudo的环境\ncategories:\n- TECHNOLOGY\ntags:\n- Ubuntu\n- Shell\npermalink:  Explore-sudo-Shell\ncomments:\ttrue\n---\n上篇[博文]({{site.baseurl}}/2015/09/09/shell运行环境之环境配置文件.html)讲解了shell里面四个配置文件的作用域以及shell的四种常用模式。在此基础上，我们进一步探究一下在用户切换过程中，运行环境的变化。在Ubuntu里，我们通常使用`sudo`来提权，使用`su`来切换用户，而这两种操作都会对bash运行环境产生影响。搞明白运行环境的变化，你将明白在公司怎样使用代理。\n<!-- more -->\n\n\n## 简介\n我们经常在终端中使用`sudo`来提权--以普通用户的身份去行使管理员的权限（前提是知道管理员用户的密码），这样减少了root用户的登录次数和管理时间，也提高了系统的安全性。不过有时候我们会直接用`su`切换到管理员进行一系列操作。`su`和`sudo`虽然不是具有相似功能的命令，但是它们的目的大部分情况是为了获取root权限。  \n\n* su命令  \nsu命令是switch user的简写，是用来切换用户的。当不加任何参数时，它将切换到root用户。它需要你想**切换到的用户**的密码，在输入密码后，你将切换到那个用户的运行环境。\n* [sudo][sudo]命令  \n该命令是superuser do的简写，能够以root的权限取执行命令，但是它需要的是**当前用户**的密码，而不是像su需要的是想要切换到的用户的密码。这样需要执行一些需要root权限的命令时就不需要频繁输入root用户的密码，当然前提是当前用户的信息是存档在特殊的文件（/etc/sudoers）中。默认情况下，系统将记住当前用户的密码一段时间，以方便用户不用经常输入密码。\n\n## [运行环境的变化][su&sudo]\n\n* sudo\n根据man的说明，sudoers提供了两种方法来限制sudo从用户环境中继承的变量。默认是env_reset变量是enabled，此时将会执行一个新的，最小的环境/etc/environment。另一种是设置env_reset变量是disabled，此时env_check和env_delete充当白列表的作用，因此不建议第二种情况。\n* sudo su  \nbash将以一个交互非登录模式运行，所以只有两个bashrc文件将被执行。所以当用户切换成root后，我们还在当前的工作的目录，而非/root目录。\n* sudo su -  \nbash将以登录模式运行的，此时/etc/profile，~/.profile将会被执行，隐形的/etc/bash.bashrc和~/.bashrc也将会被执行。此时，我们的当前目录是/root。\n* sudo -i将\n-i是--login的简写，所以接近sudo su -的情况\n* sudo /bin/bash\nbash将以非登录模式运行，上面四个文件将不会被执行。\n\n\n## 试验\n\n* 问题  \n今天在公司准备使用命令行`sudo /opt/logstash/bin/plugin install logstash-output-webhdfs`给logstash安装logstash-output-webhdfs插件，以实现将logstash收集的日志信息存储到Hadoop文件系统这一目的。但是却一直提示如下错误：\n\n\t> Unable to download data from https://rubygems.org/ - 连接被对端重置 (https://rubygems.global.ssl.fastly.net/latest_specs.4.8.gz)  \n\t> ERROR: Installation aborted, verification failed for logstash-output-webhdfs\n\n这里公司上网环境是使用了代理。本人在~/.bashrc中添加了`export http_proxy=xxx`和`export https_proxy=xxx`。接下来按照网上的解决方法作了如下尝试，均已失败告终。    \n\n1. 用Google搜索错误提示[Unable to download data from https://rubygems.org][unable]  \n2. [手动安装插件logstash-output-webhdfs][manual]  \n\n* 解决方案\n\n1. [设置sudo的运行环境][sudo_change]\n使用`sudo visudo`对/etc/sudoers文件进行如下修改：\n\n\t```sh\n\tDefaults env_keep = \"http_proxy https_proxy\"\n\tDefaults        env_reset\n\t```\n通过保留当前用户的http_proxy和https_proxy变量，使得sudo情况下也能使用代理。具体参考[这里][sudo_env]。\n\n2. 进入root用户，并设定http_proxy和https_proxy代理。\n\n## 参考文献\n2. [如何更换rubygem镜像的源][unable]\n3. [如何手动安装logstash插件logstash-output-elasticsearch-shield][manual]\n5. [维基百科sudo][sudo]\n7. [su和sudo对运行环境的影响][su&sudo]\n1. [sudo使用代理][sudo_change]\n2. [sudo环境设置][sudo_env]\n\n\n[unable]:   http://www.sjsjw.com/kf_jiagou/article/027841ABA028365.asp\n[manual]:  https://discuss.elastic.co/t/shield-w-logstash-offline-install/25072\n[sudo]:     https://zh.wikipedia.org/zh/Sudo\n[su&sudo]:  http://askubuntu.com/questions/376199/sudo-su-vs-sudo-i-vs-sudo-bin-bash-when-does-it-matter-which-is-used\n[sudo_change]:\thttps://getpocket.com/a/read/149876899\n[sudo_env]:\t\t\thttp://my.oschina.net/alphajay/blog/28811\n","slug":"Explore-sudo-Shell","published":1,"date":"2015-09-12T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1k001ll73y649a59wc","content":"<p>上篇[博文](/2015/09/09/shell运行环境之环境配置文件.html)讲解了shell里面四个配置文件的作用域以及shell的四种常用模式。在此基础上，我们进一步探究一下在用户切换过程中，运行环境的变化。在Ubuntu里，我们通常使用<code>sudo</code>来提权，使用<code>su</code>来切换用户，而这两种操作都会对bash运行环境产生影响。搞明白运行环境的变化，你将明白在公司怎样使用代理。 <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p>我们经常在终端中使用<code>sudo</code>来提权–以普通用户的身份去行使管理员的权限（前提是知道管理员用户的密码），这样减少了root用户的登录次数和管理时间，也提高了系统的安全性。不过有时候我们会直接用<code>su</code>切换到管理员进行一系列操作。<code>su</code>和<code>sudo</code>虽然不是具有相似功能的命令，但是它们的目的大部分情况是为了获取root权限。</p>\n<ul>\n<li>su命令<br>\nsu命令是switch user的简写，是用来切换用户的。当不加任何参数时，它将切换到root用户。它需要你想<strong>切换到的用户</strong>的密码，在输入密码后，你将切换到那个用户的运行环境。</li>\n<li><a href=\"https://zh.wikipedia.org/zh/Sudo\" target=\"_blank\" rel=\"external\">sudo</a>命令<br>\n该命令是superuser do的简写，能够以root的权限取执行命令，但是它需要的是<strong>当前用户</strong>的密码，而不是像su需要的是想要切换到的用户的密码。这样需要执行一些需要root权限的命令时就不需要频繁输入root用户的密码，当然前提是当前用户的信息是存档在特殊的文件（/etc/sudoers）中。默认情况下，系统将记住当前用户的密码一段时间，以方便用户不用经常输入密码。</li>\n</ul>\n<h2 id=\"运行环境的变化susudo\"><a href=\"http://askubuntu.com/questions/376199/sudo-su-vs-sudo-i-vs-sudo-bin-bash-when-does-it-matter-which-is-used\" target=\"_blank\" rel=\"external\">运行环境的变化</a></h2>\n<ul>\n<li>sudo 根据man的说明，sudoers提供了两种方法来限制sudo从用户环境中继承的变量。默认是env_reset变量是enabled，此时将会执行一个新的，最小的环境/etc/environment。另一种是设置env_reset变量是disabled，此时env_check和env_delete充当白列表的作用，因此不建议第二种情况。</li>\n<li>sudo su<br>\nbash将以一个交互非登录模式运行，所以只有两个bashrc文件将被执行。所以当用户切换成root后，我们还在当前的工作的目录，而非/root目录。</li>\n<li>sudo su -<br>\nbash将以登录模式运行的，此时/etc/profile，<sub>/.profile将会被执行，隐形的/etc/bash.bashrc和</sub>/.bashrc也将会被执行。此时，我们的当前目录是/root。</li>\n<li>sudo -i将 -i是–login的简写，所以接近sudo su -的情况</li>\n<li>sudo /bin/bash bash将以非登录模式运行，上面四个文件将不会被执行。</li>\n</ul>\n<h2 id=\"试验\">试验</h2>\n<ul>\n<li><p>问题<br>\n今天在公司准备使用命令行<code>sudo /opt/logstash/bin/plugin install logstash-output-webhdfs</code>给logstash安装logstash-output-webhdfs插件，以实现将logstash收集的日志信息存储到Hadoop文件系统这一目的。但是却一直提示如下错误：</p>\n<blockquote>\n<p>Unable to download data from https://rubygems.org/ - 连接被对端重置 (https://rubygems.global.ssl.fastly.net/latest_specs.4.8.gz)<br>\nERROR: Installation aborted, verification failed for logstash-output-webhdfs</p>\n</blockquote></li>\n</ul>\n<p>这里公司上网环境是使用了代理。本人在~/.bashrc中添加了<code>export http_proxy=xxx</code>和<code>export https_proxy=xxx</code>。接下来按照网上的解决方法作了如下尝试，均已失败告终。</p>\n<ol style=\"list-style-type: decimal\">\n<li>用Google搜索错误提示<a href=\"http://www.sjsjw.com/kf_jiagou/article/027841ABA028365.asp\" target=\"_blank\" rel=\"external\">Unable to download data from https://rubygems.org</a><br>\n</li>\n<li><a href=\"https://discuss.elastic.co/t/shield-w-logstash-offline-install/25072\" target=\"_blank\" rel=\"external\">手动安装插件logstash-output-webhdfs</a></li>\n</ol>\n<ul>\n<li>解决方案</li>\n</ul>\n<ol style=\"list-style-type: decimal\">\n<li><p><a href=\"https://getpocket.com/a/read/149876899\" target=\"_blank\" rel=\"external\">设置sudo的运行环境</a> 使用<code>sudo visudo</code>对/etc/sudoers文件进行如下修改：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Defaults env_keep = <span class=\"string\">\"http_proxy https_proxy\"</span></div><div class=\"line\">Defaults        env_reset</div></pre></td></tr></table></figure></li>\n</ol>\n<p>通过保留当前用户的http_proxy和https_proxy变量，使得sudo情况下也能使用代理。具体参考<a href=\"http://my.oschina.net/alphajay/blog/28811\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>进入root用户，并设定http_proxy和https_proxy代理。</li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li><a href=\"http://www.sjsjw.com/kf_jiagou/article/027841ABA028365.asp\" target=\"_blank\" rel=\"external\">如何更换rubygem镜像的源</a></li>\n<li><a href=\"https://discuss.elastic.co/t/shield-w-logstash-offline-install/25072\" target=\"_blank\" rel=\"external\">如何手动安装logstash插件logstash-output-elasticsearch-shield</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh/Sudo\" target=\"_blank\" rel=\"external\">维基百科sudo</a></li>\n<li><a href=\"http://askubuntu.com/questions/376199/sudo-su-vs-sudo-i-vs-sudo-bin-bash-when-does-it-matter-which-is-used\" target=\"_blank\" rel=\"external\">su和sudo对运行环境的影响</a></li>\n<li><a href=\"https://getpocket.com/a/read/149876899\" target=\"_blank\" rel=\"external\">sudo使用代理</a></li>\n<li><a href=\"http://my.oschina.net/alphajay/blog/28811\" target=\"_blank\" rel=\"external\">sudo环境设置</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>上篇[博文](/2015/09/09/shell运行环境之环境配置文件.html)讲解了shell里面四个配置文件的作用域以及shell的四种常用模式。在此基础上，我们进一步探究一下在用户切换过程中，运行环境的变化。在Ubuntu里，我们通常使用<code>sudo</code>来提权，使用<code>su</code>来切换用户，而这两种操作都会对bash运行环境产生影响。搞明白运行环境的变化，你将明白在公司怎样使用代理。","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p>我们经常在终端中使用<code>sudo</code>来提权–以普通用户的身份去行使管理员的权限（前提是知道管理员用户的密码），这样减少了root用户的登录次数和管理时间，也提高了系统的安全性。不过有时候我们会直接用<code>su</code>切换到管理员进行一系列操作。<code>su</code>和<code>sudo</code>虽然不是具有相似功能的命令，但是它们的目的大部分情况是为了获取root权限。</p>\n<ul>\n<li>su命令<br>\nsu命令是switch user的简写，是用来切换用户的。当不加任何参数时，它将切换到root用户。它需要你想<strong>切换到的用户</strong>的密码，在输入密码后，你将切换到那个用户的运行环境。</li>\n<li><a href=\"https://zh.wikipedia.org/zh/Sudo\" target=\"_blank\" rel=\"external\">sudo</a>命令<br>\n该命令是superuser do的简写，能够以root的权限取执行命令，但是它需要的是<strong>当前用户</strong>的密码，而不是像su需要的是想要切换到的用户的密码。这样需要执行一些需要root权限的命令时就不需要频繁输入root用户的密码，当然前提是当前用户的信息是存档在特殊的文件（/etc/sudoers）中。默认情况下，系统将记住当前用户的密码一段时间，以方便用户不用经常输入密码。</li>\n</ul>\n<h2 id=\"运行环境的变化susudo\"><a href=\"http://askubuntu.com/questions/376199/sudo-su-vs-sudo-i-vs-sudo-bin-bash-when-does-it-matter-which-is-used\" target=\"_blank\" rel=\"external\">运行环境的变化</a></h2>\n<ul>\n<li>sudo 根据man的说明，sudoers提供了两种方法来限制sudo从用户环境中继承的变量。默认是env_reset变量是enabled，此时将会执行一个新的，最小的环境/etc/environment。另一种是设置env_reset变量是disabled，此时env_check和env_delete充当白列表的作用，因此不建议第二种情况。</li>\n<li>sudo su<br>\nbash将以一个交互非登录模式运行，所以只有两个bashrc文件将被执行。所以当用户切换成root后，我们还在当前的工作的目录，而非/root目录。</li>\n<li>sudo su -<br>\nbash将以登录模式运行的，此时/etc/profile，<sub>/.profile将会被执行，隐形的/etc/bash.bashrc和</sub>/.bashrc也将会被执行。此时，我们的当前目录是/root。</li>\n<li>sudo -i将 -i是–login的简写，所以接近sudo su -的情况</li>\n<li>sudo /bin/bash bash将以非登录模式运行，上面四个文件将不会被执行。</li>\n</ul>\n<h2 id=\"试验\">试验</h2>\n<ul>\n<li><p>问题<br>\n今天在公司准备使用命令行<code>sudo /opt/logstash/bin/plugin install logstash-output-webhdfs</code>给logstash安装logstash-output-webhdfs插件，以实现将logstash收集的日志信息存储到Hadoop文件系统这一目的。但是却一直提示如下错误：</p>\n<blockquote>\n<p>Unable to download data from https://rubygems.org/ - 连接被对端重置 (https://rubygems.global.ssl.fastly.net/latest_specs.4.8.gz)<br>\nERROR: Installation aborted, verification failed for logstash-output-webhdfs</p>\n</blockquote></li>\n</ul>\n<p>这里公司上网环境是使用了代理。本人在~/.bashrc中添加了<code>export http_proxy=xxx</code>和<code>export https_proxy=xxx</code>。接下来按照网上的解决方法作了如下尝试，均已失败告终。</p>\n<ol style=\"list-style-type: decimal\">\n<li>用Google搜索错误提示<a href=\"http://www.sjsjw.com/kf_jiagou/article/027841ABA028365.asp\" target=\"_blank\" rel=\"external\">Unable to download data from https://rubygems.org</a><br>\n</li>\n<li><a href=\"https://discuss.elastic.co/t/shield-w-logstash-offline-install/25072\" target=\"_blank\" rel=\"external\">手动安装插件logstash-output-webhdfs</a></li>\n</ol>\n<ul>\n<li>解决方案</li>\n</ul>\n<ol style=\"list-style-type: decimal\">\n<li><p><a href=\"https://getpocket.com/a/read/149876899\" target=\"_blank\" rel=\"external\">设置sudo的运行环境</a> 使用<code>sudo visudo</code>对/etc/sudoers文件进行如下修改：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Defaults env_keep = <span class=\"string\">\"http_proxy https_proxy\"</span></div><div class=\"line\">Defaults        env_reset</div></pre></td></tr></table></figure></li>\n</ol>\n<p>通过保留当前用户的http_proxy和https_proxy变量，使得sudo情况下也能使用代理。具体参考<a href=\"http://my.oschina.net/alphajay/blog/28811\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>进入root用户，并设定http_proxy和https_proxy代理。</li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li><a href=\"http://www.sjsjw.com/kf_jiagou/article/027841ABA028365.asp\" target=\"_blank\" rel=\"external\">如何更换rubygem镜像的源</a></li>\n<li><a href=\"https://discuss.elastic.co/t/shield-w-logstash-offline-install/25072\" target=\"_blank\" rel=\"external\">如何手动安装logstash插件logstash-output-elasticsearch-shield</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh/Sudo\" target=\"_blank\" rel=\"external\">维基百科sudo</a></li>\n<li><a href=\"http://askubuntu.com/questions/376199/sudo-su-vs-sudo-i-vs-sudo-bin-bash-when-does-it-matter-which-is-used\" target=\"_blank\" rel=\"external\">su和sudo对运行环境的影响</a></li>\n<li><a href=\"https://getpocket.com/a/read/149876899\" target=\"_blank\" rel=\"external\">sudo使用代理</a></li>\n<li><a href=\"http://my.oschina.net/alphajay/blog/28811\" target=\"_blank\" rel=\"external\">sudo环境设置</a></li>\n</ol>"},{"layout":"post","title":"C语言编程之运算符","comments":1,"_content":"在C语言中有很多运算符，像求字节数运算符[sizeof]，赋值运算符,算术运算符,关系运算符,逻辑运算符，条件运算符，位运算符，指针运算符等。这些运算符在运算时是有优先级的，会最终影响结果。所以了解其优先级以及运算方法是挺重要的（虽然本人觉得这些都可以通过加括号来解决，但是还是要了解一下，以便更快读懂他人程序）。\n<!-- more -->\n\n\n## 类型转换\n在C语言中，有很多双目运算符（一个运算符有两个操作数），一般情况下两个操作数的数据类型要是一样的，不过当两边类型不一致时就要进行==类型转换==。而类型转换的最基本的原则是==往最高级转换==。其转换的关系如下图：  \n![convert_type]({{site.baseurl}}/assets/images/convert_type.png)  \n图中纵向代表转换的顺序，int->unsigned->long->double;而两个横向的转换是当表达式中出现了float会当作double来处理，出现了short，char类型都会当作int来处理，也就是说这步是必须的，必须执行的转换。所以我们得到以下的结论：\n\n1. 表达式的结果类型只有int/unsigned/long/double四种类型。\n2. 表达式的结果类型只要看表达式中数据类型最高的那个。\n\n## 自增/自减\n自增和自减概念类似，这里以自增为例。自增包括前自增和后自增。前自增（++i）是指变量先自增，然后将自增后的结果当作表达式的值;而后自增（i++）是指变量先将值当作表达式的值，然后再自增1。这个在大学学C语言就知道了，这里在提及是为了下面关于自增/自减的两种使用情况。\n\n1. 自增/自减操作符只能用于变量，不能用于表达式\n\n    ```c\n    #include<stdio.h>\n\n    int main(){\n        int i=1;\n        printf(\"i = %d\\n\",i);\n        printf(\"i++ = %d\\n\",i++);\n        printf(\"i = %d\\n\",i);\n        printf(\"++i = %d\\n\",++i);\n        rintf(\"i = %d\\n\",i);\n\n        // error: lvalue required as increment operand\n        //printf(\"(-i)++ = %d\\n\",(-i)++);\n        //printf(\"++i++ = %d\\n\",++i++);\n\n        return 0;\n    }\n    ```\n    由注释的三行可知：当给表达式进行自增操作的时候，回报左值需要增量操作数。\n2. 在输出中，计算顺序是从右往左\n\n    ```c\n    #include<stdio.h>\n\n    int main(){\n        int i=1;\n        // 输出多个自增\n        printf(\"i = %d\\n\",i);\n        printf(\"i = %d, i++ =%d\\n\",i,i++);\n        printf(\"i = %d\\n\",i);\n        printf(\"i++ = %d, ++i =%d\\n\",i,++i);\n        printf(\"i = %d\\n\",i);\n\n        return 0;\n    }\n    ```\n\n    根据下图输出的截图，我们发现运算的顺序是从右往左的。代码见[附件]({{site.baseurl}}/assets/attachs/selfinc.c.txt)。\n\n    ![increasment]({{site.baseurl}}/assets/images/increasment.png)  \n\n## 混合运算\n虽然本人觉得这部分绝对是装x的作死的，因为多用（）就能解决表达式的可读性，但为了读懂某些装x作死的coder写的code，还是稍微了解一下。\n\n* 操作符的优先级\n    1. 括号级别  \n    这是C语言中运算级别最高的操作符了。  \n    ![operator1]({{site.baseurl}}/assets/images/operator1.png)\n    2. 单目运算符  \n    第二级别的运算符有两个共同的特征:\n        * 它们都是单目运算符（强制类型转换和长度运算符sizeof个人也觉得算单目）\n        * 它们都是从右往左运算的（右撇子三剑客之一）。\n    ![operator2]({{site.baseurl}}/assets/images/operator2.png)\n    3. 双目运算符  \n    第三级别里面的操作符就“群魔乱舞”了。  \n        1. 算术运算符  \n        对于算术运算符，可能都知道乘除高于加减，但是还得记得取模%和乘除是同级的。  \n        ![operator34]({{site.baseurl}}/assets/images/operator34.png)  \n        2. 移位运算符  \n        有点疑问，见问题&回答1。  \n        ![operator5]({{site.baseurl}}/assets/images/operator5.png)  \n        3. 关系运算符  \n        记住一点，大于小于高于等于。  \n        ![operator67]({{site.baseurl}}/assets/images/operator67.png)  \n        4. 位操作符和逻辑操作符  \n        位操作符和逻辑操作符算是双目运算符中比较特殊的两个操作符，其特殊之处如下：  \n            * 按位取反操作符和逻辑非操作符是单目运算符，跻身第二级别\n            * 按位操作符优先级高于逻辑操作符\n            * 按位与& > 按位异或^ > 按位或|; 逻辑与&& > 逻辑或||\n\n        ![operator8-12]({{site.baseurl}}/assets/images/operator8-12.png)  \n    4. 三目运算符  \n    这也是从右往左运算的操作符（右撇子三剑客之一）\n    ![operator13]({{site.baseurl}}/assets/images/operator13.png)\n    5. 赋值家族运算符\n    这是除了不常用的逗号运算符以外优先基本最低的运算符了，而且也是最后一个从右往左运算的操作（右撇子三剑客之一）。\n    ![operator14]({{site.baseurl}}/assets/images/operator14.png)\n    6. 逗号运算符\n    这是优先级别最低的运算符，也是最不常用的运算符。\n    ![operator15]({{site.baseurl}}/assets/images/operator15.png)\n* 记忆要诀  \n上面的优先级还是比较繁琐的，还是下面的基础要诀比较重要：  \n    * 括号最重要，操作数越多优先级越低（单目>双目>三目）  \n    * 双目中，算术运算符 > 移位运算符 > 关系运算符 > 位操作符 > 逻辑操作符  \n    * 三目运算符（条件运算符） > 赋值家族运算符 > 逗号运算符  \n    * 相同优先级中，按结合顺序计算。只有三种运算符是从右往左的，分别是单目运算符，条件运算符和赋值运算符。  \n* 剪刀法切割表达式  \n\n    ```c\n    short s;\n    int i;\n    float f;\n    double d;\n    unsigned u;\n    printf(\"%d\\n\",123%s+(i+'@')+i*u-f/d);\n    ```\n剪刀法是将表达式中的符号按照优先级由低到高的顺序依次减开，而且除了右撇子三剑客之外都要从右往左开始剪。比如上式表达式中按下面的顺序剪开：\n    1. u-f\n    2. ）+i\n    3. s+(  \n此时表达式将变成四个部分，分别是123%s[int]，(i+'@')[int],i*u[unsigned],f/d[double]。最终的结果也是double类型的。\n\n\n## 问题&回答\n1. Q：在移位运算符中，我们发现其用法是变量>>表达式，按理说这样的用法4>>1应该会报错的（和自增/自减类似），但是执行代码`printf(\"%d\\n\",4>>1);`会获得结果2。  \nA: 尚且无解\n\n\n## 参考文献\n1. [计算机导论与C语言基础][coursera_c_8]\n2. [C语言运算符优先级列表][operator]\n3. [运算符优先级][baidu_op]\n\n[coursera_c_8]: https://www.coursera.org/learn/jisuanji-biancheng/home/week/8\n[operator]: http://www.jb51.net/article/37282.htm\n[baidu_op]: https://www.baidu.com/link?url=Dxl9sKUNMilpQ6j0ntrsvTU9x_XC4SO_oLhDdDGf0eH5j66dL9L4Am84PcUWKIt9qIhzz8ymJ358i_1jtuzcfq&wd=&eqid=d2c31b200000d9dd000000045625cbc3\n","source":"_posts/2015-10-10-C语言编程之运算符.md","raw":"---\nlayout:\tpost\ntitle:\tC语言编程之运算符\ncategories:\n- TECHNOLOGY\ntags:\n- C\n- Coding\npermalink:  Review-operator-C\ncomments:\ttrue\n---\n在C语言中有很多运算符，像求字节数运算符[sizeof]，赋值运算符,算术运算符,关系运算符,逻辑运算符，条件运算符，位运算符，指针运算符等。这些运算符在运算时是有优先级的，会最终影响结果。所以了解其优先级以及运算方法是挺重要的（虽然本人觉得这些都可以通过加括号来解决，但是还是要了解一下，以便更快读懂他人程序）。\n<!-- more -->\n\n\n## 类型转换\n在C语言中，有很多双目运算符（一个运算符有两个操作数），一般情况下两个操作数的数据类型要是一样的，不过当两边类型不一致时就要进行==类型转换==。而类型转换的最基本的原则是==往最高级转换==。其转换的关系如下图：  \n![convert_type]({{site.baseurl}}/assets/images/convert_type.png)  \n图中纵向代表转换的顺序，int->unsigned->long->double;而两个横向的转换是当表达式中出现了float会当作double来处理，出现了short，char类型都会当作int来处理，也就是说这步是必须的，必须执行的转换。所以我们得到以下的结论：\n\n1. 表达式的结果类型只有int/unsigned/long/double四种类型。\n2. 表达式的结果类型只要看表达式中数据类型最高的那个。\n\n## 自增/自减\n自增和自减概念类似，这里以自增为例。自增包括前自增和后自增。前自增（++i）是指变量先自增，然后将自增后的结果当作表达式的值;而后自增（i++）是指变量先将值当作表达式的值，然后再自增1。这个在大学学C语言就知道了，这里在提及是为了下面关于自增/自减的两种使用情况。\n\n1. 自增/自减操作符只能用于变量，不能用于表达式\n\n    ```c\n    #include<stdio.h>\n\n    int main(){\n        int i=1;\n        printf(\"i = %d\\n\",i);\n        printf(\"i++ = %d\\n\",i++);\n        printf(\"i = %d\\n\",i);\n        printf(\"++i = %d\\n\",++i);\n        rintf(\"i = %d\\n\",i);\n\n        // error: lvalue required as increment operand\n        //printf(\"(-i)++ = %d\\n\",(-i)++);\n        //printf(\"++i++ = %d\\n\",++i++);\n\n        return 0;\n    }\n    ```\n    由注释的三行可知：当给表达式进行自增操作的时候，回报左值需要增量操作数。\n2. 在输出中，计算顺序是从右往左\n\n    ```c\n    #include<stdio.h>\n\n    int main(){\n        int i=1;\n        // 输出多个自增\n        printf(\"i = %d\\n\",i);\n        printf(\"i = %d, i++ =%d\\n\",i,i++);\n        printf(\"i = %d\\n\",i);\n        printf(\"i++ = %d, ++i =%d\\n\",i,++i);\n        printf(\"i = %d\\n\",i);\n\n        return 0;\n    }\n    ```\n\n    根据下图输出的截图，我们发现运算的顺序是从右往左的。代码见[附件]({{site.baseurl}}/assets/attachs/selfinc.c.txt)。\n\n    ![increasment]({{site.baseurl}}/assets/images/increasment.png)  \n\n## 混合运算\n虽然本人觉得这部分绝对是装x的作死的，因为多用（）就能解决表达式的可读性，但为了读懂某些装x作死的coder写的code，还是稍微了解一下。\n\n* 操作符的优先级\n    1. 括号级别  \n    这是C语言中运算级别最高的操作符了。  \n    ![operator1]({{site.baseurl}}/assets/images/operator1.png)\n    2. 单目运算符  \n    第二级别的运算符有两个共同的特征:\n        * 它们都是单目运算符（强制类型转换和长度运算符sizeof个人也觉得算单目）\n        * 它们都是从右往左运算的（右撇子三剑客之一）。\n    ![operator2]({{site.baseurl}}/assets/images/operator2.png)\n    3. 双目运算符  \n    第三级别里面的操作符就“群魔乱舞”了。  \n        1. 算术运算符  \n        对于算术运算符，可能都知道乘除高于加减，但是还得记得取模%和乘除是同级的。  \n        ![operator34]({{site.baseurl}}/assets/images/operator34.png)  \n        2. 移位运算符  \n        有点疑问，见问题&回答1。  \n        ![operator5]({{site.baseurl}}/assets/images/operator5.png)  \n        3. 关系运算符  \n        记住一点，大于小于高于等于。  \n        ![operator67]({{site.baseurl}}/assets/images/operator67.png)  \n        4. 位操作符和逻辑操作符  \n        位操作符和逻辑操作符算是双目运算符中比较特殊的两个操作符，其特殊之处如下：  \n            * 按位取反操作符和逻辑非操作符是单目运算符，跻身第二级别\n            * 按位操作符优先级高于逻辑操作符\n            * 按位与& > 按位异或^ > 按位或|; 逻辑与&& > 逻辑或||\n\n        ![operator8-12]({{site.baseurl}}/assets/images/operator8-12.png)  \n    4. 三目运算符  \n    这也是从右往左运算的操作符（右撇子三剑客之一）\n    ![operator13]({{site.baseurl}}/assets/images/operator13.png)\n    5. 赋值家族运算符\n    这是除了不常用的逗号运算符以外优先基本最低的运算符了，而且也是最后一个从右往左运算的操作（右撇子三剑客之一）。\n    ![operator14]({{site.baseurl}}/assets/images/operator14.png)\n    6. 逗号运算符\n    这是优先级别最低的运算符，也是最不常用的运算符。\n    ![operator15]({{site.baseurl}}/assets/images/operator15.png)\n* 记忆要诀  \n上面的优先级还是比较繁琐的，还是下面的基础要诀比较重要：  \n    * 括号最重要，操作数越多优先级越低（单目>双目>三目）  \n    * 双目中，算术运算符 > 移位运算符 > 关系运算符 > 位操作符 > 逻辑操作符  \n    * 三目运算符（条件运算符） > 赋值家族运算符 > 逗号运算符  \n    * 相同优先级中，按结合顺序计算。只有三种运算符是从右往左的，分别是单目运算符，条件运算符和赋值运算符。  \n* 剪刀法切割表达式  \n\n    ```c\n    short s;\n    int i;\n    float f;\n    double d;\n    unsigned u;\n    printf(\"%d\\n\",123%s+(i+'@')+i*u-f/d);\n    ```\n剪刀法是将表达式中的符号按照优先级由低到高的顺序依次减开，而且除了右撇子三剑客之外都要从右往左开始剪。比如上式表达式中按下面的顺序剪开：\n    1. u-f\n    2. ）+i\n    3. s+(  \n此时表达式将变成四个部分，分别是123%s[int]，(i+'@')[int],i*u[unsigned],f/d[double]。最终的结果也是double类型的。\n\n\n## 问题&回答\n1. Q：在移位运算符中，我们发现其用法是变量>>表达式，按理说这样的用法4>>1应该会报错的（和自增/自减类似），但是执行代码`printf(\"%d\\n\",4>>1);`会获得结果2。  \nA: 尚且无解\n\n\n## 参考文献\n1. [计算机导论与C语言基础][coursera_c_8]\n2. [C语言运算符优先级列表][operator]\n3. [运算符优先级][baidu_op]\n\n[coursera_c_8]: https://www.coursera.org/learn/jisuanji-biancheng/home/week/8\n[operator]: http://www.jb51.net/article/37282.htm\n[baidu_op]: https://www.baidu.com/link?url=Dxl9sKUNMilpQ6j0ntrsvTU9x_XC4SO_oLhDdDGf0eH5j66dL9L4Am84PcUWKIt9qIhzz8ymJ358i_1jtuzcfq&wd=&eqid=d2c31b200000d9dd000000045625cbc3\n","slug":"Review-operator-C","published":1,"date":"2015-10-09T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1l001ml73yl2wu0tux","content":"<p>在C语言中有很多运算符，像求字节数运算符[sizeof]，赋值运算符,算术运算符,关系运算符,逻辑运算符，条件运算符，位运算符，指针运算符等。这些运算符在运算时是有优先级的，会最终影响结果。所以了解其优先级以及运算方法是挺重要的（虽然本人觉得这些都可以通过加括号来解决，但是还是要了解一下，以便更快读懂他人程序）。 <a id=\"more\"></a></p>\n<h2 id=\"类型转换\">类型转换</h2>\n<p>在C语言中，有很多双目运算符（一个运算符有两个操作数），一般情况下两个操作数的数据类型要是一样的，不过当两边类型不一致时就要进行==类型转换==。而类型转换的最基本的原则是==往最高级转换==。其转换的关系如下图：<br>\n[convert_type](/assets/images/convert_type.png)<br>\n图中纵向代表转换的顺序，int-&gt;unsigned-&gt;long-&gt;double;而两个横向的转换是当表达式中出现了float会当作double来处理，出现了short，char类型都会当作int来处理，也就是说这步是必须的，必须执行的转换。所以我们得到以下的结论：</p>\n<ol style=\"list-style-type: decimal\">\n<li>表达式的结果类型只有int/unsigned/long/double四种类型。</li>\n<li>表达式的结果类型只要看表达式中数据类型最高的那个。</li>\n</ol>\n<h2 id=\"自增自减\">自增/自减</h2>\n<p>自增和自减概念类似，这里以自增为例。自增包括前自增和后自增。前自增（++i）是指变量先自增，然后将自增后的结果当作表达式的值;而后自增（i++）是指变量先将值当作表达式的值，然后再自增1。这个在大学学C语言就知道了，这里在提及是为了下面关于自增/自减的两种使用情况。</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>自增/自减操作符只能用于变量，不能用于表达式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i = %d\\n\"</span>,i);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i++ = %d\\n\"</span>,i++);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i = %d\\n\"</span>,i);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"++i = %d\\n\"</span>,++i);</div><div class=\"line\">    rintf(<span class=\"string\">\"i = %d\\n\"</span>,i);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// error: lvalue required as increment operand</span></div><div class=\"line\">    <span class=\"comment\">//printf(\"(-i)++ = %d\\n\",(-i)++);</span></div><div class=\"line\">    <span class=\"comment\">//printf(\"++i++ = %d\\n\",++i++);</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n由注释的三行可知：当给表达式进行自增操作的时候，回报左值需要增量操作数。</li>\n<li><p>在输出中，计算顺序是从右往左</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"comment\">// 输出多个自增</span></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i = %d\\n\"</span>,i);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i = %d, i++ =%d\\n\"</span>,i,i++);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i = %d\\n\"</span>,i);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i++ = %d, ++i =%d\\n\"</span>,i,++i);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i = %d\\n\"</span>,i);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据下图输出的截图，我们发现运算的顺序是从右往左的。代码见[附件](/assets/attachs/selfinc.c.txt)。</p>\n<p>[increasment](/assets/images/increasment.png)</p></li>\n</ol>\n<h2 id=\"混合运算\">混合运算</h2>\n<p>虽然本人觉得这部分绝对是装x的作死的，因为多用（）就能解决表达式的可读性，但为了读懂某些装x作死的coder写的code，还是稍微了解一下。</p>\n<ul>\n<li>操作符的优先级\n<ol style=\"list-style-type: decimal\">\n<li>括号级别<br>\n这是C语言中运算级别最高的操作符了。<br>\n[operator1](/assets/images/operator1.png)</li>\n<li>单目运算符<br>\n第二级别的运算符有两个共同的特征:\n<ul>\n<li>它们都是单目运算符（强制类型转换和长度运算符sizeof个人也觉得算单目）</li>\n<li>它们都是从右往左运算的（右撇子三剑客之一）。 [operator2](/assets/images/operator2.png)</li>\n</ul></li>\n<li>双目运算符<br>\n第三级别里面的操作符就“群魔乱舞”了。\n<ol style=\"list-style-type: decimal\">\n<li>算术运算符<br>\n对于算术运算符，可能都知道乘除高于加减，但是还得记得取模%和乘除是同级的。<br>\n[operator34](/assets/images/operator34.png)<br>\n</li>\n<li>移位运算符<br>\n有点疑问，见问题&amp;回答1。<br>\n[operator5](/assets/images/operator5.png)<br>\n</li>\n<li>关系运算符<br>\n记住一点，大于小于高于等于。<br>\n[operator67](/assets/images/operator67.png)<br>\n</li>\n<li>位操作符和逻辑操作符<br>\n位操作符和逻辑操作符算是双目运算符中比较特殊的两个操作符，其特殊之处如下：\n<ul>\n<li>按位取反操作符和逻辑非操作符是单目运算符，跻身第二级别</li>\n<li>按位操作符优先级高于逻辑操作符</li>\n<li>按位与&amp; &gt; 按位异或^ &gt; 按位或|; 逻辑与&amp;&amp; &gt; 逻辑或||</li>\n</ul></li>\n</ol>\n[operator8-12](/assets/images/operator8-12.png)<br>\n</li>\n<li>三目运算符<br>\n这也是从右往左运算的操作符（右撇子三剑客之一） [operator13](/assets/images/operator13.png)</li>\n<li>赋值家族运算符 这是除了不常用的逗号运算符以外优先基本最低的运算符了，而且也是最后一个从右往左运算的操作（右撇子三剑客之一）。 [operator14](/assets/images/operator14.png)</li>\n<li>逗号运算符 这是优先级别最低的运算符，也是最不常用的运算符。 [operator15](/assets/images/operator15.png)</li>\n</ol></li>\n<li>记忆要诀<br>\n上面的优先级还是比较繁琐的，还是下面的基础要诀比较重要：\n<ul>\n<li>括号最重要，操作数越多优先级越低（单目&gt;双目&gt;三目）<br>\n</li>\n<li>双目中，算术运算符 &gt; 移位运算符 &gt; 关系运算符 &gt; 位操作符 &gt; 逻辑操作符<br>\n</li>\n<li>三目运算符（条件运算符） &gt; 赋值家族运算符 &gt; 逗号运算符<br>\n</li>\n<li>相同优先级中，按结合顺序计算。只有三种运算符是从右往左的，分别是单目运算符，条件运算符和赋值运算符。<br>\n</li>\n</ul></li>\n<li><p>剪刀法切割表达式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">short</span> s;</div><div class=\"line\"><span class=\"keyword\">int</span> i;</div><div class=\"line\"><span class=\"keyword\">float</span> f;</div><div class=\"line\"><span class=\"keyword\">double</span> d;</div><div class=\"line\"><span class=\"keyword\">unsigned</span> u;</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,<span class=\"number\">123</span>%s+(i+<span class=\"string\">'@'</span>)+i*u-f/d);</div></pre></td></tr></table></figure></li>\n</ul>\n<p>剪刀法是将表达式中的符号按照优先级由低到高的顺序依次减开，而且除了右撇子三剑客之外都要从右往左开始剪。比如上式表达式中按下面的顺序剪开： 1. u-f 2. ）+i 3. s+(<br>\n此时表达式将变成四个部分，分别是123%s[int]，(i+‘@’)[int],i*u[unsigned],f/d[double]。最终的结果也是double类型的。</p>\n<h2 id=\"问题回答\">问题&amp;回答</h2>\n<ol style=\"list-style-type: decimal\">\n<li>Q：在移位运算符中，我们发现其用法是变量&gt;&gt;表达式，按理说这样的用法4&gt;&gt;1应该会报错的（和自增/自减类似），但是执行代码<code>printf(&quot;%d\\n&quot;,4&gt;&gt;1);</code>会获得结果2。<br>\nA: 尚且无解</li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://www.coursera.org/learn/jisuanji-biancheng/home/week/8\" target=\"_blank\" rel=\"external\">计算机导论与C语言基础</a></li>\n<li><a href=\"http://www.jb51.net/article/37282.htm\" target=\"_blank\" rel=\"external\">C语言运算符优先级列表</a></li>\n<li><a href=\"https://www.baidu.com/link?url=Dxl9sKUNMilpQ6j0ntrsvTU9x_XC4SO_oLhDdDGf0eH5j66dL9L4Am84PcUWKIt9qIhzz8ymJ358i_1jtuzcfq&amp;wd=&amp;eqid=d2c31b200000d9dd000000045625cbc3\" target=\"_blank\" rel=\"external\">运算符优先级</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在C语言中有很多运算符，像求字节数运算符[sizeof]，赋值运算符,算术运算符,关系运算符,逻辑运算符，条件运算符，位运算符，指针运算符等。这些运算符在运算时是有优先级的，会最终影响结果。所以了解其优先级以及运算方法是挺重要的（虽然本人觉得这些都可以通过加括号来解决，但是还是要了解一下，以便更快读懂他人程序）。","more":"</p>\n<h2 id=\"类型转换\">类型转换</h2>\n<p>在C语言中，有很多双目运算符（一个运算符有两个操作数），一般情况下两个操作数的数据类型要是一样的，不过当两边类型不一致时就要进行==类型转换==。而类型转换的最基本的原则是==往最高级转换==。其转换的关系如下图：<br>\n[convert_type](/assets/images/convert_type.png)<br>\n图中纵向代表转换的顺序，int-&gt;unsigned-&gt;long-&gt;double;而两个横向的转换是当表达式中出现了float会当作double来处理，出现了short，char类型都会当作int来处理，也就是说这步是必须的，必须执行的转换。所以我们得到以下的结论：</p>\n<ol style=\"list-style-type: decimal\">\n<li>表达式的结果类型只有int/unsigned/long/double四种类型。</li>\n<li>表达式的结果类型只要看表达式中数据类型最高的那个。</li>\n</ol>\n<h2 id=\"自增自减\">自增/自减</h2>\n<p>自增和自减概念类似，这里以自增为例。自增包括前自增和后自增。前自增（++i）是指变量先自增，然后将自增后的结果当作表达式的值;而后自增（i++）是指变量先将值当作表达式的值，然后再自增1。这个在大学学C语言就知道了，这里在提及是为了下面关于自增/自减的两种使用情况。</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>自增/自减操作符只能用于变量，不能用于表达式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i = %d\\n\"</span>,i);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i++ = %d\\n\"</span>,i++);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i = %d\\n\"</span>,i);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"++i = %d\\n\"</span>,++i);</div><div class=\"line\">    rintf(<span class=\"string\">\"i = %d\\n\"</span>,i);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// error: lvalue required as increment operand</span></div><div class=\"line\">    <span class=\"comment\">//printf(\"(-i)++ = %d\\n\",(-i)++);</span></div><div class=\"line\">    <span class=\"comment\">//printf(\"++i++ = %d\\n\",++i++);</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n由注释的三行可知：当给表达式进行自增操作的时候，回报左值需要增量操作数。</li>\n<li><p>在输出中，计算顺序是从右往左</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"comment\">// 输出多个自增</span></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i = %d\\n\"</span>,i);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i = %d, i++ =%d\\n\"</span>,i,i++);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i = %d\\n\"</span>,i);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i++ = %d, ++i =%d\\n\"</span>,i,++i);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"i = %d\\n\"</span>,i);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据下图输出的截图，我们发现运算的顺序是从右往左的。代码见[附件](/assets/attachs/selfinc.c.txt)。</p>\n<p>[increasment](/assets/images/increasment.png)</p></li>\n</ol>\n<h2 id=\"混合运算\">混合运算</h2>\n<p>虽然本人觉得这部分绝对是装x的作死的，因为多用（）就能解决表达式的可读性，但为了读懂某些装x作死的coder写的code，还是稍微了解一下。</p>\n<ul>\n<li>操作符的优先级\n<ol style=\"list-style-type: decimal\">\n<li>括号级别<br>\n这是C语言中运算级别最高的操作符了。<br>\n[operator1](/assets/images/operator1.png)</li>\n<li>单目运算符<br>\n第二级别的运算符有两个共同的特征:\n<ul>\n<li>它们都是单目运算符（强制类型转换和长度运算符sizeof个人也觉得算单目）</li>\n<li>它们都是从右往左运算的（右撇子三剑客之一）。 [operator2](/assets/images/operator2.png)</li>\n</ul></li>\n<li>双目运算符<br>\n第三级别里面的操作符就“群魔乱舞”了。\n<ol style=\"list-style-type: decimal\">\n<li>算术运算符<br>\n对于算术运算符，可能都知道乘除高于加减，但是还得记得取模%和乘除是同级的。<br>\n[operator34](/assets/images/operator34.png)<br>\n</li>\n<li>移位运算符<br>\n有点疑问，见问题&amp;回答1。<br>\n[operator5](/assets/images/operator5.png)<br>\n</li>\n<li>关系运算符<br>\n记住一点，大于小于高于等于。<br>\n[operator67](/assets/images/operator67.png)<br>\n</li>\n<li>位操作符和逻辑操作符<br>\n位操作符和逻辑操作符算是双目运算符中比较特殊的两个操作符，其特殊之处如下：\n<ul>\n<li>按位取反操作符和逻辑非操作符是单目运算符，跻身第二级别</li>\n<li>按位操作符优先级高于逻辑操作符</li>\n<li>按位与&amp; &gt; 按位异或^ &gt; 按位或|; 逻辑与&amp;&amp; &gt; 逻辑或||</li>\n</ul></li>\n</ol>\n[operator8-12](/assets/images/operator8-12.png)<br>\n</li>\n<li>三目运算符<br>\n这也是从右往左运算的操作符（右撇子三剑客之一） [operator13](/assets/images/operator13.png)</li>\n<li>赋值家族运算符 这是除了不常用的逗号运算符以外优先基本最低的运算符了，而且也是最后一个从右往左运算的操作（右撇子三剑客之一）。 [operator14](/assets/images/operator14.png)</li>\n<li>逗号运算符 这是优先级别最低的运算符，也是最不常用的运算符。 [operator15](/assets/images/operator15.png)</li>\n</ol></li>\n<li>记忆要诀<br>\n上面的优先级还是比较繁琐的，还是下面的基础要诀比较重要：\n<ul>\n<li>括号最重要，操作数越多优先级越低（单目&gt;双目&gt;三目）<br>\n</li>\n<li>双目中，算术运算符 &gt; 移位运算符 &gt; 关系运算符 &gt; 位操作符 &gt; 逻辑操作符<br>\n</li>\n<li>三目运算符（条件运算符） &gt; 赋值家族运算符 &gt; 逗号运算符<br>\n</li>\n<li>相同优先级中，按结合顺序计算。只有三种运算符是从右往左的，分别是单目运算符，条件运算符和赋值运算符。<br>\n</li>\n</ul></li>\n<li><p>剪刀法切割表达式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">short</span> s;</div><div class=\"line\"><span class=\"keyword\">int</span> i;</div><div class=\"line\"><span class=\"keyword\">float</span> f;</div><div class=\"line\"><span class=\"keyword\">double</span> d;</div><div class=\"line\"><span class=\"keyword\">unsigned</span> u;</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,<span class=\"number\">123</span>%s+(i+<span class=\"string\">'@'</span>)+i*u-f/d);</div></pre></td></tr></table></figure></li>\n</ul>\n<p>剪刀法是将表达式中的符号按照优先级由低到高的顺序依次减开，而且除了右撇子三剑客之外都要从右往左开始剪。比如上式表达式中按下面的顺序剪开： 1. u-f 2. ）+i 3. s+(<br>\n此时表达式将变成四个部分，分别是123%s[int]，(i+‘@’)[int],i*u[unsigned],f/d[double]。最终的结果也是double类型的。</p>\n<h2 id=\"问题回答\">问题&amp;回答</h2>\n<ol style=\"list-style-type: decimal\">\n<li>Q：在移位运算符中，我们发现其用法是变量&gt;&gt;表达式，按理说这样的用法4&gt;&gt;1应该会报错的（和自增/自减类似），但是执行代码<code>printf(&quot;%d\\n&quot;,4&gt;&gt;1);</code>会获得结果2。<br>\nA: 尚且无解</li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://www.coursera.org/learn/jisuanji-biancheng/home/week/8\" target=\"_blank\" rel=\"external\">计算机导论与C语言基础</a></li>\n<li><a href=\"http://www.jb51.net/article/37282.htm\" target=\"_blank\" rel=\"external\">C语言运算符优先级列表</a></li>\n<li><a href=\"https://www.baidu.com/link?url=Dxl9sKUNMilpQ6j0ntrsvTU9x_XC4SO_oLhDdDGf0eH5j66dL9L4Am84PcUWKIt9qIhzz8ymJ358i_1jtuzcfq&amp;wd=&amp;eqid=d2c31b200000d9dd000000045625cbc3\" target=\"_blank\" rel=\"external\">运算符优先级</a></li>\n</ol>"},{"layout":"post","title":"C语言编程之数据类型","category":["C","Interview"],"comments":1,"_content":"在众多C语言面试题目里，经常会考察数据类型以查看面试者的基本知识的掌握程度。这里对C语言的基本数据类型和自定义数据类型进行一些试验，并理解自定义构造类型中构造数据类型的**字节对齐**规则。\n<!-- more -->\n\n\n## 基本类型\nC语言中基本数据类型就6（6=3+2+1）个，其中3个整型，2个浮点型，还有1个字符型。\n\n1. 代码片段  \n\n    ```c\n    // 整型\n    printf(\"sizeof(short) is %ld byte.\\n\",sizeof(short));\n    printf(\"sizeof(int) is %ld byte.\\n\",sizeof(int));\n    printf(\"sizeof(long) is %ld byte.\\n\",sizeof(long));\n    // 浮点型\n    printf(\"sizeof(float) is %ld byte.\\n\",sizeof(float));\n    printf(\"sizeof(double) is %ld byte.\\n\",sizeof(double));\n    // 字符型\n    printf(\"sizeof(char) is %ld byte.\\n\",sizeof(char));\n    ```\n2. 解析  \n因为系统是64位的ubuntu，使用的是gcc编译器，所以字符型占1个字节，short型占2个字节，int型占4个字节，long型占8个字节（32位占4个字节），float型占4个字节，double型占8个字节。\n\n## 自定义类型\n自定义数据类型有5个，分别是数组类型，空类型，指针类型，类和构造数据类型。其中构造数据类型又包含结构体，枚举型和共用体三个。\n### 数组类型\n其占用的空间是数组元素类型*数组长度。\n\n### [空类型][void]\n1. 代码片段\n\n    ```c\n    printf(\"sizeof(void) is %ld byte.\\n\",sizeof(void));\n    ```\n2. 解析  \n空类型只占用1个字节空间\n\n### 指针类型\n指针类型的大小跟指针所指向的数据类型无关，它都是8个字节。包括空类型指针也是如此。\n\n### 类\n待定\n\n### 构造数据类型\n* 字节对齐  \n对于构造数据类型所占空间的大小是经常被考察，而出题者想要考察的是面试者对[字节对齐][byteass]的了解。字节对齐规则有下面三个条件：\n    1. 数据成员对齐规则  \n    结构体或联合体的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的起始位置要从该成员大小或成员的子成员大小（如数组，结构体）的整数倍开始。\n    2. 结构体作为成员  \n    如果一个结构里有某些结构体成员，则结构体成员要从内部最大元素大小的整数倍地址开始存储。\n    3. 首尾验证  \n    结构体的总大小必须是其内部最大成员的整数倍，不足的要补齐。\n\n* 结构体  \n    1. 代码片段  \n\n        ```c\n        // struct\n        struct student{\n            char name[10];\n            int age;\n            char sex;\n            int a;\n            char b,c;\n        };\n\n        printf(\"sizeof(struct student) is %ld byte.\\n\",sizeof(struct student));\n        ```\n    2. 解析  \n    对于结构体`struct student`所占的空间是28个字节，如果将`int a`换成`char a`，则结构体所占的空间是20个字节。这里涉及到[字节对齐][byteassign]的规则。  \n    在上面的结构体中，字符数组name虽然占10个字节[0-9]的空间，但由于int占\n4个字节，得从4的倍数开始存储，所以age占了offset从12-15的四个字节。而10-11这两个字节由系统补齐。接着下面的`char sex`后面也会补3个字节，最后的char要补2个字节，所以结构体的总大小为28（28=12+4+4+4+4）个字节。当将`int sex`改为`char sex`后，第一个规则将不会让sex后面填充了，所以此时将结构体的总大小为20（20=12+4+1+1+2）个字节。\n\n* 共用体\n    1. 代码片段\n\n        ```c\n        // union\n        union u{\n            char ch;\n            int num;\n            double dou;\n            char name[10];\n        };\n        printf(\"sizeof(union u) is %ld byte.\\n\",sizeof(union u));\n        ```\n    2. 解析  \n    共用体将会占用16个字节空间，根据条件3很容易得到。虽然char name只占了10个字节，但是由于double类型占8个字符，整个共用体的占用空间必须是8的整数倍，所以占用的空间会是16字节了。\n\n* 枚举类型\n    1. 代码片段\n\n        ```c\n        // enum\n        enum days{mon,tue,wed,thu,fri,sat,sun};\n\n        printf(\"sizeof(enum days) is %ld byte.\\n\",sizeof(enum days));\n        ```\n    2. 解析  \n    枚举类型的大小恒为4个字节。\n\n## 试验\n* 验证C语言中数据类型所占空间大小\n    * [源码]({{site.baseurl}}/assets/attachs/varstype.c.txt)  \n    结果如下图  \n    ![vartype1]({{site.baseurl}}/assets/images/vartype1.png)  \n    ![vartype2]({{site.baseurl}}/assets/images/vartype2.png)  \n    * 解析\n        1. 每种数据类型的大小\n        2. 变量和变量类型求sizeof后完全一致，不存在类型没有定义变量就占用很少的空间。\n\n\n\n## 参考文献\n1. [深入了解void以及void指针][void]\n2. [字节对齐][byteassign]\n3. [5分钟搞定内存字节对齐][byteass]\n\n\n\n[void]: http://www.jb51.net/article/36570.htm\n[byteassign]: http://baike.baidu.com/link?url=enYabBEQUdTupCd9s7gx4hl-TqqT_nzFGxx0NIBYMXT_IIvXvwUUpmCPEESUoemnQRP33gfL3YIr6xkNSX8slK\n[byteass]: http://blog.csdn.net/hairetz/article/details/4084088\n","source":"_posts/2015-10-08-C语言编程之数据类型.md","raw":"---\nlayout:\tpost\ntitle:\tC语言编程之数据类型\ncategories:\n- TECHNOLOGY\ntags:\n- C\n- Interview\npermalink:  Review-datetype-C\ncategory:\t[C,Interview]\ncomments:\ttrue\n---\n在众多C语言面试题目里，经常会考察数据类型以查看面试者的基本知识的掌握程度。这里对C语言的基本数据类型和自定义数据类型进行一些试验，并理解自定义构造类型中构造数据类型的**字节对齐**规则。\n<!-- more -->\n\n\n## 基本类型\nC语言中基本数据类型就6（6=3+2+1）个，其中3个整型，2个浮点型，还有1个字符型。\n\n1. 代码片段  \n\n    ```c\n    // 整型\n    printf(\"sizeof(short) is %ld byte.\\n\",sizeof(short));\n    printf(\"sizeof(int) is %ld byte.\\n\",sizeof(int));\n    printf(\"sizeof(long) is %ld byte.\\n\",sizeof(long));\n    // 浮点型\n    printf(\"sizeof(float) is %ld byte.\\n\",sizeof(float));\n    printf(\"sizeof(double) is %ld byte.\\n\",sizeof(double));\n    // 字符型\n    printf(\"sizeof(char) is %ld byte.\\n\",sizeof(char));\n    ```\n2. 解析  \n因为系统是64位的ubuntu，使用的是gcc编译器，所以字符型占1个字节，short型占2个字节，int型占4个字节，long型占8个字节（32位占4个字节），float型占4个字节，double型占8个字节。\n\n## 自定义类型\n自定义数据类型有5个，分别是数组类型，空类型，指针类型，类和构造数据类型。其中构造数据类型又包含结构体，枚举型和共用体三个。\n### 数组类型\n其占用的空间是数组元素类型*数组长度。\n\n### [空类型][void]\n1. 代码片段\n\n    ```c\n    printf(\"sizeof(void) is %ld byte.\\n\",sizeof(void));\n    ```\n2. 解析  \n空类型只占用1个字节空间\n\n### 指针类型\n指针类型的大小跟指针所指向的数据类型无关，它都是8个字节。包括空类型指针也是如此。\n\n### 类\n待定\n\n### 构造数据类型\n* 字节对齐  \n对于构造数据类型所占空间的大小是经常被考察，而出题者想要考察的是面试者对[字节对齐][byteass]的了解。字节对齐规则有下面三个条件：\n    1. 数据成员对齐规则  \n    结构体或联合体的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的起始位置要从该成员大小或成员的子成员大小（如数组，结构体）的整数倍开始。\n    2. 结构体作为成员  \n    如果一个结构里有某些结构体成员，则结构体成员要从内部最大元素大小的整数倍地址开始存储。\n    3. 首尾验证  \n    结构体的总大小必须是其内部最大成员的整数倍，不足的要补齐。\n\n* 结构体  \n    1. 代码片段  \n\n        ```c\n        // struct\n        struct student{\n            char name[10];\n            int age;\n            char sex;\n            int a;\n            char b,c;\n        };\n\n        printf(\"sizeof(struct student) is %ld byte.\\n\",sizeof(struct student));\n        ```\n    2. 解析  \n    对于结构体`struct student`所占的空间是28个字节，如果将`int a`换成`char a`，则结构体所占的空间是20个字节。这里涉及到[字节对齐][byteassign]的规则。  \n    在上面的结构体中，字符数组name虽然占10个字节[0-9]的空间，但由于int占\n4个字节，得从4的倍数开始存储，所以age占了offset从12-15的四个字节。而10-11这两个字节由系统补齐。接着下面的`char sex`后面也会补3个字节，最后的char要补2个字节，所以结构体的总大小为28（28=12+4+4+4+4）个字节。当将`int sex`改为`char sex`后，第一个规则将不会让sex后面填充了，所以此时将结构体的总大小为20（20=12+4+1+1+2）个字节。\n\n* 共用体\n    1. 代码片段\n\n        ```c\n        // union\n        union u{\n            char ch;\n            int num;\n            double dou;\n            char name[10];\n        };\n        printf(\"sizeof(union u) is %ld byte.\\n\",sizeof(union u));\n        ```\n    2. 解析  \n    共用体将会占用16个字节空间，根据条件3很容易得到。虽然char name只占了10个字节，但是由于double类型占8个字符，整个共用体的占用空间必须是8的整数倍，所以占用的空间会是16字节了。\n\n* 枚举类型\n    1. 代码片段\n\n        ```c\n        // enum\n        enum days{mon,tue,wed,thu,fri,sat,sun};\n\n        printf(\"sizeof(enum days) is %ld byte.\\n\",sizeof(enum days));\n        ```\n    2. 解析  \n    枚举类型的大小恒为4个字节。\n\n## 试验\n* 验证C语言中数据类型所占空间大小\n    * [源码]({{site.baseurl}}/assets/attachs/varstype.c.txt)  \n    结果如下图  \n    ![vartype1]({{site.baseurl}}/assets/images/vartype1.png)  \n    ![vartype2]({{site.baseurl}}/assets/images/vartype2.png)  \n    * 解析\n        1. 每种数据类型的大小\n        2. 变量和变量类型求sizeof后完全一致，不存在类型没有定义变量就占用很少的空间。\n\n\n\n## 参考文献\n1. [深入了解void以及void指针][void]\n2. [字节对齐][byteassign]\n3. [5分钟搞定内存字节对齐][byteass]\n\n\n\n[void]: http://www.jb51.net/article/36570.htm\n[byteassign]: http://baike.baidu.com/link?url=enYabBEQUdTupCd9s7gx4hl-TqqT_nzFGxx0NIBYMXT_IIvXvwUUpmCPEESUoemnQRP33gfL3YIr6xkNSX8slK\n[byteass]: http://blog.csdn.net/hairetz/article/details/4084088\n","slug":"Review-datetype-C","published":1,"date":"2015-10-07T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1l001nl73y6laxi1bh","content":"<p>在众多C语言面试题目里，经常会考察数据类型以查看面试者的基本知识的掌握程度。这里对C语言的基本数据类型和自定义数据类型进行一些试验，并理解自定义构造类型中构造数据类型的<strong>字节对齐</strong>规则。 <a id=\"more\"></a></p>\n<h2 id=\"基本类型\">基本类型</h2>\n<p>C语言中基本数据类型就6（6=3+2+1）个，其中3个整型，2个浮点型，还有1个字符型。</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 整型</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(short) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">short</span>));</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(int) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(long) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span>));</div><div class=\"line\"><span class=\"comment\">// 浮点型</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(float) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">float</span>));</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(double) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">double</span>));</div><div class=\"line\"><span class=\"comment\">// 字符型</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(char) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>));</div></pre></td></tr></table></figure></li>\n<li><p>解析<br>\n因为系统是64位的ubuntu，使用的是gcc编译器，所以字符型占1个字节，short型占2个字节，int型占4个字节，long型占8个字节（32位占4个字节），float型占4个字节，double型占8个字节。</p></li>\n</ol>\n<h2 id=\"自定义类型\">自定义类型</h2>\n<p>自定义数据类型有5个，分别是数组类型，空类型，指针类型，类和构造数据类型。其中构造数据类型又包含结构体，枚举型和共用体三个。 ### 数组类型 其占用的空间是数组元素类型*数组长度。</p>\n<h3 id=\"空类型void\"><a href=\"http://www.jb51.net/article/36570.htm\" target=\"_blank\" rel=\"external\">空类型</a></h3>\n<ol style=\"list-style-type: decimal\">\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(void) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span>));</div></pre></td></tr></table></figure></li>\n<li><p>解析<br>\n空类型只占用1个字节空间</p></li>\n</ol>\n<h3 id=\"指针类型\">指针类型</h3>\n<p>指针类型的大小跟指针所指向的数据类型无关，它都是8个字节。包括空类型指针也是如此。</p>\n<h3 id=\"类\">类</h3>\n<p>待定</p>\n<h3 id=\"构造数据类型\">构造数据类型</h3>\n<ul>\n<li>字节对齐<br>\n对于构造数据类型所占空间的大小是经常被考察，而出题者想要考察的是面试者对<a href=\"http://blog.csdn.net/hairetz/article/details/4084088\" target=\"_blank\" rel=\"external\">字节对齐</a>的了解。字节对齐规则有下面三个条件：\n<ol style=\"list-style-type: decimal\">\n<li>数据成员对齐规则<br>\n结构体或联合体的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的起始位置要从该成员大小或成员的子成员大小（如数组，结构体）的整数倍开始。</li>\n<li>结构体作为成员<br>\n如果一个结构里有某些结构体成员，则结构体成员要从内部最大元素大小的整数倍地址开始存储。</li>\n<li>首尾验证<br>\n结构体的总大小必须是其内部最大成员的整数倍，不足的要补齐。</li>\n</ol></li>\n<li>结构体\n<ol style=\"list-style-type: decimal\">\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// struct</span></div><div class=\"line\"><span class=\"keyword\">struct</span> student&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> age;</div><div class=\"line\">    <span class=\"keyword\">char</span> sex;</div><div class=\"line\">    <span class=\"keyword\">int</span> a;</div><div class=\"line\">    <span class=\"keyword\">char</span> b,c;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(struct student) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> student));</div></pre></td></tr></table></figure></li>\n<li><p>解析<br>\n对于结构体<code>struct student</code>所占的空间是28个字节，如果将<code>int a</code>换成<code>char a</code>，则结构体所占的空间是20个字节。这里涉及到<a href=\"http://baike.baidu.com/link?url=enYabBEQUdTupCd9s7gx4hl-TqqT_nzFGxx0NIBYMXT_IIvXvwUUpmCPEESUoemnQRP33gfL3YIr6xkNSX8slK\" target=\"_blank\" rel=\"external\">字节对齐</a>的规则。<br>\n在上面的结构体中，字符数组name虽然占10个字节[0-9]的空间，但由于int占 4个字节，得从4的倍数开始存储，所以age占了offset从12-15的四个字节。而10-11这两个字节由系统补齐。接着下面的<code>char sex</code>后面也会补3个字节，最后的char要补2个字节，所以结构体的总大小为28（28=12+4+4+4+4）个字节。当将<code>int sex</code>改为<code>char sex</code>后，第一个规则将不会让sex后面填充了，所以此时将结构体的总大小为20（20=12+4+1+1+2）个字节。</p></li>\n</ol></li>\n<li>共用体\n<ol style=\"list-style-type: decimal\">\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// union</span></div><div class=\"line\"><span class=\"keyword\">union</span> u&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> ch;</div><div class=\"line\">    <span class=\"keyword\">int</span> num;</div><div class=\"line\">    <span class=\"keyword\">double</span> dou;</div><div class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(union u) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">union</span> u));</div></pre></td></tr></table></figure></li>\n<li><p>解析<br>\n共用体将会占用16个字节空间，根据条件3很容易得到。虽然char name只占了10个字节，但是由于double类型占8个字符，整个共用体的占用空间必须是8的整数倍，所以占用的空间会是16字节了。</p></li>\n</ol></li>\n<li>枚举类型\n<ol style=\"list-style-type: decimal\">\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// enum</span></div><div class=\"line\"><span class=\"keyword\">enum</span> days&#123;mon,tue,wed,thu,fri,sat,sun&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(enum days) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">enum</span> days));</div></pre></td></tr></table></figure></li>\n<li><p>解析<br>\n枚举类型的大小恒为4个字节。</p></li>\n</ol></li>\n</ul>\n<h2 id=\"试验\">试验</h2>\n<ul>\n<li>验证C语言中数据类型所占空间大小\n<ul>\n<li>[源码](/assets/attachs/varstype.c.txt)<br>\n结果如下图<br>\n[vartype1](/assets/images/vartype1.png)<br>\n[vartype2](/assets/images/vartype2.png)<br>\n</li>\n<li>解析\n<ol style=\"list-style-type: decimal\">\n<li>每种数据类型的大小</li>\n<li>变量和变量类型求sizeof后完全一致，不存在类型没有定义变量就占用很少的空间。</li>\n</ol></li>\n</ul></li>\n</ul>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://www.jb51.net/article/36570.htm\" target=\"_blank\" rel=\"external\">深入了解void以及void指针</a></li>\n<li><a href=\"http://baike.baidu.com/link?url=enYabBEQUdTupCd9s7gx4hl-TqqT_nzFGxx0NIBYMXT_IIvXvwUUpmCPEESUoemnQRP33gfL3YIr6xkNSX8slK\" target=\"_blank\" rel=\"external\">字节对齐</a></li>\n<li><a href=\"http://blog.csdn.net/hairetz/article/details/4084088\" target=\"_blank\" rel=\"external\">5分钟搞定内存字节对齐</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在众多C语言面试题目里，经常会考察数据类型以查看面试者的基本知识的掌握程度。这里对C语言的基本数据类型和自定义数据类型进行一些试验，并理解自定义构造类型中构造数据类型的<strong>字节对齐</strong>规则。","more":"</p>\n<h2 id=\"基本类型\">基本类型</h2>\n<p>C语言中基本数据类型就6（6=3+2+1）个，其中3个整型，2个浮点型，还有1个字符型。</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 整型</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(short) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">short</span>));</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(int) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(long) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span>));</div><div class=\"line\"><span class=\"comment\">// 浮点型</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(float) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">float</span>));</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(double) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">double</span>));</div><div class=\"line\"><span class=\"comment\">// 字符型</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(char) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>));</div></pre></td></tr></table></figure></li>\n<li><p>解析<br>\n因为系统是64位的ubuntu，使用的是gcc编译器，所以字符型占1个字节，short型占2个字节，int型占4个字节，long型占8个字节（32位占4个字节），float型占4个字节，double型占8个字节。</p></li>\n</ol>\n<h2 id=\"自定义类型\">自定义类型</h2>\n<p>自定义数据类型有5个，分别是数组类型，空类型，指针类型，类和构造数据类型。其中构造数据类型又包含结构体，枚举型和共用体三个。 ### 数组类型 其占用的空间是数组元素类型*数组长度。</p>\n<h3 id=\"空类型void\"><a href=\"http://www.jb51.net/article/36570.htm\" target=\"_blank\" rel=\"external\">空类型</a></h3>\n<ol style=\"list-style-type: decimal\">\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(void) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span>));</div></pre></td></tr></table></figure></li>\n<li><p>解析<br>\n空类型只占用1个字节空间</p></li>\n</ol>\n<h3 id=\"指针类型\">指针类型</h3>\n<p>指针类型的大小跟指针所指向的数据类型无关，它都是8个字节。包括空类型指针也是如此。</p>\n<h3 id=\"类\">类</h3>\n<p>待定</p>\n<h3 id=\"构造数据类型\">构造数据类型</h3>\n<ul>\n<li>字节对齐<br>\n对于构造数据类型所占空间的大小是经常被考察，而出题者想要考察的是面试者对<a href=\"http://blog.csdn.net/hairetz/article/details/4084088\" target=\"_blank\" rel=\"external\">字节对齐</a>的了解。字节对齐规则有下面三个条件：\n<ol style=\"list-style-type: decimal\">\n<li>数据成员对齐规则<br>\n结构体或联合体的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的起始位置要从该成员大小或成员的子成员大小（如数组，结构体）的整数倍开始。</li>\n<li>结构体作为成员<br>\n如果一个结构里有某些结构体成员，则结构体成员要从内部最大元素大小的整数倍地址开始存储。</li>\n<li>首尾验证<br>\n结构体的总大小必须是其内部最大成员的整数倍，不足的要补齐。</li>\n</ol></li>\n<li>结构体\n<ol style=\"list-style-type: decimal\">\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// struct</span></div><div class=\"line\"><span class=\"keyword\">struct</span> student&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> age;</div><div class=\"line\">    <span class=\"keyword\">char</span> sex;</div><div class=\"line\">    <span class=\"keyword\">int</span> a;</div><div class=\"line\">    <span class=\"keyword\">char</span> b,c;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(struct student) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> student));</div></pre></td></tr></table></figure></li>\n<li><p>解析<br>\n对于结构体<code>struct student</code>所占的空间是28个字节，如果将<code>int a</code>换成<code>char a</code>，则结构体所占的空间是20个字节。这里涉及到<a href=\"http://baike.baidu.com/link?url=enYabBEQUdTupCd9s7gx4hl-TqqT_nzFGxx0NIBYMXT_IIvXvwUUpmCPEESUoemnQRP33gfL3YIr6xkNSX8slK\" target=\"_blank\" rel=\"external\">字节对齐</a>的规则。<br>\n在上面的结构体中，字符数组name虽然占10个字节[0-9]的空间，但由于int占 4个字节，得从4的倍数开始存储，所以age占了offset从12-15的四个字节。而10-11这两个字节由系统补齐。接着下面的<code>char sex</code>后面也会补3个字节，最后的char要补2个字节，所以结构体的总大小为28（28=12+4+4+4+4）个字节。当将<code>int sex</code>改为<code>char sex</code>后，第一个规则将不会让sex后面填充了，所以此时将结构体的总大小为20（20=12+4+1+1+2）个字节。</p></li>\n</ol></li>\n<li>共用体\n<ol style=\"list-style-type: decimal\">\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// union</span></div><div class=\"line\"><span class=\"keyword\">union</span> u&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> ch;</div><div class=\"line\">    <span class=\"keyword\">int</span> num;</div><div class=\"line\">    <span class=\"keyword\">double</span> dou;</div><div class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(union u) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">union</span> u));</div></pre></td></tr></table></figure></li>\n<li><p>解析<br>\n共用体将会占用16个字节空间，根据条件3很容易得到。虽然char name只占了10个字节，但是由于double类型占8个字符，整个共用体的占用空间必须是8的整数倍，所以占用的空间会是16字节了。</p></li>\n</ol></li>\n<li>枚举类型\n<ol style=\"list-style-type: decimal\">\n<li><p>代码片段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// enum</span></div><div class=\"line\"><span class=\"keyword\">enum</span> days&#123;mon,tue,wed,thu,fri,sat,sun&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sizeof(enum days) is %ld byte.\\n\"</span>,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">enum</span> days));</div></pre></td></tr></table></figure></li>\n<li><p>解析<br>\n枚举类型的大小恒为4个字节。</p></li>\n</ol></li>\n</ul>\n<h2 id=\"试验\">试验</h2>\n<ul>\n<li>验证C语言中数据类型所占空间大小\n<ul>\n<li>[源码](/assets/attachs/varstype.c.txt)<br>\n结果如下图<br>\n[vartype1](/assets/images/vartype1.png)<br>\n[vartype2](/assets/images/vartype2.png)<br>\n</li>\n<li>解析\n<ol style=\"list-style-type: decimal\">\n<li>每种数据类型的大小</li>\n<li>变量和变量类型求sizeof后完全一致，不存在类型没有定义变量就占用很少的空间。</li>\n</ol></li>\n</ul></li>\n</ul>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://www.jb51.net/article/36570.htm\" target=\"_blank\" rel=\"external\">深入了解void以及void指针</a></li>\n<li><a href=\"http://baike.baidu.com/link?url=enYabBEQUdTupCd9s7gx4hl-TqqT_nzFGxx0NIBYMXT_IIvXvwUUpmCPEESUoemnQRP33gfL3YIr6xkNSX8slK\" target=\"_blank\" rel=\"external\">字节对齐</a></li>\n<li><a href=\"http://blog.csdn.net/hairetz/article/details/4084088\" target=\"_blank\" rel=\"external\">5分钟搞定内存字节对齐</a></li>\n</ol>"},{"layout":"post","title":"C家族语言编程之输入","comments":1,"_content":"大家都知道C++语言是兼容C语言的，所以在C++中我们有最起码两种方式来实现输入输出。但是这里我还是想将这二者区分开来。毕竟目前还是喜欢在纯C的环境下面编程。所以这里就稍微介绍一下C/C++里面常用的输入输出。\n<!-- more -->\n\n## 输入的过程\n在C家族语言的编程中，我们经常需要在键盘上输入一些字符给程序。比如我们要输入“How are you？\\n”，在我们输入上面的字符后敲击回车\"\\n\"，此时这串字符串会先被送到一个叫输入缓冲区(一般叫stdin)的地方，然后程序再从输入缓冲区中获取这些字符。而并不是先接受\"How\"，然后接受\"are\"，最后再接受\"you?\\n\"，很简单的反例就是当我们在输入时发现输入了我们并不想输入的字符时，我们用<backspace>可以取消之前的输入，如果不是采用输入缓冲区的机制，那么就会产生误解。\n\n\n除了了解输入缓冲区的概念外，还要知道输入缓冲区指针，==一个只能前进不能后退的指针==，它用来标注程序目前读到缓冲区什么位置。而对于不同的输入函数，我们要注意两点，第一点是它怎样区分多个输入值，或者说缓冲区指针会吸收掉哪些分隔符;第二点是它接受输入成功后的返回值。\n\n\n## C里的输入\n* scanf  \n这是最常用的一种输入，无论整数还是字符串等都能够完美解决，其返回值为成功赋值的数据项数。当遇到文件结束符时返回0。它区分多个输入值的分隔符为空格，制表符和回车。\n\n* ==gets==  \ngets是从标准输入缓冲区上读字符串。可以无限读取，不会判断上限，以回车结束读取。如果读取溢出时，多出来的字符将会被写入到堆栈中，这就**覆盖了堆栈原来的内容**，破坏一个或多个不相关变量的值。这个导致gets函数已经被gcc摒弃，所以用fgets来取代gets。\n\n* fgets  \n能够从stream中读取数据，每次读取一行。读取的数据保存在buf指向的字符数组中，每次最多读取bufsize-1个字符（第bufsize个字符赋值'\\0'），如果文件中该行不足bufsize个字符，则读完该行就结束。此时特别注意，**fgets不会像gets将'\\n'替换成'\\0'，而是在'\\n'后面添加'\\0'**。函数成功将返回buf地址，失败或读到文件结尾将返回NULL，所以不能通过fgets的返回值来判断函数是否出错而终止，应该借助feof函数或者ferror函数来判断。\n\n```c\n#include<stdio.h>\n\n#define LEN 10\n\nint main(){\n    int a,b;\n    char str[LEN];\n\n    printf(\"%d\\n\",scanf(\"%d %d\",&a,&b));\n    /* fflush(stdin); */\n    getchar();\n    printf(\"%s\\n\",fgets(str,LEN,stdin));\n\n    return 0;\n}\n```\n通过下图中几个测试样例可以看出fgets以上的特点。\n\n![fgets]({{site.baseurl}}/assets/images/fgets.png)  \n\n\n## C++中的输入\n\n* cin  \ncin是标准输入istream的一个对象，常用的方法\"cin>>x\"，是将输入缓冲区中对象赋给x对象。其返回值根据\">>\"输入操作符的定义知道是返回cin对象。cin会吸收的分隔符有空格，制表符和回车符。\n\n```c\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n    int i;\n\n    cout<<(cin>>i)<<endl;\n\n    return 0;\n}\n```\n在多次执行该代码，发现当正确输入一个整数（90）时，返回\"ox601090\"，当输入错误（字符k）时，返回0。而且在输入90前敲了空格，制表符，回车发现cin都没有执行，所以它会吃掉那些分隔符。具体见下图：\n\n![cin]({{site.baseurl}}/assets/images/cin.png)\n\n* cin.get()/cin.get(char)  \n用于读入一个字符，字符中包括空格，制表符，回车等。常用的方法是\"while((c=cin.get())!=EOF){}\"或\"while(cin.get(c)){}\"。其中EOF代表文件终止符，在终端中用<ctrl+Z>终止。\n\n* cin.get(str,len,'\\n')/cin.getline(str,len,'\\n')  \n用于读取一串字符，其中str代表字符串存储的地址，len代表最多读取len-1个字符，'\\n'代表终止符，即碰到'\\n'也停止读取。\n二者也是有区别的，区别就是getline遇到终止字符时结束，会将缓冲区指针移动到终止字符之后，而get遇到终止字符时，缓冲区指针不会动。也就是说getline会吃掉终止符号。验证代码[input.cpp]({{site.baseurl}}/assets/attachs/input.cpp.txt)执行的结果如下图所示：\n![get_getline]({{site.baseurl}}/assets/images/get_getline.png)  \n有两个注意点：\n    1. 代码中用cin.get()吃掉了4后面的换行符。\n    2. 在getline中遇到'e'终止并吃掉了'e'，所以第二次输出时输出的是\"ll\\nmm\"，而get中遇到了'e'终止，却无法吃掉'e'，导致再进行cin.get(str,10,'e')时无法获取字符就又终止了。\n\n\n\n## 问题&回答\n1. Q:根据\">>\"输入操作符的定义知道返回值是cin对象，所以才可以使用像\"cin>>a>>b;\"这样的连续输入，但是像\"while(cin>>x){}\"这样的用法意味着cin>>x会返回0，为什么？  \nA: 参见[cin的返回值探究][return_cin]。\n\n\n## 参考文献\n1. [cin的返回值探究][return_cin]\n2. [百科gets][bike_gets]\n2. [百科fgets][bike_fgets]\n\n\n[ref_label]: http://siteurl\n[return_cin]:   http://blog.csdn.net/kongbai308416350/article/details/4470914\n[bike_gets]:    http://baike.baidu.com/link?url=3IuFZpWf27rB7L83gIaDIJUuMMuSSWB-Xdrsy4mb-ml3vyuaEHHr3ceOIT_H8eDDVDh0L_pi2h4UheKYe-Vqda\n[bike_fgets]:   http://baike.baidu.com/link?url=08NOHmRHSYROfmu2O2uvfe3hwOx_Ur2fZlGqPFGV4f-3kL9y4ggUAI4t9l5D64ZmNoL8Cbc7AwuCW-rcCutGJa\n","source":"_posts/2015-10-24-C家族语言之输入输出.md","raw":"---\nlayout:\tpost\ntitle:\tC家族语言编程之输入\ncategories:\n- TECHNOLOGY\ntags:\n- C\n- C++\n- Coding\npermalink:  Review-input-C\ncomments:\ttrue\n---\n大家都知道C++语言是兼容C语言的，所以在C++中我们有最起码两种方式来实现输入输出。但是这里我还是想将这二者区分开来。毕竟目前还是喜欢在纯C的环境下面编程。所以这里就稍微介绍一下C/C++里面常用的输入输出。\n<!-- more -->\n\n## 输入的过程\n在C家族语言的编程中，我们经常需要在键盘上输入一些字符给程序。比如我们要输入“How are you？\\n”，在我们输入上面的字符后敲击回车\"\\n\"，此时这串字符串会先被送到一个叫输入缓冲区(一般叫stdin)的地方，然后程序再从输入缓冲区中获取这些字符。而并不是先接受\"How\"，然后接受\"are\"，最后再接受\"you?\\n\"，很简单的反例就是当我们在输入时发现输入了我们并不想输入的字符时，我们用<backspace>可以取消之前的输入，如果不是采用输入缓冲区的机制，那么就会产生误解。\n\n\n除了了解输入缓冲区的概念外，还要知道输入缓冲区指针，==一个只能前进不能后退的指针==，它用来标注程序目前读到缓冲区什么位置。而对于不同的输入函数，我们要注意两点，第一点是它怎样区分多个输入值，或者说缓冲区指针会吸收掉哪些分隔符;第二点是它接受输入成功后的返回值。\n\n\n## C里的输入\n* scanf  \n这是最常用的一种输入，无论整数还是字符串等都能够完美解决，其返回值为成功赋值的数据项数。当遇到文件结束符时返回0。它区分多个输入值的分隔符为空格，制表符和回车。\n\n* ==gets==  \ngets是从标准输入缓冲区上读字符串。可以无限读取，不会判断上限，以回车结束读取。如果读取溢出时，多出来的字符将会被写入到堆栈中，这就**覆盖了堆栈原来的内容**，破坏一个或多个不相关变量的值。这个导致gets函数已经被gcc摒弃，所以用fgets来取代gets。\n\n* fgets  \n能够从stream中读取数据，每次读取一行。读取的数据保存在buf指向的字符数组中，每次最多读取bufsize-1个字符（第bufsize个字符赋值'\\0'），如果文件中该行不足bufsize个字符，则读完该行就结束。此时特别注意，**fgets不会像gets将'\\n'替换成'\\0'，而是在'\\n'后面添加'\\0'**。函数成功将返回buf地址，失败或读到文件结尾将返回NULL，所以不能通过fgets的返回值来判断函数是否出错而终止，应该借助feof函数或者ferror函数来判断。\n\n```c\n#include<stdio.h>\n\n#define LEN 10\n\nint main(){\n    int a,b;\n    char str[LEN];\n\n    printf(\"%d\\n\",scanf(\"%d %d\",&a,&b));\n    /* fflush(stdin); */\n    getchar();\n    printf(\"%s\\n\",fgets(str,LEN,stdin));\n\n    return 0;\n}\n```\n通过下图中几个测试样例可以看出fgets以上的特点。\n\n![fgets]({{site.baseurl}}/assets/images/fgets.png)  \n\n\n## C++中的输入\n\n* cin  \ncin是标准输入istream的一个对象，常用的方法\"cin>>x\"，是将输入缓冲区中对象赋给x对象。其返回值根据\">>\"输入操作符的定义知道是返回cin对象。cin会吸收的分隔符有空格，制表符和回车符。\n\n```c\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n    int i;\n\n    cout<<(cin>>i)<<endl;\n\n    return 0;\n}\n```\n在多次执行该代码，发现当正确输入一个整数（90）时，返回\"ox601090\"，当输入错误（字符k）时，返回0。而且在输入90前敲了空格，制表符，回车发现cin都没有执行，所以它会吃掉那些分隔符。具体见下图：\n\n![cin]({{site.baseurl}}/assets/images/cin.png)\n\n* cin.get()/cin.get(char)  \n用于读入一个字符，字符中包括空格，制表符，回车等。常用的方法是\"while((c=cin.get())!=EOF){}\"或\"while(cin.get(c)){}\"。其中EOF代表文件终止符，在终端中用<ctrl+Z>终止。\n\n* cin.get(str,len,'\\n')/cin.getline(str,len,'\\n')  \n用于读取一串字符，其中str代表字符串存储的地址，len代表最多读取len-1个字符，'\\n'代表终止符，即碰到'\\n'也停止读取。\n二者也是有区别的，区别就是getline遇到终止字符时结束，会将缓冲区指针移动到终止字符之后，而get遇到终止字符时，缓冲区指针不会动。也就是说getline会吃掉终止符号。验证代码[input.cpp]({{site.baseurl}}/assets/attachs/input.cpp.txt)执行的结果如下图所示：\n![get_getline]({{site.baseurl}}/assets/images/get_getline.png)  \n有两个注意点：\n    1. 代码中用cin.get()吃掉了4后面的换行符。\n    2. 在getline中遇到'e'终止并吃掉了'e'，所以第二次输出时输出的是\"ll\\nmm\"，而get中遇到了'e'终止，却无法吃掉'e'，导致再进行cin.get(str,10,'e')时无法获取字符就又终止了。\n\n\n\n## 问题&回答\n1. Q:根据\">>\"输入操作符的定义知道返回值是cin对象，所以才可以使用像\"cin>>a>>b;\"这样的连续输入，但是像\"while(cin>>x){}\"这样的用法意味着cin>>x会返回0，为什么？  \nA: 参见[cin的返回值探究][return_cin]。\n\n\n## 参考文献\n1. [cin的返回值探究][return_cin]\n2. [百科gets][bike_gets]\n2. [百科fgets][bike_fgets]\n\n\n[ref_label]: http://siteurl\n[return_cin]:   http://blog.csdn.net/kongbai308416350/article/details/4470914\n[bike_gets]:    http://baike.baidu.com/link?url=3IuFZpWf27rB7L83gIaDIJUuMMuSSWB-Xdrsy4mb-ml3vyuaEHHr3ceOIT_H8eDDVDh0L_pi2h4UheKYe-Vqda\n[bike_fgets]:   http://baike.baidu.com/link?url=08NOHmRHSYROfmu2O2uvfe3hwOx_Ur2fZlGqPFGV4f-3kL9y4ggUAI4t9l5D64ZmNoL8Cbc7AwuCW-rcCutGJa\n","slug":"Review-input-C","published":1,"date":"2015-10-23T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1m001ol73yhlkfy00r","content":"<p>大家都知道C++语言是兼容C语言的，所以在C++中我们有最起码两种方式来实现输入输出。但是这里我还是想将这二者区分开来。毕竟目前还是喜欢在纯C的环境下面编程。所以这里就稍微介绍一下C/C++里面常用的输入输出。 <a id=\"more\"></a></p>\n<h2 id=\"输入的过程\">输入的过程</h2>\n<p>在C家族语言的编程中，我们经常需要在键盘上输入一些字符给程序。比如我们要输入“How are you？”，在我们输入上面的字符后敲击回车“”，此时这串字符串会先被送到一个叫输入缓冲区(一般叫stdin)的地方，然后程序再从输入缓冲区中获取这些字符。而并不是先接受“How”，然后接受“are”，最后再接受“you?”，很简单的反例就是当我们在输入时发现输入了我们并不想输入的字符时，我们用<backspace>可以取消之前的输入，如果不是采用输入缓冲区的机制，那么就会产生误解。</backspace></p>\n<p>除了了解输入缓冲区的概念外，还要知道输入缓冲区指针，==一个只能前进不能后退的指针==，它用来标注程序目前读到缓冲区什么位置。而对于不同的输入函数，我们要注意两点，第一点是它怎样区分多个输入值，或者说缓冲区指针会吸收掉哪些分隔符;第二点是它接受输入成功后的返回值。</p>\n<h2 id=\"c里的输入\">C里的输入</h2>\n<ul>\n<li><p>scanf<br>\n这是最常用的一种输入，无论整数还是字符串等都能够完美解决，其返回值为成功赋值的数据项数。当遇到文件结束符时返回0。它区分多个输入值的分隔符为空格，制表符和回车。</p></li>\n<li><p>==gets==<br>\ngets是从标准输入缓冲区上读字符串。可以无限读取，不会判断上限，以回车结束读取。如果读取溢出时，多出来的字符将会被写入到堆栈中，这就<strong>覆盖了堆栈原来的内容</strong>，破坏一个或多个不相关变量的值。这个导致gets函数已经被gcc摒弃，所以用fgets来取代gets。</p></li>\n<li><p>fgets<br>\n能够从stream中读取数据，每次读取一行。读取的数据保存在buf指向的字符数组中，每次最多读取bufsize-1个字符（第bufsize个字符赋值’’），如果文件中该行不足bufsize个字符，则读完该行就结束。此时特别注意，<strong>fgets不会像gets将’‘替换成’‘，而是在’‘后面添加’’</strong>。函数成功将返回buf地址，失败或读到文件结尾将返回NULL，所以不能通过fgets的返回值来判断函数是否出错而终止，应该借助feof函数或者ferror函数来判断。</p></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LEN 10</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> a,b;</div><div class=\"line\">    <span class=\"keyword\">char</span> str[LEN];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;a,&amp;b));</div><div class=\"line\">    <span class=\"comment\">/* fflush(stdin); */</span></div><div class=\"line\">    getchar();</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,fgets(str,LEN,<span class=\"built_in\">stdin</span>));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过下图中几个测试样例可以看出fgets以上的特点。</p>\n<p>[fgets](/assets/images/fgets.png)</p>\n<h2 id=\"c中的输入\">C++中的输入</h2>\n<ul>\n<li>cin<br>\ncin是标准输入istream的一个对象，常用的方法“cin&gt;&gt;x”，是将输入缓冲区中对象赋给x对象。其返回值根据“&gt;&gt;”输入操作符的定义知道是返回cin对象。cin会吸收的分隔符有空格，制表符和回车符。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;(<span class=\"built_in\">cin</span>&gt;&gt;i)&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在多次执行该代码，发现当正确输入一个整数（90）时，返回“ox601090”，当输入错误（字符k）时，返回0。而且在输入90前敲了空格，制表符，回车发现cin都没有执行，所以它会吃掉那些分隔符。具体见下图：</p>\n<p>[cin](/assets/images/cin.png)</p>\n<ul>\n<li><p>cin.get()/cin.get(char)<br>\n用于读入一个字符，字符中包括空格，制表符，回车等。常用的方法是“while((c=cin.get())!=EOF){}”或“while(cin.get(c)){}”。其中EOF代表文件终止符，在终端中用<ctrl+z>终止。</ctrl+z></p></li>\n<li>cin.get(str,len,‘’)/cin.getline(str,len,‘’)<br>\n用于读取一串字符，其中str代表字符串存储的地址，len代表最多读取len-1个字符，‘’代表终止符，即碰到’’也停止读取。 二者也是有区别的，区别就是getline遇到终止字符时结束，会将缓冲区指针移动到终止字符之后，而get遇到终止字符时，缓冲区指针不会动。也就是说getline会吃掉终止符号。验证代码[input.cpp](/assets/attachs/input.cpp.txt)执行的结果如下图所示： [get_getline](/assets/images/get_getline.png)<br>\n有两个注意点：\n<ol style=\"list-style-type: decimal\">\n<li>代码中用cin.get()吃掉了4后面的换行符。</li>\n<li>在getline中遇到’e’终止并吃掉了’e’，所以第二次输出时输出的是“ll”，而get中遇到了’e’终止，却无法吃掉’e’，导致再进行cin.get(str,10,‘e’)时无法获取字符就又终止了。</li>\n</ol></li>\n</ul>\n<h2 id=\"问题回答\">问题&amp;回答</h2>\n<ol style=\"list-style-type: decimal\">\n<li>Q:根据“&gt;&gt;”输入操作符的定义知道返回值是cin对象，所以才可以使用像“cin&gt;&gt;a&gt;&gt;b;”这样的连续输入，但是像“while(cin&gt;&gt;x){}”这样的用法意味着cin&gt;&gt;x会返回0，为什么？<br>\nA: 参见<a href=\"http://blog.csdn.net/kongbai308416350/article/details/4470914\" target=\"_blank\" rel=\"external\">cin的返回值探究</a>。</li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://blog.csdn.net/kongbai308416350/article/details/4470914\" target=\"_blank\" rel=\"external\">cin的返回值探究</a></li>\n<li><a href=\"http://baike.baidu.com/link?url=3IuFZpWf27rB7L83gIaDIJUuMMuSSWB-Xdrsy4mb-ml3vyuaEHHr3ceOIT_H8eDDVDh0L_pi2h4UheKYe-Vqda\" target=\"_blank\" rel=\"external\">百科gets</a></li>\n<li><a href=\"http://baike.baidu.com/link?url=08NOHmRHSYROfmu2O2uvfe3hwOx_Ur2fZlGqPFGV4f-3kL9y4ggUAI4t9l5D64ZmNoL8Cbc7AwuCW-rcCutGJa\" target=\"_blank\" rel=\"external\">百科fgets</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>大家都知道C++语言是兼容C语言的，所以在C++中我们有最起码两种方式来实现输入输出。但是这里我还是想将这二者区分开来。毕竟目前还是喜欢在纯C的环境下面编程。所以这里就稍微介绍一下C/C++里面常用的输入输出。","more":"</p>\n<h2 id=\"输入的过程\">输入的过程</h2>\n<p>在C家族语言的编程中，我们经常需要在键盘上输入一些字符给程序。比如我们要输入“How are you？”，在我们输入上面的字符后敲击回车“”，此时这串字符串会先被送到一个叫输入缓冲区(一般叫stdin)的地方，然后程序再从输入缓冲区中获取这些字符。而并不是先接受“How”，然后接受“are”，最后再接受“you?”，很简单的反例就是当我们在输入时发现输入了我们并不想输入的字符时，我们用<backspace>可以取消之前的输入，如果不是采用输入缓冲区的机制，那么就会产生误解。</backspace></p>\n<p>除了了解输入缓冲区的概念外，还要知道输入缓冲区指针，==一个只能前进不能后退的指针==，它用来标注程序目前读到缓冲区什么位置。而对于不同的输入函数，我们要注意两点，第一点是它怎样区分多个输入值，或者说缓冲区指针会吸收掉哪些分隔符;第二点是它接受输入成功后的返回值。</p>\n<h2 id=\"c里的输入\">C里的输入</h2>\n<ul>\n<li><p>scanf<br>\n这是最常用的一种输入，无论整数还是字符串等都能够完美解决，其返回值为成功赋值的数据项数。当遇到文件结束符时返回0。它区分多个输入值的分隔符为空格，制表符和回车。</p></li>\n<li><p>==gets==<br>\ngets是从标准输入缓冲区上读字符串。可以无限读取，不会判断上限，以回车结束读取。如果读取溢出时，多出来的字符将会被写入到堆栈中，这就<strong>覆盖了堆栈原来的内容</strong>，破坏一个或多个不相关变量的值。这个导致gets函数已经被gcc摒弃，所以用fgets来取代gets。</p></li>\n<li><p>fgets<br>\n能够从stream中读取数据，每次读取一行。读取的数据保存在buf指向的字符数组中，每次最多读取bufsize-1个字符（第bufsize个字符赋值’’），如果文件中该行不足bufsize个字符，则读完该行就结束。此时特别注意，<strong>fgets不会像gets将’‘替换成’‘，而是在’‘后面添加’’</strong>。函数成功将返回buf地址，失败或读到文件结尾将返回NULL，所以不能通过fgets的返回值来判断函数是否出错而终止，应该借助feof函数或者ferror函数来判断。</p></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LEN 10</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> a,b;</div><div class=\"line\">    <span class=\"keyword\">char</span> str[LEN];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;a,&amp;b));</div><div class=\"line\">    <span class=\"comment\">/* fflush(stdin); */</span></div><div class=\"line\">    getchar();</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,fgets(str,LEN,<span class=\"built_in\">stdin</span>));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过下图中几个测试样例可以看出fgets以上的特点。</p>\n<p>[fgets](/assets/images/fgets.png)</p>\n<h2 id=\"c中的输入\">C++中的输入</h2>\n<ul>\n<li>cin<br>\ncin是标准输入istream的一个对象，常用的方法“cin&gt;&gt;x”，是将输入缓冲区中对象赋给x对象。其返回值根据“&gt;&gt;”输入操作符的定义知道是返回cin对象。cin会吸收的分隔符有空格，制表符和回车符。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;(<span class=\"built_in\">cin</span>&gt;&gt;i)&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在多次执行该代码，发现当正确输入一个整数（90）时，返回“ox601090”，当输入错误（字符k）时，返回0。而且在输入90前敲了空格，制表符，回车发现cin都没有执行，所以它会吃掉那些分隔符。具体见下图：</p>\n<p>[cin](/assets/images/cin.png)</p>\n<ul>\n<li><p>cin.get()/cin.get(char)<br>\n用于读入一个字符，字符中包括空格，制表符，回车等。常用的方法是“while((c=cin.get())!=EOF){}”或“while(cin.get(c)){}”。其中EOF代表文件终止符，在终端中用<ctrl+z>终止。</ctrl+z></p></li>\n<li>cin.get(str,len,‘’)/cin.getline(str,len,‘’)<br>\n用于读取一串字符，其中str代表字符串存储的地址，len代表最多读取len-1个字符，‘’代表终止符，即碰到’’也停止读取。 二者也是有区别的，区别就是getline遇到终止字符时结束，会将缓冲区指针移动到终止字符之后，而get遇到终止字符时，缓冲区指针不会动。也就是说getline会吃掉终止符号。验证代码[input.cpp](/assets/attachs/input.cpp.txt)执行的结果如下图所示： [get_getline](/assets/images/get_getline.png)<br>\n有两个注意点：\n<ol style=\"list-style-type: decimal\">\n<li>代码中用cin.get()吃掉了4后面的换行符。</li>\n<li>在getline中遇到’e’终止并吃掉了’e’，所以第二次输出时输出的是“ll”，而get中遇到了’e’终止，却无法吃掉’e’，导致再进行cin.get(str,10,‘e’)时无法获取字符就又终止了。</li>\n</ol></li>\n</ul>\n<h2 id=\"问题回答\">问题&amp;回答</h2>\n<ol style=\"list-style-type: decimal\">\n<li>Q:根据“&gt;&gt;”输入操作符的定义知道返回值是cin对象，所以才可以使用像“cin&gt;&gt;a&gt;&gt;b;”这样的连续输入，但是像“while(cin&gt;&gt;x){}”这样的用法意味着cin&gt;&gt;x会返回0，为什么？<br>\nA: 参见<a href=\"http://blog.csdn.net/kongbai308416350/article/details/4470914\" target=\"_blank\" rel=\"external\">cin的返回值探究</a>。</li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://blog.csdn.net/kongbai308416350/article/details/4470914\" target=\"_blank\" rel=\"external\">cin的返回值探究</a></li>\n<li><a href=\"http://baike.baidu.com/link?url=3IuFZpWf27rB7L83gIaDIJUuMMuSSWB-Xdrsy4mb-ml3vyuaEHHr3ceOIT_H8eDDVDh0L_pi2h4UheKYe-Vqda\" target=\"_blank\" rel=\"external\">百科gets</a></li>\n<li><a href=\"http://baike.baidu.com/link?url=08NOHmRHSYROfmu2O2uvfe3hwOx_Ur2fZlGqPFGV4f-3kL9y4ggUAI4t9l5D64ZmNoL8Cbc7AwuCW-rcCutGJa\" target=\"_blank\" rel=\"external\">百科fgets</a></li>\n</ol>"},{"layout":"post","title":"Vim配置之进阶篇","comments":1,"_content":"在上一篇博文[Vim配置之入门篇]({{site.baseurl}}/2015/08/31/VIM配置之入门篇.html)中，只是大略介绍了Vim的基本配置以及几个常用的使用插件，但是在后面的使用中发现该配置的Vim并不是很好用，特别是minibuffer，taglist，fileexplore直接存在冲突，而且它的插件管理也比较麻烦。本篇博文主要就是解决这两个问题以及尝试一些更适合码农的插件。\n<!-- more -->\n\n\n## 简介\n之前使用Vim的初衷一方面是其插件的强大，更主要的方面是适合装13。但是随着对Vim更多的了解，才发现Vim的强大还是有缘由的，从下面的评价足以看出：\n> * 世界上只有三种编辑器，EMACS、VIM和其它  \n> * VIM is the God of editors, EMACS is God’s editor  \n> * EMACS is actually an OS which pretends to be an editor\n\n根据上篇博文中的配置在日常使用的出现的问题，在此给出解决方案，对于插件间的冲突问题是用tagbar取代taglist，而插件管理是采用bundle插件。对于vim里面实用方便的插件的确有不少。\n\n\n## 高效插件\nvim的插件很多，而且功能很强大，非常强大。官网的插件地址在[这里][vim_script]。\n\n* vundle  \nvundle是个用来管理vim插件的插件，它高效的利用了git，使得vim插件的安装，更新和卸载都交由vundle管理，从而将使用者从vim安装配置中解放出来。\n\t1. 安装vundle\n\n\t\t```sh\n\t\tgit clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle\n\t\t```\n\t2. 使用vundle管理vim插件\n\t\t1. 在[Vim Script][vim_script]选好想要使用的插件\n\t\t2. 在vim配置文件.vimrc中添加`Plugin plugin_name`\n\t\t3. 执行Vundle初始化命令`:PluginInstall`，插件就安装好了\n\t\t4. 常用命令  \n\n\t\t```sh\n\t\t# 更新插件\n\t\t:PluginInstall!\n\t\t# 清除不再使用的插件\n\t\t:PluginClean\n\t\t# 列出所有插件\n\t\t:PluginList\n\t\t# 查找插件\n\t\t:PluginSearch\n\t\t```\n\t3. vundle在.vimrc中的配置\n\n\t\t```vim\n\t\t\" 文件类型检测关闭[必须]（/usr/share/vim/vim74/filetype.vim）\n\t\tfiletype off\n\t\t\" 设置runtime path包含Vundle的路径并且初始化\n\t\tset rtp+=~/.vim/bundle/Vundle.vim\n\t\t\" 设置plugins安装地址\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 安装Vundle，让其管理插件[必须]\n\t\tPlugin 'gmarik/Vundle.vim'\n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" Vundle插件安装样例:\n\t\t\" 插件在github上\n\t\t\" Plugin 'tpope/vim-fugitive'\n\t\t\" 插件来自网页http://vim-scripts.org/vim/scripts.html\n\t\t\" Plugin 'L9'\n\t\t\" Git插件，但插件不在Github上\n\t\t\" Plugin 'git://git.wincent.com/command-t.git'\n\t\t\" 插件在本地机器上 (i.e. when working on your own plugin)\n\t\t\" Plugin 'file:///home/gmarik/path/to/plugin'\n\t\t\" The sparkup vim script is in a subdirectory of this repo called vim.\n\t\t\" Pass the path to set the runtimepath properly.\n\t\t\" Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}\n\t\t\" 使用用户名来避免插件冲突 ie. L9\n\t\t\" Plugin 'user/L9', {'name': 'newL9'}\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\n\t\t\" 所有插件的添加在end之前[必须]\n\t\tcall vundle#end()            \n\t\t\" 文件类型对应的插件[必须]（/usr/share/vim/vim74/ftplugin.vim）\n\t\tfiletype plugin on\n\t\t\" 文件类型对应的缩进文件\n\t\tfiletype indent on\n\t\t```\n\n\n* The-NERD-tree  \nNERDTree是Vim最常用的插件之一，可以在Vim运行时显示目录和文件结构，类似TextMate左侧的文件浏览器，但操作起来更为方便，你可以在手不离开键盘的情况下快速浏览文件，并在文件和文件夹之间进行切换。其样例如下图所示：\n![NERDTree]({{site.baseurl}}/assets/images/the-NERD-tree.gif)\n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle')\n\t\t\" 在Vim的编辑窗口中树状显示文件目录[The-NERD-tree]\n\t\tPlugin 'The-NERD-tree'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" The-NERD-tree配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 不显示缓冲文件，中间文件\n\t\tlet NERDTreeIgnore=[ '.pyc$', '.pyo$', '.obj$', '.o$', '.so$', '.egg$', '^.git$', '^.svn$', '^.hg$' ]\n\t\t\" 只剩一个NERDTree窗口时退出vim\n\t\tautocmd bufenter * if (winnr(\"$\") == 1 && exists(\"b:NERDTreeType\") &&b:NERDTreeType == \"primary\") | q | endif\n\t\t\" <F9>打开/关闭文件管理器\n\t\tnnoremap <silent> <F9> :NERDTreeToggle<CR>\n\t\t```\n\n* The-NERD-Commenter  \n这个插件也是必备的，主要自动注释内容。当你xml自然是xml注释，当你是java自然就是java的注释规则。其样例如下图所示：\n![nerdcommenter]({{site.baseurl}}/assets/images/nerdcommenter.gif)\n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 快速添加/去除注释\n\t\tPlugin 'The-NERD-Commenter'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" The-NERD-Commenter配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 注释的时候自动加个空格, 强迫症必配\n\t\tlet g:NERDSpaceDelims=1\n\t\t\" mm智能判断加上/解开注释\n\t\tmap mm <leader>c<space>\n\t\t```\n\n* ctrlp\n这是个文件查找的插件，其功能和NERDTree有点类似，但是还是有点区别吧。其样例如下图所示：\n![nerdcommenter]({{site.baseurl}}/assets/images/vim-ctrlp.gif)\n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 文件搜索\n\t\tPlugin 'kien/ctrlp.vim'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" ctrlp配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 设置CtrlP的本地工作目录，0代表不设置该功能\n\t\tlet g:ctrlp_working_path_mode=0\n\t\t\" ctrlp窗口在底部\n\t\tlet g:ctrlp_match_window_bottom=1\n\t\t\" ctrlp窗口最大高度为15行\n\t\tlet g:ctrlp_max_height=15\n\t\t\" 窗口\n\t\tlet g:ctrlp_match_window_reversed=0\n\t\t\" 最近打开的文件的个数\n\t\tlet g:ctrlp_mruf_max=500\n\t\t\" 记录但去掉重复的软链接\n\t\tlet g:ctrlp_follow_symlinks=1\n\t\t\" <Ctrl-f>启动文件查找\n\t\tlet g:ctrlp_map = '<c-f>'\n\t\t\" Ctrlp启动文件查找\n\t\tlet g:ctrlp_cmd = 'CtrlP'\n\t\t\" 相当于mru功能，show recently opened files\n\t\tmap <c-p> :CtrlPMRU<CR>\n\t\t\" 忽略以下文件类型\n\t\tset wildignore+=*/tmp/*,*.so,*.swp,*.zip\n\t\t\" 忽略以下文件目录\n\t\tlet g:ctrlp_custom_ignore = {'dir':  '/].(git|hg|svn|rvm)$','file': '(exe|so|dll|zip|tar|tar.gz)$'}\n\t\t```\n\n* ctags  \nctags可以建立源码树的标签索引（标签就是一个标识符被定义的地方，如函数定义），使程序员在编程时能迅速定位函数、变量、宏定义等位置去查看原形。\n    1. 安装exuberant-ctags工具\n\n        ```sh\n        sudo apt-get install exuberant-ctags\n        ```\n    2. 创建C++代码库索引\n        1. 下载[libstdc++](http://www.vim.org/scripts/download_script.php?src_id=9178)头文件,包含c++中STL，streams等。\n        2. 解压到~/.vim/tags目录后执行ctags命令\n\n            ```sh\n            ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_src\n            mv tags ~/.vim/tags/cpptag\n            ```\n        3. 在.vimrc中设置\n\n            ```vim\n            set tags+=~/.vim/tags/cpptag\n            ```\n    3. 创建gcc代码库索引\n        1. ubuntu中安装完build-essential后，会在/usr/include/c++目录下有C/C++的头文件。\n\n            ```sh\n            sudo apt-get install build-essential\n            ```\n        2. 拷贝/usr/include/c++/4.8里的文件到~/.vim/tags/gcc文件夹里后执行ctags命令\n\n            ```sh\n            cp -R /usr/include/c++/4.8 ~/.vim/tags/gcc\n            ctags -R --c++-kinds=+p --fields=+iaS --extra=+q gcc\n            mv tags ~/.vim/tags/gcctag\n            ```\n        3. 在.vimrc中设置\n\n            ```vim\n            set tags+=~/.vim/tags/gcctag\n            ```\n\n* cscope\nCscope，一个应用程序，程式员使用它来协助程式撰写及追踪程式码，主要使用于C语言程式。最早起源于贝尔实验室，运作在PDP-11上，由Joe Steffen开始发展。\n1. 安装cscope工具\n\n    ```sh\n    sudo apt-get install cscope\n    ```\n2. 创建gnu c库索引\n    1. 下载[glibc](http://ftp.gnu.org/gnu/glibc/glibc-2.22.tar.xz)文件,它是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。\n    2. 解压到~/.vim/tags目录后执行cscope命令\n\n        ```sh\n        cd ~/.vim/tags/glibc-2.22\n\t\t\t\tcscope -Rbq\n        ```\n    3. 在.vimrc中设置\n\n        ```vim\n\t\t\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\t\t\" cscope配置\n\t\t\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\t\tif has(\"cscope\")\n\t\t\t\t  \" 设置cscope的命令位置\n\t\t\t\t  set csprg=/usr/local/bin/cscope\n\t\t\t\t  \" 设定quickfix来显示cscope的结果\n\t\t\t\t  set cscopequickfix=s-,c-,d-,i-,t-,e-\n\t\t\t\t  \" 先搜索tags标签文件，在搜索cscope数据库\n\t\t\t\t  set csto=1\n\t\t\t\t  \" 使用cstag查询，也就是同时搜索cscope数据库和tags标签文件\n\t\t\t\t  set cst\n\t\t\t\t  \" 不显示添加数据库是否成功\n\t\t\t\t  set nocsverb\n\t\t\t\t  \"\n\t\t\t\t  if filereadable(\"cscope.out\")\n\t\t\t\t    \" 添加当前目录下的cscope数据库\n\t\t\t\t    cs add cscope.out\n\t\t\t\t  else\n\t\t\t\t    \" 添加vim自带的cscope数据库\n\t\t\t\t    \" gnu c 数据库\n\t\t\t\t    cs add ~/.vim/tags/glibc-2.22/cscope.out ~/.vim/tags/glibc-2.22\n\t\t\t\t  endif\n\t\t\t\t  \" 显示添加数据库成功\n\t\t\t\t  set csverb\n\t\t\t\tendif\n\n\t\t\t\t\" 映射快捷键\"<C-_>g的按法是先按\"Ctrl+Shift+-\", 然后很快再按\"g\"\n\t\t\t\t\" 查找本 C 符号（可以跳过注释）\n\t\t\t\tnmap <C-_>s :cs find s <C-R>=expand(\"<cword>\")<CR><CR>\n\t\t\t\t\"查找本定义\n\t\t\t\tnmap <C-_>g :cs find g <C-R>=expand(\"<cword>\")<CR><CR>\n\t\t\t\t\"查找调用本函数的函数\n\t\t\t\tnmap <C-_>c :cs find c <C-R>=expand(\"<cword>\")<CR><CR>\n\t\t\t\t\"查找本字符串\n\t\t\t\tnmap <C-_>t :cs find t <C-R>=expand(\"<cword>\")<CR><CR>\n\t\t\t\t\"查找本 egrep 模式\n\t\t\t\tnmap <C-_>e :cs find e <C-R>=expand(\"<cword>\")<CR><CR>\n\t\t\t\t\"查找本文件\n\t\t\t\tnmap <C-_>f :cs find f <C-R>=expand(\"<cfile>\")<CR><CR>\n\t\t\t\t\"查找包含本文件的文件\n\t\t\t\tnmap <C-_>i :cs find i ^<C-R>=expand(\"<cfile>\")<CR>$<CR>\n\t\t\t\t\"查找本函数调用的函数\n\t\t\t\tnmap <C-_>d :cs find d <C-R>=expand(\"<cword>\")<CR><CR>\n        ```\n\n\n* tagbar  \ntagbar插件是和taglist功能类似的插件，但是它比taglist更优秀，并且能和NERDTree完美配合。\n\t1. tagbar的优势\n\t\t* 支持头文件的函数列表显示  \n\t\t细心的读者可能会发现，tagbar对函数的可见级别也是做了区分的，分别用+ – # 并配合着色来做了区分\n\t\t* 对面向对象的支持更好  \n\t\ttaglist虽然也会列出类列表，但是整体还是很不直观\n\t\t* 自动根据文件修改时间来重建  \n\t\ttaglist在这一点上体验就很不好，其实明明可以通过这种时间戳的方式来实现\n\t2. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 替换taglist的插件[tagbar]\n\t\tPlugin 'majutsushi/tagbar'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" tagbar配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 启动时自动focus\n\t\tlet g:tagbar_autofocus=1\n\t\t\" <F10>打开/关闭Tagbar\n\t\tnnoremap <silent> <F10> :TagbarToggle<CR>\n\t\t```\n\n* rainbow  \n这个插件也是必备的，该插件的主要功能是给配对的(){}[]不同的颜色来区别，非常方便看括号的作用域\n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 括号显示增强\n\t\tPlugin 'luochen1990/rainbow'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" rainbow配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" rainbow激活\n\t\tlet g:rainbow_active = 1\n\t\t```\n\t2. 给rainbow添加自动启动功能\n\n\t\t```vim\n\t\tif (exists('g:rainbow_active') && g:rainbow_active)\n\t\t\tauto syntax * call rainbow#hook()\n\t\t\tauto colorscheme * call rainbow#show()\n\t\t\t\" 下面这命令使rainbow在vim启动时被打开\n\t\t\tautocmd VimEnter * nested call rainbow#toggle()\n\t\tendif\n\t\t```\n\n\n* [syntastic][syntastic]  \n这是一个非常有用的插件，它能够实时的进行语法和编码风格的检查，利用它几乎可以做到编码完成后无编译错误。并且它还集成了静态检查工具：lint，可以让你的代码更加完美。更强大的它支持近百种编程语言，像是一个集大成的实时编译器。出现错误之后，可以非常方便的跳转到出错处。其样例如下图所示：\n![nerdcommenter]({{site.baseurl}}/assets/images/vim-syntastic.png)\n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 语义高亮\n\t\tPlugin 'scrooloose/syntastic'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" syntastic配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 首次打开和保存时都要进行语义检查\n\t\tlet g:syntastic_check_on_open = 1  \n\t\t\" 设置错误提示符'x'\n\t\tlet g:syntastic_error_symbol = 'x'  \n\t\t\" 设置警告提示符'!'\n\t\tlet g:syntastic_warning_symbol = '!'  \n\t\t\" 当鼠标放在错误行则显示错误信息\n\t\tlet g:syntastic_enable_balloons = 1  \n\t\t\" 保存退出时不用进行语义检测\n\t\tlet g:syntastic_check_on_wq = 0\n\t\t\" 编译有误则错误窗口显示，否在不显示\n\t\tlet g:syntastic_auto_loc_list = 1\n\t\t\" 错误总会填充到错误窗口\n\t\tlet g:syntastic_always_populate_loc_list = 1\n\t\t```\n\n\n\n\n* [YouCompleteMe][youcompleteme]   \nYouCompleteMe对代码的补全完全达到了编译器级别，绝不弱于Visual Assist。它是基于LLVM/clang，一个Apple公司为了代替GNU/GCC而支持的编译器，正因为YouCompleteMe有了编译器的支持，而不再像以往的插件一样基于文本来进行匹配，所以准确率才如此之高。而且，它是C/S架构，会在本机创建一个服务器端，利用clang来解析代码，然后将结果返回给客户端，所以也就解决了VIM是单线程而造成的各种补全插件速度奇慢的诟病，在使用时，几乎感觉不到任何的延时，体验达到了Visual Assist的级别。  \nYouCompleteMe除了补全以外，还有一个非常重要的作用：代码跳转，同样可以达到编译器级别的准确度，媲美Visual Assist与Source Insight。其样例如下图所示：\n![nerdcommenter]({{site.baseurl}}/assets/images/youcompleteme.gif)\n\t1. 安装必备软件\n\n\t\t```sh\n\t\tsudo apt-get install clang llvm cmake python python-dev\n\t\t```\n\t1. 手动编译\n\n\t\t```sh\n\t\tcd ~/.vim/bundle/YouCompleteMe\n\t\t./install.sh --clang-completer\n\t\t```\n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 自动补全\n\t\tPlugin 'Valloric/YouCompleteMe'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" YouCompleteMe配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 设置YCM配置文件的路径\n\t\tlet g:ycm_global_ycm_extra_conf='~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py'\n\t\t\" 开启关键字语法检测\n\t\tlet g:ycm_seed_identifiers_with_syntax = 1\n\t\t\" 自动触发补全\n\t\tlet g:ycm_auto_trigger = 1\n\t\t\" YCM触发的条件\n\t\tlet g:ycm_semantic_triggers = {  \n\t\t\\ 'c' : ['->' , '.'],\n\t\t\\ 'cpp,objcpp' : ['->','.','::'],\n\t\t\\ 'java,javascript,python,scala' : ['.'],\n\t\t\\ 'ruby' : ['.','::'],\n\t\t\\}\n\t\t\" 不用每次询问.ycm_extra_conf.py位置\n\t\tlet g:ycm_confirm_extra_conf=0\n\t\t\" YCM也从tags文件中收集标识符\n\t\tlet g:ycm_collect_identifiers_from_tags_files=1\n\t\t\" 当输入注释的时候不用弹出提示\n\t\tlet g:ycm_complete_in_comments=0\n\t\t\" 当输入字符的时候弹出提示\n\t\tlet g:ycm_complete_in_strings=1\n\t\t```\n> **TIps:Tab无效**  \n> 如果出现安装YouCompleteMe后，虽然看到YouCompleteMe的提示框，但是无法使用 < Tab > 进行自动补全，只能使用上下方向键+回车来选择时，就要检查一下.vimrc是否打开了粘贴模式，即设置了set paste．该模式会屏蔽所有映射和缩写．（对于ultisnips也有同样的问题）\n\n\n* [ultisnips][ultisnips]  \n这个插件也是必备的，该插件的主要功能是用来快速输入固定的代码块，像文件开头的版权声明，`#ifndef... #def... #endif`这样宏定义，markdown写jekyll博文的head信息．最关键的是可以按照自己的习惯[自定义代码块][snips_code]，这样就不用按照IDE的习惯培养自己了．其动态效果如下所示：\n    ![ultisnippets]({{site.baseurl}}/assets/images/ultisnippets-md.gif)  \n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" ultisnips\n        Plugin 'SirVer/ultisnips'\n        \" Snippets are separated from the engine\n        Plugin 'honza/vim-snippets'\n\t\tcall vundle#end()  \n\n        \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n        \" ultisnips配置\n        \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n        \" 如果使用了Valloric/YouCompleteMe,就别设置为<tab>\n        let g:UltiSnipsExpandTrigger=\"<c-j>\"\n        \" 前选片段\n        let g:UltiSnipsJumpForwardTrigger=\"<C-f>\"\n        \" 后选片段\n        let g:UltiSnipsJumpBackwardTrigger=\"<C-b>\"\n        \" 使用:UltiSnipsEdit打开片段定义文件时分屏位置\n        let g:UltiSnipsEditSplit=\"vertical\"\n\t\t```\n    2. 自定义代码块  \n    我们注意到安装ultisnips过程中，除了安装自身以外，还安装了honza的vim-snippets，而它的一大作用是提供了大量（目前是80个）的程序片段，像c，python，markdown，make，sh，sql等。而这些snippets都在.vim/bundle/vim-snippets/snippets文件夹中。除此之外，我们还可以自定义自己的代码块，建议是放在.vim/UltiSnippets目录下（和bundle同等级），一方面是.vim/bundle/vim-snippets/snippets下的代码块是别人的git项目。另一方面.vim/UltiSnippets下的文件可以覆盖vim-snippets里的配置，这样更符合DIY的目的。关于如何编写snippets，网上找到的资源不多，给出如下建议：\n        * 查看.vim/bundle/vim-snippets/snippets里的代码\n        * 通过`:help snippets`查看ultisnips的帮助文档\n        * 博文[自定义自己的代码块][snips_code]中的样列\n\n            ```sh\n                ## head Jekyll写博文时插入的头文件信息\n                snippet head \"Jekyll post header\" b # b代表begin（snippet should be expanded only at the beginning of a line ）\n                ---\n                layout:       default\n                title:        ${1:blog_name}\n                category:     [${2:cate1,cate2}]\n                comments:     true\n                date:         `!v strftime(\"%Y-%m-%d %H:%M:%S\")`\n                ---\n                ${0}        # 代表tab最终停留的位置\n\n                endsnippet\n                ```\n\n* [tabular][tabular]  \n这是一个处女座或码农必备的插件，因为当你看到代码/文字杂乱的排版--等号，冒号，表格等不能对齐时，应该会抓狂吧。而tabular这个插件能完美的解决这个问题。就像下面的图例一样，只需要输入命令`:Tabularize /*`（*代表对齐的符号）即可：  \n![tabular]({{site.baseurl}}/assets/images/vim-tabular.gif)\n    1. 在vim中的安装和配置\n\n        ```vim\n        call vundle#begin('~/.vim/bundle/')\n        \" tab对齐\n        Plugin 'godlygeek/tabular'\n        call vundle#end()  \n\n        \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n        \" tabular配置\n        \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n        \" 目前还尚在摸索中\n        ```\n\n* [vim-markdown][vim-markdown]\nvim-markdown是一款用来对原生markdown和扩展markdown语法进行语义高亮和规则匹配的插件。\n  1. 在vim中的安装和配置\n\n    ```vim\n    call vundle#begin('~/.vim/bundle/')\n    \" markdown语义高亮\n    Plugin 'plasticboy/vim-markdown'\n    call vundle#end()\n\n    \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n    \" tabular配置\n    \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n    \" vim识别md\n    autocmd BufNewFile,BufReadPost *.md set filetype=markdown\n    let g:vimmarkdownfoldingdisabled=1 \"取消代码折叠\n    let g:vimmarkdownnodefaultkeymappings=1 \"取消默认的键对应\n    let g:vimmarkdownmath=1 \"使用数学符号\n    let g:vimmarkdownfrontmatter=1 \"高亮YMAL frontmatter\n    ```\n\n\n* [markdown同步预览][markdown-preview]\nmarkdown-preview是一款用来将vim打开的markdown文件翻译为html显示在浏览器里的插件，该插件的亮点在于实时更新。\n  1. 在vim中的安装和配置\n\n    ```vim\n    call vundle#begin('~/.vim/bundle/')\n    \" markdown同步显示\n    Plugin 'iamcco/mathjax-support-for-mkdp'\n    Plugin 'iamcco/markdown-preview.vim'\n    call vundle#end()\n\n    \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n    \" markdown-preview.vim配置\n    \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n    \" 设置启动chrome浏览器的命令\n    let g:mkdp_path_to_chrome = \"open -a Google\\\\ Chrome\"\n    \" 设置为1则打开markdown文件时自动打开浏览器\n    let g:mkdp_auto_start = 1\n    \" 设置为1则在编辑markdown的时候预览窗口是否打开，未开则自动打开\n    let g:mkdp_auto_open = 1\n    \" 切换buffer时自动关闭预览窗口，设置为0则在切换buffer时不自动关闭\n    let g:mkdp_auto_close = 1\n    \" 设置为1则只有在保存文件或退出插入模式时更新预览，默认为0，实时更新预览\n    let g:mkdp_refresh_slow = 0\n    \" 设置为1则所有文件都使用MarkdownPreview进行预览，默认只有markdown文件可以\n    let g:mkdp_command_for_global = 0\n    ```\n\n\n* [emmet-vim][emmet]  \nEmmet的前身就叫做Zen Coding，它是个前端插件。官方支持很多软件，像Sublime Text、Notepad++、Dreamweaver、Eclipse、Adobe Brackets等，而Emmet.vim并非Emmet亲生，而是由日本Yasuhiro Matsumoto开发。对于前段开发者而言它是一件神器，能够节省大量的重复coding劳动。鉴于前端开发的少，这里只是mark一下。\n\n\n\n## 参考文献\n1. [有趣的vim游戏][vim_adventures]\n2. [Vim学习指南][vim_progressively]\n3. [vim plugin][vim_plugin]\n3. [Vim Script][vim_script]\n4. [Vim配置及说明——IDE编程环境][vim_ide]\n5. [高效vim插件][vim_plugin2]\n6. [VIM助记图][Vim_Cheat_Sheet]\n7. [Vimer的程序世界][vimer]\n8. [vimium][vimium]\n9. [youcompleteme][youcompleteme]\n9. [syntastic][syntastic]\n1. [python IDE][python_ide]\n1. [ultisnips][ultisnips]\n2. [自定义自己的代码块][snips_code]\n3. [前端开发神器Emmet][emmet]\n4. [Emmet教程][study_emmet]\n5. [对齐神器-tabular][tabular]\n1. [vim-markdown][vim-markdown]\n\n\n[vim_adventures]:\thttp://vim-adventures.com/\n[vim_progressively]:\thttp://www.oschina.net/translate/learn-vim-progressively\n[vim_plugin]:\t\thttp://my.oschina.net/swuly302/blog/156784\n[vim_script]:\t\thttp://vim-scripts.org/vim/scripts.html\n[vim_ide]:\t\t\thttp://www.it165.net/pro/html/201404/11505.html\n[vim_plugin2]:\t\thttp://my.oschina.net/swuly302/blog/156784\n[Vim_Cheat_Sheet]:\thttp://overapi.com/vim/\n[vimer]:\t\t\thttp://www.vimer.cn/\n[vimium]:\t\t\thttps://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb\n[youcompleteme]:\thttp://valloric.github.io/YouCompleteMe/\n[syntastic]:\t\thttps://github.com/scrooloose/syntastic/blob/master/doc/syntastic.txt\n[python_ide]:       http://3502990.blog.51cto.com/3492990/985750\n[ultisnips]:        https://github.com/SirVer/ultisnips\n[snips_code]:       http://mednoter.com/UltiSnips.html\n[emmet]:            https://github.com/mattn/emmet-vim\n[study_emmet]:      https://www.zfanw.com/blog/zencoding-vim-tutorial-chinese.html\n[tabular]:          https://github.com/godlygeek/tabular\n[vim-markdown]:     https://github.com/plasticboy/vim-markdown\n\n","source":"_posts/2015-09-25-VIM配置之进阶篇.md","raw":"---\nlayout: post\ntitle:  Vim配置之进阶篇\ncategories:\n- TECHNOLOGY\ntags:\n- Vim\n- Plugin\npermalink:  Explore-advanced-vim\ncomments:   true\n---\n在上一篇博文[Vim配置之入门篇]({{site.baseurl}}/2015/08/31/VIM配置之入门篇.html)中，只是大略介绍了Vim的基本配置以及几个常用的使用插件，但是在后面的使用中发现该配置的Vim并不是很好用，特别是minibuffer，taglist，fileexplore直接存在冲突，而且它的插件管理也比较麻烦。本篇博文主要就是解决这两个问题以及尝试一些更适合码农的插件。\n<!-- more -->\n\n\n## 简介\n之前使用Vim的初衷一方面是其插件的强大，更主要的方面是适合装13。但是随着对Vim更多的了解，才发现Vim的强大还是有缘由的，从下面的评价足以看出：\n> * 世界上只有三种编辑器，EMACS、VIM和其它  \n> * VIM is the God of editors, EMACS is God’s editor  \n> * EMACS is actually an OS which pretends to be an editor\n\n根据上篇博文中的配置在日常使用的出现的问题，在此给出解决方案，对于插件间的冲突问题是用tagbar取代taglist，而插件管理是采用bundle插件。对于vim里面实用方便的插件的确有不少。\n\n\n## 高效插件\nvim的插件很多，而且功能很强大，非常强大。官网的插件地址在[这里][vim_script]。\n\n* vundle  \nvundle是个用来管理vim插件的插件，它高效的利用了git，使得vim插件的安装，更新和卸载都交由vundle管理，从而将使用者从vim安装配置中解放出来。\n\t1. 安装vundle\n\n\t\t```sh\n\t\tgit clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle\n\t\t```\n\t2. 使用vundle管理vim插件\n\t\t1. 在[Vim Script][vim_script]选好想要使用的插件\n\t\t2. 在vim配置文件.vimrc中添加`Plugin plugin_name`\n\t\t3. 执行Vundle初始化命令`:PluginInstall`，插件就安装好了\n\t\t4. 常用命令  \n\n\t\t```sh\n\t\t# 更新插件\n\t\t:PluginInstall!\n\t\t# 清除不再使用的插件\n\t\t:PluginClean\n\t\t# 列出所有插件\n\t\t:PluginList\n\t\t# 查找插件\n\t\t:PluginSearch\n\t\t```\n\t3. vundle在.vimrc中的配置\n\n\t\t```vim\n\t\t\" 文件类型检测关闭[必须]（/usr/share/vim/vim74/filetype.vim）\n\t\tfiletype off\n\t\t\" 设置runtime path包含Vundle的路径并且初始化\n\t\tset rtp+=~/.vim/bundle/Vundle.vim\n\t\t\" 设置plugins安装地址\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 安装Vundle，让其管理插件[必须]\n\t\tPlugin 'gmarik/Vundle.vim'\n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" Vundle插件安装样例:\n\t\t\" 插件在github上\n\t\t\" Plugin 'tpope/vim-fugitive'\n\t\t\" 插件来自网页http://vim-scripts.org/vim/scripts.html\n\t\t\" Plugin 'L9'\n\t\t\" Git插件，但插件不在Github上\n\t\t\" Plugin 'git://git.wincent.com/command-t.git'\n\t\t\" 插件在本地机器上 (i.e. when working on your own plugin)\n\t\t\" Plugin 'file:///home/gmarik/path/to/plugin'\n\t\t\" The sparkup vim script is in a subdirectory of this repo called vim.\n\t\t\" Pass the path to set the runtimepath properly.\n\t\t\" Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}\n\t\t\" 使用用户名来避免插件冲突 ie. L9\n\t\t\" Plugin 'user/L9', {'name': 'newL9'}\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\n\t\t\" 所有插件的添加在end之前[必须]\n\t\tcall vundle#end()            \n\t\t\" 文件类型对应的插件[必须]（/usr/share/vim/vim74/ftplugin.vim）\n\t\tfiletype plugin on\n\t\t\" 文件类型对应的缩进文件\n\t\tfiletype indent on\n\t\t```\n\n\n* The-NERD-tree  \nNERDTree是Vim最常用的插件之一，可以在Vim运行时显示目录和文件结构，类似TextMate左侧的文件浏览器，但操作起来更为方便，你可以在手不离开键盘的情况下快速浏览文件，并在文件和文件夹之间进行切换。其样例如下图所示：\n![NERDTree]({{site.baseurl}}/assets/images/the-NERD-tree.gif)\n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle')\n\t\t\" 在Vim的编辑窗口中树状显示文件目录[The-NERD-tree]\n\t\tPlugin 'The-NERD-tree'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" The-NERD-tree配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 不显示缓冲文件，中间文件\n\t\tlet NERDTreeIgnore=[ '.pyc$', '.pyo$', '.obj$', '.o$', '.so$', '.egg$', '^.git$', '^.svn$', '^.hg$' ]\n\t\t\" 只剩一个NERDTree窗口时退出vim\n\t\tautocmd bufenter * if (winnr(\"$\") == 1 && exists(\"b:NERDTreeType\") &&b:NERDTreeType == \"primary\") | q | endif\n\t\t\" <F9>打开/关闭文件管理器\n\t\tnnoremap <silent> <F9> :NERDTreeToggle<CR>\n\t\t```\n\n* The-NERD-Commenter  \n这个插件也是必备的，主要自动注释内容。当你xml自然是xml注释，当你是java自然就是java的注释规则。其样例如下图所示：\n![nerdcommenter]({{site.baseurl}}/assets/images/nerdcommenter.gif)\n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 快速添加/去除注释\n\t\tPlugin 'The-NERD-Commenter'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" The-NERD-Commenter配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 注释的时候自动加个空格, 强迫症必配\n\t\tlet g:NERDSpaceDelims=1\n\t\t\" mm智能判断加上/解开注释\n\t\tmap mm <leader>c<space>\n\t\t```\n\n* ctrlp\n这是个文件查找的插件，其功能和NERDTree有点类似，但是还是有点区别吧。其样例如下图所示：\n![nerdcommenter]({{site.baseurl}}/assets/images/vim-ctrlp.gif)\n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 文件搜索\n\t\tPlugin 'kien/ctrlp.vim'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" ctrlp配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 设置CtrlP的本地工作目录，0代表不设置该功能\n\t\tlet g:ctrlp_working_path_mode=0\n\t\t\" ctrlp窗口在底部\n\t\tlet g:ctrlp_match_window_bottom=1\n\t\t\" ctrlp窗口最大高度为15行\n\t\tlet g:ctrlp_max_height=15\n\t\t\" 窗口\n\t\tlet g:ctrlp_match_window_reversed=0\n\t\t\" 最近打开的文件的个数\n\t\tlet g:ctrlp_mruf_max=500\n\t\t\" 记录但去掉重复的软链接\n\t\tlet g:ctrlp_follow_symlinks=1\n\t\t\" <Ctrl-f>启动文件查找\n\t\tlet g:ctrlp_map = '<c-f>'\n\t\t\" Ctrlp启动文件查找\n\t\tlet g:ctrlp_cmd = 'CtrlP'\n\t\t\" 相当于mru功能，show recently opened files\n\t\tmap <c-p> :CtrlPMRU<CR>\n\t\t\" 忽略以下文件类型\n\t\tset wildignore+=*/tmp/*,*.so,*.swp,*.zip\n\t\t\" 忽略以下文件目录\n\t\tlet g:ctrlp_custom_ignore = {'dir':  '/].(git|hg|svn|rvm)$','file': '(exe|so|dll|zip|tar|tar.gz)$'}\n\t\t```\n\n* ctags  \nctags可以建立源码树的标签索引（标签就是一个标识符被定义的地方，如函数定义），使程序员在编程时能迅速定位函数、变量、宏定义等位置去查看原形。\n    1. 安装exuberant-ctags工具\n\n        ```sh\n        sudo apt-get install exuberant-ctags\n        ```\n    2. 创建C++代码库索引\n        1. 下载[libstdc++](http://www.vim.org/scripts/download_script.php?src_id=9178)头文件,包含c++中STL，streams等。\n        2. 解压到~/.vim/tags目录后执行ctags命令\n\n            ```sh\n            ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_src\n            mv tags ~/.vim/tags/cpptag\n            ```\n        3. 在.vimrc中设置\n\n            ```vim\n            set tags+=~/.vim/tags/cpptag\n            ```\n    3. 创建gcc代码库索引\n        1. ubuntu中安装完build-essential后，会在/usr/include/c++目录下有C/C++的头文件。\n\n            ```sh\n            sudo apt-get install build-essential\n            ```\n        2. 拷贝/usr/include/c++/4.8里的文件到~/.vim/tags/gcc文件夹里后执行ctags命令\n\n            ```sh\n            cp -R /usr/include/c++/4.8 ~/.vim/tags/gcc\n            ctags -R --c++-kinds=+p --fields=+iaS --extra=+q gcc\n            mv tags ~/.vim/tags/gcctag\n            ```\n        3. 在.vimrc中设置\n\n            ```vim\n            set tags+=~/.vim/tags/gcctag\n            ```\n\n* cscope\nCscope，一个应用程序，程式员使用它来协助程式撰写及追踪程式码，主要使用于C语言程式。最早起源于贝尔实验室，运作在PDP-11上，由Joe Steffen开始发展。\n1. 安装cscope工具\n\n    ```sh\n    sudo apt-get install cscope\n    ```\n2. 创建gnu c库索引\n    1. 下载[glibc](http://ftp.gnu.org/gnu/glibc/glibc-2.22.tar.xz)文件,它是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。\n    2. 解压到~/.vim/tags目录后执行cscope命令\n\n        ```sh\n        cd ~/.vim/tags/glibc-2.22\n\t\t\t\tcscope -Rbq\n        ```\n    3. 在.vimrc中设置\n\n        ```vim\n\t\t\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\t\t\" cscope配置\n\t\t\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\t\tif has(\"cscope\")\n\t\t\t\t  \" 设置cscope的命令位置\n\t\t\t\t  set csprg=/usr/local/bin/cscope\n\t\t\t\t  \" 设定quickfix来显示cscope的结果\n\t\t\t\t  set cscopequickfix=s-,c-,d-,i-,t-,e-\n\t\t\t\t  \" 先搜索tags标签文件，在搜索cscope数据库\n\t\t\t\t  set csto=1\n\t\t\t\t  \" 使用cstag查询，也就是同时搜索cscope数据库和tags标签文件\n\t\t\t\t  set cst\n\t\t\t\t  \" 不显示添加数据库是否成功\n\t\t\t\t  set nocsverb\n\t\t\t\t  \"\n\t\t\t\t  if filereadable(\"cscope.out\")\n\t\t\t\t    \" 添加当前目录下的cscope数据库\n\t\t\t\t    cs add cscope.out\n\t\t\t\t  else\n\t\t\t\t    \" 添加vim自带的cscope数据库\n\t\t\t\t    \" gnu c 数据库\n\t\t\t\t    cs add ~/.vim/tags/glibc-2.22/cscope.out ~/.vim/tags/glibc-2.22\n\t\t\t\t  endif\n\t\t\t\t  \" 显示添加数据库成功\n\t\t\t\t  set csverb\n\t\t\t\tendif\n\n\t\t\t\t\" 映射快捷键\"<C-_>g的按法是先按\"Ctrl+Shift+-\", 然后很快再按\"g\"\n\t\t\t\t\" 查找本 C 符号（可以跳过注释）\n\t\t\t\tnmap <C-_>s :cs find s <C-R>=expand(\"<cword>\")<CR><CR>\n\t\t\t\t\"查找本定义\n\t\t\t\tnmap <C-_>g :cs find g <C-R>=expand(\"<cword>\")<CR><CR>\n\t\t\t\t\"查找调用本函数的函数\n\t\t\t\tnmap <C-_>c :cs find c <C-R>=expand(\"<cword>\")<CR><CR>\n\t\t\t\t\"查找本字符串\n\t\t\t\tnmap <C-_>t :cs find t <C-R>=expand(\"<cword>\")<CR><CR>\n\t\t\t\t\"查找本 egrep 模式\n\t\t\t\tnmap <C-_>e :cs find e <C-R>=expand(\"<cword>\")<CR><CR>\n\t\t\t\t\"查找本文件\n\t\t\t\tnmap <C-_>f :cs find f <C-R>=expand(\"<cfile>\")<CR><CR>\n\t\t\t\t\"查找包含本文件的文件\n\t\t\t\tnmap <C-_>i :cs find i ^<C-R>=expand(\"<cfile>\")<CR>$<CR>\n\t\t\t\t\"查找本函数调用的函数\n\t\t\t\tnmap <C-_>d :cs find d <C-R>=expand(\"<cword>\")<CR><CR>\n        ```\n\n\n* tagbar  \ntagbar插件是和taglist功能类似的插件，但是它比taglist更优秀，并且能和NERDTree完美配合。\n\t1. tagbar的优势\n\t\t* 支持头文件的函数列表显示  \n\t\t细心的读者可能会发现，tagbar对函数的可见级别也是做了区分的，分别用+ – # 并配合着色来做了区分\n\t\t* 对面向对象的支持更好  \n\t\ttaglist虽然也会列出类列表，但是整体还是很不直观\n\t\t* 自动根据文件修改时间来重建  \n\t\ttaglist在这一点上体验就很不好，其实明明可以通过这种时间戳的方式来实现\n\t2. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 替换taglist的插件[tagbar]\n\t\tPlugin 'majutsushi/tagbar'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" tagbar配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 启动时自动focus\n\t\tlet g:tagbar_autofocus=1\n\t\t\" <F10>打开/关闭Tagbar\n\t\tnnoremap <silent> <F10> :TagbarToggle<CR>\n\t\t```\n\n* rainbow  \n这个插件也是必备的，该插件的主要功能是给配对的(){}[]不同的颜色来区别，非常方便看括号的作用域\n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 括号显示增强\n\t\tPlugin 'luochen1990/rainbow'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" rainbow配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" rainbow激活\n\t\tlet g:rainbow_active = 1\n\t\t```\n\t2. 给rainbow添加自动启动功能\n\n\t\t```vim\n\t\tif (exists('g:rainbow_active') && g:rainbow_active)\n\t\t\tauto syntax * call rainbow#hook()\n\t\t\tauto colorscheme * call rainbow#show()\n\t\t\t\" 下面这命令使rainbow在vim启动时被打开\n\t\t\tautocmd VimEnter * nested call rainbow#toggle()\n\t\tendif\n\t\t```\n\n\n* [syntastic][syntastic]  \n这是一个非常有用的插件，它能够实时的进行语法和编码风格的检查，利用它几乎可以做到编码完成后无编译错误。并且它还集成了静态检查工具：lint，可以让你的代码更加完美。更强大的它支持近百种编程语言，像是一个集大成的实时编译器。出现错误之后，可以非常方便的跳转到出错处。其样例如下图所示：\n![nerdcommenter]({{site.baseurl}}/assets/images/vim-syntastic.png)\n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 语义高亮\n\t\tPlugin 'scrooloose/syntastic'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" syntastic配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 首次打开和保存时都要进行语义检查\n\t\tlet g:syntastic_check_on_open = 1  \n\t\t\" 设置错误提示符'x'\n\t\tlet g:syntastic_error_symbol = 'x'  \n\t\t\" 设置警告提示符'!'\n\t\tlet g:syntastic_warning_symbol = '!'  \n\t\t\" 当鼠标放在错误行则显示错误信息\n\t\tlet g:syntastic_enable_balloons = 1  \n\t\t\" 保存退出时不用进行语义检测\n\t\tlet g:syntastic_check_on_wq = 0\n\t\t\" 编译有误则错误窗口显示，否在不显示\n\t\tlet g:syntastic_auto_loc_list = 1\n\t\t\" 错误总会填充到错误窗口\n\t\tlet g:syntastic_always_populate_loc_list = 1\n\t\t```\n\n\n\n\n* [YouCompleteMe][youcompleteme]   \nYouCompleteMe对代码的补全完全达到了编译器级别，绝不弱于Visual Assist。它是基于LLVM/clang，一个Apple公司为了代替GNU/GCC而支持的编译器，正因为YouCompleteMe有了编译器的支持，而不再像以往的插件一样基于文本来进行匹配，所以准确率才如此之高。而且，它是C/S架构，会在本机创建一个服务器端，利用clang来解析代码，然后将结果返回给客户端，所以也就解决了VIM是单线程而造成的各种补全插件速度奇慢的诟病，在使用时，几乎感觉不到任何的延时，体验达到了Visual Assist的级别。  \nYouCompleteMe除了补全以外，还有一个非常重要的作用：代码跳转，同样可以达到编译器级别的准确度，媲美Visual Assist与Source Insight。其样例如下图所示：\n![nerdcommenter]({{site.baseurl}}/assets/images/youcompleteme.gif)\n\t1. 安装必备软件\n\n\t\t```sh\n\t\tsudo apt-get install clang llvm cmake python python-dev\n\t\t```\n\t1. 手动编译\n\n\t\t```sh\n\t\tcd ~/.vim/bundle/YouCompleteMe\n\t\t./install.sh --clang-completer\n\t\t```\n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" 自动补全\n\t\tPlugin 'Valloric/YouCompleteMe'\n\t\tcall vundle#end()  \n\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" YouCompleteMe配置\n\t\t\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\t\t\" 设置YCM配置文件的路径\n\t\tlet g:ycm_global_ycm_extra_conf='~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py'\n\t\t\" 开启关键字语法检测\n\t\tlet g:ycm_seed_identifiers_with_syntax = 1\n\t\t\" 自动触发补全\n\t\tlet g:ycm_auto_trigger = 1\n\t\t\" YCM触发的条件\n\t\tlet g:ycm_semantic_triggers = {  \n\t\t\\ 'c' : ['->' , '.'],\n\t\t\\ 'cpp,objcpp' : ['->','.','::'],\n\t\t\\ 'java,javascript,python,scala' : ['.'],\n\t\t\\ 'ruby' : ['.','::'],\n\t\t\\}\n\t\t\" 不用每次询问.ycm_extra_conf.py位置\n\t\tlet g:ycm_confirm_extra_conf=0\n\t\t\" YCM也从tags文件中收集标识符\n\t\tlet g:ycm_collect_identifiers_from_tags_files=1\n\t\t\" 当输入注释的时候不用弹出提示\n\t\tlet g:ycm_complete_in_comments=0\n\t\t\" 当输入字符的时候弹出提示\n\t\tlet g:ycm_complete_in_strings=1\n\t\t```\n> **TIps:Tab无效**  \n> 如果出现安装YouCompleteMe后，虽然看到YouCompleteMe的提示框，但是无法使用 < Tab > 进行自动补全，只能使用上下方向键+回车来选择时，就要检查一下.vimrc是否打开了粘贴模式，即设置了set paste．该模式会屏蔽所有映射和缩写．（对于ultisnips也有同样的问题）\n\n\n* [ultisnips][ultisnips]  \n这个插件也是必备的，该插件的主要功能是用来快速输入固定的代码块，像文件开头的版权声明，`#ifndef... #def... #endif`这样宏定义，markdown写jekyll博文的head信息．最关键的是可以按照自己的习惯[自定义代码块][snips_code]，这样就不用按照IDE的习惯培养自己了．其动态效果如下所示：\n    ![ultisnippets]({{site.baseurl}}/assets/images/ultisnippets-md.gif)  \n\t1. 在vim中的安装和配置\n\n\t\t```vim\n\t\tcall vundle#begin('~/.vim/bundle/')\n\t\t\" ultisnips\n        Plugin 'SirVer/ultisnips'\n        \" Snippets are separated from the engine\n        Plugin 'honza/vim-snippets'\n\t\tcall vundle#end()  \n\n        \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n        \" ultisnips配置\n        \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n        \" 如果使用了Valloric/YouCompleteMe,就别设置为<tab>\n        let g:UltiSnipsExpandTrigger=\"<c-j>\"\n        \" 前选片段\n        let g:UltiSnipsJumpForwardTrigger=\"<C-f>\"\n        \" 后选片段\n        let g:UltiSnipsJumpBackwardTrigger=\"<C-b>\"\n        \" 使用:UltiSnipsEdit打开片段定义文件时分屏位置\n        let g:UltiSnipsEditSplit=\"vertical\"\n\t\t```\n    2. 自定义代码块  \n    我们注意到安装ultisnips过程中，除了安装自身以外，还安装了honza的vim-snippets，而它的一大作用是提供了大量（目前是80个）的程序片段，像c，python，markdown，make，sh，sql等。而这些snippets都在.vim/bundle/vim-snippets/snippets文件夹中。除此之外，我们还可以自定义自己的代码块，建议是放在.vim/UltiSnippets目录下（和bundle同等级），一方面是.vim/bundle/vim-snippets/snippets下的代码块是别人的git项目。另一方面.vim/UltiSnippets下的文件可以覆盖vim-snippets里的配置，这样更符合DIY的目的。关于如何编写snippets，网上找到的资源不多，给出如下建议：\n        * 查看.vim/bundle/vim-snippets/snippets里的代码\n        * 通过`:help snippets`查看ultisnips的帮助文档\n        * 博文[自定义自己的代码块][snips_code]中的样列\n\n            ```sh\n                ## head Jekyll写博文时插入的头文件信息\n                snippet head \"Jekyll post header\" b # b代表begin（snippet should be expanded only at the beginning of a line ）\n                ---\n                layout:       default\n                title:        ${1:blog_name}\n                category:     [${2:cate1,cate2}]\n                comments:     true\n                date:         `!v strftime(\"%Y-%m-%d %H:%M:%S\")`\n                ---\n                ${0}        # 代表tab最终停留的位置\n\n                endsnippet\n                ```\n\n* [tabular][tabular]  \n这是一个处女座或码农必备的插件，因为当你看到代码/文字杂乱的排版--等号，冒号，表格等不能对齐时，应该会抓狂吧。而tabular这个插件能完美的解决这个问题。就像下面的图例一样，只需要输入命令`:Tabularize /*`（*代表对齐的符号）即可：  \n![tabular]({{site.baseurl}}/assets/images/vim-tabular.gif)\n    1. 在vim中的安装和配置\n\n        ```vim\n        call vundle#begin('~/.vim/bundle/')\n        \" tab对齐\n        Plugin 'godlygeek/tabular'\n        call vundle#end()  \n\n        \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n        \" tabular配置\n        \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n        \" 目前还尚在摸索中\n        ```\n\n* [vim-markdown][vim-markdown]\nvim-markdown是一款用来对原生markdown和扩展markdown语法进行语义高亮和规则匹配的插件。\n  1. 在vim中的安装和配置\n\n    ```vim\n    call vundle#begin('~/.vim/bundle/')\n    \" markdown语义高亮\n    Plugin 'plasticboy/vim-markdown'\n    call vundle#end()\n\n    \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n    \" tabular配置\n    \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n    \" vim识别md\n    autocmd BufNewFile,BufReadPost *.md set filetype=markdown\n    let g:vimmarkdownfoldingdisabled=1 \"取消代码折叠\n    let g:vimmarkdownnodefaultkeymappings=1 \"取消默认的键对应\n    let g:vimmarkdownmath=1 \"使用数学符号\n    let g:vimmarkdownfrontmatter=1 \"高亮YMAL frontmatter\n    ```\n\n\n* [markdown同步预览][markdown-preview]\nmarkdown-preview是一款用来将vim打开的markdown文件翻译为html显示在浏览器里的插件，该插件的亮点在于实时更新。\n  1. 在vim中的安装和配置\n\n    ```vim\n    call vundle#begin('~/.vim/bundle/')\n    \" markdown同步显示\n    Plugin 'iamcco/mathjax-support-for-mkdp'\n    Plugin 'iamcco/markdown-preview.vim'\n    call vundle#end()\n\n    \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n    \" markdown-preview.vim配置\n    \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n    \" 设置启动chrome浏览器的命令\n    let g:mkdp_path_to_chrome = \"open -a Google\\\\ Chrome\"\n    \" 设置为1则打开markdown文件时自动打开浏览器\n    let g:mkdp_auto_start = 1\n    \" 设置为1则在编辑markdown的时候预览窗口是否打开，未开则自动打开\n    let g:mkdp_auto_open = 1\n    \" 切换buffer时自动关闭预览窗口，设置为0则在切换buffer时不自动关闭\n    let g:mkdp_auto_close = 1\n    \" 设置为1则只有在保存文件或退出插入模式时更新预览，默认为0，实时更新预览\n    let g:mkdp_refresh_slow = 0\n    \" 设置为1则所有文件都使用MarkdownPreview进行预览，默认只有markdown文件可以\n    let g:mkdp_command_for_global = 0\n    ```\n\n\n* [emmet-vim][emmet]  \nEmmet的前身就叫做Zen Coding，它是个前端插件。官方支持很多软件，像Sublime Text、Notepad++、Dreamweaver、Eclipse、Adobe Brackets等，而Emmet.vim并非Emmet亲生，而是由日本Yasuhiro Matsumoto开发。对于前段开发者而言它是一件神器，能够节省大量的重复coding劳动。鉴于前端开发的少，这里只是mark一下。\n\n\n\n## 参考文献\n1. [有趣的vim游戏][vim_adventures]\n2. [Vim学习指南][vim_progressively]\n3. [vim plugin][vim_plugin]\n3. [Vim Script][vim_script]\n4. [Vim配置及说明——IDE编程环境][vim_ide]\n5. [高效vim插件][vim_plugin2]\n6. [VIM助记图][Vim_Cheat_Sheet]\n7. [Vimer的程序世界][vimer]\n8. [vimium][vimium]\n9. [youcompleteme][youcompleteme]\n9. [syntastic][syntastic]\n1. [python IDE][python_ide]\n1. [ultisnips][ultisnips]\n2. [自定义自己的代码块][snips_code]\n3. [前端开发神器Emmet][emmet]\n4. [Emmet教程][study_emmet]\n5. [对齐神器-tabular][tabular]\n1. [vim-markdown][vim-markdown]\n\n\n[vim_adventures]:\thttp://vim-adventures.com/\n[vim_progressively]:\thttp://www.oschina.net/translate/learn-vim-progressively\n[vim_plugin]:\t\thttp://my.oschina.net/swuly302/blog/156784\n[vim_script]:\t\thttp://vim-scripts.org/vim/scripts.html\n[vim_ide]:\t\t\thttp://www.it165.net/pro/html/201404/11505.html\n[vim_plugin2]:\t\thttp://my.oschina.net/swuly302/blog/156784\n[Vim_Cheat_Sheet]:\thttp://overapi.com/vim/\n[vimer]:\t\t\thttp://www.vimer.cn/\n[vimium]:\t\t\thttps://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb\n[youcompleteme]:\thttp://valloric.github.io/YouCompleteMe/\n[syntastic]:\t\thttps://github.com/scrooloose/syntastic/blob/master/doc/syntastic.txt\n[python_ide]:       http://3502990.blog.51cto.com/3492990/985750\n[ultisnips]:        https://github.com/SirVer/ultisnips\n[snips_code]:       http://mednoter.com/UltiSnips.html\n[emmet]:            https://github.com/mattn/emmet-vim\n[study_emmet]:      https://www.zfanw.com/blog/zencoding-vim-tutorial-chinese.html\n[tabular]:          https://github.com/godlygeek/tabular\n[vim-markdown]:     https://github.com/plasticboy/vim-markdown\n\n","slug":"Explore-advanced-vim","published":1,"date":"2015-09-24T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1m001pl73yic29veyu","content":"<p>在上一篇博文[Vim配置之入门篇](/2015/08/31/VIM配置之入门篇.html)中，只是大略介绍了Vim的基本配置以及几个常用的使用插件，但是在后面的使用中发现该配置的Vim并不是很好用，特别是minibuffer，taglist，fileexplore直接存在冲突，而且它的插件管理也比较麻烦。本篇博文主要就是解决这两个问题以及尝试一些更适合码农的插件。 <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p>之前使用Vim的初衷一方面是其插件的强大，更主要的方面是适合装13。但是随着对Vim更多的了解，才发现Vim的强大还是有缘由的，从下面的评价足以看出： &gt; * 世界上只有三种编辑器，EMACS、VIM和其它<br>\n&gt; * VIM is the God of editors, EMACS is God’s editor<br>\n&gt; * EMACS is actually an OS which pretends to be an editor</p>\n<p>根据上篇博文中的配置在日常使用的出现的问题，在此给出解决方案，对于插件间的冲突问题是用tagbar取代taglist，而插件管理是采用bundle插件。对于vim里面实用方便的插件的确有不少。</p>\n<h2 id=\"高效插件\">高效插件</h2>\n<p>vim的插件很多，而且功能很强大，非常强大。官网的插件地址在<a href=\"http://vim-scripts.org/vim/scripts.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<ul>\n<li>vundle<br>\nvundle是个用来管理vim插件的插件，它高效的利用了git，使得vim插件的安装，更新和卸载都交由vundle管理，从而将使用者从vim安装配置中解放出来。\n<ol style=\"list-style-type: decimal\">\n<li><p>安装vundle</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle</div></pre></td></tr></table></figure></li>\n<li>使用vundle管理vim插件\n<ol style=\"list-style-type: decimal\">\n<li>在<a href=\"http://vim-scripts.org/vim/scripts.html\" target=\"_blank\" rel=\"external\">Vim Script</a>选好想要使用的插件</li>\n<li>在vim配置文件.vimrc中添加<code>Plugin plugin_name</code></li>\n<li>执行Vundle初始化命令<code>:PluginInstall</code>，插件就安装好了</li>\n<li>常用命令</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 更新插件</span></div><div class=\"line\">:PluginInstall!</div><div class=\"line\"><span class=\"comment\"># 清除不再使用的插件</span></div><div class=\"line\">:PluginClean</div><div class=\"line\"><span class=\"comment\"># 列出所有插件</span></div><div class=\"line\">:PluginList</div><div class=\"line\"><span class=\"comment\"># 查找插件</span></div><div class=\"line\">:PluginSearch</div></pre></td></tr></table></figure></li>\n<li><p>vundle在.vimrc中的配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">\" 文件类型检测关闭[必须]（/usr/share/vim/vim74/filetype.vim）</span></div><div class=\"line\"><span class=\"keyword\">filetype</span> off</div><div class=\"line\"><span class=\"comment\">\" 设置runtime path包含Vundle的路径并且初始化</span></div><div class=\"line\"><span class=\"keyword\">set</span> rtp+=~/.<span class=\"keyword\">vim</span>/bundle/Vundle.<span class=\"keyword\">vim</span></div><div class=\"line\"><span class=\"comment\">\" 设置plugins安装地址</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 安装Vundle，让其管理插件[必须]</span></div><div class=\"line\">Plugin <span class=\"string\">'gmarik/Vundle.vim'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" Vundle插件安装样例:</span></div><div class=\"line\"><span class=\"comment\">\" 插件在github上</span></div><div class=\"line\"><span class=\"comment\">\" Plugin 'tpope/vim-fugitive'</span></div><div class=\"line\"><span class=\"comment\">\" 插件来自网页http://vim-scripts.org/vim/scripts.html</span></div><div class=\"line\"><span class=\"comment\">\" Plugin 'L9'</span></div><div class=\"line\"><span class=\"comment\">\" Git插件，但插件不在Github上</span></div><div class=\"line\"><span class=\"comment\">\" Plugin 'git://git.wincent.com/command-t.git'</span></div><div class=\"line\"><span class=\"comment\">\" 插件在本地机器上 (i.e. when working on your own plugin)</span></div><div class=\"line\"><span class=\"comment\">\" Plugin 'file:///home/gmarik/path/to/plugin'</span></div><div class=\"line\"><span class=\"comment\">\" The sparkup vim script is in a subdirectory of this repo called vim.</span></div><div class=\"line\"><span class=\"comment\">\" Pass the path to set the runtimepath properly.</span></div><div class=\"line\"><span class=\"comment\">\" Plugin 'rstacruz/sparkup', &#123;'rtp': 'vim/'&#125;</span></div><div class=\"line\"><span class=\"comment\">\" 使用用户名来避免插件冲突 ie. L9</span></div><div class=\"line\"><span class=\"comment\">\" Plugin 'user/L9', &#123;'name': 'newL9'&#125;</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">\" 所有插件的添加在end之前[必须]</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()            </div><div class=\"line\"><span class=\"comment\">\" 文件类型对应的插件[必须]（/usr/share/vim/vim74/ftplugin.vim）</span></div><div class=\"line\"><span class=\"keyword\">filetype</span> plugin <span class=\"keyword\">on</span></div><div class=\"line\"><span class=\"comment\">\" 文件类型对应的缩进文件</span></div><div class=\"line\"><span class=\"keyword\">filetype</span> <span class=\"built_in\">indent</span> <span class=\"keyword\">on</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>The-NERD-tree<br>\nNERDTree是Vim最常用的插件之一，可以在Vim运行时显示目录和文件结构，类似TextMate左侧的文件浏览器，但操作起来更为方便，你可以在手不离开键盘的情况下快速浏览文件，并在文件和文件夹之间进行切换。其样例如下图所示： [NERDTree](/assets/images/the-NERD-tree.gif)\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle'</span>)</div><div class=\"line\"><span class=\"comment\">\" 在Vim的编辑窗口中树状显示文件目录[The-NERD-tree]</span></div><div class=\"line\">Plugin <span class=\"string\">'The-NERD-tree'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" The-NERD-tree配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 不显示缓冲文件，中间文件</span></div><div class=\"line\"><span class=\"keyword\">let</span> NERDTreeIgnore=[ <span class=\"string\">'.pyc$'</span>, <span class=\"string\">'.pyo$'</span>, <span class=\"string\">'.obj$'</span>, <span class=\"string\">'.o$'</span>, <span class=\"string\">'.so$'</span>, <span class=\"string\">'.egg$'</span>, <span class=\"string\">'^.git$'</span>, <span class=\"string\">'^.svn$'</span>, <span class=\"string\">'^.hg$'</span> ]</div><div class=\"line\"><span class=\"comment\">\" 只剩一个NERDTree窗口时退出vim</span></div><div class=\"line\"><span class=\"keyword\">autocmd</span> bufenter * <span class=\"keyword\">if</span> (<span class=\"built_in\">winnr</span>(<span class=\"string\">\"$\"</span>) == <span class=\"number\">1</span> &amp;&amp; <span class=\"built_in\">exists</span>(<span class=\"string\">\"b:NERDTreeType\"</span>) &amp;&amp;<span class=\"variable\">b:NERDTreeType</span> == <span class=\"string\">\"primary\"</span>) | q | <span class=\"keyword\">endif</span></div><div class=\"line\"><span class=\"comment\">\" &lt;F9&gt;打开/关闭文件管理器</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;silent&gt;</span> <span class=\"symbol\">&lt;F9&gt;</span> :NERDTreeToggle<span class=\"symbol\">&lt;CR&gt;</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>The-NERD-Commenter<br>\n这个插件也是必备的，主要自动注释内容。当你xml自然是xml注释，当你是java自然就是java的注释规则。其样例如下图所示： [nerdcommenter](/assets/images/nerdcommenter.gif)\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 快速添加/去除注释</span></div><div class=\"line\">Plugin <span class=\"string\">'The-NERD-Commenter'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" The-NERD-Commenter配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 注释的时候自动加个空格, 强迫症必配</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:NERDSpaceDelims</span>=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" mm智能判断加上/解开注释</span></div><div class=\"line\"><span class=\"keyword\">map</span> mm <span class=\"symbol\">&lt;leader&gt;</span><span class=\"keyword\">c</span><span class=\"symbol\">&lt;space&gt;</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>ctrlp 这是个文件查找的插件，其功能和NERDTree有点类似，但是还是有点区别吧。其样例如下图所示： [nerdcommenter](/assets/images/vim-ctrlp.gif)\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 文件搜索</span></div><div class=\"line\">Plugin <span class=\"string\">'kien/ctrlp.vim'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" ctrlp配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 设置CtrlP的本地工作目录，0代表不设置该功能</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_working_path_mode</span>=<span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">\" ctrlp窗口在底部</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_match_window_bottom</span>=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" ctrlp窗口最大高度为15行</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_max_height</span>=<span class=\"number\">15</span></div><div class=\"line\"><span class=\"comment\">\" 窗口</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_match_window_reversed</span>=<span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">\" 最近打开的文件的个数</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_mruf_max</span>=<span class=\"number\">500</span></div><div class=\"line\"><span class=\"comment\">\" 记录但去掉重复的软链接</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_follow_symlinks</span>=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" &lt;Ctrl-f&gt;启动文件查找</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_map</span> = <span class=\"string\">'&lt;c-f&gt;'</span></div><div class=\"line\"><span class=\"comment\">\" Ctrlp启动文件查找</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_cmd</span> = <span class=\"string\">'CtrlP'</span></div><div class=\"line\"><span class=\"comment\">\" 相当于mru功能，show recently opened files</span></div><div class=\"line\"><span class=\"keyword\">map</span> <span class=\"symbol\">&lt;c-p&gt;</span> :CtrlPMRU<span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\" 忽略以下文件类型</span></div><div class=\"line\"><span class=\"keyword\">set</span> wildignore+=*/tmp/*,*.<span class=\"keyword\">so</span>,*.swp,*.zip</div><div class=\"line\"><span class=\"comment\">\" 忽略以下文件目录</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_custom_ignore</span> = &#123;<span class=\"string\">'dir'</span>:  <span class=\"string\">'/].(git|hg|svn|rvm)$'</span>,<span class=\"string\">'file'</span>: <span class=\"string\">'(exe|so|dll|zip|tar|tar.gz)$'</span>&#125;</div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>ctags<br>\nctags可以建立源码树的标签索引（标签就是一个标识符被定义的地方，如函数定义），使程序员在编程时能迅速定位函数、变量、宏定义等位置去查看原形。\n<ol style=\"list-style-type: decimal\">\n<li><p>安装exuberant-ctags工具</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install exuberant-ctags</div></pre></td></tr></table></figure></li>\n<li>创建C++代码库索引\n<ol style=\"list-style-type: decimal\">\n<li>下载<a href=\"http://www.vim.org/scripts/download_script.php?src_id=9178\" target=\"_blank\" rel=\"external\">libstdc++</a>头文件,包含c++中STL，streams等。</li>\n<li><p>解压到~/.vim/tags目录后执行ctags命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_src</div><div class=\"line\">mv tags ~/.vim/tags/cpptag</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中设置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">tags</span>+=~/.<span class=\"keyword\">vim</span>/<span class=\"keyword\">tags</span>/cpptag</div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>创建gcc代码库索引\n<ol style=\"list-style-type: decimal\">\n<li><p>ubuntu中安装完build-essential后，会在/usr/include/c++目录下有C/C++的头文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install build-essential</div></pre></td></tr></table></figure></li>\n<li><p>拷贝/usr/include/c++/4.8里的文件到~/.vim/tags/gcc文件夹里后执行ctags命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cp -R /usr/include/c++/4.8 ~/.vim/tags/gcc</div><div class=\"line\">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q gcc</div><div class=\"line\">mv tags ~/.vim/tags/gcctag</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中设置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">tags</span>+=~/.<span class=\"keyword\">vim</span>/<span class=\"keyword\">tags</span>/gcctag</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ol></li>\n<li>cscope Cscope，一个应用程序，程式员使用它来协助程式撰写及追踪程式码，主要使用于C语言程式。最早起源于贝尔实验室，运作在PDP-11上，由Joe Steffen开始发展。</li>\n</ul>\n<ol style=\"list-style-type: decimal\">\n<li><p>安装cscope工具</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install cscope</div></pre></td></tr></table></figure></li>\n<li>创建gnu c库索引\n<ol style=\"list-style-type: decimal\">\n<li>下载<a href=\"http://ftp.gnu.org/gnu/glibc/glibc-2.22.tar.xz\" target=\"_blank\" rel=\"external\">glibc</a>文件,它是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。</li>\n<li><p>解压到~/.vim/tags目录后执行cscope命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"built_in\">cd</span> ~/.vim/tags/glibc-2.22</div><div class=\"line\">cscope -Rbq</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中设置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" cscope配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">has</span>(<span class=\"string\">\"cscope\"</span>)</div><div class=\"line\">  <span class=\"comment\">\" 设置cscope的命令位置</span></div><div class=\"line\">  <span class=\"keyword\">set</span> csprg=/usr/local/bin/<span class=\"keyword\">cscope</span></div><div class=\"line\">  <span class=\"comment\">\" 设定quickfix来显示cscope的结果</span></div><div class=\"line\">  <span class=\"keyword\">set</span> cscopequickfix=s-,<span class=\"keyword\">c</span>-,d-,i-,t-,<span class=\"keyword\">e</span>-</div><div class=\"line\">  <span class=\"comment\">\" 先搜索tags标签文件，在搜索cscope数据库</span></div><div class=\"line\">  <span class=\"keyword\">set</span> csto=<span class=\"number\">1</span></div><div class=\"line\">  <span class=\"comment\">\" 使用cstag查询，也就是同时搜索cscope数据库和tags标签文件</span></div><div class=\"line\">  <span class=\"keyword\">set</span> <span class=\"keyword\">cst</span></div><div class=\"line\">  <span class=\"comment\">\" 不显示添加数据库是否成功</span></div><div class=\"line\">  <span class=\"keyword\">set</span> nocsverb</div><div class=\"line\">  <span class=\"comment\">\"</span></div><div class=\"line\">  <span class=\"keyword\">if</span> <span class=\"built_in\">filereadable</span>(<span class=\"string\">\"cscope.out\"</span>)</div><div class=\"line\">    <span class=\"comment\">\" 添加当前目录下的cscope数据库</span></div><div class=\"line\">    <span class=\"keyword\">cs</span> <span class=\"built_in\">add</span> <span class=\"keyword\">cscope</span>.out</div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    <span class=\"comment\">\" 添加vim自带的cscope数据库</span></div><div class=\"line\">    <span class=\"comment\">\" gnu c 数据库</span></div><div class=\"line\">    <span class=\"keyword\">cs</span> <span class=\"built_in\">add</span> ~/.<span class=\"keyword\">vim</span>/<span class=\"keyword\">tags</span>/glibc-<span class=\"number\">2.22</span>/<span class=\"keyword\">cscope</span>.out ~/.<span class=\"keyword\">vim</span>/<span class=\"keyword\">tags</span>/glibc-<span class=\"number\">2.22</span></div><div class=\"line\">  <span class=\"keyword\">endif</span></div><div class=\"line\">  <span class=\"comment\">\" 显示添加数据库成功</span></div><div class=\"line\">  <span class=\"keyword\">set</span> csverb</div><div class=\"line\"><span class=\"keyword\">endif</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\" 映射快捷键\"</span><span class=\"symbol\">&lt;C-_&gt;</span>g的按法是先按<span class=\"string\">\"Ctrl+Shift+-\"</span>, 然后很快再按<span class=\"string\">\"g\"</span></div><div class=\"line\"><span class=\"comment\">\" 查找本 C 符号（可以跳过注释）</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span>s :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> s <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cword&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找本定义</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span>g :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> g <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cword&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找调用本函数的函数</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span><span class=\"keyword\">c</span> :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> <span class=\"keyword\">c</span> <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cword&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找本字符串</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span>t :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> t <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cword&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找本 egrep 模式</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span><span class=\"keyword\">e</span> :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> <span class=\"keyword\">e</span> <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cword&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找本文件</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span><span class=\"keyword\">f</span> :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> <span class=\"keyword\">f</span> <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cfile&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找包含本文件的文件</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span>i :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> i ^<span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cfile&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span>$<span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找本函数调用的函数</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span>d :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> d <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cword&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n</ol>\n<ul>\n<li>tagbar<br>\ntagbar插件是和taglist功能类似的插件，但是它比taglist更优秀，并且能和NERDTree完美配合。\n<ol style=\"list-style-type: decimal\">\n<li>tagbar的优势\n<ul>\n<li>支持头文件的函数列表显示<br>\n细心的读者可能会发现，tagbar对函数的可见级别也是做了区分的，分别用+ – # 并配合着色来做了区分</li>\n<li>对面向对象的支持更好<br>\ntaglist虽然也会列出类列表，但是整体还是很不直观</li>\n<li>自动根据文件修改时间来重建<br>\ntaglist在这一点上体验就很不好，其实明明可以通过这种时间戳的方式来实现</li>\n</ul></li>\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 替换taglist的插件[tagbar]</span></div><div class=\"line\">Plugin <span class=\"string\">'majutsushi/tagbar'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" tagbar配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 启动时自动focus</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:tagbar_autofocus</span>=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" &lt;F10&gt;打开/关闭Tagbar</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;silent&gt;</span> <span class=\"symbol\">&lt;F10&gt;</span> :TagbarToggle<span class=\"symbol\">&lt;CR&gt;</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>rainbow<br>\n这个插件也是必备的，该插件的主要功能是给配对的(){}[]不同的颜色来区别，非常方便看括号的作用域\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 括号显示增强</span></div><div class=\"line\">Plugin <span class=\"string\">'luochen1990/rainbow'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" rainbow配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" rainbow激活</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:rainbow_active</span> = <span class=\"number\">1</span></div></pre></td></tr></table></figure></li>\n<li><p>给rainbow添加自动启动功能</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">exists</span>(<span class=\"string\">'g:rainbow_active'</span>) &amp;&amp; <span class=\"variable\">g:rainbow_active</span>)</div><div class=\"line\">\tauto <span class=\"keyword\">syntax</span> * <span class=\"keyword\">call</span> rainbow#hook()</div><div class=\"line\">\tauto <span class=\"keyword\">colorscheme</span> * <span class=\"keyword\">call</span> rainbow#show()</div><div class=\"line\">\t<span class=\"comment\">\" 下面这命令使rainbow在vim启动时被打开</span></div><div class=\"line\">\t<span class=\"keyword\">autocmd</span> VimEnter * nested <span class=\"keyword\">call</span> rainbow#toggle()</div><div class=\"line\"><span class=\"keyword\">endif</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li><a href=\"https://github.com/scrooloose/syntastic/blob/master/doc/syntastic.txt\" target=\"_blank\" rel=\"external\">syntastic</a><br>\n这是一个非常有用的插件，它能够实时的进行语法和编码风格的检查，利用它几乎可以做到编码完成后无编译错误。并且它还集成了静态检查工具：lint，可以让你的代码更加完美。更强大的它支持近百种编程语言，像是一个集大成的实时编译器。出现错误之后，可以非常方便的跳转到出错处。其样例如下图所示： [nerdcommenter](/assets/images/vim-syntastic.png)\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 语义高亮</span></div><div class=\"line\">Plugin <span class=\"string\">'scrooloose/syntastic'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" syntastic配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 首次打开和保存时都要进行语义检查</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_check_on_open</span> = <span class=\"number\">1</span>  </div><div class=\"line\"><span class=\"comment\">\" 设置错误提示符'x'</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_error_symbol</span> = <span class=\"string\">'x'</span>  </div><div class=\"line\"><span class=\"comment\">\" 设置警告提示符'!'</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_warning_symbol</span> = <span class=\"string\">'!'</span>  </div><div class=\"line\"><span class=\"comment\">\" 当鼠标放在错误行则显示错误信息</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_enable_balloons</span> = <span class=\"number\">1</span>  </div><div class=\"line\"><span class=\"comment\">\" 保存退出时不用进行语义检测</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_check_on_wq</span> = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">\" 编译有误则错误窗口显示，否在不显示</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_auto_loc_list</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 错误总会填充到错误窗口</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_always_populate_loc_list</span> = <span class=\"number\">1</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li><a href=\"http://valloric.github.io/YouCompleteMe/\" target=\"_blank\" rel=\"external\">YouCompleteMe</a><br>\nYouCompleteMe对代码的补全完全达到了编译器级别，绝不弱于Visual Assist。它是基于LLVM/clang，一个Apple公司为了代替GNU/GCC而支持的编译器，正因为YouCompleteMe有了编译器的支持，而不再像以往的插件一样基于文本来进行匹配，所以准确率才如此之高。而且，它是C/S架构，会在本机创建一个服务器端，利用clang来解析代码，然后将结果返回给客户端，所以也就解决了VIM是单线程而造成的各种补全插件速度奇慢的诟病，在使用时，几乎感觉不到任何的延时，体验达到了Visual Assist的级别。<br>\nYouCompleteMe除了补全以外，还有一个非常重要的作用：代码跳转，同样可以达到编译器级别的准确度，媲美Visual Assist与Source Insight。其样例如下图所示： [nerdcommenter](/assets/images/youcompleteme.gif)\n<ol style=\"list-style-type: decimal\">\n<li><p>安装必备软件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install clang llvm cmake python python-dev</div></pre></td></tr></table></figure></li>\n<li><p>手动编译</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> ~/.vim/bundle/YouCompleteMe</div><div class=\"line\">./install.sh --clang-completer</div></pre></td></tr></table></figure></li>\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 自动补全</span></div><div class=\"line\">Plugin <span class=\"string\">'Valloric/YouCompleteMe'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" YouCompleteMe配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 设置YCM配置文件的路径</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_global_ycm_extra_conf</span>=<span class=\"string\">'~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py'</span></div><div class=\"line\"><span class=\"comment\">\" 开启关键字语法检测</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_seed_identifiers_with_syntax</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 自动触发补全</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_auto_trigger</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" YCM触发的条件</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_semantic_triggers</span> = &#123;  </div><div class=\"line\">\\ <span class=\"string\">'c'</span> : [<span class=\"string\">'-&gt;'</span> , <span class=\"string\">'.'</span>],</div><div class=\"line\">\\ <span class=\"string\">'cpp,objcpp'</span> : [<span class=\"string\">'-&gt;'</span>,<span class=\"string\">'.'</span>,<span class=\"string\">'::'</span>],</div><div class=\"line\">\\ <span class=\"string\">'java,javascript,python,scala'</span> : [<span class=\"string\">'.'</span>],</div><div class=\"line\">\\ <span class=\"string\">'ruby'</span> : [<span class=\"string\">'.'</span>,<span class=\"string\">'::'</span>],</div><div class=\"line\">\\&#125;</div><div class=\"line\"><span class=\"comment\">\" 不用每次询问.ycm_extra_conf.py位置</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_confirm_extra_conf</span>=<span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">\" YCM也从tags文件中收集标识符</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_collect_identifiers_from_tags_files</span>=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 当输入注释的时候不用弹出提示</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_complete_in_comments</span>=<span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">\" 当输入字符的时候弹出提示</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_complete_in_strings</span>=<span class=\"number\">1</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n</ul>\n<blockquote>\n<p><strong>TIps:Tab无效</strong><br>\n如果出现安装YouCompleteMe后，虽然看到YouCompleteMe的提示框，但是无法使用 &lt; Tab &gt; 进行自动补全，只能使用上下方向键+回车来选择时，就要检查一下.vimrc是否打开了粘贴模式，即设置了set paste．该模式会屏蔽所有映射和缩写．（对于ultisnips也有同样的问题）</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/SirVer/ultisnips\" target=\"_blank\" rel=\"external\">ultisnips</a><br>\n这个插件也是必备的，该插件的主要功能是用来快速输入固定的代码块，像文件开头的版权声明，<code>#ifndef... #def... #endif</code>这样宏定义，markdown写jekyll博文的head信息．最关键的是可以按照自己的习惯<a href=\"http://mednoter.com/UltiSnips.html\" target=\"_blank\" rel=\"external\">自定义代码块</a>，这样就不用按照IDE的习惯培养自己了．其动态效果如下所示： [ultisnippets](/assets/images/ultisnippets-md.gif)\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" ultisnips</span></div><div class=\"line\">      Plugin <span class=\"string\">'SirVer/ultisnips'</span></div><div class=\"line\">      <span class=\"comment\">\" Snippets are separated from the engine</span></div><div class=\"line\">      Plugin <span class=\"string\">'honza/vim-snippets'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\">      <span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\">      <span class=\"comment\">\" ultisnips配置</span></div><div class=\"line\">      <span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\">      <span class=\"comment\">\" 如果使用了Valloric/YouCompleteMe,就别设置为&lt;tab&gt;</span></div><div class=\"line\">      <span class=\"keyword\">let</span> <span class=\"variable\">g:UltiSnipsExpandTrigger</span>=<span class=\"string\">\"&lt;c-j&gt;\"</span></div><div class=\"line\">      <span class=\"comment\">\" 前选片段</span></div><div class=\"line\">      <span class=\"keyword\">let</span> <span class=\"variable\">g:UltiSnipsJumpForwardTrigger</span>=<span class=\"string\">\"&lt;C-f&gt;\"</span></div><div class=\"line\">      <span class=\"comment\">\" 后选片段</span></div><div class=\"line\">      <span class=\"keyword\">let</span> <span class=\"variable\">g:UltiSnipsJumpBackwardTrigger</span>=<span class=\"string\">\"&lt;C-b&gt;\"</span></div><div class=\"line\">      <span class=\"comment\">\" 使用:UltiSnipsEdit打开片段定义文件时分屏位置</span></div><div class=\"line\">      <span class=\"keyword\">let</span> <span class=\"variable\">g:UltiSnipsEditSplit</span>=<span class=\"string\">\"vertical\"</span></div></pre></td></tr></table></figure></li>\n<li>自定义代码块<br>\n我们注意到安装ultisnips过程中，除了安装自身以外，还安装了honza的vim-snippets，而它的一大作用是提供了大量（目前是80个）的程序片段，像c，python，markdown，make，sh，sql等。而这些snippets都在.vim/bundle/vim-snippets/snippets文件夹中。除此之外，我们还可以自定义自己的代码块，建议是放在.vim/UltiSnippets目录下（和bundle同等级），一方面是.vim/bundle/vim-snippets/snippets下的代码块是别人的git项目。另一方面.vim/UltiSnippets下的文件可以覆盖vim-snippets里的配置，这样更符合DIY的目的。关于如何编写snippets，网上找到的资源不多，给出如下建议：\n<ul>\n<li>查看.vim/bundle/vim-snippets/snippets里的代码</li>\n<li>通过<code>:help snippets</code>查看ultisnips的帮助文档</li>\n<li><p>博文<a href=\"http://mednoter.com/UltiSnips.html\" target=\"_blank\" rel=\"external\">自定义自己的代码块</a>中的样列</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">## head Jekyll写博文时插入的头文件信息</span></div><div class=\"line\">snippet head <span class=\"string\">\"Jekyll post header\"</span> b <span class=\"comment\"># b代表begin（snippet should be expanded only at the beginning of a line ）</span></div><div class=\"line\">---</div><div class=\"line\">layout:       default</div><div class=\"line\">title:        <span class=\"variable\">$&#123;1:blog_name&#125;</span></div><div class=\"line\">category:     [<span class=\"variable\">$&#123;2:cate1,cate2&#125;</span>]</div><div class=\"line\">comments:     <span class=\"literal\">true</span></div><div class=\"line\">date:         `!v strftime(<span class=\"string\">\"%Y-%m-%d %H:%M:%S\"</span>)`</div><div class=\"line\">---</div><div class=\"line\"><span class=\"variable\">$&#123;0&#125;</span>        <span class=\"comment\"># 代表tab最终停留的位置</span></div><div class=\"line\"></div><div class=\"line\">endsnippet</div></pre></td></tr></table></figure></li>\n</ul></li>\n</ol></li>\n<li><a href=\"https://github.com/godlygeek/tabular\" target=\"_blank\" rel=\"external\">tabular</a><br>\n这是一个处女座或码农必备的插件，因为当你看到代码/文字杂乱的排版–等号，冒号，表格等不能对齐时，应该会抓狂吧。而tabular这个插件能完美的解决这个问题。就像下面的图例一样，只需要输入命令<code>:Tabularize /*</code>（*代表对齐的符号）即可：<br>\n<img src=\"https://github.com/godlygeek/tabular\" alt=\"tabular\">(/assets/images/vim-tabular.gif)\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" tab对齐</span></div><div class=\"line\">Plugin <span class=\"string\">'godlygeek/tabular'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" tabular配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 目前还尚在摸索中</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li><a href=\"https://github.com/plasticboy/vim-markdown\" target=\"_blank\" rel=\"external\">vim-markdown</a> vim-markdown是一款用来对原生markdown和扩展markdown语法进行语义高亮和规则匹配的插件。</li>\n</ul>\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" markdown语义高亮</span></div><div class=\"line\">Plugin <span class=\"string\">'plasticboy/vim-markdown'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()</div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" tabular配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" vim识别md</span></div><div class=\"line\"><span class=\"keyword\">autocmd</span> BufNewFile,BufReadPost *.md <span class=\"keyword\">set</span> <span class=\"keyword\">filetype</span>=markdown</div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:vimmarkdownfoldingdisabled</span>=<span class=\"number\">1</span> <span class=\"comment\">\"取消代码折叠</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:vimmarkdownnodefaultkeymappings</span>=<span class=\"number\">1</span> <span class=\"comment\">\"取消默认的键对应</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:vimmarkdownmath</span>=<span class=\"number\">1</span> <span class=\"comment\">\"使用数学符号</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:vimmarkdownfrontmatter</span>=<span class=\"number\">1</span> <span class=\"comment\">\"高亮YMAL frontmatter</span></div></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>[markdown同步预览][markdown-preview] markdown-preview是一款用来将vim打开的markdown文件翻译为html显示在浏览器里的插件，该插件的亮点在于实时更新。</li>\n</ul>\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" markdown同步显示</span></div><div class=\"line\">Plugin <span class=\"string\">'iamcco/mathjax-support-for-mkdp'</span></div><div class=\"line\">Plugin <span class=\"string\">'iamcco/markdown-preview.vim'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()</div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" markdown-preview.vim配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 设置启动chrome浏览器的命令</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:mkdp_path_to_chrome</span> = <span class=\"string\">\"open -a Google\\\\ Chrome\"</span></div><div class=\"line\"><span class=\"comment\">\" 设置为1则打开markdown文件时自动打开浏览器</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:mkdp_auto_start</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 设置为1则在编辑markdown的时候预览窗口是否打开，未开则自动打开</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:mkdp_auto_open</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 切换buffer时自动关闭预览窗口，设置为0则在切换buffer时不自动关闭</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:mkdp_auto_close</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 设置为1则只有在保存文件或退出插入模式时更新预览，默认为0，实时更新预览</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:mkdp_refresh_slow</span> = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">\" 设置为1则所有文件都使用MarkdownPreview进行预览，默认只有markdown文件可以</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:mkdp_command_for_global</span> = <span class=\"number\">0</span></div></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/mattn/emmet-vim\" target=\"_blank\" rel=\"external\">emmet-vim</a><br>\nEmmet的前身就叫做Zen Coding，它是个前端插件。官方支持很多软件，像Sublime Text、Notepad++、Dreamweaver、Eclipse、Adobe Brackets等，而Emmet.vim并非Emmet亲生，而是由日本Yasuhiro Matsumoto开发。对于前段开发者而言它是一件神器，能够节省大量的重复coding劳动。鉴于前端开发的少，这里只是mark一下。</li>\n</ul>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://vim-adventures.com/\" target=\"_blank\" rel=\"external\">有趣的vim游戏</a></li>\n<li><a href=\"http://www.oschina.net/translate/learn-vim-progressively\" target=\"_blank\" rel=\"external\">Vim学习指南</a></li>\n<li><a href=\"http://my.oschina.net/swuly302/blog/156784\" target=\"_blank\" rel=\"external\">vim plugin</a></li>\n<li><a href=\"http://vim-scripts.org/vim/scripts.html\" target=\"_blank\" rel=\"external\">Vim Script</a></li>\n<li><a href=\"http://www.it165.net/pro/html/201404/11505.html\" target=\"_blank\" rel=\"external\">Vim配置及说明——IDE编程环境</a></li>\n<li><a href=\"http://my.oschina.net/swuly302/blog/156784\" target=\"_blank\" rel=\"external\">高效vim插件</a></li>\n<li><a href=\"http://overapi.com/vim/\" target=\"_blank\" rel=\"external\">VIM助记图</a></li>\n<li><a href=\"http://www.vimer.cn/\" target=\"_blank\" rel=\"external\">Vimer的程序世界</a></li>\n<li><a href=\"https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb\" target=\"_blank\" rel=\"external\">vimium</a></li>\n<li><a href=\"http://valloric.github.io/YouCompleteMe/\" target=\"_blank\" rel=\"external\">youcompleteme</a></li>\n<li><a href=\"https://github.com/scrooloose/syntastic/blob/master/doc/syntastic.txt\" target=\"_blank\" rel=\"external\">syntastic</a></li>\n<li><a href=\"http://3502990.blog.51cto.com/3492990/985750\" target=\"_blank\" rel=\"external\">python IDE</a></li>\n<li><a href=\"https://github.com/SirVer/ultisnips\" target=\"_blank\" rel=\"external\">ultisnips</a></li>\n<li><a href=\"http://mednoter.com/UltiSnips.html\" target=\"_blank\" rel=\"external\">自定义自己的代码块</a></li>\n<li><a href=\"https://github.com/mattn/emmet-vim\" target=\"_blank\" rel=\"external\">前端开发神器Emmet</a></li>\n<li><a href=\"https://www.zfanw.com/blog/zencoding-vim-tutorial-chinese.html\" target=\"_blank\" rel=\"external\">Emmet教程</a></li>\n<li><a href=\"https://github.com/godlygeek/tabular\" target=\"_blank\" rel=\"external\">对齐神器-tabular</a></li>\n<li><a href=\"https://github.com/plasticboy/vim-markdown\" target=\"_blank\" rel=\"external\">vim-markdown</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在上一篇博文[Vim配置之入门篇](/2015/08/31/VIM配置之入门篇.html)中，只是大略介绍了Vim的基本配置以及几个常用的使用插件，但是在后面的使用中发现该配置的Vim并不是很好用，特别是minibuffer，taglist，fileexplore直接存在冲突，而且它的插件管理也比较麻烦。本篇博文主要就是解决这两个问题以及尝试一些更适合码农的插件。","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p>之前使用Vim的初衷一方面是其插件的强大，更主要的方面是适合装13。但是随着对Vim更多的了解，才发现Vim的强大还是有缘由的，从下面的评价足以看出： &gt; * 世界上只有三种编辑器，EMACS、VIM和其它<br>\n&gt; * VIM is the God of editors, EMACS is God’s editor<br>\n&gt; * EMACS is actually an OS which pretends to be an editor</p>\n<p>根据上篇博文中的配置在日常使用的出现的问题，在此给出解决方案，对于插件间的冲突问题是用tagbar取代taglist，而插件管理是采用bundle插件。对于vim里面实用方便的插件的确有不少。</p>\n<h2 id=\"高效插件\">高效插件</h2>\n<p>vim的插件很多，而且功能很强大，非常强大。官网的插件地址在<a href=\"http://vim-scripts.org/vim/scripts.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<ul>\n<li>vundle<br>\nvundle是个用来管理vim插件的插件，它高效的利用了git，使得vim插件的安装，更新和卸载都交由vundle管理，从而将使用者从vim安装配置中解放出来。\n<ol style=\"list-style-type: decimal\">\n<li><p>安装vundle</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle</div></pre></td></tr></table></figure></li>\n<li>使用vundle管理vim插件\n<ol style=\"list-style-type: decimal\">\n<li>在<a href=\"http://vim-scripts.org/vim/scripts.html\" target=\"_blank\" rel=\"external\">Vim Script</a>选好想要使用的插件</li>\n<li>在vim配置文件.vimrc中添加<code>Plugin plugin_name</code></li>\n<li>执行Vundle初始化命令<code>:PluginInstall</code>，插件就安装好了</li>\n<li>常用命令</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 更新插件</span></div><div class=\"line\">:PluginInstall!</div><div class=\"line\"><span class=\"comment\"># 清除不再使用的插件</span></div><div class=\"line\">:PluginClean</div><div class=\"line\"><span class=\"comment\"># 列出所有插件</span></div><div class=\"line\">:PluginList</div><div class=\"line\"><span class=\"comment\"># 查找插件</span></div><div class=\"line\">:PluginSearch</div></pre></td></tr></table></figure></li>\n<li><p>vundle在.vimrc中的配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">\" 文件类型检测关闭[必须]（/usr/share/vim/vim74/filetype.vim）</span></div><div class=\"line\"><span class=\"keyword\">filetype</span> off</div><div class=\"line\"><span class=\"comment\">\" 设置runtime path包含Vundle的路径并且初始化</span></div><div class=\"line\"><span class=\"keyword\">set</span> rtp+=~/.<span class=\"keyword\">vim</span>/bundle/Vundle.<span class=\"keyword\">vim</span></div><div class=\"line\"><span class=\"comment\">\" 设置plugins安装地址</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 安装Vundle，让其管理插件[必须]</span></div><div class=\"line\">Plugin <span class=\"string\">'gmarik/Vundle.vim'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" Vundle插件安装样例:</span></div><div class=\"line\"><span class=\"comment\">\" 插件在github上</span></div><div class=\"line\"><span class=\"comment\">\" Plugin 'tpope/vim-fugitive'</span></div><div class=\"line\"><span class=\"comment\">\" 插件来自网页http://vim-scripts.org/vim/scripts.html</span></div><div class=\"line\"><span class=\"comment\">\" Plugin 'L9'</span></div><div class=\"line\"><span class=\"comment\">\" Git插件，但插件不在Github上</span></div><div class=\"line\"><span class=\"comment\">\" Plugin 'git://git.wincent.com/command-t.git'</span></div><div class=\"line\"><span class=\"comment\">\" 插件在本地机器上 (i.e. when working on your own plugin)</span></div><div class=\"line\"><span class=\"comment\">\" Plugin 'file:///home/gmarik/path/to/plugin'</span></div><div class=\"line\"><span class=\"comment\">\" The sparkup vim script is in a subdirectory of this repo called vim.</span></div><div class=\"line\"><span class=\"comment\">\" Pass the path to set the runtimepath properly.</span></div><div class=\"line\"><span class=\"comment\">\" Plugin 'rstacruz/sparkup', &#123;'rtp': 'vim/'&#125;</span></div><div class=\"line\"><span class=\"comment\">\" 使用用户名来避免插件冲突 ie. L9</span></div><div class=\"line\"><span class=\"comment\">\" Plugin 'user/L9', &#123;'name': 'newL9'&#125;</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">\" 所有插件的添加在end之前[必须]</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()            </div><div class=\"line\"><span class=\"comment\">\" 文件类型对应的插件[必须]（/usr/share/vim/vim74/ftplugin.vim）</span></div><div class=\"line\"><span class=\"keyword\">filetype</span> plugin <span class=\"keyword\">on</span></div><div class=\"line\"><span class=\"comment\">\" 文件类型对应的缩进文件</span></div><div class=\"line\"><span class=\"keyword\">filetype</span> <span class=\"built_in\">indent</span> <span class=\"keyword\">on</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>The-NERD-tree<br>\nNERDTree是Vim最常用的插件之一，可以在Vim运行时显示目录和文件结构，类似TextMate左侧的文件浏览器，但操作起来更为方便，你可以在手不离开键盘的情况下快速浏览文件，并在文件和文件夹之间进行切换。其样例如下图所示： [NERDTree](/assets/images/the-NERD-tree.gif)\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle'</span>)</div><div class=\"line\"><span class=\"comment\">\" 在Vim的编辑窗口中树状显示文件目录[The-NERD-tree]</span></div><div class=\"line\">Plugin <span class=\"string\">'The-NERD-tree'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" The-NERD-tree配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 不显示缓冲文件，中间文件</span></div><div class=\"line\"><span class=\"keyword\">let</span> NERDTreeIgnore=[ <span class=\"string\">'.pyc$'</span>, <span class=\"string\">'.pyo$'</span>, <span class=\"string\">'.obj$'</span>, <span class=\"string\">'.o$'</span>, <span class=\"string\">'.so$'</span>, <span class=\"string\">'.egg$'</span>, <span class=\"string\">'^.git$'</span>, <span class=\"string\">'^.svn$'</span>, <span class=\"string\">'^.hg$'</span> ]</div><div class=\"line\"><span class=\"comment\">\" 只剩一个NERDTree窗口时退出vim</span></div><div class=\"line\"><span class=\"keyword\">autocmd</span> bufenter * <span class=\"keyword\">if</span> (<span class=\"built_in\">winnr</span>(<span class=\"string\">\"$\"</span>) == <span class=\"number\">1</span> &amp;&amp; <span class=\"built_in\">exists</span>(<span class=\"string\">\"b:NERDTreeType\"</span>) &amp;&amp;<span class=\"variable\">b:NERDTreeType</span> == <span class=\"string\">\"primary\"</span>) | q | <span class=\"keyword\">endif</span></div><div class=\"line\"><span class=\"comment\">\" &lt;F9&gt;打开/关闭文件管理器</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;silent&gt;</span> <span class=\"symbol\">&lt;F9&gt;</span> :NERDTreeToggle<span class=\"symbol\">&lt;CR&gt;</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>The-NERD-Commenter<br>\n这个插件也是必备的，主要自动注释内容。当你xml自然是xml注释，当你是java自然就是java的注释规则。其样例如下图所示： [nerdcommenter](/assets/images/nerdcommenter.gif)\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 快速添加/去除注释</span></div><div class=\"line\">Plugin <span class=\"string\">'The-NERD-Commenter'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" The-NERD-Commenter配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 注释的时候自动加个空格, 强迫症必配</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:NERDSpaceDelims</span>=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" mm智能判断加上/解开注释</span></div><div class=\"line\"><span class=\"keyword\">map</span> mm <span class=\"symbol\">&lt;leader&gt;</span><span class=\"keyword\">c</span><span class=\"symbol\">&lt;space&gt;</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>ctrlp 这是个文件查找的插件，其功能和NERDTree有点类似，但是还是有点区别吧。其样例如下图所示： [nerdcommenter](/assets/images/vim-ctrlp.gif)\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 文件搜索</span></div><div class=\"line\">Plugin <span class=\"string\">'kien/ctrlp.vim'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" ctrlp配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 设置CtrlP的本地工作目录，0代表不设置该功能</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_working_path_mode</span>=<span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">\" ctrlp窗口在底部</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_match_window_bottom</span>=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" ctrlp窗口最大高度为15行</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_max_height</span>=<span class=\"number\">15</span></div><div class=\"line\"><span class=\"comment\">\" 窗口</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_match_window_reversed</span>=<span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">\" 最近打开的文件的个数</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_mruf_max</span>=<span class=\"number\">500</span></div><div class=\"line\"><span class=\"comment\">\" 记录但去掉重复的软链接</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_follow_symlinks</span>=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" &lt;Ctrl-f&gt;启动文件查找</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_map</span> = <span class=\"string\">'&lt;c-f&gt;'</span></div><div class=\"line\"><span class=\"comment\">\" Ctrlp启动文件查找</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_cmd</span> = <span class=\"string\">'CtrlP'</span></div><div class=\"line\"><span class=\"comment\">\" 相当于mru功能，show recently opened files</span></div><div class=\"line\"><span class=\"keyword\">map</span> <span class=\"symbol\">&lt;c-p&gt;</span> :CtrlPMRU<span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\" 忽略以下文件类型</span></div><div class=\"line\"><span class=\"keyword\">set</span> wildignore+=*/tmp/*,*.<span class=\"keyword\">so</span>,*.swp,*.zip</div><div class=\"line\"><span class=\"comment\">\" 忽略以下文件目录</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ctrlp_custom_ignore</span> = &#123;<span class=\"string\">'dir'</span>:  <span class=\"string\">'/].(git|hg|svn|rvm)$'</span>,<span class=\"string\">'file'</span>: <span class=\"string\">'(exe|so|dll|zip|tar|tar.gz)$'</span>&#125;</div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>ctags<br>\nctags可以建立源码树的标签索引（标签就是一个标识符被定义的地方，如函数定义），使程序员在编程时能迅速定位函数、变量、宏定义等位置去查看原形。\n<ol style=\"list-style-type: decimal\">\n<li><p>安装exuberant-ctags工具</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install exuberant-ctags</div></pre></td></tr></table></figure></li>\n<li>创建C++代码库索引\n<ol style=\"list-style-type: decimal\">\n<li>下载<a href=\"http://www.vim.org/scripts/download_script.php?src_id=9178\" target=\"_blank\" rel=\"external\">libstdc++</a>头文件,包含c++中STL，streams等。</li>\n<li><p>解压到~/.vim/tags目录后执行ctags命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_src</div><div class=\"line\">mv tags ~/.vim/tags/cpptag</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中设置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">tags</span>+=~/.<span class=\"keyword\">vim</span>/<span class=\"keyword\">tags</span>/cpptag</div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>创建gcc代码库索引\n<ol style=\"list-style-type: decimal\">\n<li><p>ubuntu中安装完build-essential后，会在/usr/include/c++目录下有C/C++的头文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install build-essential</div></pre></td></tr></table></figure></li>\n<li><p>拷贝/usr/include/c++/4.8里的文件到~/.vim/tags/gcc文件夹里后执行ctags命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cp -R /usr/include/c++/4.8 ~/.vim/tags/gcc</div><div class=\"line\">ctags -R --c++-kinds=+p --fields=+iaS --extra=+q gcc</div><div class=\"line\">mv tags ~/.vim/tags/gcctag</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中设置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">tags</span>+=~/.<span class=\"keyword\">vim</span>/<span class=\"keyword\">tags</span>/gcctag</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ol></li>\n<li>cscope Cscope，一个应用程序，程式员使用它来协助程式撰写及追踪程式码，主要使用于C语言程式。最早起源于贝尔实验室，运作在PDP-11上，由Joe Steffen开始发展。</li>\n</ul>\n<ol style=\"list-style-type: decimal\">\n<li><p>安装cscope工具</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install cscope</div></pre></td></tr></table></figure></li>\n<li>创建gnu c库索引\n<ol style=\"list-style-type: decimal\">\n<li>下载<a href=\"http://ftp.gnu.org/gnu/glibc/glibc-2.22.tar.xz\" target=\"_blank\" rel=\"external\">glibc</a>文件,它是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。</li>\n<li><p>解压到~/.vim/tags目录后执行cscope命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"built_in\">cd</span> ~/.vim/tags/glibc-2.22</div><div class=\"line\">cscope -Rbq</div></pre></td></tr></table></figure></li>\n<li><p>在.vimrc中设置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" cscope配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">has</span>(<span class=\"string\">\"cscope\"</span>)</div><div class=\"line\">  <span class=\"comment\">\" 设置cscope的命令位置</span></div><div class=\"line\">  <span class=\"keyword\">set</span> csprg=/usr/local/bin/<span class=\"keyword\">cscope</span></div><div class=\"line\">  <span class=\"comment\">\" 设定quickfix来显示cscope的结果</span></div><div class=\"line\">  <span class=\"keyword\">set</span> cscopequickfix=s-,<span class=\"keyword\">c</span>-,d-,i-,t-,<span class=\"keyword\">e</span>-</div><div class=\"line\">  <span class=\"comment\">\" 先搜索tags标签文件，在搜索cscope数据库</span></div><div class=\"line\">  <span class=\"keyword\">set</span> csto=<span class=\"number\">1</span></div><div class=\"line\">  <span class=\"comment\">\" 使用cstag查询，也就是同时搜索cscope数据库和tags标签文件</span></div><div class=\"line\">  <span class=\"keyword\">set</span> <span class=\"keyword\">cst</span></div><div class=\"line\">  <span class=\"comment\">\" 不显示添加数据库是否成功</span></div><div class=\"line\">  <span class=\"keyword\">set</span> nocsverb</div><div class=\"line\">  <span class=\"comment\">\"</span></div><div class=\"line\">  <span class=\"keyword\">if</span> <span class=\"built_in\">filereadable</span>(<span class=\"string\">\"cscope.out\"</span>)</div><div class=\"line\">    <span class=\"comment\">\" 添加当前目录下的cscope数据库</span></div><div class=\"line\">    <span class=\"keyword\">cs</span> <span class=\"built_in\">add</span> <span class=\"keyword\">cscope</span>.out</div><div class=\"line\">  <span class=\"keyword\">else</span></div><div class=\"line\">    <span class=\"comment\">\" 添加vim自带的cscope数据库</span></div><div class=\"line\">    <span class=\"comment\">\" gnu c 数据库</span></div><div class=\"line\">    <span class=\"keyword\">cs</span> <span class=\"built_in\">add</span> ~/.<span class=\"keyword\">vim</span>/<span class=\"keyword\">tags</span>/glibc-<span class=\"number\">2.22</span>/<span class=\"keyword\">cscope</span>.out ~/.<span class=\"keyword\">vim</span>/<span class=\"keyword\">tags</span>/glibc-<span class=\"number\">2.22</span></div><div class=\"line\">  <span class=\"keyword\">endif</span></div><div class=\"line\">  <span class=\"comment\">\" 显示添加数据库成功</span></div><div class=\"line\">  <span class=\"keyword\">set</span> csverb</div><div class=\"line\"><span class=\"keyword\">endif</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\" 映射快捷键\"</span><span class=\"symbol\">&lt;C-_&gt;</span>g的按法是先按<span class=\"string\">\"Ctrl+Shift+-\"</span>, 然后很快再按<span class=\"string\">\"g\"</span></div><div class=\"line\"><span class=\"comment\">\" 查找本 C 符号（可以跳过注释）</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span>s :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> s <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cword&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找本定义</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span>g :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> g <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cword&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找调用本函数的函数</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span><span class=\"keyword\">c</span> :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> <span class=\"keyword\">c</span> <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cword&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找本字符串</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span>t :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> t <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cword&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找本 egrep 模式</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span><span class=\"keyword\">e</span> :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> <span class=\"keyword\">e</span> <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cword&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找本文件</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span><span class=\"keyword\">f</span> :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> <span class=\"keyword\">f</span> <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cfile&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找包含本文件的文件</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span>i :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> i ^<span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cfile&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span>$<span class=\"symbol\">&lt;CR&gt;</span></div><div class=\"line\"><span class=\"comment\">\"查找本函数调用的函数</span></div><div class=\"line\"><span class=\"keyword\">nmap</span> <span class=\"symbol\">&lt;C-_&gt;</span>d :<span class=\"keyword\">cs</span> <span class=\"keyword\">find</span> d <span class=\"symbol\">&lt;C-R&gt;</span>=<span class=\"built_in\">expand</span>(<span class=\"string\">\"&lt;cword&gt;\"</span>)<span class=\"symbol\">&lt;CR&gt;</span><span class=\"symbol\">&lt;CR&gt;</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n</ol>\n<ul>\n<li>tagbar<br>\ntagbar插件是和taglist功能类似的插件，但是它比taglist更优秀，并且能和NERDTree完美配合。\n<ol style=\"list-style-type: decimal\">\n<li>tagbar的优势\n<ul>\n<li>支持头文件的函数列表显示<br>\n细心的读者可能会发现，tagbar对函数的可见级别也是做了区分的，分别用+ – # 并配合着色来做了区分</li>\n<li>对面向对象的支持更好<br>\ntaglist虽然也会列出类列表，但是整体还是很不直观</li>\n<li>自动根据文件修改时间来重建<br>\ntaglist在这一点上体验就很不好，其实明明可以通过这种时间戳的方式来实现</li>\n</ul></li>\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 替换taglist的插件[tagbar]</span></div><div class=\"line\">Plugin <span class=\"string\">'majutsushi/tagbar'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" tagbar配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 启动时自动focus</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:tagbar_autofocus</span>=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" &lt;F10&gt;打开/关闭Tagbar</span></div><div class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;silent&gt;</span> <span class=\"symbol\">&lt;F10&gt;</span> :TagbarToggle<span class=\"symbol\">&lt;CR&gt;</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li>rainbow<br>\n这个插件也是必备的，该插件的主要功能是给配对的(){}[]不同的颜色来区别，非常方便看括号的作用域\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 括号显示增强</span></div><div class=\"line\">Plugin <span class=\"string\">'luochen1990/rainbow'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" rainbow配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" rainbow激活</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:rainbow_active</span> = <span class=\"number\">1</span></div></pre></td></tr></table></figure></li>\n<li><p>给rainbow添加自动启动功能</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">exists</span>(<span class=\"string\">'g:rainbow_active'</span>) &amp;&amp; <span class=\"variable\">g:rainbow_active</span>)</div><div class=\"line\">\tauto <span class=\"keyword\">syntax</span> * <span class=\"keyword\">call</span> rainbow#hook()</div><div class=\"line\">\tauto <span class=\"keyword\">colorscheme</span> * <span class=\"keyword\">call</span> rainbow#show()</div><div class=\"line\">\t<span class=\"comment\">\" 下面这命令使rainbow在vim启动时被打开</span></div><div class=\"line\">\t<span class=\"keyword\">autocmd</span> VimEnter * nested <span class=\"keyword\">call</span> rainbow#toggle()</div><div class=\"line\"><span class=\"keyword\">endif</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li><a href=\"https://github.com/scrooloose/syntastic/blob/master/doc/syntastic.txt\" target=\"_blank\" rel=\"external\">syntastic</a><br>\n这是一个非常有用的插件，它能够实时的进行语法和编码风格的检查，利用它几乎可以做到编码完成后无编译错误。并且它还集成了静态检查工具：lint，可以让你的代码更加完美。更强大的它支持近百种编程语言，像是一个集大成的实时编译器。出现错误之后，可以非常方便的跳转到出错处。其样例如下图所示： [nerdcommenter](/assets/images/vim-syntastic.png)\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 语义高亮</span></div><div class=\"line\">Plugin <span class=\"string\">'scrooloose/syntastic'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" syntastic配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 首次打开和保存时都要进行语义检查</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_check_on_open</span> = <span class=\"number\">1</span>  </div><div class=\"line\"><span class=\"comment\">\" 设置错误提示符'x'</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_error_symbol</span> = <span class=\"string\">'x'</span>  </div><div class=\"line\"><span class=\"comment\">\" 设置警告提示符'!'</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_warning_symbol</span> = <span class=\"string\">'!'</span>  </div><div class=\"line\"><span class=\"comment\">\" 当鼠标放在错误行则显示错误信息</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_enable_balloons</span> = <span class=\"number\">1</span>  </div><div class=\"line\"><span class=\"comment\">\" 保存退出时不用进行语义检测</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_check_on_wq</span> = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">\" 编译有误则错误窗口显示，否在不显示</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_auto_loc_list</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 错误总会填充到错误窗口</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:syntastic_always_populate_loc_list</span> = <span class=\"number\">1</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li><a href=\"http://valloric.github.io/YouCompleteMe/\" target=\"_blank\" rel=\"external\">YouCompleteMe</a><br>\nYouCompleteMe对代码的补全完全达到了编译器级别，绝不弱于Visual Assist。它是基于LLVM/clang，一个Apple公司为了代替GNU/GCC而支持的编译器，正因为YouCompleteMe有了编译器的支持，而不再像以往的插件一样基于文本来进行匹配，所以准确率才如此之高。而且，它是C/S架构，会在本机创建一个服务器端，利用clang来解析代码，然后将结果返回给客户端，所以也就解决了VIM是单线程而造成的各种补全插件速度奇慢的诟病，在使用时，几乎感觉不到任何的延时，体验达到了Visual Assist的级别。<br>\nYouCompleteMe除了补全以外，还有一个非常重要的作用：代码跳转，同样可以达到编译器级别的准确度，媲美Visual Assist与Source Insight。其样例如下图所示： [nerdcommenter](/assets/images/youcompleteme.gif)\n<ol style=\"list-style-type: decimal\">\n<li><p>安装必备软件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install clang llvm cmake python python-dev</div></pre></td></tr></table></figure></li>\n<li><p>手动编译</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> ~/.vim/bundle/YouCompleteMe</div><div class=\"line\">./install.sh --clang-completer</div></pre></td></tr></table></figure></li>\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" 自动补全</span></div><div class=\"line\">Plugin <span class=\"string\">'Valloric/YouCompleteMe'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" YouCompleteMe配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 设置YCM配置文件的路径</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_global_ycm_extra_conf</span>=<span class=\"string\">'~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py'</span></div><div class=\"line\"><span class=\"comment\">\" 开启关键字语法检测</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_seed_identifiers_with_syntax</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 自动触发补全</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_auto_trigger</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" YCM触发的条件</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_semantic_triggers</span> = &#123;  </div><div class=\"line\">\\ <span class=\"string\">'c'</span> : [<span class=\"string\">'-&gt;'</span> , <span class=\"string\">'.'</span>],</div><div class=\"line\">\\ <span class=\"string\">'cpp,objcpp'</span> : [<span class=\"string\">'-&gt;'</span>,<span class=\"string\">'.'</span>,<span class=\"string\">'::'</span>],</div><div class=\"line\">\\ <span class=\"string\">'java,javascript,python,scala'</span> : [<span class=\"string\">'.'</span>],</div><div class=\"line\">\\ <span class=\"string\">'ruby'</span> : [<span class=\"string\">'.'</span>,<span class=\"string\">'::'</span>],</div><div class=\"line\">\\&#125;</div><div class=\"line\"><span class=\"comment\">\" 不用每次询问.ycm_extra_conf.py位置</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_confirm_extra_conf</span>=<span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">\" YCM也从tags文件中收集标识符</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_collect_identifiers_from_tags_files</span>=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 当输入注释的时候不用弹出提示</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_complete_in_comments</span>=<span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">\" 当输入字符的时候弹出提示</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:ycm_complete_in_strings</span>=<span class=\"number\">1</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n</ul>\n<blockquote>\n<p><strong>TIps:Tab无效</strong><br>\n如果出现安装YouCompleteMe后，虽然看到YouCompleteMe的提示框，但是无法使用 &lt; Tab &gt; 进行自动补全，只能使用上下方向键+回车来选择时，就要检查一下.vimrc是否打开了粘贴模式，即设置了set paste．该模式会屏蔽所有映射和缩写．（对于ultisnips也有同样的问题）</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/SirVer/ultisnips\" target=\"_blank\" rel=\"external\">ultisnips</a><br>\n这个插件也是必备的，该插件的主要功能是用来快速输入固定的代码块，像文件开头的版权声明，<code>#ifndef... #def... #endif</code>这样宏定义，markdown写jekyll博文的head信息．最关键的是可以按照自己的习惯<a href=\"http://mednoter.com/UltiSnips.html\" target=\"_blank\" rel=\"external\">自定义代码块</a>，这样就不用按照IDE的习惯培养自己了．其动态效果如下所示： [ultisnippets](/assets/images/ultisnippets-md.gif)\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" ultisnips</span></div><div class=\"line\">      Plugin <span class=\"string\">'SirVer/ultisnips'</span></div><div class=\"line\">      <span class=\"comment\">\" Snippets are separated from the engine</span></div><div class=\"line\">      Plugin <span class=\"string\">'honza/vim-snippets'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\">      <span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\">      <span class=\"comment\">\" ultisnips配置</span></div><div class=\"line\">      <span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\">      <span class=\"comment\">\" 如果使用了Valloric/YouCompleteMe,就别设置为&lt;tab&gt;</span></div><div class=\"line\">      <span class=\"keyword\">let</span> <span class=\"variable\">g:UltiSnipsExpandTrigger</span>=<span class=\"string\">\"&lt;c-j&gt;\"</span></div><div class=\"line\">      <span class=\"comment\">\" 前选片段</span></div><div class=\"line\">      <span class=\"keyword\">let</span> <span class=\"variable\">g:UltiSnipsJumpForwardTrigger</span>=<span class=\"string\">\"&lt;C-f&gt;\"</span></div><div class=\"line\">      <span class=\"comment\">\" 后选片段</span></div><div class=\"line\">      <span class=\"keyword\">let</span> <span class=\"variable\">g:UltiSnipsJumpBackwardTrigger</span>=<span class=\"string\">\"&lt;C-b&gt;\"</span></div><div class=\"line\">      <span class=\"comment\">\" 使用:UltiSnipsEdit打开片段定义文件时分屏位置</span></div><div class=\"line\">      <span class=\"keyword\">let</span> <span class=\"variable\">g:UltiSnipsEditSplit</span>=<span class=\"string\">\"vertical\"</span></div></pre></td></tr></table></figure></li>\n<li>自定义代码块<br>\n我们注意到安装ultisnips过程中，除了安装自身以外，还安装了honza的vim-snippets，而它的一大作用是提供了大量（目前是80个）的程序片段，像c，python，markdown，make，sh，sql等。而这些snippets都在.vim/bundle/vim-snippets/snippets文件夹中。除此之外，我们还可以自定义自己的代码块，建议是放在.vim/UltiSnippets目录下（和bundle同等级），一方面是.vim/bundle/vim-snippets/snippets下的代码块是别人的git项目。另一方面.vim/UltiSnippets下的文件可以覆盖vim-snippets里的配置，这样更符合DIY的目的。关于如何编写snippets，网上找到的资源不多，给出如下建议：\n<ul>\n<li>查看.vim/bundle/vim-snippets/snippets里的代码</li>\n<li>通过<code>:help snippets</code>查看ultisnips的帮助文档</li>\n<li><p>博文<a href=\"http://mednoter.com/UltiSnips.html\" target=\"_blank\" rel=\"external\">自定义自己的代码块</a>中的样列</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">## head Jekyll写博文时插入的头文件信息</span></div><div class=\"line\">snippet head <span class=\"string\">\"Jekyll post header\"</span> b <span class=\"comment\"># b代表begin（snippet should be expanded only at the beginning of a line ）</span></div><div class=\"line\">---</div><div class=\"line\">layout:       default</div><div class=\"line\">title:        <span class=\"variable\">$&#123;1:blog_name&#125;</span></div><div class=\"line\">category:     [<span class=\"variable\">$&#123;2:cate1,cate2&#125;</span>]</div><div class=\"line\">comments:     <span class=\"literal\">true</span></div><div class=\"line\">date:         `!v strftime(<span class=\"string\">\"%Y-%m-%d %H:%M:%S\"</span>)`</div><div class=\"line\">---</div><div class=\"line\"><span class=\"variable\">$&#123;0&#125;</span>        <span class=\"comment\"># 代表tab最终停留的位置</span></div><div class=\"line\"></div><div class=\"line\">endsnippet</div></pre></td></tr></table></figure></li>\n</ul></li>\n</ol></li>\n<li><a href=\"https://github.com/godlygeek/tabular\" target=\"_blank\" rel=\"external\">tabular</a><br>\n这是一个处女座或码农必备的插件，因为当你看到代码/文字杂乱的排版–等号，冒号，表格等不能对齐时，应该会抓狂吧。而tabular这个插件能完美的解决这个问题。就像下面的图例一样，只需要输入命令<code>:Tabularize /*</code>（*代表对齐的符号）即可：<br>\n<img src=\"https://github.com/godlygeek/tabular\" alt=\"tabular\">(/assets/images/vim-tabular.gif)\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" tab对齐</span></div><div class=\"line\">Plugin <span class=\"string\">'godlygeek/tabular'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()  </div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" tabular配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 目前还尚在摸索中</span></div></pre></td></tr></table></figure></li>\n</ol></li>\n<li><a href=\"https://github.com/plasticboy/vim-markdown\" target=\"_blank\" rel=\"external\">vim-markdown</a> vim-markdown是一款用来对原生markdown和扩展markdown语法进行语义高亮和规则匹配的插件。</li>\n</ul>\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" markdown语义高亮</span></div><div class=\"line\">Plugin <span class=\"string\">'plasticboy/vim-markdown'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()</div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" tabular配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" vim识别md</span></div><div class=\"line\"><span class=\"keyword\">autocmd</span> BufNewFile,BufReadPost *.md <span class=\"keyword\">set</span> <span class=\"keyword\">filetype</span>=markdown</div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:vimmarkdownfoldingdisabled</span>=<span class=\"number\">1</span> <span class=\"comment\">\"取消代码折叠</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:vimmarkdownnodefaultkeymappings</span>=<span class=\"number\">1</span> <span class=\"comment\">\"取消默认的键对应</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:vimmarkdownmath</span>=<span class=\"number\">1</span> <span class=\"comment\">\"使用数学符号</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:vimmarkdownfrontmatter</span>=<span class=\"number\">1</span> <span class=\"comment\">\"高亮YMAL frontmatter</span></div></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>[markdown同步预览][markdown-preview] markdown-preview是一款用来将vim打开的markdown文件翻译为html显示在浏览器里的插件，该插件的亮点在于实时更新。</li>\n</ul>\n<ol style=\"list-style-type: decimal\">\n<li><p>在vim中的安装和配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">call</span> vundle#begin(<span class=\"string\">'~/.vim/bundle/'</span>)</div><div class=\"line\"><span class=\"comment\">\" markdown同步显示</span></div><div class=\"line\">Plugin <span class=\"string\">'iamcco/mathjax-support-for-mkdp'</span></div><div class=\"line\">Plugin <span class=\"string\">'iamcco/markdown-preview.vim'</span></div><div class=\"line\"><span class=\"keyword\">call</span> vundle#end()</div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" markdown-preview.vim配置</span></div><div class=\"line\"><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span><span class=\"string\">\"\"</span></div><div class=\"line\"><span class=\"comment\">\" 设置启动chrome浏览器的命令</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:mkdp_path_to_chrome</span> = <span class=\"string\">\"open -a Google\\\\ Chrome\"</span></div><div class=\"line\"><span class=\"comment\">\" 设置为1则打开markdown文件时自动打开浏览器</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:mkdp_auto_start</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 设置为1则在编辑markdown的时候预览窗口是否打开，未开则自动打开</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:mkdp_auto_open</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 切换buffer时自动关闭预览窗口，设置为0则在切换buffer时不自动关闭</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:mkdp_auto_close</span> = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">\" 设置为1则只有在保存文件或退出插入模式时更新预览，默认为0，实时更新预览</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:mkdp_refresh_slow</span> = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"comment\">\" 设置为1则所有文件都使用MarkdownPreview进行预览，默认只有markdown文件可以</span></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">g:mkdp_command_for_global</span> = <span class=\"number\">0</span></div></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/mattn/emmet-vim\" target=\"_blank\" rel=\"external\">emmet-vim</a><br>\nEmmet的前身就叫做Zen Coding，它是个前端插件。官方支持很多软件，像Sublime Text、Notepad++、Dreamweaver、Eclipse、Adobe Brackets等，而Emmet.vim并非Emmet亲生，而是由日本Yasuhiro Matsumoto开发。对于前段开发者而言它是一件神器，能够节省大量的重复coding劳动。鉴于前端开发的少，这里只是mark一下。</li>\n</ul>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://vim-adventures.com/\" target=\"_blank\" rel=\"external\">有趣的vim游戏</a></li>\n<li><a href=\"http://www.oschina.net/translate/learn-vim-progressively\" target=\"_blank\" rel=\"external\">Vim学习指南</a></li>\n<li><a href=\"http://my.oschina.net/swuly302/blog/156784\" target=\"_blank\" rel=\"external\">vim plugin</a></li>\n<li><a href=\"http://vim-scripts.org/vim/scripts.html\" target=\"_blank\" rel=\"external\">Vim Script</a></li>\n<li><a href=\"http://www.it165.net/pro/html/201404/11505.html\" target=\"_blank\" rel=\"external\">Vim配置及说明——IDE编程环境</a></li>\n<li><a href=\"http://my.oschina.net/swuly302/blog/156784\" target=\"_blank\" rel=\"external\">高效vim插件</a></li>\n<li><a href=\"http://overapi.com/vim/\" target=\"_blank\" rel=\"external\">VIM助记图</a></li>\n<li><a href=\"http://www.vimer.cn/\" target=\"_blank\" rel=\"external\">Vimer的程序世界</a></li>\n<li><a href=\"https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb\" target=\"_blank\" rel=\"external\">vimium</a></li>\n<li><a href=\"http://valloric.github.io/YouCompleteMe/\" target=\"_blank\" rel=\"external\">youcompleteme</a></li>\n<li><a href=\"https://github.com/scrooloose/syntastic/blob/master/doc/syntastic.txt\" target=\"_blank\" rel=\"external\">syntastic</a></li>\n<li><a href=\"http://3502990.blog.51cto.com/3492990/985750\" target=\"_blank\" rel=\"external\">python IDE</a></li>\n<li><a href=\"https://github.com/SirVer/ultisnips\" target=\"_blank\" rel=\"external\">ultisnips</a></li>\n<li><a href=\"http://mednoter.com/UltiSnips.html\" target=\"_blank\" rel=\"external\">自定义自己的代码块</a></li>\n<li><a href=\"https://github.com/mattn/emmet-vim\" target=\"_blank\" rel=\"external\">前端开发神器Emmet</a></li>\n<li><a href=\"https://www.zfanw.com/blog/zencoding-vim-tutorial-chinese.html\" target=\"_blank\" rel=\"external\">Emmet教程</a></li>\n<li><a href=\"https://github.com/godlygeek/tabular\" target=\"_blank\" rel=\"external\">对齐神器-tabular</a></li>\n<li><a href=\"https://github.com/plasticboy/vim-markdown\" target=\"_blank\" rel=\"external\">vim-markdown</a></li>\n</ol>"},{"layout":"post","title":"ML之线性回归","comments":1,"_content":"线性回归[Line Regression]估计是我们接触最早的机器学习的算法了，差不过在高中的时候我们就会做一类题：就是给定xy坐标上的一些点（一般是线性的），然后用$y=ax+b$进行拟合，最后求出一个$(a,b)$以及y的预测值$\\hat{y}$。其中$y=ax+b$在ML中叫模型，$(a,b)$叫模型参数（回归系数），或者特征x的权重，而y就是结果或标签，求解模型的方法叫最小二乘法[Ordinary Least Square Estimation]。本文将结合sklearning详细介绍一下线性回归方法。\n<!-- more -->\n\n## 概念理解\n线性归是统计学里方法，“回归”一词的由来见下面的Tips。在统计学中，[线性回归][wiki_line_regression]是确定因变量$y$和一个或多个自变量$X$之间线性关系的统计分析方法。当自变量只有一个时叫简单线性回归，当自变量有多个时叫多维/多元线性回归（与多变量线性回归的区别见QA1）。\n\n> **Tips:回归的由来**  \n> 回归的方法是由达尔文的表兄弟Francis Galton发明的。Galton于这年完成了第一次回归预测，目的是根据上一代豌豆种子（双亲）的尺寸来预测下一代豌豆种子（孩子）的尺寸。他注意到如果双亲的高度比平均高度高，它们的子女也倾向于比平均高度高，但尚不及双亲。孩子的高度向着平均高度回退（回归）。Galton在多项研究上都注意到这个现象，所以尽管这个英文单词跟数值预测没有任何关系，但这种研究方法仍被称为回归。\n\n\n### 回归vs分类\n谈及回归，不可避免的谈到分类，这两个概念很相似，只不过分类的结果是1,2,3这样的离散型，而回归的结果却是连续型。二者都可以用来预测。\n\n## 问题描述\n给定一个随机样本集$(Y,X)$，$Y = [y_1, \\cdots, y_n]^T$，$X = [X_1, \\cdots, X_n]^T$，$X_i=[1, x_{i1}, \\cdots, x_{id}]$，其中ｎ是样本集的个数，ｄ是样本的维度．线性回归模型就是寻找这样的回归系数$W=[w_0, w_1, \\cdots, w_d]^T$，使得代价函数$J(W)$尽可能的小．一般将平方误差作为代价，此时\n$$\nJ(W)  =  (Y-XW)^T \\* (Y-XW)\n      =  \\sum_{i=1}^n (y_i - X_i*W)\n$$\n\n这里求代价函数$J(W)$最小值，可以通过对$W$求导，得到$X^T*(Y-XW)$，令其等于0，解出$W$如下：\n$$\nW=(X^T X)^{-1} X^T Y\n$$\n其具体的推导过程见下面的附录－多元线性回归的推导过程．\n\n> **Tips:**  \n> 上述公式中包含$(X^T X)^{-1}$，也就是说要对矩阵求逆，所以这个方程只在逆矩阵存在的时候适用的。因此必须要在代码中对此作出判断。\n>\n\n\n\n\n## kdfjs\n\n\n## 问题&回答\n1. Q：多维线性回归和多变量线性回归的区别  \nA：该回答参考[这篇英文博文][multiple_vs_multivariate]。  \n    * 差异性  \n    该问题和线性没有关系。多维回归是指回归模型拥有一个因变量和多个自变量，而多变量回归是指回归模型拥有多个因变量和多个自变量。二者的区别是在于因变量的个数。\n    * 联系  \n    多变量回归可以由多个多维回归模型构成。\n    * 举例说明  \n    多变量回归一般用于解决系数的混合检验问题。比如，你想要知道SAT的各项分数对第一学年和第二学年有什么样的影响。一种方法是运行两个简单回归模型，并且查看系数是否相似;另一种方法是运行一个多变量回归模型，而且这种方式是正规的概率检验方式。虽然系数是一样的，但是后续你可以计算它们的相似度和其他属性等。\n\n## 参考文献\n1. [线性回归wiki][wiki_line_regression]\n2. [多维线性回归vs多变量线性回归][multiple_vs_multivariate]\n1. [机器学习实战][meachine_learning_70]\n\n[wiki_line_regression]:  https://en.wikipedia.org/wiki/Linear_regression\n[multiple_vs_multivariate]:  http://www.answers.com/Q/What_is_difference_between_multivariate_regression_and_multipal_regression\n[meachine_learning_70]:  http://share.weiyun.com/f33d5770eba223764845beddf0d6bc09\n\n\n## 附录\n### 多元线性回归的推导过程\n","source":"_posts/2015-10-19-ML之线性回归.md","raw":"---\nlayout:\t\tpost\ntitle:\t\tML之线性回归\ncategories:\n- TECHNOLOGY\ntags:\n- ML\n- Algorithm\npermalink:  Explore-LR-ML\ncomments:\ttrue\n---\n线性回归[Line Regression]估计是我们接触最早的机器学习的算法了，差不过在高中的时候我们就会做一类题：就是给定xy坐标上的一些点（一般是线性的），然后用$y=ax+b$进行拟合，最后求出一个$(a,b)$以及y的预测值$\\hat{y}$。其中$y=ax+b$在ML中叫模型，$(a,b)$叫模型参数（回归系数），或者特征x的权重，而y就是结果或标签，求解模型的方法叫最小二乘法[Ordinary Least Square Estimation]。本文将结合sklearning详细介绍一下线性回归方法。\n<!-- more -->\n\n## 概念理解\n线性归是统计学里方法，“回归”一词的由来见下面的Tips。在统计学中，[线性回归][wiki_line_regression]是确定因变量$y$和一个或多个自变量$X$之间线性关系的统计分析方法。当自变量只有一个时叫简单线性回归，当自变量有多个时叫多维/多元线性回归（与多变量线性回归的区别见QA1）。\n\n> **Tips:回归的由来**  \n> 回归的方法是由达尔文的表兄弟Francis Galton发明的。Galton于这年完成了第一次回归预测，目的是根据上一代豌豆种子（双亲）的尺寸来预测下一代豌豆种子（孩子）的尺寸。他注意到如果双亲的高度比平均高度高，它们的子女也倾向于比平均高度高，但尚不及双亲。孩子的高度向着平均高度回退（回归）。Galton在多项研究上都注意到这个现象，所以尽管这个英文单词跟数值预测没有任何关系，但这种研究方法仍被称为回归。\n\n\n### 回归vs分类\n谈及回归，不可避免的谈到分类，这两个概念很相似，只不过分类的结果是1,2,3这样的离散型，而回归的结果却是连续型。二者都可以用来预测。\n\n## 问题描述\n给定一个随机样本集$(Y,X)$，$Y = [y_1, \\cdots, y_n]^T$，$X = [X_1, \\cdots, X_n]^T$，$X_i=[1, x_{i1}, \\cdots, x_{id}]$，其中ｎ是样本集的个数，ｄ是样本的维度．线性回归模型就是寻找这样的回归系数$W=[w_0, w_1, \\cdots, w_d]^T$，使得代价函数$J(W)$尽可能的小．一般将平方误差作为代价，此时\n$$\nJ(W)  =  (Y-XW)^T \\* (Y-XW)\n      =  \\sum_{i=1}^n (y_i - X_i*W)\n$$\n\n这里求代价函数$J(W)$最小值，可以通过对$W$求导，得到$X^T*(Y-XW)$，令其等于0，解出$W$如下：\n$$\nW=(X^T X)^{-1} X^T Y\n$$\n其具体的推导过程见下面的附录－多元线性回归的推导过程．\n\n> **Tips:**  \n> 上述公式中包含$(X^T X)^{-1}$，也就是说要对矩阵求逆，所以这个方程只在逆矩阵存在的时候适用的。因此必须要在代码中对此作出判断。\n>\n\n\n\n\n## kdfjs\n\n\n## 问题&回答\n1. Q：多维线性回归和多变量线性回归的区别  \nA：该回答参考[这篇英文博文][multiple_vs_multivariate]。  \n    * 差异性  \n    该问题和线性没有关系。多维回归是指回归模型拥有一个因变量和多个自变量，而多变量回归是指回归模型拥有多个因变量和多个自变量。二者的区别是在于因变量的个数。\n    * 联系  \n    多变量回归可以由多个多维回归模型构成。\n    * 举例说明  \n    多变量回归一般用于解决系数的混合检验问题。比如，你想要知道SAT的各项分数对第一学年和第二学年有什么样的影响。一种方法是运行两个简单回归模型，并且查看系数是否相似;另一种方法是运行一个多变量回归模型，而且这种方式是正规的概率检验方式。虽然系数是一样的，但是后续你可以计算它们的相似度和其他属性等。\n\n## 参考文献\n1. [线性回归wiki][wiki_line_regression]\n2. [多维线性回归vs多变量线性回归][multiple_vs_multivariate]\n1. [机器学习实战][meachine_learning_70]\n\n[wiki_line_regression]:  https://en.wikipedia.org/wiki/Linear_regression\n[multiple_vs_multivariate]:  http://www.answers.com/Q/What_is_difference_between_multivariate_regression_and_multipal_regression\n[meachine_learning_70]:  http://share.weiyun.com/f33d5770eba223764845beddf0d6bc09\n\n\n## 附录\n### 多元线性回归的推导过程\n","slug":"Explore-LR-ML","published":1,"date":"2015-10-18T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1m001ql73y6g8d1jvx","content":"<p>线性回归[Line Regression]估计是我们接触最早的机器学习的算法了，差不过在高中的时候我们就会做一类题：就是给定xy坐标上的一些点（一般是线性的），然后用<span class=\"math inline\">\\(y=ax+b\\)</span>进行拟合，最后求出一个<span class=\"math inline\">\\((a,b)\\)</span>以及y的预测值<span class=\"math inline\">\\(\\hat{y}\\)</span>。其中<span class=\"math inline\">\\(y=ax+b\\)</span>在ML中叫模型，<span class=\"math inline\">\\((a,b)\\)</span>叫模型参数（回归系数），或者特征x的权重，而y就是结果或标签，求解模型的方法叫最小二乘法[Ordinary Least Square Estimation]。本文将结合sklearning详细介绍一下线性回归方法。 <a id=\"more\"></a></p>\n<h2 id=\"概念理解\">概念理解</h2>\n<p>线性归是统计学里方法，“回归”一词的由来见下面的Tips。在统计学中，<a href=\"https://en.wikipedia.org/wiki/Linear_regression\" target=\"_blank\" rel=\"external\">线性回归</a>是确定因变量<span class=\"math inline\">\\(y\\)</span>和一个或多个自变量<span class=\"math inline\">\\(X\\)</span>之间线性关系的统计分析方法。当自变量只有一个时叫简单线性回归，当自变量有多个时叫多维/多元线性回归（与多变量线性回归的区别见QA1）。</p>\n<blockquote>\n<p><strong>Tips:回归的由来</strong><br>\n回归的方法是由达尔文的表兄弟Francis Galton发明的。Galton于这年完成了第一次回归预测，目的是根据上一代豌豆种子（双亲）的尺寸来预测下一代豌豆种子（孩子）的尺寸。他注意到如果双亲的高度比平均高度高，它们的子女也倾向于比平均高度高，但尚不及双亲。孩子的高度向着平均高度回退（回归）。Galton在多项研究上都注意到这个现象，所以尽管这个英文单词跟数值预测没有任何关系，但这种研究方法仍被称为回归。</p>\n</blockquote>\n<h3 id=\"回归vs分类\">回归vs分类</h3>\n<p>谈及回归，不可避免的谈到分类，这两个概念很相似，只不过分类的结果是1,2,3这样的离散型，而回归的结果却是连续型。二者都可以用来预测。</p>\n<h2 id=\"问题描述\">问题描述</h2>\n<p>给定一个随机样本集<span class=\"math inline\">\\((Y,X)\\)</span>，<span class=\"math inline\">\\(Y = [y_1, \\cdots, y_n]^T\\)</span>，<span class=\"math inline\">\\(X = [X_1, \\cdots, X_n]^T\\)</span>，<span class=\"math inline\">\\(X_i=[1, x_{i1}, \\cdots, x_{id}]\\)</span>，其中ｎ是样本集的个数，ｄ是样本的维度．线性回归模型就是寻找这样的回归系数<span class=\"math inline\">\\(W=[w_0, w_1, \\cdots, w_d]^T\\)</span>，使得代价函数<span class=\"math inline\">\\(J(W)\\)</span>尽可能的小．一般将平方误差作为代价，此时 <span class=\"math display\">\\[\nJ(W)  =  (Y-XW)^T \\* (Y-XW)\n      =  \\sum_{i=1}^n (y_i - X_i*W)\n\\]</span></p>\n<p>这里求代价函数<span class=\"math inline\">\\(J(W)\\)</span>最小值，可以通过对<span class=\"math inline\">\\(W\\)</span>求导，得到<span class=\"math inline\">\\(X^T*(Y-XW)\\)</span>，令其等于0，解出<span class=\"math inline\">\\(W\\)</span>如下： <span class=\"math display\">\\[\nW=(X^T X)^{-1} X^T Y\n\\]</span> 其具体的推导过程见下面的附录－多元线性回归的推导过程．</p>\n<blockquote>\n<p><strong>Tips:</strong><br>\n上述公式中包含<span class=\"math inline\">\\((X^T X)^{-1}\\)</span>，也就是说要对矩阵求逆，所以这个方程只在逆矩阵存在的时候适用的。因此必须要在代码中对此作出判断。</p>\n</blockquote>\n<h2 id=\"kdfjs\">kdfjs</h2>\n<h2 id=\"问题回答\">问题&amp;回答</h2>\n<ol style=\"list-style-type: decimal\">\n<li>Q：多维线性回归和多变量线性回归的区别<br>\nA：该回答参考<a href=\"http://www.answers.com/Q/What_is_difference_between_multivariate_regression_and_multipal_regression\" target=\"_blank\" rel=\"external\">这篇英文博文</a>。\n<ul>\n<li>差异性<br>\n该问题和线性没有关系。多维回归是指回归模型拥有一个因变量和多个自变量，而多变量回归是指回归模型拥有多个因变量和多个自变量。二者的区别是在于因变量的个数。</li>\n<li>联系<br>\n多变量回归可以由多个多维回归模型构成。</li>\n<li>举例说明<br>\n多变量回归一般用于解决系数的混合检验问题。比如，你想要知道SAT的各项分数对第一学年和第二学年有什么样的影响。一种方法是运行两个简单回归模型，并且查看系数是否相似;另一种方法是运行一个多变量回归模型，而且这种方式是正规的概率检验方式。虽然系数是一样的，但是后续你可以计算它们的相似度和其他属性等。</li>\n</ul></li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://en.wikipedia.org/wiki/Linear_regression\" target=\"_blank\" rel=\"external\">线性回归wiki</a></li>\n<li><a href=\"http://www.answers.com/Q/What_is_difference_between_multivariate_regression_and_multipal_regression\" target=\"_blank\" rel=\"external\">多维线性回归vs多变量线性回归</a></li>\n<li><a href=\"http://share.weiyun.com/f33d5770eba223764845beddf0d6bc09\" target=\"_blank\" rel=\"external\">机器学习实战</a></li>\n</ol>\n<h2 id=\"附录\">附录</h2>\n<h3 id=\"多元线性回归的推导过程\">多元线性回归的推导过程</h3>\n","site":{"data":{}},"excerpt":"<p>线性回归[Line Regression]估计是我们接触最早的机器学习的算法了，差不过在高中的时候我们就会做一类题：就是给定xy坐标上的一些点（一般是线性的），然后用<span class=\"math inline\">\\(y=ax+b\\)</span>进行拟合，最后求出一个<span class=\"math inline\">\\((a,b)\\)</span>以及y的预测值<span class=\"math inline\">\\(\\hat{y}\\)</span>。其中<span class=\"math inline\">\\(y=ax+b\\)</span>在ML中叫模型，<span class=\"math inline\">\\((a,b)\\)</span>叫模型参数（回归系数），或者特征x的权重，而y就是结果或标签，求解模型的方法叫最小二乘法[Ordinary Least Square Estimation]。本文将结合sklearning详细介绍一下线性回归方法。","more":"</p>\n<h2 id=\"概念理解\">概念理解</h2>\n<p>线性归是统计学里方法，“回归”一词的由来见下面的Tips。在统计学中，<a href=\"https://en.wikipedia.org/wiki/Linear_regression\" target=\"_blank\" rel=\"external\">线性回归</a>是确定因变量<span class=\"math inline\">\\(y\\)</span>和一个或多个自变量<span class=\"math inline\">\\(X\\)</span>之间线性关系的统计分析方法。当自变量只有一个时叫简单线性回归，当自变量有多个时叫多维/多元线性回归（与多变量线性回归的区别见QA1）。</p>\n<blockquote>\n<p><strong>Tips:回归的由来</strong><br>\n回归的方法是由达尔文的表兄弟Francis Galton发明的。Galton于这年完成了第一次回归预测，目的是根据上一代豌豆种子（双亲）的尺寸来预测下一代豌豆种子（孩子）的尺寸。他注意到如果双亲的高度比平均高度高，它们的子女也倾向于比平均高度高，但尚不及双亲。孩子的高度向着平均高度回退（回归）。Galton在多项研究上都注意到这个现象，所以尽管这个英文单词跟数值预测没有任何关系，但这种研究方法仍被称为回归。</p>\n</blockquote>\n<h3 id=\"回归vs分类\">回归vs分类</h3>\n<p>谈及回归，不可避免的谈到分类，这两个概念很相似，只不过分类的结果是1,2,3这样的离散型，而回归的结果却是连续型。二者都可以用来预测。</p>\n<h2 id=\"问题描述\">问题描述</h2>\n<p>给定一个随机样本集<span class=\"math inline\">\\((Y,X)\\)</span>，<span class=\"math inline\">\\(Y = [y_1, \\cdots, y_n]^T\\)</span>，<span class=\"math inline\">\\(X = [X_1, \\cdots, X_n]^T\\)</span>，<span class=\"math inline\">\\(X_i=[1, x_{i1}, \\cdots, x_{id}]\\)</span>，其中ｎ是样本集的个数，ｄ是样本的维度．线性回归模型就是寻找这样的回归系数<span class=\"math inline\">\\(W=[w_0, w_1, \\cdots, w_d]^T\\)</span>，使得代价函数<span class=\"math inline\">\\(J(W)\\)</span>尽可能的小．一般将平方误差作为代价，此时 <span class=\"math display\">\\[\nJ(W)  =  (Y-XW)^T \\* (Y-XW)\n      =  \\sum_{i=1}^n (y_i - X_i*W)\n\\]</span></p>\n<p>这里求代价函数<span class=\"math inline\">\\(J(W)\\)</span>最小值，可以通过对<span class=\"math inline\">\\(W\\)</span>求导，得到<span class=\"math inline\">\\(X^T*(Y-XW)\\)</span>，令其等于0，解出<span class=\"math inline\">\\(W\\)</span>如下： <span class=\"math display\">\\[\nW=(X^T X)^{-1} X^T Y\n\\]</span> 其具体的推导过程见下面的附录－多元线性回归的推导过程．</p>\n<blockquote>\n<p><strong>Tips:</strong><br>\n上述公式中包含<span class=\"math inline\">\\((X^T X)^{-1}\\)</span>，也就是说要对矩阵求逆，所以这个方程只在逆矩阵存在的时候适用的。因此必须要在代码中对此作出判断。</p>\n</blockquote>\n<h2 id=\"kdfjs\">kdfjs</h2>\n<h2 id=\"问题回答\">问题&amp;回答</h2>\n<ol style=\"list-style-type: decimal\">\n<li>Q：多维线性回归和多变量线性回归的区别<br>\nA：该回答参考<a href=\"http://www.answers.com/Q/What_is_difference_between_multivariate_regression_and_multipal_regression\" target=\"_blank\" rel=\"external\">这篇英文博文</a>。\n<ul>\n<li>差异性<br>\n该问题和线性没有关系。多维回归是指回归模型拥有一个因变量和多个自变量，而多变量回归是指回归模型拥有多个因变量和多个自变量。二者的区别是在于因变量的个数。</li>\n<li>联系<br>\n多变量回归可以由多个多维回归模型构成。</li>\n<li>举例说明<br>\n多变量回归一般用于解决系数的混合检验问题。比如，你想要知道SAT的各项分数对第一学年和第二学年有什么样的影响。一种方法是运行两个简单回归模型，并且查看系数是否相似;另一种方法是运行一个多变量回归模型，而且这种方式是正规的概率检验方式。虽然系数是一样的，但是后续你可以计算它们的相似度和其他属性等。</li>\n</ul></li>\n</ol>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://en.wikipedia.org/wiki/Linear_regression\" target=\"_blank\" rel=\"external\">线性回归wiki</a></li>\n<li><a href=\"http://www.answers.com/Q/What_is_difference_between_multivariate_regression_and_multipal_regression\" target=\"_blank\" rel=\"external\">多维线性回归vs多变量线性回归</a></li>\n<li><a href=\"http://share.weiyun.com/f33d5770eba223764845beddf0d6bc09\" target=\"_blank\" rel=\"external\">机器学习实战</a></li>\n</ol>\n<h2 id=\"附录\">附录</h2>\n<h3 id=\"多元线性回归的推导过程\">多元线性回归的推导过程</h3>"},{"layout":"post","title":"C语言编程之指针","category":["C","Coding"],"comments":1,"_content":"c语言之所以强大，以及其自由性，很大部分体现在其灵活的指针运用上。因此，说指针是c语言的灵魂，一点都不为过。同时，这种说法也让很多人产生误解，似乎只有C语言的指针才能算指针。basic不支持指针，在此不论。其实，pascal语言本身也是支持指针的。从最初的pascal发展至今的object pascal，可以说在指针运用上，丝毫不会逊色于c语言的指针。还有Java语言，虽然任何教程都没有提及指针，但是在我看来任何类对象（基本数据类型不确定）的创建都使用了指针。所以对指针的理解决定了你对编程语言的理解。\n<!-- more -->\n\n\n## 指针基础\n[指针][baike_pointer]（Pointer）是编程语言中的一个对象，它的值直接指向（points to）存在电脑存储器中另一个地方的值。这里先介绍一下变量的三要素：变量名，存储地址和存储内容。在下图的内存分配表中，**存储变量(b)的地址(1008)**称为指向变量(b)的指针，意思是通过它(1008)能找到以它为地址的内存单元(b)。而**存储这个指针(1008)的变量(a)**叫做指针变量，又因为这个指针是指向b变量的，所以又叫它为指向变量b的指针变量。  \n![pointer]({{site.baseurl}}/assets/images/pointers.png)  \n\n对于指针变量，我们只要抓在两点就可以了，第一个是它指向的地址是多少，第二是它的基类型是啥。对于指针的基类型，在指针的定义中或者malloc/new申请内存时很容易获得。指向基本数据类型指针的基类型就是基本数据类型，而数组指针基类型的识别有点难，但其实只要抓住一点就能解决了，即去掉定义中的一个*和变量名，剩下的就是指针的基类型。\n\n```c++\n    int *a;     // 基类型为int，它是管辖范围是一个变量\n    int **b;  // 基类型为int *，它是管辖范围是一个一维数组\n    b = (int **)row*sizeof(int*);   // b的类型是int **，其基类型为int*，管辖范围包含row个int*变量的一维数组[C]\n    b = new int*[row];      // b的类型是int **，其基类型为int*，管辖范围是包含row个int*变量的一维数组[C++]\n```\n\n\n## 操作符&*\n操作符&叫取址操作符，其后面常跟变量，用来获取变量的地址的操作符。\n\n操作符\\*叫取值操作符，其后面常跟地址，用来获取地址所定位内存空间里的值。如\\*point 是point所指向的存储单元的内容，而对于这个内容的理解有两种，一个是变量本身，另一个是具体的存储内容，特别声明这里的内容是变量本身。换句话说就是存储内容的变化也会导致\\*point值的变化。对于指针还有另外一点，就是指针的增加point+i，这里指针实际移动的距离是i\\*sizeof(指针的基类型)。下面来说一下这个经典案例\\*point++，该操作首先考虑优先级，因为这三个操作符都是一元同级操作符，所以按照从右往左的顺序操作。即\\*point++等价于\\*(point++)。\n\n\n这两个操作是一个对立的操作。一个是通过地址获取变量值，另一个是通过变量名获取地址。下面从管辖范围的角度来理解这两个操作。这个管辖范围是对指针基类型在内存上的解读，更物理测量里面的精确度概念类似。其层级为高维数组>一维数组>单个基本数据类型。\n\n* \\&E 相当于把E的管辖范围上升了一个级别\n* \\*E 相当于把E的管辖范围下降了一个级别\n* 数组名相当于指向数组第一个元素的指针，但是其管辖范围根据基类型来定。\n\n样例代码如下所示：\n\n```c\n    int a[4]={1,2,3,4};\n    printf(\"%p\\n\",a);       //x\n    printf(\"%p\\n\",a+1);     //x+4\n    printf(\"%p\\n\",&a);      //x\n    printf(\"%p\\n\",&a+1);    //x+16\n    printf(\"%p\\n\",*(&a));   //x\n    printf(\"%p\\n\",*(&a)+1); //x+4\n    printf(\"\\n\");\n\n    int b[2][3]={1,2,3},{4,5,6};    //这里由于jekyll问题，无法在两个一维数组外面添加{}\n    printf(\"%p\\n\",b);       //x\n    printf(\"%p\\n\",b+1);     //x+12\n    printf(\"%p\\n\",&b);      //x\n    printf(\"%p\\n\",&b+1);    //x+24\n    printf(\"%p\\n\",*(&b));   //x\n    printf(\"%p\\n\",*(&b)+1); //x+12\n    printf(\"%p\\n\",b[0]);    //x\n    printf(\"%p\\n\",b[0]+1);  //x+4\n    printf(\"%p\\n\",&b[0]);   //x\n    printf(\"%p\\n\",&b[0]+1); //x+12\n    printf(\"%p\\n\",*(&b[0]));    //x\n    printf(\"%p\\n\",*(&b[0])+1);  //x+4\n```\n代码中的一维数组a和二维数组b在内存中的表示情况如下图所示，其中红色的弧/圈表示指针的管辖范围（精确度）。\n![pointer]({{site.baseurl}}/assets/images/pointer_array.png)  \n\n## 数组和指针\n通常在函数调用中，我们会将数组名当作参数传递给函数，而函数中定义形参却通常定义为常量指针（const int* arr）。对于这二者还是有很多相识点的。\n\n* 最重要的点：==数组名代表的就是数组首元素的地址==。\n* 数组名这样的操作(arr++)是不对的,而p却可以（p=arr，p++），因为arr是常量类型。\n* 数组中的移位记住这样一个等式 \\*(point+i )= point[i]\n\n这里稍微提一下二维数组的定义。比如\n\n```c\n    int arr[2][3]={1,2,3,4,5,6};\n    int (*p)[3]=arr;\n```\n这里的二维数组指针p是代表包含3个int型元素的一维数组。\n\n## 指针和字符串\n指针和字符串的区别与指针和数组的区别很类似。因为C语言中没有字符型变量，只能用字符数组来存储，唯一的区别是字符串必须以'\\0'结尾。不过在面试的时候经常会问这样的一个问题：下面两种定义有什么区别。\n\n```c\n    char p[10]=\"hello\";\n    char *cp=\"hello\";\n```\n对于这个问题，我们得了解这个定义，首先p是字符数组，虽然长度为5,但p[5]一定为'\\0';而cp是这字符指针，是个**常量指针**，二者存储/指向的内容都为\"hello\"字符串。最关键的一点是两者在内存中存储区不一样。字符数组p是存储在栈区，而常量指针本身也是存储在栈区，但是它指向的字符串\"hello\"是存储在一个专门放常量的地方，在程序结束后释放。关于程序存储区的详细讨论将在另一片博文[程序中的存储区][memory]中讨论。\n\n\n## 常量&指针\n常量比较常用来保护实参，限制形参，保证实参在被调函数中的不可改变的特性（const int \\*）。还有另外一个类似宏定义的功能，又因为常量会被存放在常量区，所以可以节省空间（const int max=100）。不过常量指针（const int \\*arr）和指针常量（int \\*const p）是两个非常容易混的概念，这里做一些总结吧。\n\n对于二者的区分，只要记住三句话\n\n1. \\*（指针）和const（常量）谁在前先读谁\n2. \\*（指针）象征着地址，而const（常量）象征着内容\n3. 谁在前面谁就不允许改变。\n\n常量指针（const int \\*p）是指向常量的指针，所以指向的内容是不能改变的，但是这个指针可以指向其他常量。指针常量（int \\*const p）是指向变量的地址为常量，而指向的内容可以改变，所以**指针常量在声明的时候一定要初始化，不能被再赋值，指向别的地址**。\n\n结合最开始的那幅指针图片来说，对于两个变量a和b，其中b是正常的变量，a是指针变量。如果a是常量（就是1008值不能改变），则a是指针常量;如果指向的b是常量（就是地址为1008里的内容不能改变），则a是常量指针。\n\n## 参考文献\n1. [wiki指针][wiki_pointer]\n2. [baike][baike_pointer]\n3. [程序如何使用内存区][c_mem]\n4. [程序中的存储区][memory]\n5. [常量指针和指针常量的区别详解][const_point]\n[wiki_pointer]: https://en.wikipedia.org/wiki/Pointer_(computer_programming)\n[baike_pointer]:    http://baike.baidu.com/link?url=_XybsUjdWr-YTN7SUA8q92EpiskSmO4EvROZLZmJbGals1NhK2sHZSRrsW80vuS-2hcie9Qk5IfP42sXOoC0h_\n[c_mem]:    http://www.cnblogs.com/JCSU/articles/1051579.html\n[memory]:   {{site.baseurl}}/2015/11/22/程序中的存储区.html\n[const_point]: http://blog.csdn.net/beyond0525/article/details/7409305\n","source":"_posts/2015-10-26-C语言编程之指针.md","raw":"---\nlayout:\tpost\ntitle:\tC语言编程之指针\ncategories:\n- TECHNOLOGY\ntags:\n- C\n- Coding\npermalink:  Review-pointer-C\ncategory:\t[C,Coding]\ncomments:\ttrue\n---\nc语言之所以强大，以及其自由性，很大部分体现在其灵活的指针运用上。因此，说指针是c语言的灵魂，一点都不为过。同时，这种说法也让很多人产生误解，似乎只有C语言的指针才能算指针。basic不支持指针，在此不论。其实，pascal语言本身也是支持指针的。从最初的pascal发展至今的object pascal，可以说在指针运用上，丝毫不会逊色于c语言的指针。还有Java语言，虽然任何教程都没有提及指针，但是在我看来任何类对象（基本数据类型不确定）的创建都使用了指针。所以对指针的理解决定了你对编程语言的理解。\n<!-- more -->\n\n\n## 指针基础\n[指针][baike_pointer]（Pointer）是编程语言中的一个对象，它的值直接指向（points to）存在电脑存储器中另一个地方的值。这里先介绍一下变量的三要素：变量名，存储地址和存储内容。在下图的内存分配表中，**存储变量(b)的地址(1008)**称为指向变量(b)的指针，意思是通过它(1008)能找到以它为地址的内存单元(b)。而**存储这个指针(1008)的变量(a)**叫做指针变量，又因为这个指针是指向b变量的，所以又叫它为指向变量b的指针变量。  \n![pointer]({{site.baseurl}}/assets/images/pointers.png)  \n\n对于指针变量，我们只要抓在两点就可以了，第一个是它指向的地址是多少，第二是它的基类型是啥。对于指针的基类型，在指针的定义中或者malloc/new申请内存时很容易获得。指向基本数据类型指针的基类型就是基本数据类型，而数组指针基类型的识别有点难，但其实只要抓住一点就能解决了，即去掉定义中的一个*和变量名，剩下的就是指针的基类型。\n\n```c++\n    int *a;     // 基类型为int，它是管辖范围是一个变量\n    int **b;  // 基类型为int *，它是管辖范围是一个一维数组\n    b = (int **)row*sizeof(int*);   // b的类型是int **，其基类型为int*，管辖范围包含row个int*变量的一维数组[C]\n    b = new int*[row];      // b的类型是int **，其基类型为int*，管辖范围是包含row个int*变量的一维数组[C++]\n```\n\n\n## 操作符&*\n操作符&叫取址操作符，其后面常跟变量，用来获取变量的地址的操作符。\n\n操作符\\*叫取值操作符，其后面常跟地址，用来获取地址所定位内存空间里的值。如\\*point 是point所指向的存储单元的内容，而对于这个内容的理解有两种，一个是变量本身，另一个是具体的存储内容，特别声明这里的内容是变量本身。换句话说就是存储内容的变化也会导致\\*point值的变化。对于指针还有另外一点，就是指针的增加point+i，这里指针实际移动的距离是i\\*sizeof(指针的基类型)。下面来说一下这个经典案例\\*point++，该操作首先考虑优先级，因为这三个操作符都是一元同级操作符，所以按照从右往左的顺序操作。即\\*point++等价于\\*(point++)。\n\n\n这两个操作是一个对立的操作。一个是通过地址获取变量值，另一个是通过变量名获取地址。下面从管辖范围的角度来理解这两个操作。这个管辖范围是对指针基类型在内存上的解读，更物理测量里面的精确度概念类似。其层级为高维数组>一维数组>单个基本数据类型。\n\n* \\&E 相当于把E的管辖范围上升了一个级别\n* \\*E 相当于把E的管辖范围下降了一个级别\n* 数组名相当于指向数组第一个元素的指针，但是其管辖范围根据基类型来定。\n\n样例代码如下所示：\n\n```c\n    int a[4]={1,2,3,4};\n    printf(\"%p\\n\",a);       //x\n    printf(\"%p\\n\",a+1);     //x+4\n    printf(\"%p\\n\",&a);      //x\n    printf(\"%p\\n\",&a+1);    //x+16\n    printf(\"%p\\n\",*(&a));   //x\n    printf(\"%p\\n\",*(&a)+1); //x+4\n    printf(\"\\n\");\n\n    int b[2][3]={1,2,3},{4,5,6};    //这里由于jekyll问题，无法在两个一维数组外面添加{}\n    printf(\"%p\\n\",b);       //x\n    printf(\"%p\\n\",b+1);     //x+12\n    printf(\"%p\\n\",&b);      //x\n    printf(\"%p\\n\",&b+1);    //x+24\n    printf(\"%p\\n\",*(&b));   //x\n    printf(\"%p\\n\",*(&b)+1); //x+12\n    printf(\"%p\\n\",b[0]);    //x\n    printf(\"%p\\n\",b[0]+1);  //x+4\n    printf(\"%p\\n\",&b[0]);   //x\n    printf(\"%p\\n\",&b[0]+1); //x+12\n    printf(\"%p\\n\",*(&b[0]));    //x\n    printf(\"%p\\n\",*(&b[0])+1);  //x+4\n```\n代码中的一维数组a和二维数组b在内存中的表示情况如下图所示，其中红色的弧/圈表示指针的管辖范围（精确度）。\n![pointer]({{site.baseurl}}/assets/images/pointer_array.png)  \n\n## 数组和指针\n通常在函数调用中，我们会将数组名当作参数传递给函数，而函数中定义形参却通常定义为常量指针（const int* arr）。对于这二者还是有很多相识点的。\n\n* 最重要的点：==数组名代表的就是数组首元素的地址==。\n* 数组名这样的操作(arr++)是不对的,而p却可以（p=arr，p++），因为arr是常量类型。\n* 数组中的移位记住这样一个等式 \\*(point+i )= point[i]\n\n这里稍微提一下二维数组的定义。比如\n\n```c\n    int arr[2][3]={1,2,3,4,5,6};\n    int (*p)[3]=arr;\n```\n这里的二维数组指针p是代表包含3个int型元素的一维数组。\n\n## 指针和字符串\n指针和字符串的区别与指针和数组的区别很类似。因为C语言中没有字符型变量，只能用字符数组来存储，唯一的区别是字符串必须以'\\0'结尾。不过在面试的时候经常会问这样的一个问题：下面两种定义有什么区别。\n\n```c\n    char p[10]=\"hello\";\n    char *cp=\"hello\";\n```\n对于这个问题，我们得了解这个定义，首先p是字符数组，虽然长度为5,但p[5]一定为'\\0';而cp是这字符指针，是个**常量指针**，二者存储/指向的内容都为\"hello\"字符串。最关键的一点是两者在内存中存储区不一样。字符数组p是存储在栈区，而常量指针本身也是存储在栈区，但是它指向的字符串\"hello\"是存储在一个专门放常量的地方，在程序结束后释放。关于程序存储区的详细讨论将在另一片博文[程序中的存储区][memory]中讨论。\n\n\n## 常量&指针\n常量比较常用来保护实参，限制形参，保证实参在被调函数中的不可改变的特性（const int \\*）。还有另外一个类似宏定义的功能，又因为常量会被存放在常量区，所以可以节省空间（const int max=100）。不过常量指针（const int \\*arr）和指针常量（int \\*const p）是两个非常容易混的概念，这里做一些总结吧。\n\n对于二者的区分，只要记住三句话\n\n1. \\*（指针）和const（常量）谁在前先读谁\n2. \\*（指针）象征着地址，而const（常量）象征着内容\n3. 谁在前面谁就不允许改变。\n\n常量指针（const int \\*p）是指向常量的指针，所以指向的内容是不能改变的，但是这个指针可以指向其他常量。指针常量（int \\*const p）是指向变量的地址为常量，而指向的内容可以改变，所以**指针常量在声明的时候一定要初始化，不能被再赋值，指向别的地址**。\n\n结合最开始的那幅指针图片来说，对于两个变量a和b，其中b是正常的变量，a是指针变量。如果a是常量（就是1008值不能改变），则a是指针常量;如果指向的b是常量（就是地址为1008里的内容不能改变），则a是常量指针。\n\n## 参考文献\n1. [wiki指针][wiki_pointer]\n2. [baike][baike_pointer]\n3. [程序如何使用内存区][c_mem]\n4. [程序中的存储区][memory]\n5. [常量指针和指针常量的区别详解][const_point]\n[wiki_pointer]: https://en.wikipedia.org/wiki/Pointer_(computer_programming)\n[baike_pointer]:    http://baike.baidu.com/link?url=_XybsUjdWr-YTN7SUA8q92EpiskSmO4EvROZLZmJbGals1NhK2sHZSRrsW80vuS-2hcie9Qk5IfP42sXOoC0h_\n[c_mem]:    http://www.cnblogs.com/JCSU/articles/1051579.html\n[memory]:   {{site.baseurl}}/2015/11/22/程序中的存储区.html\n[const_point]: http://blog.csdn.net/beyond0525/article/details/7409305\n","slug":"Review-pointer-C","published":1,"date":"2015-10-25T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1n001rl73yc38o0d1j","content":"<p>c语言之所以强大，以及其自由性，很大部分体现在其灵活的指针运用上。因此，说指针是c语言的灵魂，一点都不为过。同时，这种说法也让很多人产生误解，似乎只有C语言的指针才能算指针。basic不支持指针，在此不论。其实，pascal语言本身也是支持指针的。从最初的pascal发展至今的object pascal，可以说在指针运用上，丝毫不会逊色于c语言的指针。还有Java语言，虽然任何教程都没有提及指针，但是在我看来任何类对象（基本数据类型不确定）的创建都使用了指针。所以对指针的理解决定了你对编程语言的理解。 <a id=\"more\"></a></p>\n<h2 id=\"指针基础\">指针基础</h2>\n<p>[指针][baike_pointer]（Pointer）是编程语言中的一个对象，它的值直接指向（points to）存在电脑存储器中另一个地方的值。这里先介绍一下变量的三要素：变量名，存储地址和存储内容。在下图的内存分配表中，<strong>存储变量(b)的地址(1008)</strong>称为指向变量(b)的指针，意思是通过它(1008)能找到以它为地址的内存单元(b)。而<strong>存储这个指针(1008)的变量(a)</strong>叫做指针变量，又因为这个指针是指向b变量的，所以又叫它为指向变量b的指针变量。<br>\n[pointer](/assets/images/pointers.png)</p>\n<p>对于指针变量，我们只要抓在两点就可以了，第一个是它指向的地址是多少，第二是它的基类型是啥。对于指针的基类型，在指针的定义中或者malloc/new申请内存时很容易获得。指向基本数据类型指针的基类型就是基本数据类型，而数组指针基类型的识别有点难，但其实只要抓住一点就能解决了，即去掉定义中的一个*和变量名，剩下的就是指针的基类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *a;     <span class=\"comment\">// 基类型为int，它是管辖范围是一个变量</span></div><div class=\"line\"><span class=\"keyword\">int</span> **b;  <span class=\"comment\">// 基类型为int *，它是管辖范围是一个一维数组</span></div><div class=\"line\">b = (<span class=\"keyword\">int</span> **)row*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>*);   <span class=\"comment\">// b的类型是int **，其基类型为int*，管辖范围包含row个int*变量的一维数组[C]</span></div><div class=\"line\">b = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>*[row];      <span class=\"comment\">// b的类型是int **，其基类型为int*，管辖范围是包含row个int*变量的一维数组[C++]</span></div></pre></td></tr></table></figure>\n<h2 id=\"操作符-操作符叫取址操作符其后面常跟变量用来获取变量的地址的操作符\">操作符&amp;* 操作符&amp;叫取址操作符，其后面常跟变量，用来获取变量的地址的操作符。</h2>\n<p>操作符*叫取值操作符，其后面常跟地址，用来获取地址所定位内存空间里的值。如*point 是point所指向的存储单元的内容，而对于这个内容的理解有两种，一个是变量本身，另一个是具体的存储内容，特别声明这里的内容是变量本身。换句话说就是存储内容的变化也会导致*point值的变化。对于指针还有另外一点，就是指针的增加point+i，这里指针实际移动的距离是i*sizeof(指针的基类型)。下面来说一下这个经典案例*point++，该操作首先考虑优先级，因为这三个操作符都是一元同级操作符，所以按照从右往左的顺序操作。即*point++等价于*(point++)。</p>\n<p>这两个操作是一个对立的操作。一个是通过地址获取变量值，另一个是通过变量名获取地址。下面从管辖范围的角度来理解这两个操作。这个管辖范围是对指针基类型在内存上的解读，更物理测量里面的精确度概念类似。其层级为高维数组&gt;一维数组&gt;单个基本数据类型。</p>\n<ul>\n<li>&amp;E 相当于把E的管辖范围上升了一个级别</li>\n<li>*E 相当于把E的管辖范围下降了一个级别</li>\n<li>数组名相当于指向数组第一个元素的指针，但是其管辖范围根据基类型来定。</li>\n</ul>\n<p>样例代码如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">4</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,a);       <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,a+<span class=\"number\">1</span>);     <span class=\"comment\">//x+4</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;a);      <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;a+<span class=\"number\">1</span>);    <span class=\"comment\">//x+16</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,*(&amp;a));   <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,*(&amp;a)+<span class=\"number\">1</span>); <span class=\"comment\">//x+4</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> b[<span class=\"number\">2</span>][<span class=\"number\">3</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;    <span class=\"comment\">//这里由于jekyll问题，无法在两个一维数组外面添加&#123;&#125;</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,b);       <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,b+<span class=\"number\">1</span>);     <span class=\"comment\">//x+12</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;b);      <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;b+<span class=\"number\">1</span>);    <span class=\"comment\">//x+24</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,*(&amp;b));   <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,*(&amp;b)+<span class=\"number\">1</span>); <span class=\"comment\">//x+12</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,b[<span class=\"number\">0</span>]);    <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,b[<span class=\"number\">0</span>]+<span class=\"number\">1</span>);  <span class=\"comment\">//x+4</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;b[<span class=\"number\">0</span>]);   <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;b[<span class=\"number\">0</span>]+<span class=\"number\">1</span>); <span class=\"comment\">//x+12</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,*(&amp;b[<span class=\"number\">0</span>]));    <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,*(&amp;b[<span class=\"number\">0</span>])+<span class=\"number\">1</span>);  <span class=\"comment\">//x+4</span></div></pre></td></tr></table></figure>\n<p>代码中的一维数组a和二维数组b在内存中的表示情况如下图所示，其中红色的弧/圈表示指针的管辖范围（精确度）。 [pointer](/assets/images/pointer_array.png)</p>\n<h2 id=\"数组和指针\">数组和指针</h2>\n<p>通常在函数调用中，我们会将数组名当作参数传递给函数，而函数中定义形参却通常定义为常量指针（const int* arr）。对于这二者还是有很多相识点的。</p>\n<ul>\n<li>最重要的点：==数组名代表的就是数组首元素的地址==。</li>\n<li>数组名这样的操作(arr++)是不对的,而p却可以（p=arr，p++），因为arr是常量类型。</li>\n<li>数组中的移位记住这样一个等式 *(point+i )= point[i]</li>\n</ul>\n<p>这里稍微提一下二维数组的定义。比如</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">2</span>][<span class=\"number\">3</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> (*p)[<span class=\"number\">3</span>]=arr;</div></pre></td></tr></table></figure>\n<p>这里的二维数组指针p是代表包含3个int型元素的一维数组。</p>\n<h2 id=\"指针和字符串\">指针和字符串</h2>\n<p>指针和字符串的区别与指针和数组的区别很类似。因为C语言中没有字符型变量，只能用字符数组来存储，唯一的区别是字符串必须以’’结尾。不过在面试的时候经常会问这样的一个问题：下面两种定义有什么区别。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span> p[<span class=\"number\">10</span>]=<span class=\"string\">\"hello\"</span>;</div><div class=\"line\"><span class=\"keyword\">char</span> *cp=<span class=\"string\">\"hello\"</span>;</div></pre></td></tr></table></figure>\n<p>对于这个问题，我们得了解这个定义，首先p是字符数组，虽然长度为5,但p[5]一定为’’;而cp是这字符指针，是个<strong>常量指针</strong>，二者存储/指向的内容都为“hello”字符串。最关键的一点是两者在内存中存储区不一样。字符数组p是存储在栈区，而常量指针本身也是存储在栈区，但是它指向的字符串“hello”是存储在一个专门放常量的地方，在程序结束后释放。关于程序存储区的详细讨论将在另一片博文[程序中的存储区][memory]中讨论。</p>\n<h2 id=\"常量指针\">常量&amp;指针</h2>\n<p>常量比较常用来保护实参，限制形参，保证实参在被调函数中的不可改变的特性（const int *）。还有另外一个类似宏定义的功能，又因为常量会被存放在常量区，所以可以节省空间（const int max=100）。不过常量指针（const int *arr）和指针常量（int *const p）是两个非常容易混的概念，这里做一些总结吧。</p>\n<p>对于二者的区分，只要记住三句话</p>\n<ol style=\"list-style-type: decimal\">\n<li>*（指针）和const（常量）谁在前先读谁</li>\n<li>*（指针）象征着地址，而const（常量）象征着内容</li>\n<li>谁在前面谁就不允许改变。</li>\n</ol>\n<p>常量指针（const int *p）是指向常量的指针，所以指向的内容是不能改变的，但是这个指针可以指向其他常量。指针常量（int *const p）是指向变量的地址为常量，而指向的内容可以改变，所以<strong>指针常量在声明的时候一定要初始化，不能被再赋值，指向别的地址</strong>。</p>\n<p>结合最开始的那幅指针图片来说，对于两个变量a和b，其中b是正常的变量，a是指针变量。如果a是常量（就是1008值不能改变），则a是指针常量;如果指向的b是常量（就是地址为1008里的内容不能改变），则a是常量指针。</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li>[wiki指针][wiki_pointer]</li>\n<li>[baike][baike_pointer]</li>\n<li>[程序如何使用内存区][c_mem]</li>\n<li>[程序中的存储区][memory]</li>\n<li>[常量指针和指针常量的区别详解][const_point] [wiki_pointer]: https://en.wikipedia.org/wiki/Pointer_(computer_programming) [baike_pointer]: http://baike.baidu.com/link?url=<em>XybsUjdWr-YTN7SUA8q92EpiskSmO4EvROZLZmJbGals1NhK2sHZSRrsW80vuS-2hcie9Qk5IfP42sXOoC0h</em> [c_mem]: http://www.cnblogs.com/JCSU/articles/1051579.html [memory]: /2015/11/22/程序中的存储区.html [const_point]: http://blog.csdn.net/beyond0525/article/details/7409305</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>c语言之所以强大，以及其自由性，很大部分体现在其灵活的指针运用上。因此，说指针是c语言的灵魂，一点都不为过。同时，这种说法也让很多人产生误解，似乎只有C语言的指针才能算指针。basic不支持指针，在此不论。其实，pascal语言本身也是支持指针的。从最初的pascal发展至今的object pascal，可以说在指针运用上，丝毫不会逊色于c语言的指针。还有Java语言，虽然任何教程都没有提及指针，但是在我看来任何类对象（基本数据类型不确定）的创建都使用了指针。所以对指针的理解决定了你对编程语言的理解。","more":"</p>\n<h2 id=\"指针基础\">指针基础</h2>\n<p>[指针][baike_pointer]（Pointer）是编程语言中的一个对象，它的值直接指向（points to）存在电脑存储器中另一个地方的值。这里先介绍一下变量的三要素：变量名，存储地址和存储内容。在下图的内存分配表中，<strong>存储变量(b)的地址(1008)</strong>称为指向变量(b)的指针，意思是通过它(1008)能找到以它为地址的内存单元(b)。而<strong>存储这个指针(1008)的变量(a)</strong>叫做指针变量，又因为这个指针是指向b变量的，所以又叫它为指向变量b的指针变量。<br>\n[pointer](/assets/images/pointers.png)</p>\n<p>对于指针变量，我们只要抓在两点就可以了，第一个是它指向的地址是多少，第二是它的基类型是啥。对于指针的基类型，在指针的定义中或者malloc/new申请内存时很容易获得。指向基本数据类型指针的基类型就是基本数据类型，而数组指针基类型的识别有点难，但其实只要抓住一点就能解决了，即去掉定义中的一个*和变量名，剩下的就是指针的基类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *a;     <span class=\"comment\">// 基类型为int，它是管辖范围是一个变量</span></div><div class=\"line\"><span class=\"keyword\">int</span> **b;  <span class=\"comment\">// 基类型为int *，它是管辖范围是一个一维数组</span></div><div class=\"line\">b = (<span class=\"keyword\">int</span> **)row*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>*);   <span class=\"comment\">// b的类型是int **，其基类型为int*，管辖范围包含row个int*变量的一维数组[C]</span></div><div class=\"line\">b = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>*[row];      <span class=\"comment\">// b的类型是int **，其基类型为int*，管辖范围是包含row个int*变量的一维数组[C++]</span></div></pre></td></tr></table></figure>\n<h2 id=\"操作符-操作符叫取址操作符其后面常跟变量用来获取变量的地址的操作符\">操作符&amp;* 操作符&amp;叫取址操作符，其后面常跟变量，用来获取变量的地址的操作符。</h2>\n<p>操作符*叫取值操作符，其后面常跟地址，用来获取地址所定位内存空间里的值。如*point 是point所指向的存储单元的内容，而对于这个内容的理解有两种，一个是变量本身，另一个是具体的存储内容，特别声明这里的内容是变量本身。换句话说就是存储内容的变化也会导致*point值的变化。对于指针还有另外一点，就是指针的增加point+i，这里指针实际移动的距离是i*sizeof(指针的基类型)。下面来说一下这个经典案例*point++，该操作首先考虑优先级，因为这三个操作符都是一元同级操作符，所以按照从右往左的顺序操作。即*point++等价于*(point++)。</p>\n<p>这两个操作是一个对立的操作。一个是通过地址获取变量值，另一个是通过变量名获取地址。下面从管辖范围的角度来理解这两个操作。这个管辖范围是对指针基类型在内存上的解读，更物理测量里面的精确度概念类似。其层级为高维数组&gt;一维数组&gt;单个基本数据类型。</p>\n<ul>\n<li>&amp;E 相当于把E的管辖范围上升了一个级别</li>\n<li>*E 相当于把E的管辖范围下降了一个级别</li>\n<li>数组名相当于指向数组第一个元素的指针，但是其管辖范围根据基类型来定。</li>\n</ul>\n<p>样例代码如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">4</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,a);       <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,a+<span class=\"number\">1</span>);     <span class=\"comment\">//x+4</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;a);      <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;a+<span class=\"number\">1</span>);    <span class=\"comment\">//x+16</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,*(&amp;a));   <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,*(&amp;a)+<span class=\"number\">1</span>); <span class=\"comment\">//x+4</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> b[<span class=\"number\">2</span>][<span class=\"number\">3</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;    <span class=\"comment\">//这里由于jekyll问题，无法在两个一维数组外面添加&#123;&#125;</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,b);       <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,b+<span class=\"number\">1</span>);     <span class=\"comment\">//x+12</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;b);      <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;b+<span class=\"number\">1</span>);    <span class=\"comment\">//x+24</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,*(&amp;b));   <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,*(&amp;b)+<span class=\"number\">1</span>); <span class=\"comment\">//x+12</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,b[<span class=\"number\">0</span>]);    <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,b[<span class=\"number\">0</span>]+<span class=\"number\">1</span>);  <span class=\"comment\">//x+4</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;b[<span class=\"number\">0</span>]);   <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;b[<span class=\"number\">0</span>]+<span class=\"number\">1</span>); <span class=\"comment\">//x+12</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,*(&amp;b[<span class=\"number\">0</span>]));    <span class=\"comment\">//x</span></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,*(&amp;b[<span class=\"number\">0</span>])+<span class=\"number\">1</span>);  <span class=\"comment\">//x+4</span></div></pre></td></tr></table></figure>\n<p>代码中的一维数组a和二维数组b在内存中的表示情况如下图所示，其中红色的弧/圈表示指针的管辖范围（精确度）。 [pointer](/assets/images/pointer_array.png)</p>\n<h2 id=\"数组和指针\">数组和指针</h2>\n<p>通常在函数调用中，我们会将数组名当作参数传递给函数，而函数中定义形参却通常定义为常量指针（const int* arr）。对于这二者还是有很多相识点的。</p>\n<ul>\n<li>最重要的点：==数组名代表的就是数组首元素的地址==。</li>\n<li>数组名这样的操作(arr++)是不对的,而p却可以（p=arr，p++），因为arr是常量类型。</li>\n<li>数组中的移位记住这样一个等式 *(point+i )= point[i]</li>\n</ul>\n<p>这里稍微提一下二维数组的定义。比如</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">2</span>][<span class=\"number\">3</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> (*p)[<span class=\"number\">3</span>]=arr;</div></pre></td></tr></table></figure>\n<p>这里的二维数组指针p是代表包含3个int型元素的一维数组。</p>\n<h2 id=\"指针和字符串\">指针和字符串</h2>\n<p>指针和字符串的区别与指针和数组的区别很类似。因为C语言中没有字符型变量，只能用字符数组来存储，唯一的区别是字符串必须以’’结尾。不过在面试的时候经常会问这样的一个问题：下面两种定义有什么区别。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">char</span> p[<span class=\"number\">10</span>]=<span class=\"string\">\"hello\"</span>;</div><div class=\"line\"><span class=\"keyword\">char</span> *cp=<span class=\"string\">\"hello\"</span>;</div></pre></td></tr></table></figure>\n<p>对于这个问题，我们得了解这个定义，首先p是字符数组，虽然长度为5,但p[5]一定为’’;而cp是这字符指针，是个<strong>常量指针</strong>，二者存储/指向的内容都为“hello”字符串。最关键的一点是两者在内存中存储区不一样。字符数组p是存储在栈区，而常量指针本身也是存储在栈区，但是它指向的字符串“hello”是存储在一个专门放常量的地方，在程序结束后释放。关于程序存储区的详细讨论将在另一片博文[程序中的存储区][memory]中讨论。</p>\n<h2 id=\"常量指针\">常量&amp;指针</h2>\n<p>常量比较常用来保护实参，限制形参，保证实参在被调函数中的不可改变的特性（const int *）。还有另外一个类似宏定义的功能，又因为常量会被存放在常量区，所以可以节省空间（const int max=100）。不过常量指针（const int *arr）和指针常量（int *const p）是两个非常容易混的概念，这里做一些总结吧。</p>\n<p>对于二者的区分，只要记住三句话</p>\n<ol style=\"list-style-type: decimal\">\n<li>*（指针）和const（常量）谁在前先读谁</li>\n<li>*（指针）象征着地址，而const（常量）象征着内容</li>\n<li>谁在前面谁就不允许改变。</li>\n</ol>\n<p>常量指针（const int *p）是指向常量的指针，所以指向的内容是不能改变的，但是这个指针可以指向其他常量。指针常量（int *const p）是指向变量的地址为常量，而指向的内容可以改变，所以<strong>指针常量在声明的时候一定要初始化，不能被再赋值，指向别的地址</strong>。</p>\n<p>结合最开始的那幅指针图片来说，对于两个变量a和b，其中b是正常的变量，a是指针变量。如果a是常量（就是1008值不能改变），则a是指针常量;如果指向的b是常量（就是地址为1008里的内容不能改变），则a是常量指针。</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li>[wiki指针][wiki_pointer]</li>\n<li>[baike][baike_pointer]</li>\n<li>[程序如何使用内存区][c_mem]</li>\n<li>[程序中的存储区][memory]</li>\n<li>[常量指针和指针常量的区别详解][const_point] [wiki_pointer]: https://en.wikipedia.org/wiki/Pointer_(computer_programming) [baike_pointer]: http://baike.baidu.com/link?url=<em>XybsUjdWr-YTN7SUA8q92EpiskSmO4EvROZLZmJbGals1NhK2sHZSRrsW80vuS-2hcie9Qk5IfP42sXOoC0h</em> [c_mem]: http://www.cnblogs.com/JCSU/articles/1051579.html [memory]: /2015/11/22/程序中的存储区.html [const_point]: http://blog.csdn.net/beyond0525/article/details/7409305</li>\n</ol>"},{"layout":"post","title":"python里的数据科学之Numpy实战","comments":1,"date":"2015-12-04T06:00:06.000Z","_content":"Python的强大就不多说了，而对于Numpy的教程网上也多得数不清，这里只是将Numpy在日常中的实用方法做个梳理小结，方便以后查阅上手。\n<!-- more -->\n\n\n## 简介\n对于数据科学，它是Python创建的所有更高层工具的基础，因为它和最基础的数据结构--矩阵有关。其核心也就是这个多维矩阵（**n**-**d**imesional **array**）,这是一个表示多维度、同质并且固定大小的阵列。Numpy这个库提供了以下内容：\n\n1. N维数组，一种多维度、同质、能快速、高效使用内存的阵列 。\n2. 提供基于矩阵的数学运算\n3. 提供线性代数，傅里叶变换和随机数生成\n\n## 多维矩阵\nNumpy的主要对象是多维矩阵（ndarray），这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格。在Numpy中维度（dimensions）叫做轴（axes），轴的个数叫做秩（rank）。其有如下属性：  \n\n* ndim   \n矩阵轴的个数，也就是秩\n* shape  \n矩阵的维度\n* size      \n矩阵元素的总个数，等于shape属性中所有元素的乘积\n* dtype   \n矩阵中元素类型\n* itemsize  \n矩阵中每个元素的字节大小\n* data      \n包含实际矩阵存放在内存的地址\n* I  \n矩阵的逆，等价于linalg.pinv，而不等价于linalg.inv\n* T  \n矩阵的转置，等价于ndarray.transpose().\n*\n\n\n多维矩阵（ndarray）除了基本属性外，还有很多处理函数。\n\n1. 构建  \n    * reshape/flatten    \n    重构矩阵/将矩阵拉伸成一维向量，等价于ndarry.reshape(ndarray.size)\n    * copy/fill      \n    深拷贝矩阵（直接赋值只是浅拷贝）/向矩阵中填充数值，和memset功能类似\n    * sort  \n    对矩阵进行排序\n    *\n2. 提取\n    * clip/diagonal  \n    提取范围里的元素/提取对角线上的元素\n    *\n2. 方法\n    * sum/prod/min/max/argmin/argmax  \n    求矩阵中所有元素的和/积/最小值/最大值/最小值索引/最大值索引\n    * mean/var/std  \n    求矩阵中所有元素的均值方差/标准差\n    *\n4. 转换\n    * tolist/tostring    \n    转换成链表/字符串\n\n> **Tips:**\n> 这里的很多函数都用来处理多维矩阵（m×n），有如下特性：  \n>\n> 1. 不加axis参数，则该函数是对矩阵所有元素起作用，即将多维矩阵拉伸成一维后进行相应操作，最后获得一个数。\n> 2. 加axis=0，则该函数是对每一列起作用，即按照列对相应元素进行运算，最终获得一个1×n的一维向量。\n> 3. 加axis=1，则该函数是对每一行起作用，即按照行对相应元素进行运算，最终获得一个m×1的一维向量。\n>\n\n\n## 基本操作\n1. 构建\n    * concatenate  \n    把多个矩阵串起来，通过axis参数调节横向（1）和纵向（0/默认）\n    * ones/zeros/ones_like/zeros_like  \n    创建全1/0矩阵/创建和矩阵相同维度的全1/0矩阵\n    * identity  \n    创建单位矩阵\n    * eye  \n    创建方阵（长宽都相当的矩阵），指定莫个对角线为1,其它为0\n2. 提取\n    * logical_and/logical_not/logical_or  \n    逻辑与/逻辑非/逻辑或\n    * where  \n    跟if类似\n    * isnan/isfinite  \n    是否是一个数/无穷\n    * take/put  \n    将一个矩阵里的元素当索引提取/存放矩阵\n    *\n3. 方法\n    * abs/sign/sqrt/log/log10/exp  \n    绝对值/取符号位/开根号/以2为底的对数/以10为底的对数/指数\n    * floor/ceil/rint  \n    向下取整/向上取整/四舍五入取整\n    * sin/cos/tan/arcsin/arccos/arctan  \n    正弦/余弦/正切/反正弦/反余弦/反正切\n    * sinh/cosh/tanh/arcsinh/arccoh/arctanh  \n    双曲正弦/双曲余弦/反双曲正弦/反双曲余弦/反双曲正切\n    * dot/outer/inner/cross  \n    点乘/外积/内积/向量积\n    * median/corrcoef/cov  \n    求中位数/相关系数/协方差\n    *\n\n\n## 线性代数\n包含线性代数的所有的函数都包含在linalg子库中。\n\n* det/eig/inv/pinv/svd  \n求矩阵的行列式/特征值和向量/逆/伪逆/奇异值分解\n*\n\n\n## 傅里叶变换\n关于傅里叶变换的函数包含在fft子库中。\n\n## 随机数生成\n关于随机数的生成函数都在random子库中。\n\n* seed  \n设定随机种子\n* rand  \n构建随机矩阵\n* random  \n获取一个随机数\n*\n\n## 多项式\n关于多项处理的函数都在polynomial子库中。\n\n\n\n## 测试工具\n关于测试工具的函数在testing子库中。\n\n\n## 参考文献\n1. [python官网][python]\n2. [Python27入门指南][python27]\n3. [Python35入门指南][python35]\n4. [numpy源码][numpy_src]\n5. [numpy快速入门][numpy_quick]\n6. [numpy教程][numpy_jc]\n7. [numpy初入门][numpy_js]\n\n[python]:   https://www.python.org/\n[python27]: http://www.pythondoc.com/pythontutorial27/\n[python35]: http://www.pythondoc.com/pythontutorial3/index.html\n[numpy_src]:    https://github.com/numpy/numpy\n[numpy_quick]:  https://docs.scipy.org/doc/numpy-dev/user/quickstart.html\n[numpy_jc]:     http://reverland.org/python/2012/08/22/numpy/\n[numpy_js]:     http://www.engr.ucsb.edu/~shell/che210d/numpy.pdf\n","source":"_posts/2015-12-04-python里的数据科学之Numpy实战.md","raw":"---\nlayout:\t\tpost\ntitle:\t\tpython里的数据科学之Numpy实战\ncategories:\n- TECHNOLOGY\ntags:\n- Python\n- ML\n- Numpy\npermalink:  Explore-Numpy-Python\ncomments:\ttrue\ndate:\t\t2015-12-04 14:00:06\n---\nPython的强大就不多说了，而对于Numpy的教程网上也多得数不清，这里只是将Numpy在日常中的实用方法做个梳理小结，方便以后查阅上手。\n<!-- more -->\n\n\n## 简介\n对于数据科学，它是Python创建的所有更高层工具的基础，因为它和最基础的数据结构--矩阵有关。其核心也就是这个多维矩阵（**n**-**d**imesional **array**）,这是一个表示多维度、同质并且固定大小的阵列。Numpy这个库提供了以下内容：\n\n1. N维数组，一种多维度、同质、能快速、高效使用内存的阵列 。\n2. 提供基于矩阵的数学运算\n3. 提供线性代数，傅里叶变换和随机数生成\n\n## 多维矩阵\nNumpy的主要对象是多维矩阵（ndarray），这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格。在Numpy中维度（dimensions）叫做轴（axes），轴的个数叫做秩（rank）。其有如下属性：  \n\n* ndim   \n矩阵轴的个数，也就是秩\n* shape  \n矩阵的维度\n* size      \n矩阵元素的总个数，等于shape属性中所有元素的乘积\n* dtype   \n矩阵中元素类型\n* itemsize  \n矩阵中每个元素的字节大小\n* data      \n包含实际矩阵存放在内存的地址\n* I  \n矩阵的逆，等价于linalg.pinv，而不等价于linalg.inv\n* T  \n矩阵的转置，等价于ndarray.transpose().\n*\n\n\n多维矩阵（ndarray）除了基本属性外，还有很多处理函数。\n\n1. 构建  \n    * reshape/flatten    \n    重构矩阵/将矩阵拉伸成一维向量，等价于ndarry.reshape(ndarray.size)\n    * copy/fill      \n    深拷贝矩阵（直接赋值只是浅拷贝）/向矩阵中填充数值，和memset功能类似\n    * sort  \n    对矩阵进行排序\n    *\n2. 提取\n    * clip/diagonal  \n    提取范围里的元素/提取对角线上的元素\n    *\n2. 方法\n    * sum/prod/min/max/argmin/argmax  \n    求矩阵中所有元素的和/积/最小值/最大值/最小值索引/最大值索引\n    * mean/var/std  \n    求矩阵中所有元素的均值方差/标准差\n    *\n4. 转换\n    * tolist/tostring    \n    转换成链表/字符串\n\n> **Tips:**\n> 这里的很多函数都用来处理多维矩阵（m×n），有如下特性：  \n>\n> 1. 不加axis参数，则该函数是对矩阵所有元素起作用，即将多维矩阵拉伸成一维后进行相应操作，最后获得一个数。\n> 2. 加axis=0，则该函数是对每一列起作用，即按照列对相应元素进行运算，最终获得一个1×n的一维向量。\n> 3. 加axis=1，则该函数是对每一行起作用，即按照行对相应元素进行运算，最终获得一个m×1的一维向量。\n>\n\n\n## 基本操作\n1. 构建\n    * concatenate  \n    把多个矩阵串起来，通过axis参数调节横向（1）和纵向（0/默认）\n    * ones/zeros/ones_like/zeros_like  \n    创建全1/0矩阵/创建和矩阵相同维度的全1/0矩阵\n    * identity  \n    创建单位矩阵\n    * eye  \n    创建方阵（长宽都相当的矩阵），指定莫个对角线为1,其它为0\n2. 提取\n    * logical_and/logical_not/logical_or  \n    逻辑与/逻辑非/逻辑或\n    * where  \n    跟if类似\n    * isnan/isfinite  \n    是否是一个数/无穷\n    * take/put  \n    将一个矩阵里的元素当索引提取/存放矩阵\n    *\n3. 方法\n    * abs/sign/sqrt/log/log10/exp  \n    绝对值/取符号位/开根号/以2为底的对数/以10为底的对数/指数\n    * floor/ceil/rint  \n    向下取整/向上取整/四舍五入取整\n    * sin/cos/tan/arcsin/arccos/arctan  \n    正弦/余弦/正切/反正弦/反余弦/反正切\n    * sinh/cosh/tanh/arcsinh/arccoh/arctanh  \n    双曲正弦/双曲余弦/反双曲正弦/反双曲余弦/反双曲正切\n    * dot/outer/inner/cross  \n    点乘/外积/内积/向量积\n    * median/corrcoef/cov  \n    求中位数/相关系数/协方差\n    *\n\n\n## 线性代数\n包含线性代数的所有的函数都包含在linalg子库中。\n\n* det/eig/inv/pinv/svd  \n求矩阵的行列式/特征值和向量/逆/伪逆/奇异值分解\n*\n\n\n## 傅里叶变换\n关于傅里叶变换的函数包含在fft子库中。\n\n## 随机数生成\n关于随机数的生成函数都在random子库中。\n\n* seed  \n设定随机种子\n* rand  \n构建随机矩阵\n* random  \n获取一个随机数\n*\n\n## 多项式\n关于多项处理的函数都在polynomial子库中。\n\n\n\n## 测试工具\n关于测试工具的函数在testing子库中。\n\n\n## 参考文献\n1. [python官网][python]\n2. [Python27入门指南][python27]\n3. [Python35入门指南][python35]\n4. [numpy源码][numpy_src]\n5. [numpy快速入门][numpy_quick]\n6. [numpy教程][numpy_jc]\n7. [numpy初入门][numpy_js]\n\n[python]:   https://www.python.org/\n[python27]: http://www.pythondoc.com/pythontutorial27/\n[python35]: http://www.pythondoc.com/pythontutorial3/index.html\n[numpy_src]:    https://github.com/numpy/numpy\n[numpy_quick]:  https://docs.scipy.org/doc/numpy-dev/user/quickstart.html\n[numpy_jc]:     http://reverland.org/python/2012/08/22/numpy/\n[numpy_js]:     http://www.engr.ucsb.edu/~shell/che210d/numpy.pdf\n","slug":"Explore-Numpy-Python","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1n001sl73y1j0mdfsh","content":"<p>Python的强大就不多说了，而对于Numpy的教程网上也多得数不清，这里只是将Numpy在日常中的实用方法做个梳理小结，方便以后查阅上手。 <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p>对于数据科学，它是Python创建的所有更高层工具的基础，因为它和最基础的数据结构–矩阵有关。其核心也就是这个多维矩阵（<strong>n</strong>-<strong>d</strong>imesional <strong>array</strong>）,这是一个表示多维度、同质并且固定大小的阵列。Numpy这个库提供了以下内容：</p>\n<ol style=\"list-style-type: decimal\">\n<li>N维数组，一种多维度、同质、能快速、高效使用内存的阵列 。</li>\n<li>提供基于矩阵的数学运算</li>\n<li>提供线性代数，傅里叶变换和随机数生成</li>\n</ol>\n<h2 id=\"多维矩阵\">多维矩阵</h2>\n<p>Numpy的主要对象是多维矩阵（ndarray），这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格。在Numpy中维度（dimensions）叫做轴（axes），轴的个数叫做秩（rank）。其有如下属性：</p>\n<ul>\n<li>ndim<br>\n矩阵轴的个数，也就是秩</li>\n<li>shape<br>\n矩阵的维度</li>\n<li>size<br>\n矩阵元素的总个数，等于shape属性中所有元素的乘积</li>\n<li>dtype<br>\n矩阵中元素类型</li>\n<li>itemsize<br>\n矩阵中每个元素的字节大小</li>\n<li>data<br>\n包含实际矩阵存放在内存的地址</li>\n<li>I<br>\n矩阵的逆，等价于linalg.pinv，而不等价于linalg.inv</li>\n<li>T<br>\n矩阵的转置，等价于ndarray.transpose().</li>\n<li></li>\n</ul>\n<p>多维矩阵（ndarray）除了基本属性外，还有很多处理函数。</p>\n<ol style=\"list-style-type: decimal\">\n<li>构建\n<ul>\n<li>reshape/flatten<br>\n重构矩阵/将矩阵拉伸成一维向量，等价于ndarry.reshape(ndarray.size)</li>\n<li>copy/fill<br>\n深拷贝矩阵（直接赋值只是浅拷贝）/向矩阵中填充数值，和memset功能类似</li>\n<li>sort<br>\n对矩阵进行排序</li>\n<li></li>\n</ul></li>\n<li>提取\n<ul>\n<li>clip/diagonal<br>\n提取范围里的元素/提取对角线上的元素</li>\n<li></li>\n</ul></li>\n<li>方法\n<ul>\n<li>sum/prod/min/max/argmin/argmax<br>\n求矩阵中所有元素的和/积/最小值/最大值/最小值索引/最大值索引</li>\n<li>mean/var/std<br>\n求矩阵中所有元素的均值方差/标准差</li>\n<li></li>\n</ul></li>\n<li>转换\n<ul>\n<li>tolist/tostring<br>\n转换成链表/字符串</li>\n</ul></li>\n</ol>\n<blockquote>\n<p><strong>Tips:</strong> 这里的很多函数都用来处理多维矩阵（m×n），有如下特性：</p>\n<ol style=\"list-style-type: decimal\">\n<li>不加axis参数，则该函数是对矩阵所有元素起作用，即将多维矩阵拉伸成一维后进行相应操作，最后获得一个数。</li>\n<li>加axis=0，则该函数是对每一列起作用，即按照列对相应元素进行运算，最终获得一个1×n的一维向量。</li>\n<li>加axis=1，则该函数是对每一行起作用，即按照行对相应元素进行运算，最终获得一个m×1的一维向量。</li>\n</ol>\n</blockquote>\n<h2 id=\"基本操作\">基本操作</h2>\n<ol style=\"list-style-type: decimal\">\n<li>构建\n<ul>\n<li>concatenate<br>\n把多个矩阵串起来，通过axis参数调节横向（1）和纵向（0/默认）</li>\n<li>ones/zeros/ones_like/zeros_like<br>\n创建全1/0矩阵/创建和矩阵相同维度的全1/0矩阵</li>\n<li>identity<br>\n创建单位矩阵</li>\n<li>eye<br>\n创建方阵（长宽都相当的矩阵），指定莫个对角线为1,其它为0</li>\n</ul></li>\n<li>提取\n<ul>\n<li>logical_and/logical_not/logical_or<br>\n逻辑与/逻辑非/逻辑或</li>\n<li>where<br>\n跟if类似</li>\n<li>isnan/isfinite<br>\n是否是一个数/无穷</li>\n<li>take/put<br>\n将一个矩阵里的元素当索引提取/存放矩阵</li>\n<li></li>\n</ul></li>\n<li>方法\n<ul>\n<li>abs/sign/sqrt/log/log10/exp<br>\n绝对值/取符号位/开根号/以2为底的对数/以10为底的对数/指数</li>\n<li>floor/ceil/rint<br>\n向下取整/向上取整/四舍五入取整</li>\n<li>sin/cos/tan/arcsin/arccos/arctan<br>\n正弦/余弦/正切/反正弦/反余弦/反正切</li>\n<li>sinh/cosh/tanh/arcsinh/arccoh/arctanh<br>\n双曲正弦/双曲余弦/反双曲正弦/反双曲余弦/反双曲正切</li>\n<li>dot/outer/inner/cross<br>\n点乘/外积/内积/向量积</li>\n<li>median/corrcoef/cov<br>\n求中位数/相关系数/协方差</li>\n<li></li>\n</ul></li>\n</ol>\n<h2 id=\"线性代数\">线性代数</h2>\n<p>包含线性代数的所有的函数都包含在linalg子库中。</p>\n<ul>\n<li>det/eig/inv/pinv/svd<br>\n求矩阵的行列式/特征值和向量/逆/伪逆/奇异值分解</li>\n<li></li>\n</ul>\n<h2 id=\"傅里叶变换\">傅里叶变换</h2>\n<p>关于傅里叶变换的函数包含在fft子库中。</p>\n<h2 id=\"随机数生成\">随机数生成</h2>\n<p>关于随机数的生成函数都在random子库中。</p>\n<ul>\n<li>seed<br>\n设定随机种子</li>\n<li>rand<br>\n构建随机矩阵</li>\n<li>random<br>\n获取一个随机数</li>\n<li></li>\n</ul>\n<h2 id=\"多项式\">多项式</h2>\n<p>关于多项处理的函数都在polynomial子库中。</p>\n<h2 id=\"测试工具\">测试工具</h2>\n<p>关于测试工具的函数在testing子库中。</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://www.python.org/\" target=\"_blank\" rel=\"external\">python官网</a></li>\n<li><a href=\"http://www.pythondoc.com/pythontutorial27/\" target=\"_blank\" rel=\"external\">Python27入门指南</a></li>\n<li><a href=\"http://www.pythondoc.com/pythontutorial3/index.html\" target=\"_blank\" rel=\"external\">Python35入门指南</a></li>\n<li><a href=\"https://github.com/numpy/numpy\" target=\"_blank\" rel=\"external\">numpy源码</a></li>\n<li><a href=\"https://docs.scipy.org/doc/numpy-dev/user/quickstart.html\" target=\"_blank\" rel=\"external\">numpy快速入门</a></li>\n<li><a href=\"http://reverland.org/python/2012/08/22/numpy/\" target=\"_blank\" rel=\"external\">numpy教程</a></li>\n<li><a href=\"http://www.engr.ucsb.edu/~shell/che210d/numpy.pdf\" target=\"_blank\" rel=\"external\">numpy初入门</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Python的强大就不多说了，而对于Numpy的教程网上也多得数不清，这里只是将Numpy在日常中的实用方法做个梳理小结，方便以后查阅上手。","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p>对于数据科学，它是Python创建的所有更高层工具的基础，因为它和最基础的数据结构–矩阵有关。其核心也就是这个多维矩阵（<strong>n</strong>-<strong>d</strong>imesional <strong>array</strong>）,这是一个表示多维度、同质并且固定大小的阵列。Numpy这个库提供了以下内容：</p>\n<ol style=\"list-style-type: decimal\">\n<li>N维数组，一种多维度、同质、能快速、高效使用内存的阵列 。</li>\n<li>提供基于矩阵的数学运算</li>\n<li>提供线性代数，傅里叶变换和随机数生成</li>\n</ol>\n<h2 id=\"多维矩阵\">多维矩阵</h2>\n<p>Numpy的主要对象是多维矩阵（ndarray），这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格。在Numpy中维度（dimensions）叫做轴（axes），轴的个数叫做秩（rank）。其有如下属性：</p>\n<ul>\n<li>ndim<br>\n矩阵轴的个数，也就是秩</li>\n<li>shape<br>\n矩阵的维度</li>\n<li>size<br>\n矩阵元素的总个数，等于shape属性中所有元素的乘积</li>\n<li>dtype<br>\n矩阵中元素类型</li>\n<li>itemsize<br>\n矩阵中每个元素的字节大小</li>\n<li>data<br>\n包含实际矩阵存放在内存的地址</li>\n<li>I<br>\n矩阵的逆，等价于linalg.pinv，而不等价于linalg.inv</li>\n<li>T<br>\n矩阵的转置，等价于ndarray.transpose().</li>\n<li></li>\n</ul>\n<p>多维矩阵（ndarray）除了基本属性外，还有很多处理函数。</p>\n<ol style=\"list-style-type: decimal\">\n<li>构建\n<ul>\n<li>reshape/flatten<br>\n重构矩阵/将矩阵拉伸成一维向量，等价于ndarry.reshape(ndarray.size)</li>\n<li>copy/fill<br>\n深拷贝矩阵（直接赋值只是浅拷贝）/向矩阵中填充数值，和memset功能类似</li>\n<li>sort<br>\n对矩阵进行排序</li>\n<li></li>\n</ul></li>\n<li>提取\n<ul>\n<li>clip/diagonal<br>\n提取范围里的元素/提取对角线上的元素</li>\n<li></li>\n</ul></li>\n<li>方法\n<ul>\n<li>sum/prod/min/max/argmin/argmax<br>\n求矩阵中所有元素的和/积/最小值/最大值/最小值索引/最大值索引</li>\n<li>mean/var/std<br>\n求矩阵中所有元素的均值方差/标准差</li>\n<li></li>\n</ul></li>\n<li>转换\n<ul>\n<li>tolist/tostring<br>\n转换成链表/字符串</li>\n</ul></li>\n</ol>\n<blockquote>\n<p><strong>Tips:</strong> 这里的很多函数都用来处理多维矩阵（m×n），有如下特性：</p>\n<ol style=\"list-style-type: decimal\">\n<li>不加axis参数，则该函数是对矩阵所有元素起作用，即将多维矩阵拉伸成一维后进行相应操作，最后获得一个数。</li>\n<li>加axis=0，则该函数是对每一列起作用，即按照列对相应元素进行运算，最终获得一个1×n的一维向量。</li>\n<li>加axis=1，则该函数是对每一行起作用，即按照行对相应元素进行运算，最终获得一个m×1的一维向量。</li>\n</ol>\n</blockquote>\n<h2 id=\"基本操作\">基本操作</h2>\n<ol style=\"list-style-type: decimal\">\n<li>构建\n<ul>\n<li>concatenate<br>\n把多个矩阵串起来，通过axis参数调节横向（1）和纵向（0/默认）</li>\n<li>ones/zeros/ones_like/zeros_like<br>\n创建全1/0矩阵/创建和矩阵相同维度的全1/0矩阵</li>\n<li>identity<br>\n创建单位矩阵</li>\n<li>eye<br>\n创建方阵（长宽都相当的矩阵），指定莫个对角线为1,其它为0</li>\n</ul></li>\n<li>提取\n<ul>\n<li>logical_and/logical_not/logical_or<br>\n逻辑与/逻辑非/逻辑或</li>\n<li>where<br>\n跟if类似</li>\n<li>isnan/isfinite<br>\n是否是一个数/无穷</li>\n<li>take/put<br>\n将一个矩阵里的元素当索引提取/存放矩阵</li>\n<li></li>\n</ul></li>\n<li>方法\n<ul>\n<li>abs/sign/sqrt/log/log10/exp<br>\n绝对值/取符号位/开根号/以2为底的对数/以10为底的对数/指数</li>\n<li>floor/ceil/rint<br>\n向下取整/向上取整/四舍五入取整</li>\n<li>sin/cos/tan/arcsin/arccos/arctan<br>\n正弦/余弦/正切/反正弦/反余弦/反正切</li>\n<li>sinh/cosh/tanh/arcsinh/arccoh/arctanh<br>\n双曲正弦/双曲余弦/反双曲正弦/反双曲余弦/反双曲正切</li>\n<li>dot/outer/inner/cross<br>\n点乘/外积/内积/向量积</li>\n<li>median/corrcoef/cov<br>\n求中位数/相关系数/协方差</li>\n<li></li>\n</ul></li>\n</ol>\n<h2 id=\"线性代数\">线性代数</h2>\n<p>包含线性代数的所有的函数都包含在linalg子库中。</p>\n<ul>\n<li>det/eig/inv/pinv/svd<br>\n求矩阵的行列式/特征值和向量/逆/伪逆/奇异值分解</li>\n<li></li>\n</ul>\n<h2 id=\"傅里叶变换\">傅里叶变换</h2>\n<p>关于傅里叶变换的函数包含在fft子库中。</p>\n<h2 id=\"随机数生成\">随机数生成</h2>\n<p>关于随机数的生成函数都在random子库中。</p>\n<ul>\n<li>seed<br>\n设定随机种子</li>\n<li>rand<br>\n构建随机矩阵</li>\n<li>random<br>\n获取一个随机数</li>\n<li></li>\n</ul>\n<h2 id=\"多项式\">多项式</h2>\n<p>关于多项处理的函数都在polynomial子库中。</p>\n<h2 id=\"测试工具\">测试工具</h2>\n<p>关于测试工具的函数在testing子库中。</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://www.python.org/\" target=\"_blank\" rel=\"external\">python官网</a></li>\n<li><a href=\"http://www.pythondoc.com/pythontutorial27/\" target=\"_blank\" rel=\"external\">Python27入门指南</a></li>\n<li><a href=\"http://www.pythondoc.com/pythontutorial3/index.html\" target=\"_blank\" rel=\"external\">Python35入门指南</a></li>\n<li><a href=\"https://github.com/numpy/numpy\" target=\"_blank\" rel=\"external\">numpy源码</a></li>\n<li><a href=\"https://docs.scipy.org/doc/numpy-dev/user/quickstart.html\" target=\"_blank\" rel=\"external\">numpy快速入门</a></li>\n<li><a href=\"http://reverland.org/python/2012/08/22/numpy/\" target=\"_blank\" rel=\"external\">numpy教程</a></li>\n<li><a href=\"http://www.engr.ucsb.edu/~shell/che210d/numpy.pdf\" target=\"_blank\" rel=\"external\">numpy初入门</a></li>\n</ol>"},{"layout":"post","title":"macbook操作系统OSX初探","comments":1,"_content":"经过一番货比三家后，终于通过苹果内部员工的85折拿下了这款Macbook Pro MF840。今天怀着激动兴奋的心情，拆了配送包裹，好好把玩了一天。本篇博文对OS X系统内置的APP进行一些摸索，最后在系统中安装了VMWare Fusion虚拟机来搭建自己的Ubuntu工作环境。而下篇博文[macbook常用软件及其管理]({{site.baseurl}}/2015/12/10/macbook常用软件及其管理.html})将详细介绍苹果系统的[软件包管理][homebrew]以及常用的软件。\n<!-- more -->\n\n## OS X系统\n苹果原生的系统还是很给力的，省电啥的还没有深刻体会，但是界面的美观，操作的流畅还是留下很深的印象。其内置的APP也是挺给力的，详细介绍见[Mac之妙][mac_app]，下面简要介绍一些。\n\n* 融入日常类\n    * 邮件  \n    集成iCloud，126和Gmail等常见的电子邮件服务。**赶快使用**\n    * 日历  \n    创建多个单独的日历来跟踪管理看似复杂却简单的日程。**赶快使用**\n    * 提醒事项  \n    相当于一个便笺，在特定的日期和时间提醒你该干什么。**赶快使用**\n    * 备忘录  \n    相当于一个随手笔记，可以随手记下闪现的灵感，还可以和Safari，照片和地图等APP联合使用。功能方面和印象笔记有点类似。**赶快使用**\n    * 通讯录  \n    它可以配合信息/FaceTime/邮件等使用。非常方便。**赶快使用**\n    * 信息/FaceTime  \n    Apple设备之间通信的工具，分别对应文本图片和音频视频。**跟微信/QQ有的一拼**\n    * iBooks  \n    Mac上用来看书的工具，书的排版没得说，缺陷就是书源少要收费。**可以和iKindle组合使用**\n    * 地图  \n    怎么说呢，甩百度两条街吧，配合它的触摸板，完美。**赶快使用**\n* 重点研究类\n    * automator[crontab]/脚本编辑器\n    自动执行常用任务，这个是日后重点研究的工具。**重点研究**\n    * 照片  \n    该应用除了让图库的管理更加轻松，可以添加位置信息，还可以批量更改图片信息等。最关键的是可以和强大且易用的编辑工具（PS/Gimp）配合使用。**重点研究**\n    * iMovie  \n    和照片的的功能类似，不过处理的对象是视频。**等图片摸透再了解吧**\n    * GarageBand  \n这次的对象是音频，可以玩转音乐。**目前只想听听歌，码码代码**\n* 打入冷宫型\n    * Pages/Numbers/Keynote  \n    分别对应Office里面的Word/Excel/PowerPoint，但是却兼容它们。**基本被Tex取代，只用来查看Office文档**\n    * App Store  \n    它的功能和Ubuntu里的软件中心类似，不过作为一个码农，还是打算将软件的管理通过命令来来维护。 **基本被HomeBrew取代**\n    * Safari  \n    苹果内置的浏览器，看视频需要adobe flash player插件。**完全被Chrome取代，可以打入冷宫**\n    * iTunes  \n    Mac上的娱乐大本营，可以听歌看电影。缺陷就是片源少还要钱。**基本被XBMC取代**\n* 不常用但实用型\n    * 活动监视器[任务管理器]\n    * 数码测色计[取色板]\n    * 迁移助理  \n    支持Mac-Mac，PC-Mac，TimeMachine-Mac快速迁移文件。\n    * 钥匙串访问  \n    安全存储你使用的所有密码\n\n## 更新&设置\n1. 系统更新  \n可能你当前的系统的并不是最新版本，所以进入系统后第一件事情就是联网，然后到APP Store里把系统和软件更新到最新版本。更新的同时可以了解苹果系统。\n\n2. 偏好设置  \n    * 触控版[学习触控版的手势]\n    * 鼠标滚轮方向[取消自然的滚动方向]\n\n## 虚拟机[VirtualBox][virbox]\n原因很简单，苹果的硬件+苹果的软件这样的组合才能奉献最佳的性能，多系统对于Macbook而言就是对硬件资源的浪费。虽说Mac支持Windows，但对于我而言，Windows只剩下游戏值得流连忘返，而我的工作环境现在只有Ubuntu。在熟悉OS X系统的过程中，Ubuntu应该还是主要的工作场所，所以虚拟机还是必不可少的。之前由于研究的不够仔细，认为VMware fusion无法支持在不同平台下运行着的虚拟机，这是不对的。要通过`文件->打开`的方式运行，通过`导入->选择现有虚拟机`的方式是无法成功的。在这样的情况下，选择Virtual Box还是VMware fusion就纯看各自心情了。我选择VMware fusion，一方面是接触VMware比较早，毕竟“初恋”是难忘的;另一方面是它对Windows和Linux的支持更到位些。优势如下：\n* 完美支持OS X EI Capitan和Windows 10,并对它们进行了优化。[对我意义不大]\n* 在Mac下虚拟运行Mac OS X EI Capitan[可以独立母系统开发Mac应用程序]\n* 高性能的3D图形加速处理能力[使得在虚拟机里面玩游戏有了点可能]\n\n安装过程很简单，直接从[官网][vmware_download]下载VMWare Fusion 8 Pro，之后通过激活码`FY7N2-6RGD2-081XZ-UYWQC-ZPKCA`激活即可。\n\n\nVirtual Box的安装也很简单，也是从[官网][virtual_download]下载Virtual Box for mac，因为它是开源的，所以不用激活啥的。\n> **Tips: vdi扩容**  \n> 默认情况下，Mac里的VirtualBox会给虚拟机分配8G的磁盘空间，但这是远远不能满足我们的工作需要的，所以当安装虚拟机时不幸分配过小的磁盘空间，可以通过下面简单的方式给虚拟机扩容\n>\n> ```sh\n> # 20480的单位是MB，所以这里扩容到20G\n> VBoxManage modifyhd xxx.vdi -resize 20480\n> ```\n\n\n## 参考文献\n1. [Mac之妙，秒在它能帮你做到的一切][mac_app]\n2. [WMWare Fusion 8 pro下载][vmware_download]\n2. [WMWare Fusion 8 Pro简介][vmware]\n3. [homebrew官网][homebrew]\n4. [Virtual Box下载][virtual_download]\n\n[mac_app]:  http://www.apple.com/cn/osx/apps/\n[vmware]:   http://www.iplaysoft.com/vmware-fusion.html\n[vmware_download]:  http://www.vmware.com/products/fusion/\n[homebrew]: http://brew.sh\n[virtual_download]: https://www.virtualbox.org/wiki/Downloads\n","source":"_posts/2015-12-09-macbook操作系统OSX初探.md","raw":"---\nlayout:\tpost\ntitle:\tmacbook操作系统OSX初探\ncategories:\n- TECHNOLOGY\ntags:\n- Mac\n- OSX\npermalink:  Explore-OSX\ncomments:\ttrue\n---\n经过一番货比三家后，终于通过苹果内部员工的85折拿下了这款Macbook Pro MF840。今天怀着激动兴奋的心情，拆了配送包裹，好好把玩了一天。本篇博文对OS X系统内置的APP进行一些摸索，最后在系统中安装了VMWare Fusion虚拟机来搭建自己的Ubuntu工作环境。而下篇博文[macbook常用软件及其管理]({{site.baseurl}}/2015/12/10/macbook常用软件及其管理.html})将详细介绍苹果系统的[软件包管理][homebrew]以及常用的软件。\n<!-- more -->\n\n## OS X系统\n苹果原生的系统还是很给力的，省电啥的还没有深刻体会，但是界面的美观，操作的流畅还是留下很深的印象。其内置的APP也是挺给力的，详细介绍见[Mac之妙][mac_app]，下面简要介绍一些。\n\n* 融入日常类\n    * 邮件  \n    集成iCloud，126和Gmail等常见的电子邮件服务。**赶快使用**\n    * 日历  \n    创建多个单独的日历来跟踪管理看似复杂却简单的日程。**赶快使用**\n    * 提醒事项  \n    相当于一个便笺，在特定的日期和时间提醒你该干什么。**赶快使用**\n    * 备忘录  \n    相当于一个随手笔记，可以随手记下闪现的灵感，还可以和Safari，照片和地图等APP联合使用。功能方面和印象笔记有点类似。**赶快使用**\n    * 通讯录  \n    它可以配合信息/FaceTime/邮件等使用。非常方便。**赶快使用**\n    * 信息/FaceTime  \n    Apple设备之间通信的工具，分别对应文本图片和音频视频。**跟微信/QQ有的一拼**\n    * iBooks  \n    Mac上用来看书的工具，书的排版没得说，缺陷就是书源少要收费。**可以和iKindle组合使用**\n    * 地图  \n    怎么说呢，甩百度两条街吧，配合它的触摸板，完美。**赶快使用**\n* 重点研究类\n    * automator[crontab]/脚本编辑器\n    自动执行常用任务，这个是日后重点研究的工具。**重点研究**\n    * 照片  \n    该应用除了让图库的管理更加轻松，可以添加位置信息，还可以批量更改图片信息等。最关键的是可以和强大且易用的编辑工具（PS/Gimp）配合使用。**重点研究**\n    * iMovie  \n    和照片的的功能类似，不过处理的对象是视频。**等图片摸透再了解吧**\n    * GarageBand  \n这次的对象是音频，可以玩转音乐。**目前只想听听歌，码码代码**\n* 打入冷宫型\n    * Pages/Numbers/Keynote  \n    分别对应Office里面的Word/Excel/PowerPoint，但是却兼容它们。**基本被Tex取代，只用来查看Office文档**\n    * App Store  \n    它的功能和Ubuntu里的软件中心类似，不过作为一个码农，还是打算将软件的管理通过命令来来维护。 **基本被HomeBrew取代**\n    * Safari  \n    苹果内置的浏览器，看视频需要adobe flash player插件。**完全被Chrome取代，可以打入冷宫**\n    * iTunes  \n    Mac上的娱乐大本营，可以听歌看电影。缺陷就是片源少还要钱。**基本被XBMC取代**\n* 不常用但实用型\n    * 活动监视器[任务管理器]\n    * 数码测色计[取色板]\n    * 迁移助理  \n    支持Mac-Mac，PC-Mac，TimeMachine-Mac快速迁移文件。\n    * 钥匙串访问  \n    安全存储你使用的所有密码\n\n## 更新&设置\n1. 系统更新  \n可能你当前的系统的并不是最新版本，所以进入系统后第一件事情就是联网，然后到APP Store里把系统和软件更新到最新版本。更新的同时可以了解苹果系统。\n\n2. 偏好设置  \n    * 触控版[学习触控版的手势]\n    * 鼠标滚轮方向[取消自然的滚动方向]\n\n## 虚拟机[VirtualBox][virbox]\n原因很简单，苹果的硬件+苹果的软件这样的组合才能奉献最佳的性能，多系统对于Macbook而言就是对硬件资源的浪费。虽说Mac支持Windows，但对于我而言，Windows只剩下游戏值得流连忘返，而我的工作环境现在只有Ubuntu。在熟悉OS X系统的过程中，Ubuntu应该还是主要的工作场所，所以虚拟机还是必不可少的。之前由于研究的不够仔细，认为VMware fusion无法支持在不同平台下运行着的虚拟机，这是不对的。要通过`文件->打开`的方式运行，通过`导入->选择现有虚拟机`的方式是无法成功的。在这样的情况下，选择Virtual Box还是VMware fusion就纯看各自心情了。我选择VMware fusion，一方面是接触VMware比较早，毕竟“初恋”是难忘的;另一方面是它对Windows和Linux的支持更到位些。优势如下：\n* 完美支持OS X EI Capitan和Windows 10,并对它们进行了优化。[对我意义不大]\n* 在Mac下虚拟运行Mac OS X EI Capitan[可以独立母系统开发Mac应用程序]\n* 高性能的3D图形加速处理能力[使得在虚拟机里面玩游戏有了点可能]\n\n安装过程很简单，直接从[官网][vmware_download]下载VMWare Fusion 8 Pro，之后通过激活码`FY7N2-6RGD2-081XZ-UYWQC-ZPKCA`激活即可。\n\n\nVirtual Box的安装也很简单，也是从[官网][virtual_download]下载Virtual Box for mac，因为它是开源的，所以不用激活啥的。\n> **Tips: vdi扩容**  \n> 默认情况下，Mac里的VirtualBox会给虚拟机分配8G的磁盘空间，但这是远远不能满足我们的工作需要的，所以当安装虚拟机时不幸分配过小的磁盘空间，可以通过下面简单的方式给虚拟机扩容\n>\n> ```sh\n> # 20480的单位是MB，所以这里扩容到20G\n> VBoxManage modifyhd xxx.vdi -resize 20480\n> ```\n\n\n## 参考文献\n1. [Mac之妙，秒在它能帮你做到的一切][mac_app]\n2. [WMWare Fusion 8 pro下载][vmware_download]\n2. [WMWare Fusion 8 Pro简介][vmware]\n3. [homebrew官网][homebrew]\n4. [Virtual Box下载][virtual_download]\n\n[mac_app]:  http://www.apple.com/cn/osx/apps/\n[vmware]:   http://www.iplaysoft.com/vmware-fusion.html\n[vmware_download]:  http://www.vmware.com/products/fusion/\n[homebrew]: http://brew.sh\n[virtual_download]: https://www.virtualbox.org/wiki/Downloads\n","slug":"Explore-OSX","published":1,"date":"2015-12-08T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1n001tl73ygtvwxv65","content":"<p>经过一番货比三家后，终于通过苹果内部员工的85折拿下了这款Macbook Pro MF840。今天怀着激动兴奋的心情，拆了配送包裹，好好把玩了一天。本篇博文对OS X系统内置的APP进行一些摸索，最后在系统中安装了VMWare Fusion虚拟机来搭建自己的Ubuntu工作环境。而下篇博文[macbook常用软件及其管理](/2015/12/10/macbook常用软件及其管理.html})将详细介绍苹果系统的<a href=\"http://brew.sh\" target=\"_blank\" rel=\"external\">软件包管理</a>以及常用的软件。 <a id=\"more\"></a></p>\n<h2 id=\"os-x系统\">OS X系统</h2>\n<p>苹果原生的系统还是很给力的，省电啥的还没有深刻体会，但是界面的美观，操作的流畅还是留下很深的印象。其内置的APP也是挺给力的，详细介绍见<a href=\"http://www.apple.com/cn/osx/apps/\" target=\"_blank\" rel=\"external\">Mac之妙</a>，下面简要介绍一些。</p>\n<ul>\n<li>融入日常类\n<ul>\n<li>邮件<br>\n集成iCloud，126和Gmail等常见的电子邮件服务。<strong>赶快使用</strong></li>\n<li>日历<br>\n创建多个单独的日历来跟踪管理看似复杂却简单的日程。<strong>赶快使用</strong></li>\n<li>提醒事项<br>\n相当于一个便笺，在特定的日期和时间提醒你该干什么。<strong>赶快使用</strong></li>\n<li>备忘录<br>\n相当于一个随手笔记，可以随手记下闪现的灵感，还可以和Safari，照片和地图等APP联合使用。功能方面和印象笔记有点类似。<strong>赶快使用</strong></li>\n<li>通讯录<br>\n它可以配合信息/FaceTime/邮件等使用。非常方便。<strong>赶快使用</strong></li>\n<li>信息/FaceTime<br>\nApple设备之间通信的工具，分别对应文本图片和音频视频。<strong>跟微信/QQ有的一拼</strong></li>\n<li>iBooks<br>\nMac上用来看书的工具，书的排版没得说，缺陷就是书源少要收费。<strong>可以和iKindle组合使用</strong></li>\n<li>地图<br>\n怎么说呢，甩百度两条街吧，配合它的触摸板，完美。<strong>赶快使用</strong></li>\n</ul></li>\n<li>重点研究类\n<ul>\n<li>automator[crontab]/脚本编辑器 自动执行常用任务，这个是日后重点研究的工具。<strong>重点研究</strong></li>\n<li>照片<br>\n该应用除了让图库的管理更加轻松，可以添加位置信息，还可以批量更改图片信息等。最关键的是可以和强大且易用的编辑工具（PS/Gimp）配合使用。<strong>重点研究</strong></li>\n<li>iMovie<br>\n和照片的的功能类似，不过处理的对象是视频。<strong>等图片摸透再了解吧</strong></li>\n<li>GarageBand<br>\n这次的对象是音频，可以玩转音乐。<strong>目前只想听听歌，码码代码</strong></li>\n</ul></li>\n<li>打入冷宫型\n<ul>\n<li>Pages/Numbers/Keynote<br>\n分别对应Office里面的Word/Excel/PowerPoint，但是却兼容它们。<strong>基本被Tex取代，只用来查看Office文档</strong></li>\n<li>App Store<br>\n它的功能和Ubuntu里的软件中心类似，不过作为一个码农，还是打算将软件的管理通过命令来来维护。 <strong>基本被HomeBrew取代</strong></li>\n<li>Safari<br>\n苹果内置的浏览器，看视频需要adobe flash player插件。<strong>完全被Chrome取代，可以打入冷宫</strong></li>\n<li>iTunes<br>\nMac上的娱乐大本营，可以听歌看电影。缺陷就是片源少还要钱。<strong>基本被XBMC取代</strong></li>\n</ul></li>\n<li>不常用但实用型\n<ul>\n<li>活动监视器[任务管理器]</li>\n<li>数码测色计[取色板]</li>\n<li>迁移助理<br>\n支持Mac-Mac，PC-Mac，TimeMachine-Mac快速迁移文件。</li>\n<li>钥匙串访问<br>\n安全存储你使用的所有密码</li>\n</ul></li>\n</ul>\n<h2 id=\"更新设置\">更新&amp;设置</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>系统更新<br>\n可能你当前的系统的并不是最新版本，所以进入系统后第一件事情就是联网，然后到APP Store里把系统和软件更新到最新版本。更新的同时可以了解苹果系统。</p></li>\n<li>偏好设置\n<ul>\n<li>触控版[学习触控版的手势]</li>\n<li>鼠标滚轮方向[取消自然的滚动方向]</li>\n</ul></li>\n</ol>\n<h2 id=\"虚拟机virtualboxvirbox\">虚拟机[VirtualBox][virbox]</h2>\n<p>原因很简单，苹果的硬件+苹果的软件这样的组合才能奉献最佳的性能，多系统对于Macbook而言就是对硬件资源的浪费。虽说Mac支持Windows，但对于我而言，Windows只剩下游戏值得流连忘返，而我的工作环境现在只有Ubuntu。在熟悉OS X系统的过程中，Ubuntu应该还是主要的工作场所，所以虚拟机还是必不可少的。之前由于研究的不够仔细，认为VMware fusion无法支持在不同平台下运行着的虚拟机，这是不对的。要通过<code>文件-&gt;打开</code>的方式运行，通过<code>导入-&gt;选择现有虚拟机</code>的方式是无法成功的。在这样的情况下，选择Virtual Box还是VMware fusion就纯看各自心情了。我选择VMware fusion，一方面是接触VMware比较早，毕竟“初恋”是难忘的;另一方面是它对Windows和Linux的支持更到位些。优势如下： * 完美支持OS X EI Capitan和Windows 10,并对它们进行了优化。[对我意义不大] * 在Mac下虚拟运行Mac OS X EI Capitan[可以独立母系统开发Mac应用程序] * 高性能的3D图形加速处理能力[使得在虚拟机里面玩游戏有了点可能]</p>\n<p>安装过程很简单，直接从<a href=\"http://www.vmware.com/products/fusion/\" target=\"_blank\" rel=\"external\">官网</a>下载VMWare Fusion 8 Pro，之后通过激活码<code>FY7N2-6RGD2-081XZ-UYWQC-ZPKCA</code>激活即可。</p>\n<p>Virtual Box的安装也很简单，也是从<a href=\"https://www.virtualbox.org/wiki/Downloads\" target=\"_blank\" rel=\"external\">官网</a>下载Virtual Box for mac，因为它是开源的，所以不用激活啥的。 &gt; <strong>Tips: vdi扩容</strong><br>\n&gt; 默认情况下，Mac里的VirtualBox会给虚拟机分配8G的磁盘空间，但这是远远不能满足我们的工作需要的，所以当安装虚拟机时不幸分配过小的磁盘空间，可以通过下面简单的方式给虚拟机扩容 &gt; &gt; <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; <span class=\"comment\"># 20480的单位是MB，所以这里扩容到20G</span></div><div class=\"line\">&gt; VBoxManage modifyhd xxx.vdi -resize 20480</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://www.apple.com/cn/osx/apps/\" target=\"_blank\" rel=\"external\">Mac之妙，秒在它能帮你做到的一切</a></li>\n<li><a href=\"http://www.vmware.com/products/fusion/\" target=\"_blank\" rel=\"external\">WMWare Fusion 8 pro下载</a></li>\n<li><a href=\"http://www.iplaysoft.com/vmware-fusion.html\" target=\"_blank\" rel=\"external\">WMWare Fusion 8 Pro简介</a></li>\n<li><a href=\"http://brew.sh\" target=\"_blank\" rel=\"external\">homebrew官网</a></li>\n<li><a href=\"https://www.virtualbox.org/wiki/Downloads\" target=\"_blank\" rel=\"external\">Virtual Box下载</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>经过一番货比三家后，终于通过苹果内部员工的85折拿下了这款Macbook Pro MF840。今天怀着激动兴奋的心情，拆了配送包裹，好好把玩了一天。本篇博文对OS X系统内置的APP进行一些摸索，最后在系统中安装了VMWare Fusion虚拟机来搭建自己的Ubuntu工作环境。而下篇博文[macbook常用软件及其管理](/2015/12/10/macbook常用软件及其管理.html})将详细介绍苹果系统的<a href=\"http://brew.sh\" target=\"_blank\" rel=\"external\">软件包管理</a>以及常用的软件。","more":"</p>\n<h2 id=\"os-x系统\">OS X系统</h2>\n<p>苹果原生的系统还是很给力的，省电啥的还没有深刻体会，但是界面的美观，操作的流畅还是留下很深的印象。其内置的APP也是挺给力的，详细介绍见<a href=\"http://www.apple.com/cn/osx/apps/\" target=\"_blank\" rel=\"external\">Mac之妙</a>，下面简要介绍一些。</p>\n<ul>\n<li>融入日常类\n<ul>\n<li>邮件<br>\n集成iCloud，126和Gmail等常见的电子邮件服务。<strong>赶快使用</strong></li>\n<li>日历<br>\n创建多个单独的日历来跟踪管理看似复杂却简单的日程。<strong>赶快使用</strong></li>\n<li>提醒事项<br>\n相当于一个便笺，在特定的日期和时间提醒你该干什么。<strong>赶快使用</strong></li>\n<li>备忘录<br>\n相当于一个随手笔记，可以随手记下闪现的灵感，还可以和Safari，照片和地图等APP联合使用。功能方面和印象笔记有点类似。<strong>赶快使用</strong></li>\n<li>通讯录<br>\n它可以配合信息/FaceTime/邮件等使用。非常方便。<strong>赶快使用</strong></li>\n<li>信息/FaceTime<br>\nApple设备之间通信的工具，分别对应文本图片和音频视频。<strong>跟微信/QQ有的一拼</strong></li>\n<li>iBooks<br>\nMac上用来看书的工具，书的排版没得说，缺陷就是书源少要收费。<strong>可以和iKindle组合使用</strong></li>\n<li>地图<br>\n怎么说呢，甩百度两条街吧，配合它的触摸板，完美。<strong>赶快使用</strong></li>\n</ul></li>\n<li>重点研究类\n<ul>\n<li>automator[crontab]/脚本编辑器 自动执行常用任务，这个是日后重点研究的工具。<strong>重点研究</strong></li>\n<li>照片<br>\n该应用除了让图库的管理更加轻松，可以添加位置信息，还可以批量更改图片信息等。最关键的是可以和强大且易用的编辑工具（PS/Gimp）配合使用。<strong>重点研究</strong></li>\n<li>iMovie<br>\n和照片的的功能类似，不过处理的对象是视频。<strong>等图片摸透再了解吧</strong></li>\n<li>GarageBand<br>\n这次的对象是音频，可以玩转音乐。<strong>目前只想听听歌，码码代码</strong></li>\n</ul></li>\n<li>打入冷宫型\n<ul>\n<li>Pages/Numbers/Keynote<br>\n分别对应Office里面的Word/Excel/PowerPoint，但是却兼容它们。<strong>基本被Tex取代，只用来查看Office文档</strong></li>\n<li>App Store<br>\n它的功能和Ubuntu里的软件中心类似，不过作为一个码农，还是打算将软件的管理通过命令来来维护。 <strong>基本被HomeBrew取代</strong></li>\n<li>Safari<br>\n苹果内置的浏览器，看视频需要adobe flash player插件。<strong>完全被Chrome取代，可以打入冷宫</strong></li>\n<li>iTunes<br>\nMac上的娱乐大本营，可以听歌看电影。缺陷就是片源少还要钱。<strong>基本被XBMC取代</strong></li>\n</ul></li>\n<li>不常用但实用型\n<ul>\n<li>活动监视器[任务管理器]</li>\n<li>数码测色计[取色板]</li>\n<li>迁移助理<br>\n支持Mac-Mac，PC-Mac，TimeMachine-Mac快速迁移文件。</li>\n<li>钥匙串访问<br>\n安全存储你使用的所有密码</li>\n</ul></li>\n</ul>\n<h2 id=\"更新设置\">更新&amp;设置</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>系统更新<br>\n可能你当前的系统的并不是最新版本，所以进入系统后第一件事情就是联网，然后到APP Store里把系统和软件更新到最新版本。更新的同时可以了解苹果系统。</p></li>\n<li>偏好设置\n<ul>\n<li>触控版[学习触控版的手势]</li>\n<li>鼠标滚轮方向[取消自然的滚动方向]</li>\n</ul></li>\n</ol>\n<h2 id=\"虚拟机virtualboxvirbox\">虚拟机[VirtualBox][virbox]</h2>\n<p>原因很简单，苹果的硬件+苹果的软件这样的组合才能奉献最佳的性能，多系统对于Macbook而言就是对硬件资源的浪费。虽说Mac支持Windows，但对于我而言，Windows只剩下游戏值得流连忘返，而我的工作环境现在只有Ubuntu。在熟悉OS X系统的过程中，Ubuntu应该还是主要的工作场所，所以虚拟机还是必不可少的。之前由于研究的不够仔细，认为VMware fusion无法支持在不同平台下运行着的虚拟机，这是不对的。要通过<code>文件-&gt;打开</code>的方式运行，通过<code>导入-&gt;选择现有虚拟机</code>的方式是无法成功的。在这样的情况下，选择Virtual Box还是VMware fusion就纯看各自心情了。我选择VMware fusion，一方面是接触VMware比较早，毕竟“初恋”是难忘的;另一方面是它对Windows和Linux的支持更到位些。优势如下： * 完美支持OS X EI Capitan和Windows 10,并对它们进行了优化。[对我意义不大] * 在Mac下虚拟运行Mac OS X EI Capitan[可以独立母系统开发Mac应用程序] * 高性能的3D图形加速处理能力[使得在虚拟机里面玩游戏有了点可能]</p>\n<p>安装过程很简单，直接从<a href=\"http://www.vmware.com/products/fusion/\" target=\"_blank\" rel=\"external\">官网</a>下载VMWare Fusion 8 Pro，之后通过激活码<code>FY7N2-6RGD2-081XZ-UYWQC-ZPKCA</code>激活即可。</p>\n<p>Virtual Box的安装也很简单，也是从<a href=\"https://www.virtualbox.org/wiki/Downloads\" target=\"_blank\" rel=\"external\">官网</a>下载Virtual Box for mac，因为它是开源的，所以不用激活啥的。 &gt; <strong>Tips: vdi扩容</strong><br>\n&gt; 默认情况下，Mac里的VirtualBox会给虚拟机分配8G的磁盘空间，但这是远远不能满足我们的工作需要的，所以当安装虚拟机时不幸分配过小的磁盘空间，可以通过下面简单的方式给虚拟机扩容 &gt; &gt; <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; <span class=\"comment\"># 20480的单位是MB，所以这里扩容到20G</span></div><div class=\"line\">&gt; VBoxManage modifyhd xxx.vdi -resize 20480</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://www.apple.com/cn/osx/apps/\" target=\"_blank\" rel=\"external\">Mac之妙，秒在它能帮你做到的一切</a></li>\n<li><a href=\"http://www.vmware.com/products/fusion/\" target=\"_blank\" rel=\"external\">WMWare Fusion 8 pro下载</a></li>\n<li><a href=\"http://www.iplaysoft.com/vmware-fusion.html\" target=\"_blank\" rel=\"external\">WMWare Fusion 8 Pro简介</a></li>\n<li><a href=\"http://brew.sh\" target=\"_blank\" rel=\"external\">homebrew官网</a></li>\n<li><a href=\"https://www.virtualbox.org/wiki/Downloads\" target=\"_blank\" rel=\"external\">Virtual Box下载</a></li>\n</ol>"},{"layout":"post","title":"Python里的数据科学之matplotlib实战","comments":1,"date":"2015-12-07T05:46:20.000Z","_content":"这篇和Numpy类似，是用来将matplotlib在日常实践中作的图片作一个总结，方便以后查询上手。\n<!-- more -->\n\n\n## 简介\nMatlplotlib是Python的一个可视化模块。该项目是由John D. Hunter发起的，但却是受Matlab启发构建的，并且有一套完全仿照Matlab函数形式的绘图接口。它让你方便地制作线条图、饼图、柱状图以及其它专业图形。使用Matplotlib，你可以定制所做图表的任一方面。\n\n\n## 散点图\n散点图是我们最常见的一种图，它一样用来显示数据点在直角坐标系平面上的分布图例。在我们不清楚数据点之间的关系时，常做该图来直观显示数据的分步情况，以便做进一步分析。\n* 图例如下：  \n![scatter]({{site.baseurl}}/assets/images/scatter.jpg)\n\n* 代码解析如下：\n\n    ```py\n    \"\"\"\n    Simple demo of a scatter plot.\n    \"\"\"\n    # coding=utf-8\n    #!/usr/bin/python\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # matplotlib支持中文\n    from pylab import mpl\n    mpl.rcParams['font.sans-serif'] = ['SimHei'] #指定默认字体\n    mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是符号的‘-’显示为方块的问题\n\n    # 构造数据\n    N = 50\n    x = np.arange(N)\n    y1 = np.random.rand(N)*25\n    y2 = np.random.rand(N)*25+25\n\n\n    ## scatter常用参数\n    # s[ize]    点的大小\n    # c[olor]   点的颜色\n    # marker    点的图案\n    # alpha     透明度\n    # label     图例说明中的标签\n    plt.scatter(x, y1, s=50, c='b', marker='+', alpha=0.5，label=‘ClassA’)\n    plt.scatter(x, y2, s=100, c='r', marker='.', alpha=0.5，label=‘ClassB’)\n    ## X/Y轴的的极限\n    xdelt = x.max() - x.min()\n    plt.xlim(x.min()-0.1*xdelt,x.max()+0.1*xdelt)\n    plt.ylim(0,50)\n    ## 横纵坐标说明\n    plt.xlabel(u'x值说明',fontsize=16)\n    plt.ylabel(u'y值说明',fontsize=16,rotation='horizontal')\n    ## 添加图例\n    plt.legend(loc=‘upper left’，frameon=True)\n    ## 图的标题\n    plt.title(u'scatter图',fontsize=20)\n    ## 保存图片\n    plt.savefig('scatter.jpg')\n    ## 显示图片\n    plt.show()\n    ```\n\n## 折线图\n折线图也是我们常见的一种图，它常用来显示数据的走向趋势。在数据分析中，常用来处理随时间而变化的连续数据。\n\n* 图例如下：  \n![polygonal]({{site.baseurl}}/assets/images/polygonal.jpg)\n\n* 代码解析如下：\n\n    ```py\n    \"\"\"\n    Simple demo of a polygonal plot.\n    \"\"\"\n    # coding=utf-8\n    #!/usr/bin/python\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # matplotlib支持中文\n    from pylab import mpl\n    mpl.rcParams['font.sans-serif'] = ['SimHei'] #指定默认字体\n    mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是符号的‘-’显示为方块的问题\n\n    # 构造数据\n    N = 50\n    x = np.linspace(-2,2,N)\n    y1 = x**3\n    y2 = np.sin(x)\n\n\n    ## plot常用参数\n    # 'b'       设置颜色和点的图案\n    # marker    点的图案\n    # label     图例说明中的标签\n    # linewidth 线宽\n    plt.plot(x, y1, 'b*-', label=‘$x^3$’, linewidth=2)\n    plt.plot(x, y2, 'r', label=‘$sin(x)$’, linewidth=2)\n    ## 设置坐标轴\n    ax= plt.gca()       # 获取当前坐标系实例\n    # 轴线/标尺设置\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.xaxis.set_ticks_position('bottom')   # X轴标尺在轴线下面\n    ax.spines['bottom'].set_position(('data',0))    # 底部轴线在数据区0的位置\n    ax.yaxis.set_ticks_position('left')     # Y轴标尺在轴线左边\n    ax.spines['left'].set_position(('data',0))  # 左边轴线在数据区0的位置\n    ## X/Y轴的的极限\n    xdelt = x.max() - x.min()\n    plt.xlim(x.min()-0.1*xdelt,x.max()+0.1*xdelt)\n    plt.ylim(0,50)\n    ## 横纵坐标说明\n    plt.xlabel(u'x值说明',fontsize=16)\n    plt.ylabel(u'y值说明',fontsize=16,rotation='horizontal')\n    ## 添加图例\n    plt.legend(loc=‘upper left’，frameon=True)\n    ## 图的标题\n    plt.title(u'折线图',fontsize=20)\n    ## 保存图片\n    plt.savefig('polygonal.jpg')\n    ## 显示图片\n    plt.show()\n    ```\n\n## 柱状图\n柱状图也是我们常见的一种图，它也叫条图，是一种以长方形的长度为变量的表达图形的统计报告图，由一系列高度不等的纵向条纹表示数据分布的情况，用来比较两个或以上的价值。在数据分析中，常用来比较不同的模型而产生的不同结果。\n\n* 图例如下：  \n![histogram]({{site.baseurl}}/assets/images/histogram.jpg)\n\n* 代码解析如下：\n\n    ```py\n    \"\"\"\n    Simple demo of a histogram plot.\n    \"\"\"\n    # coding=utf-8\n    #!/usr/bin/python\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # matplotlib支持中文\n    from pylab import mpl\n    mpl.rcParams['font.sans-serif'] = ['SimHei'] #指定默认字体\n    mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是符号的‘-’显示为方块的问题\n\n    # 构造数据\n    mu = 100\n    sigma = 15\n    x = mu + sigma * np.random.randn(10000)\n\n\n    num_bins = 5\n    ## hist常用参数\n    # num_bins  条数\n    # marker    点的图案\n    # label     图例说明中的标签\n    # linewidth 线宽\n    plt.ot(x, y1, 'b', label=‘$x^3$’, linewidth=2)\n    plt.plot(x, y2, 'r', label=‘$sin(x)$’, linewidth=2)\n    ## 设置坐标轴\n    ax= plt.gca()       # 获取当前坐标系实例\n    # 轴线/标尺设置\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.xaxis.set_ticks_position('bottom')   # X轴标尺在轴线下面\n    ax.spines['bottom'].set_position(('data',0))    # 底部轴线在数据区0的位置\n    ax.yaxis.set_ticks_position('left')     # Y轴标尺在轴线左边\n    ax.spines['left'].set_position(('data',0))  # 左边轴线在数据区0的位置\n    ## X/Y轴的的极限\n    xdelt = x.max() - x.min()\n    plt.xlim(x.min()-0.1*xdelt,x.max()+0.1*xdelt)\n    plt.ylim(0,50)\n    ## 横纵坐标说明\n    plt.xlabel(u'x值说明',fontsize=16)\n    plt.ylabel(u'y值说明',fontsize=16,rotation='horizontal')\n    ## 添加图例\n    plt.legend(loc=‘upper left’，frameon=True)\n    ## 图的标题\n    plt.title(u'折线图',fontsize=20)\n    ## 保存图片\n    plt.savefig('polygonal.jpg')\n    ## 显示图片\n    plt.show()\n    ```\n\n## section\n\n\n\n## 参考文献\n1. [matplotlib官网图例][plt_org]\n2. [matplotlib源码][plt_git]\n3. [matplotlib入门][plt_tour]\n\n\n[plt_org]: http://matplotlib.org\n[plt_git]:  https://github.com/matplotlib\n[plt_tour]: http://reverland.org/python/2012/09/07/matplotlib-tutorial/\n","source":"_posts/2015-12-07-python里的数据科学之Matplotlib实战.md","raw":"---\nlayout:\t\tpost\ntitle:\t\tPython里的数据科学之matplotlib实战\ncategories:\n- TECHNOLOGY\ntags:\n- Python\n- ML\n- Plt\npermalink:  Explore-matplotlib-Python\ncomments:\ttrue\ndate:\t\t2015-12-07 13:46:20\n---\n这篇和Numpy类似，是用来将matplotlib在日常实践中作的图片作一个总结，方便以后查询上手。\n<!-- more -->\n\n\n## 简介\nMatlplotlib是Python的一个可视化模块。该项目是由John D. Hunter发起的，但却是受Matlab启发构建的，并且有一套完全仿照Matlab函数形式的绘图接口。它让你方便地制作线条图、饼图、柱状图以及其它专业图形。使用Matplotlib，你可以定制所做图表的任一方面。\n\n\n## 散点图\n散点图是我们最常见的一种图，它一样用来显示数据点在直角坐标系平面上的分布图例。在我们不清楚数据点之间的关系时，常做该图来直观显示数据的分步情况，以便做进一步分析。\n* 图例如下：  \n![scatter]({{site.baseurl}}/assets/images/scatter.jpg)\n\n* 代码解析如下：\n\n    ```py\n    \"\"\"\n    Simple demo of a scatter plot.\n    \"\"\"\n    # coding=utf-8\n    #!/usr/bin/python\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # matplotlib支持中文\n    from pylab import mpl\n    mpl.rcParams['font.sans-serif'] = ['SimHei'] #指定默认字体\n    mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是符号的‘-’显示为方块的问题\n\n    # 构造数据\n    N = 50\n    x = np.arange(N)\n    y1 = np.random.rand(N)*25\n    y2 = np.random.rand(N)*25+25\n\n\n    ## scatter常用参数\n    # s[ize]    点的大小\n    # c[olor]   点的颜色\n    # marker    点的图案\n    # alpha     透明度\n    # label     图例说明中的标签\n    plt.scatter(x, y1, s=50, c='b', marker='+', alpha=0.5，label=‘ClassA’)\n    plt.scatter(x, y2, s=100, c='r', marker='.', alpha=0.5，label=‘ClassB’)\n    ## X/Y轴的的极限\n    xdelt = x.max() - x.min()\n    plt.xlim(x.min()-0.1*xdelt,x.max()+0.1*xdelt)\n    plt.ylim(0,50)\n    ## 横纵坐标说明\n    plt.xlabel(u'x值说明',fontsize=16)\n    plt.ylabel(u'y值说明',fontsize=16,rotation='horizontal')\n    ## 添加图例\n    plt.legend(loc=‘upper left’，frameon=True)\n    ## 图的标题\n    plt.title(u'scatter图',fontsize=20)\n    ## 保存图片\n    plt.savefig('scatter.jpg')\n    ## 显示图片\n    plt.show()\n    ```\n\n## 折线图\n折线图也是我们常见的一种图，它常用来显示数据的走向趋势。在数据分析中，常用来处理随时间而变化的连续数据。\n\n* 图例如下：  \n![polygonal]({{site.baseurl}}/assets/images/polygonal.jpg)\n\n* 代码解析如下：\n\n    ```py\n    \"\"\"\n    Simple demo of a polygonal plot.\n    \"\"\"\n    # coding=utf-8\n    #!/usr/bin/python\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # matplotlib支持中文\n    from pylab import mpl\n    mpl.rcParams['font.sans-serif'] = ['SimHei'] #指定默认字体\n    mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是符号的‘-’显示为方块的问题\n\n    # 构造数据\n    N = 50\n    x = np.linspace(-2,2,N)\n    y1 = x**3\n    y2 = np.sin(x)\n\n\n    ## plot常用参数\n    # 'b'       设置颜色和点的图案\n    # marker    点的图案\n    # label     图例说明中的标签\n    # linewidth 线宽\n    plt.plot(x, y1, 'b*-', label=‘$x^3$’, linewidth=2)\n    plt.plot(x, y2, 'r', label=‘$sin(x)$’, linewidth=2)\n    ## 设置坐标轴\n    ax= plt.gca()       # 获取当前坐标系实例\n    # 轴线/标尺设置\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.xaxis.set_ticks_position('bottom')   # X轴标尺在轴线下面\n    ax.spines['bottom'].set_position(('data',0))    # 底部轴线在数据区0的位置\n    ax.yaxis.set_ticks_position('left')     # Y轴标尺在轴线左边\n    ax.spines['left'].set_position(('data',0))  # 左边轴线在数据区0的位置\n    ## X/Y轴的的极限\n    xdelt = x.max() - x.min()\n    plt.xlim(x.min()-0.1*xdelt,x.max()+0.1*xdelt)\n    plt.ylim(0,50)\n    ## 横纵坐标说明\n    plt.xlabel(u'x值说明',fontsize=16)\n    plt.ylabel(u'y值说明',fontsize=16,rotation='horizontal')\n    ## 添加图例\n    plt.legend(loc=‘upper left’，frameon=True)\n    ## 图的标题\n    plt.title(u'折线图',fontsize=20)\n    ## 保存图片\n    plt.savefig('polygonal.jpg')\n    ## 显示图片\n    plt.show()\n    ```\n\n## 柱状图\n柱状图也是我们常见的一种图，它也叫条图，是一种以长方形的长度为变量的表达图形的统计报告图，由一系列高度不等的纵向条纹表示数据分布的情况，用来比较两个或以上的价值。在数据分析中，常用来比较不同的模型而产生的不同结果。\n\n* 图例如下：  \n![histogram]({{site.baseurl}}/assets/images/histogram.jpg)\n\n* 代码解析如下：\n\n    ```py\n    \"\"\"\n    Simple demo of a histogram plot.\n    \"\"\"\n    # coding=utf-8\n    #!/usr/bin/python\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # matplotlib支持中文\n    from pylab import mpl\n    mpl.rcParams['font.sans-serif'] = ['SimHei'] #指定默认字体\n    mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是符号的‘-’显示为方块的问题\n\n    # 构造数据\n    mu = 100\n    sigma = 15\n    x = mu + sigma * np.random.randn(10000)\n\n\n    num_bins = 5\n    ## hist常用参数\n    # num_bins  条数\n    # marker    点的图案\n    # label     图例说明中的标签\n    # linewidth 线宽\n    plt.ot(x, y1, 'b', label=‘$x^3$’, linewidth=2)\n    plt.plot(x, y2, 'r', label=‘$sin(x)$’, linewidth=2)\n    ## 设置坐标轴\n    ax= plt.gca()       # 获取当前坐标系实例\n    # 轴线/标尺设置\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.xaxis.set_ticks_position('bottom')   # X轴标尺在轴线下面\n    ax.spines['bottom'].set_position(('data',0))    # 底部轴线在数据区0的位置\n    ax.yaxis.set_ticks_position('left')     # Y轴标尺在轴线左边\n    ax.spines['left'].set_position(('data',0))  # 左边轴线在数据区0的位置\n    ## X/Y轴的的极限\n    xdelt = x.max() - x.min()\n    plt.xlim(x.min()-0.1*xdelt,x.max()+0.1*xdelt)\n    plt.ylim(0,50)\n    ## 横纵坐标说明\n    plt.xlabel(u'x值说明',fontsize=16)\n    plt.ylabel(u'y值说明',fontsize=16,rotation='horizontal')\n    ## 添加图例\n    plt.legend(loc=‘upper left’，frameon=True)\n    ## 图的标题\n    plt.title(u'折线图',fontsize=20)\n    ## 保存图片\n    plt.savefig('polygonal.jpg')\n    ## 显示图片\n    plt.show()\n    ```\n\n## section\n\n\n\n## 参考文献\n1. [matplotlib官网图例][plt_org]\n2. [matplotlib源码][plt_git]\n3. [matplotlib入门][plt_tour]\n\n\n[plt_org]: http://matplotlib.org\n[plt_git]:  https://github.com/matplotlib\n[plt_tour]: http://reverland.org/python/2012/09/07/matplotlib-tutorial/\n","slug":"Explore-matplotlib-Python","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1o001ul73y4m23nvnv","content":"<p>这篇和Numpy类似，是用来将matplotlib在日常实践中作的图片作一个总结，方便以后查询上手。 <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p>Matlplotlib是Python的一个可视化模块。该项目是由John D. Hunter发起的，但却是受Matlab启发构建的，并且有一套完全仿照Matlab函数形式的绘图接口。它让你方便地制作线条图、饼图、柱状图以及其它专业图形。使用Matplotlib，你可以定制所做图表的任一方面。</p>\n<h2 id=\"散点图\">散点图</h2>\n<p>散点图是我们最常见的一种图，它一样用来显示数据点在直角坐标系平面上的分布图例。在我们不清楚数据点之间的关系时，常做该图来直观显示数据的分步情况，以便做进一步分析。 * 图例如下：<br>\n[scatter](/assets/images/scatter.jpg)</p>\n<ul>\n<li><p>代码解析如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">Simple demo of a scatter plot.</div><div class=\"line\">\"\"\"</div><div class=\"line\"><span class=\"comment\"># coding=utf-8</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</div><div class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># matplotlib支持中文</span></div><div class=\"line\"><span class=\"keyword\">from</span> pylab <span class=\"keyword\">import</span> mpl</div><div class=\"line\">mpl.rcParams[<span class=\"string\">'font.sans-serif'</span>] = [<span class=\"string\">'SimHei'</span>] <span class=\"comment\">#指定默认字体</span></div><div class=\"line\">mpl.rcParams[<span class=\"string\">'axes.unicode_minus'</span>] = <span class=\"keyword\">False</span> <span class=\"comment\"># 解决保存图像是符号的‘-’显示为方块的问题</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 构造数据</span></div><div class=\"line\">N = <span class=\"number\">50</span></div><div class=\"line\">x = np.arange(N)</div><div class=\"line\">y1 = np.random.rand(N)*<span class=\"number\">25</span></div><div class=\"line\">y2 = np.random.rand(N)*<span class=\"number\">25</span>+<span class=\"number\">25</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">## scatter常用参数</span></div><div class=\"line\"><span class=\"comment\"># s[ize]    点的大小</span></div><div class=\"line\"><span class=\"comment\"># c[olor]   点的颜色</span></div><div class=\"line\"><span class=\"comment\"># marker    点的图案</span></div><div class=\"line\"><span class=\"comment\"># alpha     透明度</span></div><div class=\"line\"><span class=\"comment\"># label     图例说明中的标签</span></div><div class=\"line\">plt.scatter(x, y1, s=<span class=\"number\">50</span>, c=<span class=\"string\">'b'</span>, marker=<span class=\"string\">'+'</span>, alpha=<span class=\"number\">0.5</span>，label=‘ClassA’)</div><div class=\"line\">plt.scatter(x, y2, s=<span class=\"number\">100</span>, c=<span class=\"string\">'r'</span>, marker=<span class=\"string\">'.'</span>, alpha=<span class=\"number\">0.5</span>，label=‘ClassB’)</div><div class=\"line\"><span class=\"comment\">## X/Y轴的的极限</span></div><div class=\"line\">xdelt = x.max() - x.min()</div><div class=\"line\">plt.xlim(x.min()<span class=\"number\">-0.1</span>*xdelt,x.max()+<span class=\"number\">0.1</span>*xdelt)</div><div class=\"line\">plt.ylim(<span class=\"number\">0</span>,<span class=\"number\">50</span>)</div><div class=\"line\"><span class=\"comment\">## 横纵坐标说明</span></div><div class=\"line\">plt.xlabel(<span class=\"string\">u'x值说明'</span>,fontsize=<span class=\"number\">16</span>)</div><div class=\"line\">plt.ylabel(<span class=\"string\">u'y值说明'</span>,fontsize=<span class=\"number\">16</span>,rotation=<span class=\"string\">'horizontal'</span>)</div><div class=\"line\"><span class=\"comment\">## 添加图例</span></div><div class=\"line\">plt.legend(loc=‘upper left’，frameon=<span class=\"keyword\">True</span>)</div><div class=\"line\"><span class=\"comment\">## 图的标题</span></div><div class=\"line\">plt.title(<span class=\"string\">u'scatter图'</span>,fontsize=<span class=\"number\">20</span>)</div><div class=\"line\"><span class=\"comment\">## 保存图片</span></div><div class=\"line\">plt.savefig(<span class=\"string\">'scatter.jpg'</span>)</div><div class=\"line\"><span class=\"comment\">## 显示图片</span></div><div class=\"line\">plt.show()</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"折线图\">折线图</h2>\n<p>折线图也是我们常见的一种图，它常用来显示数据的走向趋势。在数据分析中，常用来处理随时间而变化的连续数据。</p>\n<ul>\n<li><p>图例如下：<br>\n[polygonal](/assets/images/polygonal.jpg)</p></li>\n<li><p>代码解析如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">Simple demo of a polygonal plot.</div><div class=\"line\">\"\"\"</div><div class=\"line\"><span class=\"comment\"># coding=utf-8</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</div><div class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># matplotlib支持中文</span></div><div class=\"line\"><span class=\"keyword\">from</span> pylab <span class=\"keyword\">import</span> mpl</div><div class=\"line\">mpl.rcParams[<span class=\"string\">'font.sans-serif'</span>] = [<span class=\"string\">'SimHei'</span>] <span class=\"comment\">#指定默认字体</span></div><div class=\"line\">mpl.rcParams[<span class=\"string\">'axes.unicode_minus'</span>] = <span class=\"keyword\">False</span> <span class=\"comment\"># 解决保存图像是符号的‘-’显示为方块的问题</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 构造数据</span></div><div class=\"line\">N = <span class=\"number\">50</span></div><div class=\"line\">x = np.linspace(<span class=\"number\">-2</span>,<span class=\"number\">2</span>,N)</div><div class=\"line\">y1 = x**<span class=\"number\">3</span></div><div class=\"line\">y2 = np.sin(x)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">## plot常用参数</span></div><div class=\"line\"><span class=\"comment\"># 'b'       设置颜色和点的图案</span></div><div class=\"line\"><span class=\"comment\"># marker    点的图案</span></div><div class=\"line\"><span class=\"comment\"># label     图例说明中的标签</span></div><div class=\"line\"><span class=\"comment\"># linewidth 线宽</span></div><div class=\"line\">plt.plot(x, y1, <span class=\"string\">'b*-'</span>, label=‘$x^<span class=\"number\">3</span>$’, linewidth=<span class=\"number\">2</span>)</div><div class=\"line\">plt.plot(x, y2, <span class=\"string\">'r'</span>, label=‘$sin(x)$’, linewidth=<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\">## 设置坐标轴</span></div><div class=\"line\">ax= plt.gca()       <span class=\"comment\"># 获取当前坐标系实例</span></div><div class=\"line\"><span class=\"comment\"># 轴线/标尺设置</span></div><div class=\"line\">ax.spines[<span class=\"string\">'right'</span>].set_visible(<span class=\"keyword\">False</span>)</div><div class=\"line\">ax.spines[<span class=\"string\">'top'</span>].set_visible(<span class=\"keyword\">False</span>)</div><div class=\"line\">ax.xaxis.set_ticks_position(<span class=\"string\">'bottom'</span>)   <span class=\"comment\"># X轴标尺在轴线下面</span></div><div class=\"line\">ax.spines[<span class=\"string\">'bottom'</span>].set_position((<span class=\"string\">'data'</span>,<span class=\"number\">0</span>))    <span class=\"comment\"># 底部轴线在数据区0的位置</span></div><div class=\"line\">ax.yaxis.set_ticks_position(<span class=\"string\">'left'</span>)     <span class=\"comment\"># Y轴标尺在轴线左边</span></div><div class=\"line\">ax.spines[<span class=\"string\">'left'</span>].set_position((<span class=\"string\">'data'</span>,<span class=\"number\">0</span>))  <span class=\"comment\"># 左边轴线在数据区0的位置</span></div><div class=\"line\"><span class=\"comment\">## X/Y轴的的极限</span></div><div class=\"line\">xdelt = x.max() - x.min()</div><div class=\"line\">plt.xlim(x.min()<span class=\"number\">-0.1</span>*xdelt,x.max()+<span class=\"number\">0.1</span>*xdelt)</div><div class=\"line\">plt.ylim(<span class=\"number\">0</span>,<span class=\"number\">50</span>)</div><div class=\"line\"><span class=\"comment\">## 横纵坐标说明</span></div><div class=\"line\">plt.xlabel(<span class=\"string\">u'x值说明'</span>,fontsize=<span class=\"number\">16</span>)</div><div class=\"line\">plt.ylabel(<span class=\"string\">u'y值说明'</span>,fontsize=<span class=\"number\">16</span>,rotation=<span class=\"string\">'horizontal'</span>)</div><div class=\"line\"><span class=\"comment\">## 添加图例</span></div><div class=\"line\">plt.legend(loc=‘upper left’，frameon=<span class=\"keyword\">True</span>)</div><div class=\"line\"><span class=\"comment\">## 图的标题</span></div><div class=\"line\">plt.title(<span class=\"string\">u'折线图'</span>,fontsize=<span class=\"number\">20</span>)</div><div class=\"line\"><span class=\"comment\">## 保存图片</span></div><div class=\"line\">plt.savefig(<span class=\"string\">'polygonal.jpg'</span>)</div><div class=\"line\"><span class=\"comment\">## 显示图片</span></div><div class=\"line\">plt.show()</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"柱状图\">柱状图</h2>\n<p>柱状图也是我们常见的一种图，它也叫条图，是一种以长方形的长度为变量的表达图形的统计报告图，由一系列高度不等的纵向条纹表示数据分布的情况，用来比较两个或以上的价值。在数据分析中，常用来比较不同的模型而产生的不同结果。</p>\n<ul>\n<li><p>图例如下：<br>\n[histogram](/assets/images/histogram.jpg)</p></li>\n<li><p>代码解析如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">Simple demo of a histogram plot.</div><div class=\"line\">\"\"\"</div><div class=\"line\"><span class=\"comment\"># coding=utf-8</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</div><div class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># matplotlib支持中文</span></div><div class=\"line\"><span class=\"keyword\">from</span> pylab <span class=\"keyword\">import</span> mpl</div><div class=\"line\">mpl.rcParams[<span class=\"string\">'font.sans-serif'</span>] = [<span class=\"string\">'SimHei'</span>] <span class=\"comment\">#指定默认字体</span></div><div class=\"line\">mpl.rcParams[<span class=\"string\">'axes.unicode_minus'</span>] = <span class=\"keyword\">False</span> <span class=\"comment\"># 解决保存图像是符号的‘-’显示为方块的问题</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 构造数据</span></div><div class=\"line\">mu = <span class=\"number\">100</span></div><div class=\"line\">sigma = <span class=\"number\">15</span></div><div class=\"line\">x = mu + sigma * np.random.randn(<span class=\"number\">10000</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">num_bins = <span class=\"number\">5</span></div><div class=\"line\"><span class=\"comment\">## hist常用参数</span></div><div class=\"line\"><span class=\"comment\"># num_bins  条数</span></div><div class=\"line\"><span class=\"comment\"># marker    点的图案</span></div><div class=\"line\"><span class=\"comment\"># label     图例说明中的标签</span></div><div class=\"line\"><span class=\"comment\"># linewidth 线宽</span></div><div class=\"line\">plt.ot(x, y1, <span class=\"string\">'b'</span>, label=‘$x^<span class=\"number\">3</span>$’, linewidth=<span class=\"number\">2</span>)</div><div class=\"line\">plt.plot(x, y2, <span class=\"string\">'r'</span>, label=‘$sin(x)$’, linewidth=<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\">## 设置坐标轴</span></div><div class=\"line\">ax= plt.gca()       <span class=\"comment\"># 获取当前坐标系实例</span></div><div class=\"line\"><span class=\"comment\"># 轴线/标尺设置</span></div><div class=\"line\">ax.spines[<span class=\"string\">'right'</span>].set_visible(<span class=\"keyword\">False</span>)</div><div class=\"line\">ax.spines[<span class=\"string\">'top'</span>].set_visible(<span class=\"keyword\">False</span>)</div><div class=\"line\">ax.xaxis.set_ticks_position(<span class=\"string\">'bottom'</span>)   <span class=\"comment\"># X轴标尺在轴线下面</span></div><div class=\"line\">ax.spines[<span class=\"string\">'bottom'</span>].set_position((<span class=\"string\">'data'</span>,<span class=\"number\">0</span>))    <span class=\"comment\"># 底部轴线在数据区0的位置</span></div><div class=\"line\">ax.yaxis.set_ticks_position(<span class=\"string\">'left'</span>)     <span class=\"comment\"># Y轴标尺在轴线左边</span></div><div class=\"line\">ax.spines[<span class=\"string\">'left'</span>].set_position((<span class=\"string\">'data'</span>,<span class=\"number\">0</span>))  <span class=\"comment\"># 左边轴线在数据区0的位置</span></div><div class=\"line\"><span class=\"comment\">## X/Y轴的的极限</span></div><div class=\"line\">xdelt = x.max() - x.min()</div><div class=\"line\">plt.xlim(x.min()<span class=\"number\">-0.1</span>*xdelt,x.max()+<span class=\"number\">0.1</span>*xdelt)</div><div class=\"line\">plt.ylim(<span class=\"number\">0</span>,<span class=\"number\">50</span>)</div><div class=\"line\"><span class=\"comment\">## 横纵坐标说明</span></div><div class=\"line\">plt.xlabel(<span class=\"string\">u'x值说明'</span>,fontsize=<span class=\"number\">16</span>)</div><div class=\"line\">plt.ylabel(<span class=\"string\">u'y值说明'</span>,fontsize=<span class=\"number\">16</span>,rotation=<span class=\"string\">'horizontal'</span>)</div><div class=\"line\"><span class=\"comment\">## 添加图例</span></div><div class=\"line\">plt.legend(loc=‘upper left’，frameon=<span class=\"keyword\">True</span>)</div><div class=\"line\"><span class=\"comment\">## 图的标题</span></div><div class=\"line\">plt.title(<span class=\"string\">u'折线图'</span>,fontsize=<span class=\"number\">20</span>)</div><div class=\"line\"><span class=\"comment\">## 保存图片</span></div><div class=\"line\">plt.savefig(<span class=\"string\">'polygonal.jpg'</span>)</div><div class=\"line\"><span class=\"comment\">## 显示图片</span></div><div class=\"line\">plt.show()</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"section\">section</h2>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://matplotlib.org\" target=\"_blank\" rel=\"external\">matplotlib官网图例</a></li>\n<li><a href=\"https://github.com/matplotlib\" target=\"_blank\" rel=\"external\">matplotlib源码</a></li>\n<li><a href=\"http://reverland.org/python/2012/09/07/matplotlib-tutorial/\" target=\"_blank\" rel=\"external\">matplotlib入门</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>这篇和Numpy类似，是用来将matplotlib在日常实践中作的图片作一个总结，方便以后查询上手。","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p>Matlplotlib是Python的一个可视化模块。该项目是由John D. Hunter发起的，但却是受Matlab启发构建的，并且有一套完全仿照Matlab函数形式的绘图接口。它让你方便地制作线条图、饼图、柱状图以及其它专业图形。使用Matplotlib，你可以定制所做图表的任一方面。</p>\n<h2 id=\"散点图\">散点图</h2>\n<p>散点图是我们最常见的一种图，它一样用来显示数据点在直角坐标系平面上的分布图例。在我们不清楚数据点之间的关系时，常做该图来直观显示数据的分步情况，以便做进一步分析。 * 图例如下：<br>\n[scatter](/assets/images/scatter.jpg)</p>\n<ul>\n<li><p>代码解析如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">Simple demo of a scatter plot.</div><div class=\"line\">\"\"\"</div><div class=\"line\"><span class=\"comment\"># coding=utf-8</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</div><div class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># matplotlib支持中文</span></div><div class=\"line\"><span class=\"keyword\">from</span> pylab <span class=\"keyword\">import</span> mpl</div><div class=\"line\">mpl.rcParams[<span class=\"string\">'font.sans-serif'</span>] = [<span class=\"string\">'SimHei'</span>] <span class=\"comment\">#指定默认字体</span></div><div class=\"line\">mpl.rcParams[<span class=\"string\">'axes.unicode_minus'</span>] = <span class=\"keyword\">False</span> <span class=\"comment\"># 解决保存图像是符号的‘-’显示为方块的问题</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 构造数据</span></div><div class=\"line\">N = <span class=\"number\">50</span></div><div class=\"line\">x = np.arange(N)</div><div class=\"line\">y1 = np.random.rand(N)*<span class=\"number\">25</span></div><div class=\"line\">y2 = np.random.rand(N)*<span class=\"number\">25</span>+<span class=\"number\">25</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">## scatter常用参数</span></div><div class=\"line\"><span class=\"comment\"># s[ize]    点的大小</span></div><div class=\"line\"><span class=\"comment\"># c[olor]   点的颜色</span></div><div class=\"line\"><span class=\"comment\"># marker    点的图案</span></div><div class=\"line\"><span class=\"comment\"># alpha     透明度</span></div><div class=\"line\"><span class=\"comment\"># label     图例说明中的标签</span></div><div class=\"line\">plt.scatter(x, y1, s=<span class=\"number\">50</span>, c=<span class=\"string\">'b'</span>, marker=<span class=\"string\">'+'</span>, alpha=<span class=\"number\">0.5</span>，label=‘ClassA’)</div><div class=\"line\">plt.scatter(x, y2, s=<span class=\"number\">100</span>, c=<span class=\"string\">'r'</span>, marker=<span class=\"string\">'.'</span>, alpha=<span class=\"number\">0.5</span>，label=‘ClassB’)</div><div class=\"line\"><span class=\"comment\">## X/Y轴的的极限</span></div><div class=\"line\">xdelt = x.max() - x.min()</div><div class=\"line\">plt.xlim(x.min()<span class=\"number\">-0.1</span>*xdelt,x.max()+<span class=\"number\">0.1</span>*xdelt)</div><div class=\"line\">plt.ylim(<span class=\"number\">0</span>,<span class=\"number\">50</span>)</div><div class=\"line\"><span class=\"comment\">## 横纵坐标说明</span></div><div class=\"line\">plt.xlabel(<span class=\"string\">u'x值说明'</span>,fontsize=<span class=\"number\">16</span>)</div><div class=\"line\">plt.ylabel(<span class=\"string\">u'y值说明'</span>,fontsize=<span class=\"number\">16</span>,rotation=<span class=\"string\">'horizontal'</span>)</div><div class=\"line\"><span class=\"comment\">## 添加图例</span></div><div class=\"line\">plt.legend(loc=‘upper left’，frameon=<span class=\"keyword\">True</span>)</div><div class=\"line\"><span class=\"comment\">## 图的标题</span></div><div class=\"line\">plt.title(<span class=\"string\">u'scatter图'</span>,fontsize=<span class=\"number\">20</span>)</div><div class=\"line\"><span class=\"comment\">## 保存图片</span></div><div class=\"line\">plt.savefig(<span class=\"string\">'scatter.jpg'</span>)</div><div class=\"line\"><span class=\"comment\">## 显示图片</span></div><div class=\"line\">plt.show()</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"折线图\">折线图</h2>\n<p>折线图也是我们常见的一种图，它常用来显示数据的走向趋势。在数据分析中，常用来处理随时间而变化的连续数据。</p>\n<ul>\n<li><p>图例如下：<br>\n[polygonal](/assets/images/polygonal.jpg)</p></li>\n<li><p>代码解析如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">Simple demo of a polygonal plot.</div><div class=\"line\">\"\"\"</div><div class=\"line\"><span class=\"comment\"># coding=utf-8</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</div><div class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># matplotlib支持中文</span></div><div class=\"line\"><span class=\"keyword\">from</span> pylab <span class=\"keyword\">import</span> mpl</div><div class=\"line\">mpl.rcParams[<span class=\"string\">'font.sans-serif'</span>] = [<span class=\"string\">'SimHei'</span>] <span class=\"comment\">#指定默认字体</span></div><div class=\"line\">mpl.rcParams[<span class=\"string\">'axes.unicode_minus'</span>] = <span class=\"keyword\">False</span> <span class=\"comment\"># 解决保存图像是符号的‘-’显示为方块的问题</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 构造数据</span></div><div class=\"line\">N = <span class=\"number\">50</span></div><div class=\"line\">x = np.linspace(<span class=\"number\">-2</span>,<span class=\"number\">2</span>,N)</div><div class=\"line\">y1 = x**<span class=\"number\">3</span></div><div class=\"line\">y2 = np.sin(x)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">## plot常用参数</span></div><div class=\"line\"><span class=\"comment\"># 'b'       设置颜色和点的图案</span></div><div class=\"line\"><span class=\"comment\"># marker    点的图案</span></div><div class=\"line\"><span class=\"comment\"># label     图例说明中的标签</span></div><div class=\"line\"><span class=\"comment\"># linewidth 线宽</span></div><div class=\"line\">plt.plot(x, y1, <span class=\"string\">'b*-'</span>, label=‘$x^<span class=\"number\">3</span>$’, linewidth=<span class=\"number\">2</span>)</div><div class=\"line\">plt.plot(x, y2, <span class=\"string\">'r'</span>, label=‘$sin(x)$’, linewidth=<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\">## 设置坐标轴</span></div><div class=\"line\">ax= plt.gca()       <span class=\"comment\"># 获取当前坐标系实例</span></div><div class=\"line\"><span class=\"comment\"># 轴线/标尺设置</span></div><div class=\"line\">ax.spines[<span class=\"string\">'right'</span>].set_visible(<span class=\"keyword\">False</span>)</div><div class=\"line\">ax.spines[<span class=\"string\">'top'</span>].set_visible(<span class=\"keyword\">False</span>)</div><div class=\"line\">ax.xaxis.set_ticks_position(<span class=\"string\">'bottom'</span>)   <span class=\"comment\"># X轴标尺在轴线下面</span></div><div class=\"line\">ax.spines[<span class=\"string\">'bottom'</span>].set_position((<span class=\"string\">'data'</span>,<span class=\"number\">0</span>))    <span class=\"comment\"># 底部轴线在数据区0的位置</span></div><div class=\"line\">ax.yaxis.set_ticks_position(<span class=\"string\">'left'</span>)     <span class=\"comment\"># Y轴标尺在轴线左边</span></div><div class=\"line\">ax.spines[<span class=\"string\">'left'</span>].set_position((<span class=\"string\">'data'</span>,<span class=\"number\">0</span>))  <span class=\"comment\"># 左边轴线在数据区0的位置</span></div><div class=\"line\"><span class=\"comment\">## X/Y轴的的极限</span></div><div class=\"line\">xdelt = x.max() - x.min()</div><div class=\"line\">plt.xlim(x.min()<span class=\"number\">-0.1</span>*xdelt,x.max()+<span class=\"number\">0.1</span>*xdelt)</div><div class=\"line\">plt.ylim(<span class=\"number\">0</span>,<span class=\"number\">50</span>)</div><div class=\"line\"><span class=\"comment\">## 横纵坐标说明</span></div><div class=\"line\">plt.xlabel(<span class=\"string\">u'x值说明'</span>,fontsize=<span class=\"number\">16</span>)</div><div class=\"line\">plt.ylabel(<span class=\"string\">u'y值说明'</span>,fontsize=<span class=\"number\">16</span>,rotation=<span class=\"string\">'horizontal'</span>)</div><div class=\"line\"><span class=\"comment\">## 添加图例</span></div><div class=\"line\">plt.legend(loc=‘upper left’，frameon=<span class=\"keyword\">True</span>)</div><div class=\"line\"><span class=\"comment\">## 图的标题</span></div><div class=\"line\">plt.title(<span class=\"string\">u'折线图'</span>,fontsize=<span class=\"number\">20</span>)</div><div class=\"line\"><span class=\"comment\">## 保存图片</span></div><div class=\"line\">plt.savefig(<span class=\"string\">'polygonal.jpg'</span>)</div><div class=\"line\"><span class=\"comment\">## 显示图片</span></div><div class=\"line\">plt.show()</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"柱状图\">柱状图</h2>\n<p>柱状图也是我们常见的一种图，它也叫条图，是一种以长方形的长度为变量的表达图形的统计报告图，由一系列高度不等的纵向条纹表示数据分布的情况，用来比较两个或以上的价值。在数据分析中，常用来比较不同的模型而产生的不同结果。</p>\n<ul>\n<li><p>图例如下：<br>\n[histogram](/assets/images/histogram.jpg)</p></li>\n<li><p>代码解析如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">Simple demo of a histogram plot.</div><div class=\"line\">\"\"\"</div><div class=\"line\"><span class=\"comment\"># coding=utf-8</span></div><div class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</div><div class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># matplotlib支持中文</span></div><div class=\"line\"><span class=\"keyword\">from</span> pylab <span class=\"keyword\">import</span> mpl</div><div class=\"line\">mpl.rcParams[<span class=\"string\">'font.sans-serif'</span>] = [<span class=\"string\">'SimHei'</span>] <span class=\"comment\">#指定默认字体</span></div><div class=\"line\">mpl.rcParams[<span class=\"string\">'axes.unicode_minus'</span>] = <span class=\"keyword\">False</span> <span class=\"comment\"># 解决保存图像是符号的‘-’显示为方块的问题</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 构造数据</span></div><div class=\"line\">mu = <span class=\"number\">100</span></div><div class=\"line\">sigma = <span class=\"number\">15</span></div><div class=\"line\">x = mu + sigma * np.random.randn(<span class=\"number\">10000</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">num_bins = <span class=\"number\">5</span></div><div class=\"line\"><span class=\"comment\">## hist常用参数</span></div><div class=\"line\"><span class=\"comment\"># num_bins  条数</span></div><div class=\"line\"><span class=\"comment\"># marker    点的图案</span></div><div class=\"line\"><span class=\"comment\"># label     图例说明中的标签</span></div><div class=\"line\"><span class=\"comment\"># linewidth 线宽</span></div><div class=\"line\">plt.ot(x, y1, <span class=\"string\">'b'</span>, label=‘$x^<span class=\"number\">3</span>$’, linewidth=<span class=\"number\">2</span>)</div><div class=\"line\">plt.plot(x, y2, <span class=\"string\">'r'</span>, label=‘$sin(x)$’, linewidth=<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\">## 设置坐标轴</span></div><div class=\"line\">ax= plt.gca()       <span class=\"comment\"># 获取当前坐标系实例</span></div><div class=\"line\"><span class=\"comment\"># 轴线/标尺设置</span></div><div class=\"line\">ax.spines[<span class=\"string\">'right'</span>].set_visible(<span class=\"keyword\">False</span>)</div><div class=\"line\">ax.spines[<span class=\"string\">'top'</span>].set_visible(<span class=\"keyword\">False</span>)</div><div class=\"line\">ax.xaxis.set_ticks_position(<span class=\"string\">'bottom'</span>)   <span class=\"comment\"># X轴标尺在轴线下面</span></div><div class=\"line\">ax.spines[<span class=\"string\">'bottom'</span>].set_position((<span class=\"string\">'data'</span>,<span class=\"number\">0</span>))    <span class=\"comment\"># 底部轴线在数据区0的位置</span></div><div class=\"line\">ax.yaxis.set_ticks_position(<span class=\"string\">'left'</span>)     <span class=\"comment\"># Y轴标尺在轴线左边</span></div><div class=\"line\">ax.spines[<span class=\"string\">'left'</span>].set_position((<span class=\"string\">'data'</span>,<span class=\"number\">0</span>))  <span class=\"comment\"># 左边轴线在数据区0的位置</span></div><div class=\"line\"><span class=\"comment\">## X/Y轴的的极限</span></div><div class=\"line\">xdelt = x.max() - x.min()</div><div class=\"line\">plt.xlim(x.min()<span class=\"number\">-0.1</span>*xdelt,x.max()+<span class=\"number\">0.1</span>*xdelt)</div><div class=\"line\">plt.ylim(<span class=\"number\">0</span>,<span class=\"number\">50</span>)</div><div class=\"line\"><span class=\"comment\">## 横纵坐标说明</span></div><div class=\"line\">plt.xlabel(<span class=\"string\">u'x值说明'</span>,fontsize=<span class=\"number\">16</span>)</div><div class=\"line\">plt.ylabel(<span class=\"string\">u'y值说明'</span>,fontsize=<span class=\"number\">16</span>,rotation=<span class=\"string\">'horizontal'</span>)</div><div class=\"line\"><span class=\"comment\">## 添加图例</span></div><div class=\"line\">plt.legend(loc=‘upper left’，frameon=<span class=\"keyword\">True</span>)</div><div class=\"line\"><span class=\"comment\">## 图的标题</span></div><div class=\"line\">plt.title(<span class=\"string\">u'折线图'</span>,fontsize=<span class=\"number\">20</span>)</div><div class=\"line\"><span class=\"comment\">## 保存图片</span></div><div class=\"line\">plt.savefig(<span class=\"string\">'polygonal.jpg'</span>)</div><div class=\"line\"><span class=\"comment\">## 显示图片</span></div><div class=\"line\">plt.show()</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"section\">section</h2>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://matplotlib.org\" target=\"_blank\" rel=\"external\">matplotlib官网图例</a></li>\n<li><a href=\"https://github.com/matplotlib\" target=\"_blank\" rel=\"external\">matplotlib源码</a></li>\n<li><a href=\"http://reverland.org/python/2012/09/07/matplotlib-tutorial/\" target=\"_blank\" rel=\"external\">matplotlib入门</a></li>\n</ol>"},{"layout":"post","title":"货比三家之MacPro_MF840","comments":1,"date":"2015-12-02T12:06:58.000Z","_content":"在临近研究生毕业，即将走向社会之际，打算将吃饭的家伙--笔记本更新一下。上一任笔记本是联想的G450,还是我刚上大学时买的呢，已经陪伴了我六年之久，途中只升级了一下内存（1+1G变成1+4G）。用它编过程，学过Photoshop，玩过真三国无双。。。现在依然可以完美运作。不过这个笔记本有个致命的缺陷，就是太大，太笨重，而且电池只能待机10min，所以非常不适合随身携带。而Mac Pro能玩虐这两点。至于说系统的差异的话，因为现在习惯的工作环境是Ubuntu，所以对于基于linux内核的OS X应该没有啥压力。而且应该会搞个OS X+Ubuntu+Windows的三系统，毕竟Windows里的游戏还是戒不了哇！\n<!-- more -->\n\n## 硬件需求\n* 型号：    MF840CH/A\n* 屏幕：    13寸Retina显示屏\n* CPU：     2.7GHz双核心Intel Core i5,Turbo Boost高达3.1GHz\n* 内存：    8G 1866MHz LPDDR3 SDRAM\n* 闪存：    基于PCIe的256GB内存\n* 显卡：    Intel Iris Graphics 6100\n* 触控板：  Force Touch触控板\n\n\n## 卖家\n1. [官网][apple]  \n官网售价为10788RMB，支持分期付款，有3期（3596/月），12期（948/月，多付588），24期（497/月，多付1140）。提供全面的售后服务。\n> **Tips:[售后服务][service]**  \n> 1. 所有苹果产品  \n> 每台 Mac、iPhone、Apple Watch、iPad、iPod 和显示器均享有免费电话技术支持，以及来自 Apple 的有限保修服务。AppleCare Protection Plan 全方位服务计划和 AppleCare+ 全方位服务计划可延长服务期限，并为你提供来自 Apple 专家的一站式维修服务和技术支持。  \n> 2. Mac和Apple显示器  \n>\n>   * 将你的服务和支持期限延长至自购买硬件之日起三年。  \n>   * 通过便捷的可选服务方案，所有随附硬件和配件均享有全球范围的维修服务。  \n>   * 直接联系 Apple 专家，就各种 Mac 主题的问题获得帮助，包括 OS X、iLife，以及连接至打印机和 AirPort 网络。  \n\n2. [苹果教育][app_edu]  \n苹果官网售价为10088RMB（**便宜700**），支持分期付款，有3期（3363/月），12期（887/月，多付558），24期（464/月，多付1048）。\n\n3. [京东][jd]  \n京东由中国邮电器材Apple授权专营店销售，免费提供售后服务。其售价为10488RMB（**便宜300**），支持百条分期，有3期（3548/月,多付156），12期（926/月，多付624），24期（489/月，多付1248）。\n> **Tips:促销**  \n> 当碰到像双11或双12这样的促销活动便天飞的时候，还是可以考虑下手的，像今年京东双12推出每1000-100+满5000-200，这样就能以9288RMB入手这台MF840。外加京东百条这样的分期付款，对于目前想买手头又有点紧张的小伙伴绝对是上上之选。\n>\n\n4. [一号店][yhd]  \n售价为9888RMB（**便宜900**），不支持分期。提供有偿的摔碰管修1年（额外369RMB）。\n5. [苹果去哪儿][taobao]  \n国行售价为9150RMB（**便宜1638**），而港行售价为8650RMB（_比国行便宜500_），不支持分期，但支持自提（上海有实体店[上海徐汇区漕溪北路41号太平洋一期汇嘉大厦17楼1708室]，从徐家汇地铁站9号出口左拐至汇嘉大厦）。至于售后服务，港行机器苹果直营店联保一年，而国行机器售后服务站或苹果直营店联保两年（整机一年，主要部件两年）。\n> **Tips:港行VS国行**  \n> 1. 相同点  \n>   \n>   * 国行和港行外观和配置一样\n>   * 都享受联保。\n> 2. 差异点  \n>   * 三码VS五码  \n>   港行机器是三码（机器盒子/保修卡/机器背面&系统内部SN号）合一，而国行是五码（牛皮纸盒子/三包卡/机器盒子/机器背面/系统内部SN号）合一  \n>   * 1年VS2年  \n>   港行机器只享有1年的联保时间，但仅限于苹果直营店，而国行机器享有1年的整机保修时间，2年的主要部件保修时间，除了苹果直营店，还可以找苹果售后服务站。\n\n6. [苹果团][pgt]  \n很多人买苹果的产品都会选择苹果团，不过我从学弟了解了一下它的流程--联系客服，给出收货地址，付完款后等货到。其在里面充当的角色就是代购，优势是它比一般人更识货，能帮你承担买到假货的风险。12月2号苹果团给出的价格是国行9010RMB（**便宜1778**），港行8710RMB（_比国行便宜300_）。\n\n\n## [验货][check]\n这里的验货教程主要来自MrMac提供的验货说明。这里稍微做一下总结。\n\n1. 检查外包装是否有磕碰，并通过外包装和的条形码，找到SN号。\n    * 检查封装线（**条形码底部和两侧，顶部是没有的**）是否工整\n    * 检测封膜上的激光气孔(**8×6个**)  \n    ![qingkong]({{site.baseurl}}/assets/images/qikong.png)\n    * 盒子背面条形码是否是原标（**字迹清晰，淡黑色**）\n2. 到[官网AppleCare保修覆盖][sn_check]上查询SN的激活状态。（**提示“请验证产品的购买日期”**）\n3. 打开包装，拿出机器查看背面开有的SN号是否和第一步一致。\n    * 检查机器背面的一次性封装纸（**未被撕开，拆手顶部有圆点的设计，背面贴纸处于正中**）\n    * 背面的SN号是否一致\n4. 激活并设置好机器，检查机器内部SN号和电源\n    * 首次开机要选择语言（**翻新机不会看到**）\n    * 检查机器配置信息（**顶部配置信息**）\n    * 检查电池循环次数（**不能超过5次**）\n\n\n## 结论\n官网情节没有必要，毕竟相差了1k+，更倾向于苹果去哪儿那家店吧，毕竟有实体店，可以现场去验证。对于国行还是港行，其实更偏向于港行吧，说实话，电脑不是那么容易出意外的，就像我之前的电脑，用了六年之久还没有问题。另外双12要来了，看看有没有折扣可以蹭。\n\n\n事实证明，双12的折扣京东还是给的满满的，如果没有苹果内部员工的85折，我可能就直接从京东上面买了。最终入手的是通过内部员工的85折入手了我个人的第二部电脑。\n\n\n\n\n## 参考文献\n1. [官网行情][apple]\n1. [苹果教育][app_edu]\n2. [京东行情][jd]\n3. [一号店行情][yhd]\n4. [淘宝铺-苹果去哪儿][taobao]\n5. [苹果团][pgt]\n6. [苹果官网的售后服务][service]\n7. [MacPro验货说明][check]\n8. [官网AppleCare保修覆盖][sn_check]\n\n\n\n[apple]:    http://www.apple.com/cn/\n[app_edu]:  http://www.apple.com/cn/education/\n[jd]:   http://item.jd.com/1580895361.html#none\n[yhd]:  http://item.yhd.com/item/45067258?union_ref=10_1&tracker_u=197057&uid=24994375895372\n[taobao]:   https://item.taobao.com/item.htm?spm=a1z10.1-c.w5003-10369358660.1.e81MTQ&id=36240916857&scene=taobao_shop\n[pgt]:  http://www.appletuan.com/\n[service]:  http://www.apple.com/cn-k12/shop/browse/home/applecare\n[check]:    http://www.mrmac.cn/t/5\n[sn_check]: https://selfsolve.apple.com/agreementWarrantyDynamic.do\n","source":"_posts/2015-12-02-货比三家之MacPro_MF840.md","raw":"---\nlayout:\t\tpost\ntitle:\t\t货比三家之MacPro_MF840\ncategories:\n- LIFE\ntags:\n- Mac\npermalink:  Buy-MacPro\ncomments:\ttrue\ndate:\t\t2015-12-02 20:06:58\n---\n在临近研究生毕业，即将走向社会之际，打算将吃饭的家伙--笔记本更新一下。上一任笔记本是联想的G450,还是我刚上大学时买的呢，已经陪伴了我六年之久，途中只升级了一下内存（1+1G变成1+4G）。用它编过程，学过Photoshop，玩过真三国无双。。。现在依然可以完美运作。不过这个笔记本有个致命的缺陷，就是太大，太笨重，而且电池只能待机10min，所以非常不适合随身携带。而Mac Pro能玩虐这两点。至于说系统的差异的话，因为现在习惯的工作环境是Ubuntu，所以对于基于linux内核的OS X应该没有啥压力。而且应该会搞个OS X+Ubuntu+Windows的三系统，毕竟Windows里的游戏还是戒不了哇！\n<!-- more -->\n\n## 硬件需求\n* 型号：    MF840CH/A\n* 屏幕：    13寸Retina显示屏\n* CPU：     2.7GHz双核心Intel Core i5,Turbo Boost高达3.1GHz\n* 内存：    8G 1866MHz LPDDR3 SDRAM\n* 闪存：    基于PCIe的256GB内存\n* 显卡：    Intel Iris Graphics 6100\n* 触控板：  Force Touch触控板\n\n\n## 卖家\n1. [官网][apple]  \n官网售价为10788RMB，支持分期付款，有3期（3596/月），12期（948/月，多付588），24期（497/月，多付1140）。提供全面的售后服务。\n> **Tips:[售后服务][service]**  \n> 1. 所有苹果产品  \n> 每台 Mac、iPhone、Apple Watch、iPad、iPod 和显示器均享有免费电话技术支持，以及来自 Apple 的有限保修服务。AppleCare Protection Plan 全方位服务计划和 AppleCare+ 全方位服务计划可延长服务期限，并为你提供来自 Apple 专家的一站式维修服务和技术支持。  \n> 2. Mac和Apple显示器  \n>\n>   * 将你的服务和支持期限延长至自购买硬件之日起三年。  \n>   * 通过便捷的可选服务方案，所有随附硬件和配件均享有全球范围的维修服务。  \n>   * 直接联系 Apple 专家，就各种 Mac 主题的问题获得帮助，包括 OS X、iLife，以及连接至打印机和 AirPort 网络。  \n\n2. [苹果教育][app_edu]  \n苹果官网售价为10088RMB（**便宜700**），支持分期付款，有3期（3363/月），12期（887/月，多付558），24期（464/月，多付1048）。\n\n3. [京东][jd]  \n京东由中国邮电器材Apple授权专营店销售，免费提供售后服务。其售价为10488RMB（**便宜300**），支持百条分期，有3期（3548/月,多付156），12期（926/月，多付624），24期（489/月，多付1248）。\n> **Tips:促销**  \n> 当碰到像双11或双12这样的促销活动便天飞的时候，还是可以考虑下手的，像今年京东双12推出每1000-100+满5000-200，这样就能以9288RMB入手这台MF840。外加京东百条这样的分期付款，对于目前想买手头又有点紧张的小伙伴绝对是上上之选。\n>\n\n4. [一号店][yhd]  \n售价为9888RMB（**便宜900**），不支持分期。提供有偿的摔碰管修1年（额外369RMB）。\n5. [苹果去哪儿][taobao]  \n国行售价为9150RMB（**便宜1638**），而港行售价为8650RMB（_比国行便宜500_），不支持分期，但支持自提（上海有实体店[上海徐汇区漕溪北路41号太平洋一期汇嘉大厦17楼1708室]，从徐家汇地铁站9号出口左拐至汇嘉大厦）。至于售后服务，港行机器苹果直营店联保一年，而国行机器售后服务站或苹果直营店联保两年（整机一年，主要部件两年）。\n> **Tips:港行VS国行**  \n> 1. 相同点  \n>   \n>   * 国行和港行外观和配置一样\n>   * 都享受联保。\n> 2. 差异点  \n>   * 三码VS五码  \n>   港行机器是三码（机器盒子/保修卡/机器背面&系统内部SN号）合一，而国行是五码（牛皮纸盒子/三包卡/机器盒子/机器背面/系统内部SN号）合一  \n>   * 1年VS2年  \n>   港行机器只享有1年的联保时间，但仅限于苹果直营店，而国行机器享有1年的整机保修时间，2年的主要部件保修时间，除了苹果直营店，还可以找苹果售后服务站。\n\n6. [苹果团][pgt]  \n很多人买苹果的产品都会选择苹果团，不过我从学弟了解了一下它的流程--联系客服，给出收货地址，付完款后等货到。其在里面充当的角色就是代购，优势是它比一般人更识货，能帮你承担买到假货的风险。12月2号苹果团给出的价格是国行9010RMB（**便宜1778**），港行8710RMB（_比国行便宜300_）。\n\n\n## [验货][check]\n这里的验货教程主要来自MrMac提供的验货说明。这里稍微做一下总结。\n\n1. 检查外包装是否有磕碰，并通过外包装和的条形码，找到SN号。\n    * 检查封装线（**条形码底部和两侧，顶部是没有的**）是否工整\n    * 检测封膜上的激光气孔(**8×6个**)  \n    ![qingkong]({{site.baseurl}}/assets/images/qikong.png)\n    * 盒子背面条形码是否是原标（**字迹清晰，淡黑色**）\n2. 到[官网AppleCare保修覆盖][sn_check]上查询SN的激活状态。（**提示“请验证产品的购买日期”**）\n3. 打开包装，拿出机器查看背面开有的SN号是否和第一步一致。\n    * 检查机器背面的一次性封装纸（**未被撕开，拆手顶部有圆点的设计，背面贴纸处于正中**）\n    * 背面的SN号是否一致\n4. 激活并设置好机器，检查机器内部SN号和电源\n    * 首次开机要选择语言（**翻新机不会看到**）\n    * 检查机器配置信息（**顶部配置信息**）\n    * 检查电池循环次数（**不能超过5次**）\n\n\n## 结论\n官网情节没有必要，毕竟相差了1k+，更倾向于苹果去哪儿那家店吧，毕竟有实体店，可以现场去验证。对于国行还是港行，其实更偏向于港行吧，说实话，电脑不是那么容易出意外的，就像我之前的电脑，用了六年之久还没有问题。另外双12要来了，看看有没有折扣可以蹭。\n\n\n事实证明，双12的折扣京东还是给的满满的，如果没有苹果内部员工的85折，我可能就直接从京东上面买了。最终入手的是通过内部员工的85折入手了我个人的第二部电脑。\n\n\n\n\n## 参考文献\n1. [官网行情][apple]\n1. [苹果教育][app_edu]\n2. [京东行情][jd]\n3. [一号店行情][yhd]\n4. [淘宝铺-苹果去哪儿][taobao]\n5. [苹果团][pgt]\n6. [苹果官网的售后服务][service]\n7. [MacPro验货说明][check]\n8. [官网AppleCare保修覆盖][sn_check]\n\n\n\n[apple]:    http://www.apple.com/cn/\n[app_edu]:  http://www.apple.com/cn/education/\n[jd]:   http://item.jd.com/1580895361.html#none\n[yhd]:  http://item.yhd.com/item/45067258?union_ref=10_1&tracker_u=197057&uid=24994375895372\n[taobao]:   https://item.taobao.com/item.htm?spm=a1z10.1-c.w5003-10369358660.1.e81MTQ&id=36240916857&scene=taobao_shop\n[pgt]:  http://www.appletuan.com/\n[service]:  http://www.apple.com/cn-k12/shop/browse/home/applecare\n[check]:    http://www.mrmac.cn/t/5\n[sn_check]: https://selfsolve.apple.com/agreementWarrantyDynamic.do\n","slug":"Buy-MacPro","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1p001vl73yf2f7nq1z","content":"<p>在临近研究生毕业，即将走向社会之际，打算将吃饭的家伙–笔记本更新一下。上一任笔记本是联想的G450,还是我刚上大学时买的呢，已经陪伴了我六年之久，途中只升级了一下内存（1+1G变成1+4G）。用它编过程，学过Photoshop，玩过真三国无双。。。现在依然可以完美运作。不过这个笔记本有个致命的缺陷，就是太大，太笨重，而且电池只能待机10min，所以非常不适合随身携带。而Mac Pro能玩虐这两点。至于说系统的差异的话，因为现在习惯的工作环境是Ubuntu，所以对于基于linux内核的OS X应该没有啥压力。而且应该会搞个OS X+Ubuntu+Windows的三系统，毕竟Windows里的游戏还是戒不了哇！ <a id=\"more\"></a></p>\n<h2 id=\"硬件需求\">硬件需求</h2>\n<ul>\n<li>型号： MF840CH/A</li>\n<li>屏幕： 13寸Retina显示屏</li>\n<li>CPU： 2.7GHz双核心Intel Core i5,Turbo Boost高达3.1GHz</li>\n<li>内存： 8G 1866MHz LPDDR3 SDRAM</li>\n<li>闪存： 基于PCIe的256GB内存</li>\n<li>显卡： Intel Iris Graphics 6100</li>\n<li>触控板： Force Touch触控板</li>\n</ul>\n<h2 id=\"卖家\">卖家</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p><a href=\"http://www.apple.com/cn/\" target=\"_blank\" rel=\"external\">官网</a><br>\n官网售价为10788RMB，支持分期付款，有3期（3596/月），12期（948/月，多付588），24期（497/月，多付1140）。提供全面的售后服务。 &gt; <strong>Tips:<a href=\"http://www.apple.com/cn-k12/shop/browse/home/applecare\" target=\"_blank\" rel=\"external\">售后服务</a></strong><br>\n&gt; 1. 所有苹果产品<br>\n&gt; 每台 Mac、iPhone、Apple Watch、iPad、iPod 和显示器均享有免费电话技术支持，以及来自 Apple 的有限保修服务。AppleCare Protection Plan 全方位服务计划和 AppleCare+ 全方位服务计划可延长服务期限，并为你提供来自 Apple 专家的一站式维修服务和技术支持。<br>\n&gt; 2. Mac和Apple显示器<br>\n&gt; &gt; * 将你的服务和支持期限延长至自购买硬件之日起三年。<br>\n&gt; * 通过便捷的可选服务方案，所有随附硬件和配件均享有全球范围的维修服务。<br>\n&gt; * 直接联系 Apple 专家，就各种 Mac 主题的问题获得帮助，包括 OS X、iLife，以及连接至打印机和 AirPort 网络。</p></li>\n<li><p><a href=\"http://www.apple.com/cn/education/\" target=\"_blank\" rel=\"external\">苹果教育</a><br>\n苹果官网售价为10088RMB（<strong>便宜700</strong>），支持分期付款，有3期（3363/月），12期（887/月，多付558），24期（464/月，多付1048）。</p></li>\n<li><p><a href=\"http://item.jd.com/1580895361.html#none\" target=\"_blank\" rel=\"external\">京东</a><br>\n京东由中国邮电器材Apple授权专营店销售，免费提供售后服务。其售价为10488RMB（<strong>便宜300</strong>），支持百条分期，有3期（3548/月,多付156），12期（926/月，多付624），24期（489/月，多付1248）。 &gt; <strong>Tips:促销</strong><br>\n&gt; 当碰到像双11或双12这样的促销活动便天飞的时候，还是可以考虑下手的，像今年京东双12推出每1000-100+满5000-200，这样就能以9288RMB入手这台MF840。外加京东百条这样的分期付款，对于目前想买手头又有点紧张的小伙伴绝对是上上之选。 &gt;</p></li>\n<li><a href=\"http://item.yhd.com/item/45067258?union_ref=10_1&amp;tracker_u=197057&amp;uid=24994375895372\" target=\"_blank\" rel=\"external\">一号店</a><br>\n售价为9888RMB（<strong>便宜900</strong>），不支持分期。提供有偿的摔碰管修1年（额外369RMB）。</li>\n<li><p><a href=\"https://item.taobao.com/item.htm?spm=a1z10.1-c.w5003-10369358660.1.e81MTQ&amp;id=36240916857&amp;scene=taobao_shop\" target=\"_blank\" rel=\"external\">苹果去哪儿</a><br>\n国行售价为9150RMB（<strong>便宜1638</strong>），而港行售价为8650RMB（<em>比国行便宜500</em>），不支持分期，但支持自提（上海有实体店[上海徐汇区漕溪北路41号太平洋一期汇嘉大厦17楼1708室]，从徐家汇地铁站9号出口左拐至汇嘉大厦）。至于售后服务，港行机器苹果直营店联保一年，而国行机器售后服务站或苹果直营店联保两年（整机一年，主要部件两年）。 &gt; <strong>Tips:港行VS国行</strong><br>\n&gt; 1. 相同点<br>\n&gt;<br>\n&gt; * 国行和港行外观和配置一样 &gt; * 都享受联保。 &gt; 2. 差异点<br>\n&gt; * 三码VS五码<br>\n&gt; 港行机器是三码（机器盒子/保修卡/机器背面&amp;系统内部SN号）合一，而国行是五码（牛皮纸盒子/三包卡/机器盒子/机器背面/系统内部SN号）合一<br>\n&gt; * 1年VS2年<br>\n&gt; 港行机器只享有1年的联保时间，但仅限于苹果直营店，而国行机器享有1年的整机保修时间，2年的主要部件保修时间，除了苹果直营店，还可以找苹果售后服务站。</p></li>\n<li><p><a href=\"http://www.appletuan.com/\" target=\"_blank\" rel=\"external\">苹果团</a><br>\n很多人买苹果的产品都会选择苹果团，不过我从学弟了解了一下它的流程–联系客服，给出收货地址，付完款后等货到。其在里面充当的角色就是代购，优势是它比一般人更识货，能帮你承担买到假货的风险。12月2号苹果团给出的价格是国行9010RMB（<strong>便宜1778</strong>），港行8710RMB（<em>比国行便宜300</em>）。</p></li>\n</ol>\n<h2 id=\"验货check\"><a href=\"http://www.mrmac.cn/t/5\" target=\"_blank\" rel=\"external\">验货</a></h2>\n<p>这里的验货教程主要来自MrMac提供的验货说明。这里稍微做一下总结。</p>\n<ol style=\"list-style-type: decimal\">\n<li>检查外包装是否有磕碰，并通过外包装和的条形码，找到SN号。\n<ul>\n<li>检查封装线（<strong>条形码底部和两侧，顶部是没有的</strong>）是否工整</li>\n<li>检测封膜上的激光气孔(<strong>8×6个</strong>)<br>\n[qingkong](/assets/images/qikong.png)</li>\n<li>盒子背面条形码是否是原标（<strong>字迹清晰，淡黑色</strong>）</li>\n</ul></li>\n<li>到<a href=\"https://selfsolve.apple.com/agreementWarrantyDynamic.do\" target=\"_blank\" rel=\"external\">官网AppleCare保修覆盖</a>上查询SN的激活状态。（<strong>提示“请验证产品的购买日期”</strong>）</li>\n<li>打开包装，拿出机器查看背面开有的SN号是否和第一步一致。\n<ul>\n<li>检查机器背面的一次性封装纸（<strong>未被撕开，拆手顶部有圆点的设计，背面贴纸处于正中</strong>）</li>\n<li>背面的SN号是否一致</li>\n</ul></li>\n<li>激活并设置好机器，检查机器内部SN号和电源\n<ul>\n<li>首次开机要选择语言（<strong>翻新机不会看到</strong>）</li>\n<li>检查机器配置信息（<strong>顶部配置信息</strong>）</li>\n<li>检查电池循环次数（<strong>不能超过5次</strong>）</li>\n</ul></li>\n</ol>\n<h2 id=\"结论\">结论</h2>\n<p>官网情节没有必要，毕竟相差了1k+，更倾向于苹果去哪儿那家店吧，毕竟有实体店，可以现场去验证。对于国行还是港行，其实更偏向于港行吧，说实话，电脑不是那么容易出意外的，就像我之前的电脑，用了六年之久还没有问题。另外双12要来了，看看有没有折扣可以蹭。</p>\n<p>事实证明，双12的折扣京东还是给的满满的，如果没有苹果内部员工的85折，我可能就直接从京东上面买了。最终入手的是通过内部员工的85折入手了我个人的第二部电脑。</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://www.apple.com/cn/\" target=\"_blank\" rel=\"external\">官网行情</a></li>\n<li><a href=\"http://www.apple.com/cn/education/\" target=\"_blank\" rel=\"external\">苹果教育</a></li>\n<li><a href=\"http://item.jd.com/1580895361.html#none\" target=\"_blank\" rel=\"external\">京东行情</a></li>\n<li><a href=\"http://item.yhd.com/item/45067258?union_ref=10_1&amp;tracker_u=197057&amp;uid=24994375895372\" target=\"_blank\" rel=\"external\">一号店行情</a></li>\n<li><a href=\"https://item.taobao.com/item.htm?spm=a1z10.1-c.w5003-10369358660.1.e81MTQ&amp;id=36240916857&amp;scene=taobao_shop\" target=\"_blank\" rel=\"external\">淘宝铺-苹果去哪儿</a></li>\n<li><a href=\"http://www.appletuan.com/\" target=\"_blank\" rel=\"external\">苹果团</a></li>\n<li><a href=\"http://www.apple.com/cn-k12/shop/browse/home/applecare\" target=\"_blank\" rel=\"external\">苹果官网的售后服务</a></li>\n<li><a href=\"http://www.mrmac.cn/t/5\" target=\"_blank\" rel=\"external\">MacPro验货说明</a></li>\n<li><a href=\"https://selfsolve.apple.com/agreementWarrantyDynamic.do\" target=\"_blank\" rel=\"external\">官网AppleCare保修覆盖</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在临近研究生毕业，即将走向社会之际，打算将吃饭的家伙–笔记本更新一下。上一任笔记本是联想的G450,还是我刚上大学时买的呢，已经陪伴了我六年之久，途中只升级了一下内存（1+1G变成1+4G）。用它编过程，学过Photoshop，玩过真三国无双。。。现在依然可以完美运作。不过这个笔记本有个致命的缺陷，就是太大，太笨重，而且电池只能待机10min，所以非常不适合随身携带。而Mac Pro能玩虐这两点。至于说系统的差异的话，因为现在习惯的工作环境是Ubuntu，所以对于基于linux内核的OS X应该没有啥压力。而且应该会搞个OS X+Ubuntu+Windows的三系统，毕竟Windows里的游戏还是戒不了哇！","more":"</p>\n<h2 id=\"硬件需求\">硬件需求</h2>\n<ul>\n<li>型号： MF840CH/A</li>\n<li>屏幕： 13寸Retina显示屏</li>\n<li>CPU： 2.7GHz双核心Intel Core i5,Turbo Boost高达3.1GHz</li>\n<li>内存： 8G 1866MHz LPDDR3 SDRAM</li>\n<li>闪存： 基于PCIe的256GB内存</li>\n<li>显卡： Intel Iris Graphics 6100</li>\n<li>触控板： Force Touch触控板</li>\n</ul>\n<h2 id=\"卖家\">卖家</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p><a href=\"http://www.apple.com/cn/\" target=\"_blank\" rel=\"external\">官网</a><br>\n官网售价为10788RMB，支持分期付款，有3期（3596/月），12期（948/月，多付588），24期（497/月，多付1140）。提供全面的售后服务。 &gt; <strong>Tips:<a href=\"http://www.apple.com/cn-k12/shop/browse/home/applecare\" target=\"_blank\" rel=\"external\">售后服务</a></strong><br>\n&gt; 1. 所有苹果产品<br>\n&gt; 每台 Mac、iPhone、Apple Watch、iPad、iPod 和显示器均享有免费电话技术支持，以及来自 Apple 的有限保修服务。AppleCare Protection Plan 全方位服务计划和 AppleCare+ 全方位服务计划可延长服务期限，并为你提供来自 Apple 专家的一站式维修服务和技术支持。<br>\n&gt; 2. Mac和Apple显示器<br>\n&gt; &gt; * 将你的服务和支持期限延长至自购买硬件之日起三年。<br>\n&gt; * 通过便捷的可选服务方案，所有随附硬件和配件均享有全球范围的维修服务。<br>\n&gt; * 直接联系 Apple 专家，就各种 Mac 主题的问题获得帮助，包括 OS X、iLife，以及连接至打印机和 AirPort 网络。</p></li>\n<li><p><a href=\"http://www.apple.com/cn/education/\" target=\"_blank\" rel=\"external\">苹果教育</a><br>\n苹果官网售价为10088RMB（<strong>便宜700</strong>），支持分期付款，有3期（3363/月），12期（887/月，多付558），24期（464/月，多付1048）。</p></li>\n<li><p><a href=\"http://item.jd.com/1580895361.html#none\" target=\"_blank\" rel=\"external\">京东</a><br>\n京东由中国邮电器材Apple授权专营店销售，免费提供售后服务。其售价为10488RMB（<strong>便宜300</strong>），支持百条分期，有3期（3548/月,多付156），12期（926/月，多付624），24期（489/月，多付1248）。 &gt; <strong>Tips:促销</strong><br>\n&gt; 当碰到像双11或双12这样的促销活动便天飞的时候，还是可以考虑下手的，像今年京东双12推出每1000-100+满5000-200，这样就能以9288RMB入手这台MF840。外加京东百条这样的分期付款，对于目前想买手头又有点紧张的小伙伴绝对是上上之选。 &gt;</p></li>\n<li><a href=\"http://item.yhd.com/item/45067258?union_ref=10_1&amp;tracker_u=197057&amp;uid=24994375895372\" target=\"_blank\" rel=\"external\">一号店</a><br>\n售价为9888RMB（<strong>便宜900</strong>），不支持分期。提供有偿的摔碰管修1年（额外369RMB）。</li>\n<li><p><a href=\"https://item.taobao.com/item.htm?spm=a1z10.1-c.w5003-10369358660.1.e81MTQ&amp;id=36240916857&amp;scene=taobao_shop\" target=\"_blank\" rel=\"external\">苹果去哪儿</a><br>\n国行售价为9150RMB（<strong>便宜1638</strong>），而港行售价为8650RMB（<em>比国行便宜500</em>），不支持分期，但支持自提（上海有实体店[上海徐汇区漕溪北路41号太平洋一期汇嘉大厦17楼1708室]，从徐家汇地铁站9号出口左拐至汇嘉大厦）。至于售后服务，港行机器苹果直营店联保一年，而国行机器售后服务站或苹果直营店联保两年（整机一年，主要部件两年）。 &gt; <strong>Tips:港行VS国行</strong><br>\n&gt; 1. 相同点<br>\n&gt;<br>\n&gt; * 国行和港行外观和配置一样 &gt; * 都享受联保。 &gt; 2. 差异点<br>\n&gt; * 三码VS五码<br>\n&gt; 港行机器是三码（机器盒子/保修卡/机器背面&amp;系统内部SN号）合一，而国行是五码（牛皮纸盒子/三包卡/机器盒子/机器背面/系统内部SN号）合一<br>\n&gt; * 1年VS2年<br>\n&gt; 港行机器只享有1年的联保时间，但仅限于苹果直营店，而国行机器享有1年的整机保修时间，2年的主要部件保修时间，除了苹果直营店，还可以找苹果售后服务站。</p></li>\n<li><p><a href=\"http://www.appletuan.com/\" target=\"_blank\" rel=\"external\">苹果团</a><br>\n很多人买苹果的产品都会选择苹果团，不过我从学弟了解了一下它的流程–联系客服，给出收货地址，付完款后等货到。其在里面充当的角色就是代购，优势是它比一般人更识货，能帮你承担买到假货的风险。12月2号苹果团给出的价格是国行9010RMB（<strong>便宜1778</strong>），港行8710RMB（<em>比国行便宜300</em>）。</p></li>\n</ol>\n<h2 id=\"验货check\"><a href=\"http://www.mrmac.cn/t/5\" target=\"_blank\" rel=\"external\">验货</a></h2>\n<p>这里的验货教程主要来自MrMac提供的验货说明。这里稍微做一下总结。</p>\n<ol style=\"list-style-type: decimal\">\n<li>检查外包装是否有磕碰，并通过外包装和的条形码，找到SN号。\n<ul>\n<li>检查封装线（<strong>条形码底部和两侧，顶部是没有的</strong>）是否工整</li>\n<li>检测封膜上的激光气孔(<strong>8×6个</strong>)<br>\n[qingkong](/assets/images/qikong.png)</li>\n<li>盒子背面条形码是否是原标（<strong>字迹清晰，淡黑色</strong>）</li>\n</ul></li>\n<li>到<a href=\"https://selfsolve.apple.com/agreementWarrantyDynamic.do\" target=\"_blank\" rel=\"external\">官网AppleCare保修覆盖</a>上查询SN的激活状态。（<strong>提示“请验证产品的购买日期”</strong>）</li>\n<li>打开包装，拿出机器查看背面开有的SN号是否和第一步一致。\n<ul>\n<li>检查机器背面的一次性封装纸（<strong>未被撕开，拆手顶部有圆点的设计，背面贴纸处于正中</strong>）</li>\n<li>背面的SN号是否一致</li>\n</ul></li>\n<li>激活并设置好机器，检查机器内部SN号和电源\n<ul>\n<li>首次开机要选择语言（<strong>翻新机不会看到</strong>）</li>\n<li>检查机器配置信息（<strong>顶部配置信息</strong>）</li>\n<li>检查电池循环次数（<strong>不能超过5次</strong>）</li>\n</ul></li>\n</ol>\n<h2 id=\"结论\">结论</h2>\n<p>官网情节没有必要，毕竟相差了1k+，更倾向于苹果去哪儿那家店吧，毕竟有实体店，可以现场去验证。对于国行还是港行，其实更偏向于港行吧，说实话，电脑不是那么容易出意外的，就像我之前的电脑，用了六年之久还没有问题。另外双12要来了，看看有没有折扣可以蹭。</p>\n<p>事实证明，双12的折扣京东还是给的满满的，如果没有苹果内部员工的85折，我可能就直接从京东上面买了。最终入手的是通过内部员工的85折入手了我个人的第二部电脑。</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://www.apple.com/cn/\" target=\"_blank\" rel=\"external\">官网行情</a></li>\n<li><a href=\"http://www.apple.com/cn/education/\" target=\"_blank\" rel=\"external\">苹果教育</a></li>\n<li><a href=\"http://item.jd.com/1580895361.html#none\" target=\"_blank\" rel=\"external\">京东行情</a></li>\n<li><a href=\"http://item.yhd.com/item/45067258?union_ref=10_1&amp;tracker_u=197057&amp;uid=24994375895372\" target=\"_blank\" rel=\"external\">一号店行情</a></li>\n<li><a href=\"https://item.taobao.com/item.htm?spm=a1z10.1-c.w5003-10369358660.1.e81MTQ&amp;id=36240916857&amp;scene=taobao_shop\" target=\"_blank\" rel=\"external\">淘宝铺-苹果去哪儿</a></li>\n<li><a href=\"http://www.appletuan.com/\" target=\"_blank\" rel=\"external\">苹果团</a></li>\n<li><a href=\"http://www.apple.com/cn-k12/shop/browse/home/applecare\" target=\"_blank\" rel=\"external\">苹果官网的售后服务</a></li>\n<li><a href=\"http://www.mrmac.cn/t/5\" target=\"_blank\" rel=\"external\">MacPro验货说明</a></li>\n<li><a href=\"https://selfsolve.apple.com/agreementWarrantyDynamic.do\" target=\"_blank\" rel=\"external\">官网AppleCare保修覆盖</a></li>\n</ol>"},{"layout":"post","title":"更快的构建自己博客","comments":1,"date":"2015-12-29T10:48:57.000Z","_content":"之前写过一篇关于用jekyll搭建个人博客的博文[搭建自己的博客]({{site.baseurl}}/2015/06/07/搭建自己的博客.html)，不过在近半年的使用中，随着博文的增加，其静态博客的构建速度变慢越来越明显。所以打算换一个更快的博客框架[hexo][hexo]。此外因为hexo是基于node.js的，所以安装，配置等操作比Jekyll简单多了。\n<!-- more -->\n\n## 简介\n\n## 环境搭建\n* Mac版\n    1. 安装Git（详情见[macbook常用软件及其管理]({{site.baseurl}}/2015/12/10/macbook常用软件及其管理.html)）\n    2. 安装Node.js\n    文档中给出的最佳方式是使用[nvm](https://github.com/creationix/nvm)安装，不过个人偏爱与brew安装，管理方便。两种方法都提供如下：\n\n    ```sh\n    # nvm安装\n    wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n    # 重启终端后安装Node.js\n    nvm install 4\n\n\n    # brew安装\n    brew install nodejs\n    ```\n    3. 安装hexo\n\n    ```sh\n    npm install -g hexo-cli\n    ```\n    hexo的常用用法如下：\n\n    ```sh\n    # 建立网站\n    hexo init <folder>\n    # 新建博文\n    hexo new [layout] <title>\n    # 生成静态文件，-d要求生成后立即部署\n    hexo generate -d\n    # 发表草稿\n    hexo publish [layout] <filename>\n    # 启动服务器\n    hexo server\n    # 部署网站，-g要求部署前生成静态文件\n    hexo deploy -g\n    # 清除缓存文件（db.json）和已生成的静态文件（public）\n    hexo clean\n    ```\n\n## 站点建立\n* 基础站点  \nhexo安装完成后，通过下面命令来构建站点文件。\n\n    ```sh\n    hexo init <folder>\n    cd <folder>\n    npm install\n    ```\n其目录结构如下：\n    * _config.yml  \n    网站的[配置](https://hexo.io/zh-cn/docs/configuration.html)信息，可以根据喜好自定义。\n    * package.json  \n    应用程序的信息，EJS，Stylus和Markdown renderer已默认安装，可以自由移除。\n    * scaffolds  \n    [模板](https://hexo.io/zh-cn/docs/writing.html)文件夹。当新建文章时，hexo会根据scaffold来建立文件。\n    * source/_drafts  \n    草稿文件\n    * source/_posts  \n    成搞文件\n    * themes  \n    [主题](https://hexo.io/zh-cn/docs/themes.html)文件夹。Hexo会根据主题来生成静态页面。\n\n* 常用插件\n    * git部署\n\n        ```sh\n        npm install hexo-deployer-git --save\n        ```\n    *\n\n## 参考文献\n1. [hexo中文文档][hexo]\n\n\n[hexo]: https://hexo.io/zh-cn/docs/\n","source":"_posts/2015-12-29-更快的构建自己博客.md","raw":"---\nlayout:\t\tpost\ntitle:\t\t更快的构建自己博客\ncategories:\n- TECHNOLOGY\ntags:\n- Mac\n- Hexo\n- Blog\npermalink:  Building-blog\ncomments:\ttrue\ndate:\t\t2015-12-29 18:48:57\n---\n之前写过一篇关于用jekyll搭建个人博客的博文[搭建自己的博客]({{site.baseurl}}/2015/06/07/搭建自己的博客.html)，不过在近半年的使用中，随着博文的增加，其静态博客的构建速度变慢越来越明显。所以打算换一个更快的博客框架[hexo][hexo]。此外因为hexo是基于node.js的，所以安装，配置等操作比Jekyll简单多了。\n<!-- more -->\n\n## 简介\n\n## 环境搭建\n* Mac版\n    1. 安装Git（详情见[macbook常用软件及其管理]({{site.baseurl}}/2015/12/10/macbook常用软件及其管理.html)）\n    2. 安装Node.js\n    文档中给出的最佳方式是使用[nvm](https://github.com/creationix/nvm)安装，不过个人偏爱与brew安装，管理方便。两种方法都提供如下：\n\n    ```sh\n    # nvm安装\n    wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n    # 重启终端后安装Node.js\n    nvm install 4\n\n\n    # brew安装\n    brew install nodejs\n    ```\n    3. 安装hexo\n\n    ```sh\n    npm install -g hexo-cli\n    ```\n    hexo的常用用法如下：\n\n    ```sh\n    # 建立网站\n    hexo init <folder>\n    # 新建博文\n    hexo new [layout] <title>\n    # 生成静态文件，-d要求生成后立即部署\n    hexo generate -d\n    # 发表草稿\n    hexo publish [layout] <filename>\n    # 启动服务器\n    hexo server\n    # 部署网站，-g要求部署前生成静态文件\n    hexo deploy -g\n    # 清除缓存文件（db.json）和已生成的静态文件（public）\n    hexo clean\n    ```\n\n## 站点建立\n* 基础站点  \nhexo安装完成后，通过下面命令来构建站点文件。\n\n    ```sh\n    hexo init <folder>\n    cd <folder>\n    npm install\n    ```\n其目录结构如下：\n    * _config.yml  \n    网站的[配置](https://hexo.io/zh-cn/docs/configuration.html)信息，可以根据喜好自定义。\n    * package.json  \n    应用程序的信息，EJS，Stylus和Markdown renderer已默认安装，可以自由移除。\n    * scaffolds  \n    [模板](https://hexo.io/zh-cn/docs/writing.html)文件夹。当新建文章时，hexo会根据scaffold来建立文件。\n    * source/_drafts  \n    草稿文件\n    * source/_posts  \n    成搞文件\n    * themes  \n    [主题](https://hexo.io/zh-cn/docs/themes.html)文件夹。Hexo会根据主题来生成静态页面。\n\n* 常用插件\n    * git部署\n\n        ```sh\n        npm install hexo-deployer-git --save\n        ```\n    *\n\n## 参考文献\n1. [hexo中文文档][hexo]\n\n\n[hexo]: https://hexo.io/zh-cn/docs/\n","slug":"Building-blog","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1p001wl73y3z9bv010","content":"<p>之前写过一篇关于用jekyll搭建个人博客的博文[搭建自己的博客](/2015/06/07/搭建自己的博客.html)，不过在近半年的使用中，随着博文的增加，其静态博客的构建速度变慢越来越明显。所以打算换一个更快的博客框架<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"external\">hexo</a>。此外因为hexo是基于node.js的，所以安装，配置等操作比Jekyll简单多了。 <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<h2 id=\"环境搭建\">环境搭建</h2>\n<ul>\n<li>Mac版\n<ol style=\"list-style-type: decimal\">\n<li>安装Git（详情见[macbook常用软件及其管理](/2015/12/10/macbook常用软件及其管理.html)）</li>\n<li>安装Node.js 文档中给出的最佳方式是使用<a href=\"https://github.com/creationix/nvm\" target=\"_blank\" rel=\"external\">nvm</a>安装，不过个人偏爱与brew安装，管理方便。两种方法都提供如下：</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># nvm安装</span></div><div class=\"line\">wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</div><div class=\"line\"><span class=\"comment\"># 重启终端后安装Node.js</span></div><div class=\"line\">nvm install 4</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># brew安装</span></div><div class=\"line\">brew install nodejs</div></pre></td></tr></table></figure>\n<ol start=\"3\" style=\"list-style-type: decimal\">\n<li>安装hexo</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<p>hexo的常用用法如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 建立网站</span></div><div class=\"line\">hexo init &lt;folder&gt;</div><div class=\"line\"><span class=\"comment\"># 新建博文</span></div><div class=\"line\">hexo new [layout] &lt;title&gt;</div><div class=\"line\"><span class=\"comment\"># 生成静态文件，-d要求生成后立即部署</span></div><div class=\"line\">hexo generate <span class=\"_\">-d</span></div><div class=\"line\"><span class=\"comment\"># 发表草稿</span></div><div class=\"line\">hexo publish [layout] &lt;filename&gt;</div><div class=\"line\"><span class=\"comment\"># 启动服务器</span></div><div class=\"line\">hexo server</div><div class=\"line\"><span class=\"comment\"># 部署网站，-g要求部署前生成静态文件</span></div><div class=\"line\">hexo deploy -g</div><div class=\"line\"><span class=\"comment\"># 清除缓存文件（db.json）和已生成的静态文件（public）</span></div><div class=\"line\">hexo clean</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"站点建立\">站点建立</h2>\n<ul>\n<li><p>基础站点<br>\nhexo安装完成后，通过下面命令来构建站点文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init &lt;folder&gt;</div><div class=\"line\"><span class=\"built_in\">cd</span> &lt;folder&gt;</div><div class=\"line\">npm install</div></pre></td></tr></table></figure></li>\n</ul>\n<p>其目录结构如下： * _config.yml<br>\n网站的<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"external\">配置</a>信息，可以根据喜好自定义。 * package.json<br>\n应用程序的信息，EJS，Stylus和Markdown renderer已默认安装，可以自由移除。 * scaffolds<br>\n<a href=\"https://hexo.io/zh-cn/docs/writing.html\" target=\"_blank\" rel=\"external\">模板</a>文件夹。当新建文章时，hexo会根据scaffold来建立文件。 * source/_drafts<br>\n草稿文件 * source/_posts<br>\n成搞文件 * themes<br>\n<a href=\"https://hexo.io/zh-cn/docs/themes.html\" target=\"_blank\" rel=\"external\">主题</a>文件夹。Hexo会根据主题来生成静态页面。</p>\n<ul>\n<li>常用插件\n<ul>\n<li><p>git部署</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></li>\n<li></li>\n</ul></li>\n</ul>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"external\">hexo中文文档</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>之前写过一篇关于用jekyll搭建个人博客的博文[搭建自己的博客](/2015/06/07/搭建自己的博客.html)，不过在近半年的使用中，随着博文的增加，其静态博客的构建速度变慢越来越明显。所以打算换一个更快的博客框架<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"external\">hexo</a>。此外因为hexo是基于node.js的，所以安装，配置等操作比Jekyll简单多了。","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<h2 id=\"环境搭建\">环境搭建</h2>\n<ul>\n<li>Mac版\n<ol style=\"list-style-type: decimal\">\n<li>安装Git（详情见[macbook常用软件及其管理](/2015/12/10/macbook常用软件及其管理.html)）</li>\n<li>安装Node.js 文档中给出的最佳方式是使用<a href=\"https://github.com/creationix/nvm\" target=\"_blank\" rel=\"external\">nvm</a>安装，不过个人偏爱与brew安装，管理方便。两种方法都提供如下：</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># nvm安装</span></div><div class=\"line\">wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</div><div class=\"line\"><span class=\"comment\"># 重启终端后安装Node.js</span></div><div class=\"line\">nvm install 4</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># brew安装</span></div><div class=\"line\">brew install nodejs</div></pre></td></tr></table></figure>\n<ol start=\"3\" style=\"list-style-type: decimal\">\n<li>安装hexo</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<p>hexo的常用用法如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 建立网站</span></div><div class=\"line\">hexo init &lt;folder&gt;</div><div class=\"line\"><span class=\"comment\"># 新建博文</span></div><div class=\"line\">hexo new [layout] &lt;title&gt;</div><div class=\"line\"><span class=\"comment\"># 生成静态文件，-d要求生成后立即部署</span></div><div class=\"line\">hexo generate <span class=\"_\">-d</span></div><div class=\"line\"><span class=\"comment\"># 发表草稿</span></div><div class=\"line\">hexo publish [layout] &lt;filename&gt;</div><div class=\"line\"><span class=\"comment\"># 启动服务器</span></div><div class=\"line\">hexo server</div><div class=\"line\"><span class=\"comment\"># 部署网站，-g要求部署前生成静态文件</span></div><div class=\"line\">hexo deploy -g</div><div class=\"line\"><span class=\"comment\"># 清除缓存文件（db.json）和已生成的静态文件（public）</span></div><div class=\"line\">hexo clean</div></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"站点建立\">站点建立</h2>\n<ul>\n<li><p>基础站点<br>\nhexo安装完成后，通过下面命令来构建站点文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init &lt;folder&gt;</div><div class=\"line\"><span class=\"built_in\">cd</span> &lt;folder&gt;</div><div class=\"line\">npm install</div></pre></td></tr></table></figure></li>\n</ul>\n<p>其目录结构如下： * _config.yml<br>\n网站的<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"external\">配置</a>信息，可以根据喜好自定义。 * package.json<br>\n应用程序的信息，EJS，Stylus和Markdown renderer已默认安装，可以自由移除。 * scaffolds<br>\n<a href=\"https://hexo.io/zh-cn/docs/writing.html\" target=\"_blank\" rel=\"external\">模板</a>文件夹。当新建文章时，hexo会根据scaffold来建立文件。 * source/_drafts<br>\n草稿文件 * source/_posts<br>\n成搞文件 * themes<br>\n<a href=\"https://hexo.io/zh-cn/docs/themes.html\" target=\"_blank\" rel=\"external\">主题</a>文件夹。Hexo会根据主题来生成静态页面。</p>\n<ul>\n<li>常用插件\n<ul>\n<li><p>git部署</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></li>\n<li></li>\n</ul></li>\n</ul>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"external\">hexo中文文档</a></li>\n</ol>"},{"layout":"post","title":"macbook常用软件及其管理","comments":1,"_content":"众所周知，基本上每个Unix系统的发行版本都有一个非常强大的软件包管理系统，它能够非常便利的管理系统中的软件，而且绝对纯净，绝壁不加任何插件，像Ubuntu里的apt，CentOS里的yum等。而Mac OS X是基于Unix的操作系统，可以安装大部分为Unix/Linux开发的软件。它也有非常好用的软件包管理系统Homebrew和Macports。\n<!-- more -->\n\n## 简介\n在Mac OS X系统中，除了Homebrew，还有其他的包管理系统，像MacPorts。之所以选择Homebrew是因为它尽可能地利用系统自带的各种库，使得软件包的编译时间大为缩短；同时由于几乎不会造成冗余，软件包的管理也清晰、灵活了许多。其另一个优势是使用Ruby定义软件包安装配置（叫做formula），定制非常简单。\n\n> **Tips:Macports**\n> Macports的工作方式是下载source code，然后在本地编译。其理念是尽量减少对系统现有库的依赖，所以第一次用macport要很长时间，但好处是更新Mac OS不会破坏你现有的package。Macports安装所有的package到/opt/local下面，这样不会和系统现有的/usr/local有冲突。\n>\n> 如果你是重量级的Linux用户，希望使用所有的open source package，哪买macports是不二选择，如果只是希望很快的安装一些便利的工具，那么homebrew更好点。前段时间，由于系统自带的python和brew安装的python产生了冲突，所以感觉我更适合macports。哈哈哈\n>\n\n\n## 安装\n1. 安装Xcode  \n    前面说过Homebrew会尽可能利用系统自带的各种库，所以要在安装brew前把系统的各种库补全。顺便把Xcode的文档也安装了。\n\n    ```sh\n    # 安装xcode\n    xcode-select --install\n    ```\n2. 包管理软件\n    * [brew][brew]&&[brew cask][cask]\n        1. 安装\n\n            ```sh\n            # 安装brew，目前是这个地址，具体以官网为准\n            ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n            # 安装brew cask\n            brew tap caskroom/cask\n            brew update && brew upgrade\n            ```\n        2. 使用(以wget为例)\n\n            ```sh\n            # 查找软件包\n            brew search wget\n            # 安装软件包\n            brew install wget\n            # 列出已安装的软件包\n            brew list\n            # 删除软件包\n            brew remove wget\n            # 查看软件包信息\n            brew info wget\n            # 列出软件包的依赖关系\n            brew deps wget\n            # 更新brew\n            brew update\n            # 列出过时的软件包（已安装但不是最新版本）\n            brew outdated\n            # 更新过时的软件包（全部或指定）\n            brew upgrade 或 brew upgrade wget\n            ```\n        > **Tips:brew和brew cask的区别**  \n        > 上面介绍了`brew`的用法，而`brew cask`的用法基本和`brew`一样，就是将`brew`替换成`brew cask`。  \n> 二者的区别是`brew`侧重于软件套件和软件环境的配置安装，而`brew cask`则偏向mac平台上图形化软件的安装。具体的体现是brew一般都是下载源码，解压，然后 `./configure && make install` ，同时会包含相关依存库，并自动配置好各种环境变量，而且易于卸载。 这样就能快速安装和升级本地的各种开发环境。而`brew cask`是已经编译好了的应用包（.dmg/.pkg），仅仅是下载解压，放在统一的目录中（/opt/homebrew-cask/Caskroom），省掉了自己去下载、解压、拖拽（安装）等蛋疼步骤，同样，卸载相当容易与干净。这个对一般用户来说会比较方便，包含很多在AppStore里没有的常用软件。\n        >\n    * [Macports][macports]\n        1. 安装  \n        有两种方式，第一种是通过`brew cask`安装，另一种是源码编译安装。\n\n            ```sh\n            # 快速安装\n            brew bask install macports\n            # 源码编译安装\n            wget https://distfiles.macports.org/MacPorts/MacPorts-2.3.4.tar.gz\n            tar zxvf MacPorts-2.3.4.tar.gz\n            cd MacPorts-2.3.4\n            ./configure && make &&sudo  make install\n            sudo echo \"export PATH=/opt/local/bin:$PATH\" >> /etc/profile\n            sudo echo \"export PATH=/opt/local/sbin:$PATH\" >> /etc/profile\n            sudo port -v selfupdate\n            ```\n        2. 使用(以wget为例)  \n\n            ```sh\n            # 查找软件包\n            port search wget\n            # 安装软件包\n            port install wget\n            # 列出已安装的软件包\n            port list\n            # 删除软件包\n            port uninstall wget\n            # 查看软件包信息\n            port info wget\n            # 列出软件包的依赖关系\n            port deps wget\n            # 更新port\n            port -v selfupdate\n            # 列出过时的软件包（已安装但不是最新版本）\n            port outdated\n            # 更新过时的软件包（全部或指定）\n            port upgrade outdated\n            ```\n\n3. 安装日常所用软件  \n\t常用软件可以直接在APP Store（软件重要但比较少）查找安装,也可以通过网上的dmg软件包（软件多但安全性要自己斟酌）安装，不过建议是用shell脚本[mac_install.sh]({{ site.baseurl }}/assets/attachs/mac_install.sh.txt)安装(通过Homebrew管理，软件多而且安全性绝对保障，最关键的是可以定制化批量安装).\n\n    1. atom\n    黑客级别的文本编辑器。\n\n        ```sh\n        brew install Caskroom/cask/atom\n        ```\n    2. neteasemusic\n    网易云音乐，一款主打歌单的听歌软件。\n\n        ```sh\n        brew install Caskroom/cask/neteasemusic\n        ```\n    3. google-chrome\n    Google浏览器chrome，插件流。\n\n        ```sh\n        brew install Caskroom/caskgoogle-chrome\n        ```\n        > **注意:**   \n        > 安装完成后,需要登陆google帐号,可以同步书签并扩展应用\n    4. QQ\n    当下国内主流交际软件。\n\n        ```sh\n        brew install Caskroom/cask/qq\n        ```\n\n    1. octave\n\n        ```bash\n        # homebrew添加第三方工具包\n        brew tap homebrew/science\n        # 更新brew&&更新过时的软件包\n        brew update && brew upgrade\n        # 一款媲美matlab的科学计算工具\n        brew install octave\n        ```\n    2. vim\n    3. data science[python]\n\n        ```sh\n        # python\n        brew install python --framework\n        # numpy\n        brew install homebrew/python/numpy\n        # scipy\n        brew install homebrew/python/scipy\n        # matplotlib\n        brew install homebrew/python/matplotlib\n        # scikit-learn--机器学习的库\n        pip install -U scikit-learn\n        # Theano--深度学习的库\n        pip install Theano\n        #\n\n        ```\n    4. launchrocket\n    LaunchRocket是一个管理brew安装的service的工具，安装之后可以看所有的service的运行状态。\n\n        ```sh\n        brew tap jimbojsb/launchrocket\n        brew cask install launchrocket\n        ```\n    5. python集成环境PyCharm\n\n        ```sh\n        brew cask install pycharm\n        ```\n        > **Tips:破解**  \n        > 在注册时选择`License server，填 http://idea.lanyus.com ，然后点击 OK.\n    6. java开发\n\n        ```sh\n        brew cask install java\n        ```\n\n## 待续\n\n## 参考文献\n3. [homebrew官网][brew]\n2. [brew cask官网][cask]\n3. [MacPorts官网][macports]\n\n[brew]:     http://brew.sh/index_zh-cn.html\n[cask]:     http://caskroom.io/\n[macports]: https://www.macports.org/\n","source":"_posts/2015-12-10-macbook常用软件及其管理.md","raw":"---\nlayout:\tpost\ntitle:\tmacbook常用软件及其管理\ncategories:\n- TECHNOLOGY\ntags:\n- Mac\n- Software\npermalink:  Manage-software-Mac\ncomments:\ttrue\n---\n众所周知，基本上每个Unix系统的发行版本都有一个非常强大的软件包管理系统，它能够非常便利的管理系统中的软件，而且绝对纯净，绝壁不加任何插件，像Ubuntu里的apt，CentOS里的yum等。而Mac OS X是基于Unix的操作系统，可以安装大部分为Unix/Linux开发的软件。它也有非常好用的软件包管理系统Homebrew和Macports。\n<!-- more -->\n\n## 简介\n在Mac OS X系统中，除了Homebrew，还有其他的包管理系统，像MacPorts。之所以选择Homebrew是因为它尽可能地利用系统自带的各种库，使得软件包的编译时间大为缩短；同时由于几乎不会造成冗余，软件包的管理也清晰、灵活了许多。其另一个优势是使用Ruby定义软件包安装配置（叫做formula），定制非常简单。\n\n> **Tips:Macports**\n> Macports的工作方式是下载source code，然后在本地编译。其理念是尽量减少对系统现有库的依赖，所以第一次用macport要很长时间，但好处是更新Mac OS不会破坏你现有的package。Macports安装所有的package到/opt/local下面，这样不会和系统现有的/usr/local有冲突。\n>\n> 如果你是重量级的Linux用户，希望使用所有的open source package，哪买macports是不二选择，如果只是希望很快的安装一些便利的工具，那么homebrew更好点。前段时间，由于系统自带的python和brew安装的python产生了冲突，所以感觉我更适合macports。哈哈哈\n>\n\n\n## 安装\n1. 安装Xcode  \n    前面说过Homebrew会尽可能利用系统自带的各种库，所以要在安装brew前把系统的各种库补全。顺便把Xcode的文档也安装了。\n\n    ```sh\n    # 安装xcode\n    xcode-select --install\n    ```\n2. 包管理软件\n    * [brew][brew]&&[brew cask][cask]\n        1. 安装\n\n            ```sh\n            # 安装brew，目前是这个地址，具体以官网为准\n            ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n            # 安装brew cask\n            brew tap caskroom/cask\n            brew update && brew upgrade\n            ```\n        2. 使用(以wget为例)\n\n            ```sh\n            # 查找软件包\n            brew search wget\n            # 安装软件包\n            brew install wget\n            # 列出已安装的软件包\n            brew list\n            # 删除软件包\n            brew remove wget\n            # 查看软件包信息\n            brew info wget\n            # 列出软件包的依赖关系\n            brew deps wget\n            # 更新brew\n            brew update\n            # 列出过时的软件包（已安装但不是最新版本）\n            brew outdated\n            # 更新过时的软件包（全部或指定）\n            brew upgrade 或 brew upgrade wget\n            ```\n        > **Tips:brew和brew cask的区别**  \n        > 上面介绍了`brew`的用法，而`brew cask`的用法基本和`brew`一样，就是将`brew`替换成`brew cask`。  \n> 二者的区别是`brew`侧重于软件套件和软件环境的配置安装，而`brew cask`则偏向mac平台上图形化软件的安装。具体的体现是brew一般都是下载源码，解压，然后 `./configure && make install` ，同时会包含相关依存库，并自动配置好各种环境变量，而且易于卸载。 这样就能快速安装和升级本地的各种开发环境。而`brew cask`是已经编译好了的应用包（.dmg/.pkg），仅仅是下载解压，放在统一的目录中（/opt/homebrew-cask/Caskroom），省掉了自己去下载、解压、拖拽（安装）等蛋疼步骤，同样，卸载相当容易与干净。这个对一般用户来说会比较方便，包含很多在AppStore里没有的常用软件。\n        >\n    * [Macports][macports]\n        1. 安装  \n        有两种方式，第一种是通过`brew cask`安装，另一种是源码编译安装。\n\n            ```sh\n            # 快速安装\n            brew bask install macports\n            # 源码编译安装\n            wget https://distfiles.macports.org/MacPorts/MacPorts-2.3.4.tar.gz\n            tar zxvf MacPorts-2.3.4.tar.gz\n            cd MacPorts-2.3.4\n            ./configure && make &&sudo  make install\n            sudo echo \"export PATH=/opt/local/bin:$PATH\" >> /etc/profile\n            sudo echo \"export PATH=/opt/local/sbin:$PATH\" >> /etc/profile\n            sudo port -v selfupdate\n            ```\n        2. 使用(以wget为例)  \n\n            ```sh\n            # 查找软件包\n            port search wget\n            # 安装软件包\n            port install wget\n            # 列出已安装的软件包\n            port list\n            # 删除软件包\n            port uninstall wget\n            # 查看软件包信息\n            port info wget\n            # 列出软件包的依赖关系\n            port deps wget\n            # 更新port\n            port -v selfupdate\n            # 列出过时的软件包（已安装但不是最新版本）\n            port outdated\n            # 更新过时的软件包（全部或指定）\n            port upgrade outdated\n            ```\n\n3. 安装日常所用软件  \n\t常用软件可以直接在APP Store（软件重要但比较少）查找安装,也可以通过网上的dmg软件包（软件多但安全性要自己斟酌）安装，不过建议是用shell脚本[mac_install.sh]({{ site.baseurl }}/assets/attachs/mac_install.sh.txt)安装(通过Homebrew管理，软件多而且安全性绝对保障，最关键的是可以定制化批量安装).\n\n    1. atom\n    黑客级别的文本编辑器。\n\n        ```sh\n        brew install Caskroom/cask/atom\n        ```\n    2. neteasemusic\n    网易云音乐，一款主打歌单的听歌软件。\n\n        ```sh\n        brew install Caskroom/cask/neteasemusic\n        ```\n    3. google-chrome\n    Google浏览器chrome，插件流。\n\n        ```sh\n        brew install Caskroom/caskgoogle-chrome\n        ```\n        > **注意:**   \n        > 安装完成后,需要登陆google帐号,可以同步书签并扩展应用\n    4. QQ\n    当下国内主流交际软件。\n\n        ```sh\n        brew install Caskroom/cask/qq\n        ```\n\n    1. octave\n\n        ```bash\n        # homebrew添加第三方工具包\n        brew tap homebrew/science\n        # 更新brew&&更新过时的软件包\n        brew update && brew upgrade\n        # 一款媲美matlab的科学计算工具\n        brew install octave\n        ```\n    2. vim\n    3. data science[python]\n\n        ```sh\n        # python\n        brew install python --framework\n        # numpy\n        brew install homebrew/python/numpy\n        # scipy\n        brew install homebrew/python/scipy\n        # matplotlib\n        brew install homebrew/python/matplotlib\n        # scikit-learn--机器学习的库\n        pip install -U scikit-learn\n        # Theano--深度学习的库\n        pip install Theano\n        #\n\n        ```\n    4. launchrocket\n    LaunchRocket是一个管理brew安装的service的工具，安装之后可以看所有的service的运行状态。\n\n        ```sh\n        brew tap jimbojsb/launchrocket\n        brew cask install launchrocket\n        ```\n    5. python集成环境PyCharm\n\n        ```sh\n        brew cask install pycharm\n        ```\n        > **Tips:破解**  \n        > 在注册时选择`License server，填 http://idea.lanyus.com ，然后点击 OK.\n    6. java开发\n\n        ```sh\n        brew cask install java\n        ```\n\n## 待续\n\n## 参考文献\n3. [homebrew官网][brew]\n2. [brew cask官网][cask]\n3. [MacPorts官网][macports]\n\n[brew]:     http://brew.sh/index_zh-cn.html\n[cask]:     http://caskroom.io/\n[macports]: https://www.macports.org/\n","slug":"Manage-software-Mac","published":1,"date":"2015-12-09T16:00:00.000Z","updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1q001xl73y5h2id8ug","content":"<p>众所周知，基本上每个Unix系统的发行版本都有一个非常强大的软件包管理系统，它能够非常便利的管理系统中的软件，而且绝对纯净，绝壁不加任何插件，像Ubuntu里的apt，CentOS里的yum等。而Mac OS X是基于Unix的操作系统，可以安装大部分为Unix/Linux开发的软件。它也有非常好用的软件包管理系统Homebrew和Macports。 <a id=\"more\"></a></p>\n<h2 id=\"简介\">简介</h2>\n<p>在Mac OS X系统中，除了Homebrew，还有其他的包管理系统，像MacPorts。之所以选择Homebrew是因为它尽可能地利用系统自带的各种库，使得软件包的编译时间大为缩短；同时由于几乎不会造成冗余，软件包的管理也清晰、灵活了许多。其另一个优势是使用Ruby定义软件包安装配置（叫做formula），定制非常简单。</p>\n<blockquote>\n<p><strong>Tips:Macports</strong> Macports的工作方式是下载source code，然后在本地编译。其理念是尽量减少对系统现有库的依赖，所以第一次用macport要很长时间，但好处是更新Mac OS不会破坏你现有的package。Macports安装所有的package到/opt/local下面，这样不会和系统现有的/usr/local有冲突。</p>\n<p>如果你是重量级的Linux用户，希望使用所有的open source package，哪买macports是不二选择，如果只是希望很快的安装一些便利的工具，那么homebrew更好点。前段时间，由于系统自带的python和brew安装的python产生了冲突，所以感觉我更适合macports。哈哈哈</p>\n</blockquote>\n<h2 id=\"安装\">安装</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>安装Xcode<br>\n前面说过Homebrew会尽可能利用系统自带的各种库，所以要在安装brew前把系统的各种库补全。顺便把Xcode的文档也安装了。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装xcode</span></div><div class=\"line\">xcode-select --install</div></pre></td></tr></table></figure></li>\n<li>包管理软件\n<ul>\n<li><a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"external\">brew</a>&amp;&amp;<a href=\"http://caskroom.io/\" target=\"_blank\" rel=\"external\">brew cask</a>\n<ol style=\"list-style-type: decimal\">\n<li><p>安装</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装brew，目前是这个地址，具体以官网为准</span></div><div class=\"line\">ruby <span class=\"_\">-e</span> <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>\"</span></div><div class=\"line\"><span class=\"comment\"># 安装brew cask</span></div><div class=\"line\">brew tap caskroom/cask</div><div class=\"line\">brew update &amp;&amp; brew upgrade</div></pre></td></tr></table></figure></li>\n<li><p>使用(以wget为例)</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 查找软件包</span></div><div class=\"line\">brew search wget</div><div class=\"line\"><span class=\"comment\"># 安装软件包</span></div><div class=\"line\">brew install wget</div><div class=\"line\"><span class=\"comment\"># 列出已安装的软件包</span></div><div class=\"line\">brew list</div><div class=\"line\"><span class=\"comment\"># 删除软件包</span></div><div class=\"line\">brew remove wget</div><div class=\"line\"><span class=\"comment\"># 查看软件包信息</span></div><div class=\"line\">brew info wget</div><div class=\"line\"><span class=\"comment\"># 列出软件包的依赖关系</span></div><div class=\"line\">brew deps wget</div><div class=\"line\"><span class=\"comment\"># 更新brew</span></div><div class=\"line\">brew update</div><div class=\"line\"><span class=\"comment\"># 列出过时的软件包（已安装但不是最新版本）</span></div><div class=\"line\">brew outdated</div><div class=\"line\"><span class=\"comment\"># 更新过时的软件包（全部或指定）</span></div><div class=\"line\">brew upgrade 或 brew upgrade wget</div></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p><strong>Tips:brew和brew cask的区别</strong><br>\n上面介绍了<code>brew</code>的用法，而<code>brew cask</code>的用法基本和<code>brew</code>一样，就是将<code>brew</code>替换成<code>brew cask</code>。<br>\n二者的区别是<code>brew</code>侧重于软件套件和软件环境的配置安装，而<code>brew cask</code>则偏向mac平台上图形化软件的安装。具体的体现是brew一般都是下载源码，解压，然后 <code>./configure &amp;&amp; make install</code> ，同时会包含相关依存库，并自动配置好各种环境变量，而且易于卸载。 这样就能快速安装和升级本地的各种开发环境。而<code>brew cask</code>是已经编译好了的应用包（.dmg/.pkg），仅仅是下载解压，放在统一的目录中（/opt/homebrew-cask/Caskroom），省掉了自己去下载、解压、拖拽（安装）等蛋疼步骤，同样，卸载相当容易与干净。这个对一般用户来说会比较方便，包含很多在AppStore里没有的常用软件。</p>\n</blockquote></li>\n<li><a href=\"https://www.macports.org/\" target=\"_blank\" rel=\"external\">Macports</a>\n<ol style=\"list-style-type: decimal\">\n<li><p>安装<br>\n有两种方式，第一种是通过<code>brew cask</code>安装，另一种是源码编译安装。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 快速安装</span></div><div class=\"line\">brew bask install macports</div><div class=\"line\"><span class=\"comment\"># 源码编译安装</span></div><div class=\"line\">wget https://distfiles.macports.org/MacPorts/MacPorts-2.3.4.tar.gz</div><div class=\"line\">tar zxvf MacPorts-2.3.4.tar.gz</div><div class=\"line\"><span class=\"built_in\">cd</span> MacPorts-2.3.4</div><div class=\"line\">./configure &amp;&amp; make &amp;&amp;sudo  make install</div><div class=\"line\">sudo <span class=\"built_in\">echo</span> <span class=\"string\">\"export PATH=/opt/local/bin:<span class=\"variable\">$PATH</span>\"</span> &gt;&gt; /etc/profile</div><div class=\"line\">sudo <span class=\"built_in\">echo</span> <span class=\"string\">\"export PATH=/opt/local/sbin:<span class=\"variable\">$PATH</span>\"</span> &gt;&gt; /etc/profile</div><div class=\"line\">sudo port -v selfupdate</div></pre></td></tr></table></figure></li>\n<li><p>使用(以wget为例)</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 查找软件包</span></div><div class=\"line\">port search wget</div><div class=\"line\"><span class=\"comment\"># 安装软件包</span></div><div class=\"line\">port install wget</div><div class=\"line\"><span class=\"comment\"># 列出已安装的软件包</span></div><div class=\"line\">port list</div><div class=\"line\"><span class=\"comment\"># 删除软件包</span></div><div class=\"line\">port uninstall wget</div><div class=\"line\"><span class=\"comment\"># 查看软件包信息</span></div><div class=\"line\">port info wget</div><div class=\"line\"><span class=\"comment\"># 列出软件包的依赖关系</span></div><div class=\"line\">port deps wget</div><div class=\"line\"><span class=\"comment\"># 更新port</span></div><div class=\"line\">port -v selfupdate</div><div class=\"line\"><span class=\"comment\"># 列出过时的软件包（已安装但不是最新版本）</span></div><div class=\"line\">port outdated</div><div class=\"line\"><span class=\"comment\"># 更新过时的软件包（全部或指定）</span></div><div class=\"line\">port upgrade outdated</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ul></li>\n<li><p>安装日常所用软件<br>\n常用软件可以直接在APP Store（软件重要但比较少）查找安装,也可以通过网上的dmg软件包（软件多但安全性要自己斟酌）安装，不过建议是用shell脚本[mac_install.sh](/assets/attachs/mac_install.sh.txt)安装(通过Homebrew管理，软件多而且安全性绝对保障，最关键的是可以定制化批量安装).</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>atom 黑客级别的文本编辑器。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install Caskroom/cask/atom</div></pre></td></tr></table></figure></li>\n<li><p>neteasemusic 网易云音乐，一款主打歌单的听歌软件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install Caskroom/cask/neteasemusic</div></pre></td></tr></table></figure></li>\n<li><p>google-chrome Google浏览器chrome，插件流。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install Caskroom/caskgoogle-chrome</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意:</strong><br>\n安装完成后,需要登陆google帐号,可以同步书签并扩展应用</p>\n</blockquote></li>\n<li><p>QQ 当下国内主流交际软件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install Caskroom/cask/qq</div></pre></td></tr></table></figure></li>\n<li><p>octave</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># homebrew添加第三方工具包</span></div><div class=\"line\">brew tap homebrew/science</div><div class=\"line\"><span class=\"comment\"># 更新brew&amp;&amp;更新过时的软件包</span></div><div class=\"line\">brew update &amp;&amp; brew upgrade</div><div class=\"line\"><span class=\"comment\"># 一款媲美matlab的科学计算工具</span></div><div class=\"line\">brew install octave</div></pre></td></tr></table></figure></li>\n<li>vim</li>\n<li><p>data science[python]</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># python</span></div><div class=\"line\">brew install python --framework</div><div class=\"line\"><span class=\"comment\"># numpy</span></div><div class=\"line\">brew install homebrew/python/numpy</div><div class=\"line\"><span class=\"comment\"># scipy</span></div><div class=\"line\">brew install homebrew/python/scipy</div><div class=\"line\"><span class=\"comment\"># matplotlib</span></div><div class=\"line\">brew install homebrew/python/matplotlib</div><div class=\"line\"><span class=\"comment\"># scikit-learn--机器学习的库</span></div><div class=\"line\">pip install -U scikit-learn</div><div class=\"line\"><span class=\"comment\"># Theano--深度学习的库</span></div><div class=\"line\">pip install Theano</div><div class=\"line\"><span class=\"comment\">#</span></div></pre></td></tr></table></figure></li>\n<li><p>launchrocket LaunchRocket是一个管理brew安装的service的工具，安装之后可以看所有的service的运行状态。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew tap jimbojsb/launchrocket</div><div class=\"line\">brew cask install launchrocket</div></pre></td></tr></table></figure></li>\n<li><p>python集成环境PyCharm</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew cask install pycharm</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Tips:破解</strong><br>\n在注册时选择`License server，填 http://idea.lanyus.com ，然后点击 OK.</p>\n</blockquote></li>\n<li><p>java开发</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew cask install java</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ol>\n<h2 id=\"待续\">待续</h2>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol start=\"3\" style=\"list-style-type: decimal\">\n<li><a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"external\">homebrew官网</a></li>\n<li><a href=\"http://caskroom.io/\" target=\"_blank\" rel=\"external\">brew cask官网</a></li>\n<li><a href=\"https://www.macports.org/\" target=\"_blank\" rel=\"external\">MacPorts官网</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>众所周知，基本上每个Unix系统的发行版本都有一个非常强大的软件包管理系统，它能够非常便利的管理系统中的软件，而且绝对纯净，绝壁不加任何插件，像Ubuntu里的apt，CentOS里的yum等。而Mac OS X是基于Unix的操作系统，可以安装大部分为Unix/Linux开发的软件。它也有非常好用的软件包管理系统Homebrew和Macports。","more":"</p>\n<h2 id=\"简介\">简介</h2>\n<p>在Mac OS X系统中，除了Homebrew，还有其他的包管理系统，像MacPorts。之所以选择Homebrew是因为它尽可能地利用系统自带的各种库，使得软件包的编译时间大为缩短；同时由于几乎不会造成冗余，软件包的管理也清晰、灵活了许多。其另一个优势是使用Ruby定义软件包安装配置（叫做formula），定制非常简单。</p>\n<blockquote>\n<p><strong>Tips:Macports</strong> Macports的工作方式是下载source code，然后在本地编译。其理念是尽量减少对系统现有库的依赖，所以第一次用macport要很长时间，但好处是更新Mac OS不会破坏你现有的package。Macports安装所有的package到/opt/local下面，这样不会和系统现有的/usr/local有冲突。</p>\n<p>如果你是重量级的Linux用户，希望使用所有的open source package，哪买macports是不二选择，如果只是希望很快的安装一些便利的工具，那么homebrew更好点。前段时间，由于系统自带的python和brew安装的python产生了冲突，所以感觉我更适合macports。哈哈哈</p>\n</blockquote>\n<h2 id=\"安装\">安装</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>安装Xcode<br>\n前面说过Homebrew会尽可能利用系统自带的各种库，所以要在安装brew前把系统的各种库补全。顺便把Xcode的文档也安装了。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装xcode</span></div><div class=\"line\">xcode-select --install</div></pre></td></tr></table></figure></li>\n<li>包管理软件\n<ul>\n<li><a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"external\">brew</a>&amp;&amp;<a href=\"http://caskroom.io/\" target=\"_blank\" rel=\"external\">brew cask</a>\n<ol style=\"list-style-type: decimal\">\n<li><p>安装</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装brew，目前是这个地址，具体以官网为准</span></div><div class=\"line\">ruby <span class=\"_\">-e</span> <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>\"</span></div><div class=\"line\"><span class=\"comment\"># 安装brew cask</span></div><div class=\"line\">brew tap caskroom/cask</div><div class=\"line\">brew update &amp;&amp; brew upgrade</div></pre></td></tr></table></figure></li>\n<li><p>使用(以wget为例)</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 查找软件包</span></div><div class=\"line\">brew search wget</div><div class=\"line\"><span class=\"comment\"># 安装软件包</span></div><div class=\"line\">brew install wget</div><div class=\"line\"><span class=\"comment\"># 列出已安装的软件包</span></div><div class=\"line\">brew list</div><div class=\"line\"><span class=\"comment\"># 删除软件包</span></div><div class=\"line\">brew remove wget</div><div class=\"line\"><span class=\"comment\"># 查看软件包信息</span></div><div class=\"line\">brew info wget</div><div class=\"line\"><span class=\"comment\"># 列出软件包的依赖关系</span></div><div class=\"line\">brew deps wget</div><div class=\"line\"><span class=\"comment\"># 更新brew</span></div><div class=\"line\">brew update</div><div class=\"line\"><span class=\"comment\"># 列出过时的软件包（已安装但不是最新版本）</span></div><div class=\"line\">brew outdated</div><div class=\"line\"><span class=\"comment\"># 更新过时的软件包（全部或指定）</span></div><div class=\"line\">brew upgrade 或 brew upgrade wget</div></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p><strong>Tips:brew和brew cask的区别</strong><br>\n上面介绍了<code>brew</code>的用法，而<code>brew cask</code>的用法基本和<code>brew</code>一样，就是将<code>brew</code>替换成<code>brew cask</code>。<br>\n二者的区别是<code>brew</code>侧重于软件套件和软件环境的配置安装，而<code>brew cask</code>则偏向mac平台上图形化软件的安装。具体的体现是brew一般都是下载源码，解压，然后 <code>./configure &amp;&amp; make install</code> ，同时会包含相关依存库，并自动配置好各种环境变量，而且易于卸载。 这样就能快速安装和升级本地的各种开发环境。而<code>brew cask</code>是已经编译好了的应用包（.dmg/.pkg），仅仅是下载解压，放在统一的目录中（/opt/homebrew-cask/Caskroom），省掉了自己去下载、解压、拖拽（安装）等蛋疼步骤，同样，卸载相当容易与干净。这个对一般用户来说会比较方便，包含很多在AppStore里没有的常用软件。</p>\n</blockquote></li>\n<li><a href=\"https://www.macports.org/\" target=\"_blank\" rel=\"external\">Macports</a>\n<ol style=\"list-style-type: decimal\">\n<li><p>安装<br>\n有两种方式，第一种是通过<code>brew cask</code>安装，另一种是源码编译安装。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 快速安装</span></div><div class=\"line\">brew bask install macports</div><div class=\"line\"><span class=\"comment\"># 源码编译安装</span></div><div class=\"line\">wget https://distfiles.macports.org/MacPorts/MacPorts-2.3.4.tar.gz</div><div class=\"line\">tar zxvf MacPorts-2.3.4.tar.gz</div><div class=\"line\"><span class=\"built_in\">cd</span> MacPorts-2.3.4</div><div class=\"line\">./configure &amp;&amp; make &amp;&amp;sudo  make install</div><div class=\"line\">sudo <span class=\"built_in\">echo</span> <span class=\"string\">\"export PATH=/opt/local/bin:<span class=\"variable\">$PATH</span>\"</span> &gt;&gt; /etc/profile</div><div class=\"line\">sudo <span class=\"built_in\">echo</span> <span class=\"string\">\"export PATH=/opt/local/sbin:<span class=\"variable\">$PATH</span>\"</span> &gt;&gt; /etc/profile</div><div class=\"line\">sudo port -v selfupdate</div></pre></td></tr></table></figure></li>\n<li><p>使用(以wget为例)</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 查找软件包</span></div><div class=\"line\">port search wget</div><div class=\"line\"><span class=\"comment\"># 安装软件包</span></div><div class=\"line\">port install wget</div><div class=\"line\"><span class=\"comment\"># 列出已安装的软件包</span></div><div class=\"line\">port list</div><div class=\"line\"><span class=\"comment\"># 删除软件包</span></div><div class=\"line\">port uninstall wget</div><div class=\"line\"><span class=\"comment\"># 查看软件包信息</span></div><div class=\"line\">port info wget</div><div class=\"line\"><span class=\"comment\"># 列出软件包的依赖关系</span></div><div class=\"line\">port deps wget</div><div class=\"line\"><span class=\"comment\"># 更新port</span></div><div class=\"line\">port -v selfupdate</div><div class=\"line\"><span class=\"comment\"># 列出过时的软件包（已安装但不是最新版本）</span></div><div class=\"line\">port outdated</div><div class=\"line\"><span class=\"comment\"># 更新过时的软件包（全部或指定）</span></div><div class=\"line\">port upgrade outdated</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ul></li>\n<li><p>安装日常所用软件<br>\n常用软件可以直接在APP Store（软件重要但比较少）查找安装,也可以通过网上的dmg软件包（软件多但安全性要自己斟酌）安装，不过建议是用shell脚本[mac_install.sh](/assets/attachs/mac_install.sh.txt)安装(通过Homebrew管理，软件多而且安全性绝对保障，最关键的是可以定制化批量安装).</p>\n<ol style=\"list-style-type: decimal\">\n<li><p>atom 黑客级别的文本编辑器。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install Caskroom/cask/atom</div></pre></td></tr></table></figure></li>\n<li><p>neteasemusic 网易云音乐，一款主打歌单的听歌软件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install Caskroom/cask/neteasemusic</div></pre></td></tr></table></figure></li>\n<li><p>google-chrome Google浏览器chrome，插件流。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install Caskroom/caskgoogle-chrome</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意:</strong><br>\n安装完成后,需要登陆google帐号,可以同步书签并扩展应用</p>\n</blockquote></li>\n<li><p>QQ 当下国内主流交际软件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install Caskroom/cask/qq</div></pre></td></tr></table></figure></li>\n<li><p>octave</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># homebrew添加第三方工具包</span></div><div class=\"line\">brew tap homebrew/science</div><div class=\"line\"><span class=\"comment\"># 更新brew&amp;&amp;更新过时的软件包</span></div><div class=\"line\">brew update &amp;&amp; brew upgrade</div><div class=\"line\"><span class=\"comment\"># 一款媲美matlab的科学计算工具</span></div><div class=\"line\">brew install octave</div></pre></td></tr></table></figure></li>\n<li>vim</li>\n<li><p>data science[python]</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># python</span></div><div class=\"line\">brew install python --framework</div><div class=\"line\"><span class=\"comment\"># numpy</span></div><div class=\"line\">brew install homebrew/python/numpy</div><div class=\"line\"><span class=\"comment\"># scipy</span></div><div class=\"line\">brew install homebrew/python/scipy</div><div class=\"line\"><span class=\"comment\"># matplotlib</span></div><div class=\"line\">brew install homebrew/python/matplotlib</div><div class=\"line\"><span class=\"comment\"># scikit-learn--机器学习的库</span></div><div class=\"line\">pip install -U scikit-learn</div><div class=\"line\"><span class=\"comment\"># Theano--深度学习的库</span></div><div class=\"line\">pip install Theano</div><div class=\"line\"><span class=\"comment\">#</span></div></pre></td></tr></table></figure></li>\n<li><p>launchrocket LaunchRocket是一个管理brew安装的service的工具，安装之后可以看所有的service的运行状态。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew tap jimbojsb/launchrocket</div><div class=\"line\">brew cask install launchrocket</div></pre></td></tr></table></figure></li>\n<li><p>python集成环境PyCharm</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew cask install pycharm</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>Tips:破解</strong><br>\n在注册时选择`License server，填 http://idea.lanyus.com ，然后点击 OK.</p>\n</blockquote></li>\n<li><p>java开发</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew cask install java</div></pre></td></tr></table></figure></li>\n</ol></li>\n</ol>\n<h2 id=\"待续\">待续</h2>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol start=\"3\" style=\"list-style-type: decimal\">\n<li><a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"external\">homebrew官网</a></li>\n<li><a href=\"http://caskroom.io/\" target=\"_blank\" rel=\"external\">brew cask官网</a></li>\n<li><a href=\"https://www.macports.org/\" target=\"_blank\" rel=\"external\">MacPorts官网</a></li>\n</ol>"},{"layout":"post","title":"程序猿得看的经典好书","comments":1,"date":"2016-01-08T07:52:23.000Z","_content":"其实想写这篇文章的缘由是因为看了微信公众号菜鸟教程推荐的那篇[编程入门技巧大全](https://mp.weixin.qq.com/s?__biz=MzA5NDIzNzY1OQ==&mid=447566521&idx=1&sn=7f086ef930e81e9075eb332af26240d6&scene=0#wechat_redirect)，对于它说的一点我非常赞同就是多看好书，多读经典，并对它推荐的经典书籍作了记录，以方便后面可以拜读。\n<!-- more -->\n\n## 什么叫好书\n差书会误人子弟，不但浪费了时间和精力，更可怕的是他会打击人的自信心,会让人越来越怀疑自己的学习能力。而好书虽然好，但是数量却很少，特别是被大家公认很有价值的好书更是少之又少。历经多年时间考验和市场风雨的残酷洗礼而仅存的巨著，更是极其稀少。君不见，中国历史上的文学小说多如牛毛，但仅存的巨著也不过《三国演义》等四本。\n\n## 编程语言\n其实对于编程语言的选择并不是非常重要，纯属个人喜好。因为语言的存在说明有它存在的理由，最起码相对其他语言有优势，所以它才不会被时间所淘汰，当然它肯定同时有它的劣势，这也是毫无疑问的。而对于一个程序猿，只要把它当作一种工具好了，我们需要了解它的优缺点，才能根据不同的应用场景来选择比较适合的开发语言，这样才能立于不败之地。\n\n对于我而言，今后将重心放在C语言家族和Python这两种语言上。C语言家族是因为它够底层，基本上任何的事都可以干，而Python属于高级语言，它强大的库已经无所不能。至于其他像Java之类的，反正基本的语法都学过，如果要用，到时候熟悉一下就好了。\n\n## 好书推荐\n这是我写这篇文章的关键。通常在某一个具体细分的技术领域，会自然而然地出现3-5本顶级著作，它们彼此相互配合，形成一个完整的体系。所以对于学习者，只需要认真研读这几本书，就足以登堂入室。下面我列出了它推荐的各个技术领域的“四书五经”。其中有斜体评论是我看过的书，好尴尬。\n\n### C\n* **C程序设计语言（第2版·新版）**  \nBrian W.Kernighan“C语言之父” C语言“倚天屠龙双剑”\n* **C Primer Plus中文版（第五版）**  \nC语言“倚天屠龙双剑” Stephen Prata\n* **C程序设计（第三版）**  \n_这本书是由清华教授谭浩强老师写的，是我上C语言课程用的教材，讲的知识非常基础，但是又不会深入到细节里面。所以比较适合初学者。_\n* **C语言大全（第四版）**  \nHERBERT SCHILDT\n* **C语言接口与实现：创建可重用软件的技术**  \nDAVID R.HANSON\n* **C语言参考手册(原书第5版)**  \nSamuel P.Harbison\n* **C程序设计教程**  \nH.M.Deitel/P.J.Deitel\n* **C陷阱与缺陷**  \nAndrew Koenig\n\n### C++\n* **C++程序设计语言（特别版）**  \nc++八大金刚----Bjarne Stroustrup“C++之父”----技术权威，用词深峻，思想深远，c++百科全书代表，圣经。\n* **C++ Primer （第3版）中文版**  \nc++八大金刚---Stanley B.Lippman----纵横书市十数年，c++最佳教本，c++百科全书代表。\n* **C++ Primer（第4版）中文版**  \nc++八大金刚---Stanley B.Lippman\n* **C++标准程序库—自修教程与参考手册**  \nc++八大金刚--Nicolai M.Josuttis----c++标准库的百科全书\n* **C++语言的设计和演化**  \nc++八大金刚----Bjarne Stroustrup“C++之父”\n* **深度探索C++对象模型**  \nc++八大金刚----Stanley B.Lippman----揭示c++底层，非常好，非常难。\n* **Essential C++中文版**  \nc++八大金刚---Stanley B.Lippman----旁枝暂略，主攻核心，轻薄短小，初学者\n* **Effective C++中文版 2nd Edition**  \nc++八大金刚------Scott Meyers----通过50个编程实例，展示专家经验，行文有趣，深处浅出。\n* **More Effective C++中文版**  \nc++八大金刚------Scott Meyers----通过35个编程实例，展示专家经验，行文有趣，深处浅出。\n* **C++编程思想（第2版）第1卷：标准C++导引**  \nBruce Eckel\n* **C++编程思想（第2版）第2卷：实用编程技术**  \nBruce Eckel\n* **C++程序设计**  \n谭浩强\n* **C++ 程序设计教程（第2版）**  \n钱能\n* **C++ Primer Plus（第五版）中文版**  \nStephen Prata\n\n> **小点评:**  \n>\n> * 广博如四库全书The c++ programming language、c++ Primer\n> * 深奥如山重水复Inside the c++ object model\n> * 程序库大全The c++ standard libray\n> * 工程经验之积累Effective c++、More Effective c++、Exceptional c++\n\n### Java\n* **java编程语言（第三版）**  \njava四大名著----James Gosling（java之父）\n* **java编程思想（第2版）**  \njava四大名著----Bruce Eckel\n* **java编程思想（第3版）**  \njava四大名著----------------Bruce Eckel\n* **java 2核心技术 卷I：基础知识（原书第7版）**  \njava四大名著-----Cay Horstmann\n* **java 2核心技术 卷II：高级特性（原书第7版）**  \njava四大名著-----Cay Horstmann\n* **Effective java中文版**  \njava四大名著--------Joshua Bloch\n* **精通Struts:基于MVC的java Web设计与开发**  \n孙卫琴\n* **精通Hibernate：java对象持久化技术详解**  \n孙卫琴\n* **Tomcat与java Web开发技术详解**  \n孙卫琴\n* **java与模式**  \n阎宏\n\n### 数据结构\n* **数据结构C++语言描述**  \nData Structures C++ ---- William Ford,William Topp -- 刘卫东 沈官林\n* **数据结构算法与应用-C++语言描述**  \nSartej Sahni 汪诗林 孙晓东等 ---- 机械工业出版社\n\n### 算法\n* **计算机程序设计艺术**  \nDonald.E.Knuth----------算法“倚天屠龙”双剑\n* **算法导论**  \nThomas H. Cormen--------算法“倚天屠龙”双剑\n* **离散数学及其应用**  \nKenneth H.Rosen\n* **具体数学—计算机科学基础**  \nDonald.E.Knuth\n\n### 网络\n* **计算机网络第四版中文版**  \n网络编程三剑客--------------Andrew S.Tanenbaum\n* **TCP/IP详解3卷本**  \nRichard Stevens----网络编程三剑客\n* **UNIX网络编程2卷本**  \nRichard Stevens----网络编程三剑客\n* **用TCP/IP进行网际互联**  \nDouglas E. Comer\n* **高级TCP/IP编程**  \nJon C. Snader\n* **C++网络编程**  \nDouglas Schmidt\n* **UNIX环境高级编程（第2版）**  \nRichard Stevens\n\n\n### Unix\n* **UNIX编程艺术**  \n* **UNIX环境高级编程（英文影印第2版）**  \nUNIX编程“圣经\n* **UNIX网络编程（卷1）：连网的APLS：套接字与XTI（第二版）（英文影印版）**  \n* **UNIX网络编程 第1卷：套接口API（第3版）**  \n* **UNIX网络编程 卷I 套接字联网API（英文版 第三版）**  \n* **UNIX网络编程 卷2：进程间通信（第2版）（英文影印版）**  \n* **UNIX网络编程（第2版）第1卷：套接口API和X/Open 传输接口API**  \n* **UNIX网络编程（第二版）第2卷：进程间通信**  \n* **UNIX编程环境**  \n* **UNIX系统编程**  \n* **UNIX环境高级编程**  \n* **Unix技术手册**  \n\n\n### Linux\n* **Linux内核设计与实现**  \n* **Linux内核完全注释**  \n* **LINUX内核分析及编程**  \n* **GNU/Linux 编程指南（第二版）**  \n* **Linux设备驱动程序（第三版）**  \n* **嵌入式设计及Linux驱动开发指南——基于ARM 9处理器**  \n* **Linux设备驱动程序 第三版（英文影印版）**  \n* **Linux内核设计与实现（第2版）**  \n* **Linux内核设计与实现（英文影印版）（第2版）**  \n* **Linux技术手册**  \n\n### 黑客技术\n* **应用密码学(协议算法与C源程序**  \nBruce Schneier\n* **网络信息安全的真相**  \nBruce Schneier\n* **黑客大曝光：网络安全机密与解决方案（第5版）**  \nSTUART MCCLURE\n* **软件加密技术内幕**  \n看雪学院\n* **加密与解密——软件保护技术与完全解决方案**  \n看雪学院\n* **加密与解密（第二版）**  \n段钢\n\n\n## 参考文献\n1. [文献1][ref_label]\n\n\n[ref_label]: http://siteurl\n","source":"_posts/2016-01-10-程序猿得看的经典好书.md","raw":"---\nlayout:\t\tpost\ntitle:\t\t程序猿得看的经典好书\ncategories:\n- READING\ntags:\n- Coding\n- C\n- C++\n- Java\n- Algorithm\n- Network\n- OS\n- Linux\npermalink:  IT-books\ncomments:\ttrue\ndate:\t\t2016-01-08 15:52:23\n---\n其实想写这篇文章的缘由是因为看了微信公众号菜鸟教程推荐的那篇[编程入门技巧大全](https://mp.weixin.qq.com/s?__biz=MzA5NDIzNzY1OQ==&mid=447566521&idx=1&sn=7f086ef930e81e9075eb332af26240d6&scene=0#wechat_redirect)，对于它说的一点我非常赞同就是多看好书，多读经典，并对它推荐的经典书籍作了记录，以方便后面可以拜读。\n<!-- more -->\n\n## 什么叫好书\n差书会误人子弟，不但浪费了时间和精力，更可怕的是他会打击人的自信心,会让人越来越怀疑自己的学习能力。而好书虽然好，但是数量却很少，特别是被大家公认很有价值的好书更是少之又少。历经多年时间考验和市场风雨的残酷洗礼而仅存的巨著，更是极其稀少。君不见，中国历史上的文学小说多如牛毛，但仅存的巨著也不过《三国演义》等四本。\n\n## 编程语言\n其实对于编程语言的选择并不是非常重要，纯属个人喜好。因为语言的存在说明有它存在的理由，最起码相对其他语言有优势，所以它才不会被时间所淘汰，当然它肯定同时有它的劣势，这也是毫无疑问的。而对于一个程序猿，只要把它当作一种工具好了，我们需要了解它的优缺点，才能根据不同的应用场景来选择比较适合的开发语言，这样才能立于不败之地。\n\n对于我而言，今后将重心放在C语言家族和Python这两种语言上。C语言家族是因为它够底层，基本上任何的事都可以干，而Python属于高级语言，它强大的库已经无所不能。至于其他像Java之类的，反正基本的语法都学过，如果要用，到时候熟悉一下就好了。\n\n## 好书推荐\n这是我写这篇文章的关键。通常在某一个具体细分的技术领域，会自然而然地出现3-5本顶级著作，它们彼此相互配合，形成一个完整的体系。所以对于学习者，只需要认真研读这几本书，就足以登堂入室。下面我列出了它推荐的各个技术领域的“四书五经”。其中有斜体评论是我看过的书，好尴尬。\n\n### C\n* **C程序设计语言（第2版·新版）**  \nBrian W.Kernighan“C语言之父” C语言“倚天屠龙双剑”\n* **C Primer Plus中文版（第五版）**  \nC语言“倚天屠龙双剑” Stephen Prata\n* **C程序设计（第三版）**  \n_这本书是由清华教授谭浩强老师写的，是我上C语言课程用的教材，讲的知识非常基础，但是又不会深入到细节里面。所以比较适合初学者。_\n* **C语言大全（第四版）**  \nHERBERT SCHILDT\n* **C语言接口与实现：创建可重用软件的技术**  \nDAVID R.HANSON\n* **C语言参考手册(原书第5版)**  \nSamuel P.Harbison\n* **C程序设计教程**  \nH.M.Deitel/P.J.Deitel\n* **C陷阱与缺陷**  \nAndrew Koenig\n\n### C++\n* **C++程序设计语言（特别版）**  \nc++八大金刚----Bjarne Stroustrup“C++之父”----技术权威，用词深峻，思想深远，c++百科全书代表，圣经。\n* **C++ Primer （第3版）中文版**  \nc++八大金刚---Stanley B.Lippman----纵横书市十数年，c++最佳教本，c++百科全书代表。\n* **C++ Primer（第4版）中文版**  \nc++八大金刚---Stanley B.Lippman\n* **C++标准程序库—自修教程与参考手册**  \nc++八大金刚--Nicolai M.Josuttis----c++标准库的百科全书\n* **C++语言的设计和演化**  \nc++八大金刚----Bjarne Stroustrup“C++之父”\n* **深度探索C++对象模型**  \nc++八大金刚----Stanley B.Lippman----揭示c++底层，非常好，非常难。\n* **Essential C++中文版**  \nc++八大金刚---Stanley B.Lippman----旁枝暂略，主攻核心，轻薄短小，初学者\n* **Effective C++中文版 2nd Edition**  \nc++八大金刚------Scott Meyers----通过50个编程实例，展示专家经验，行文有趣，深处浅出。\n* **More Effective C++中文版**  \nc++八大金刚------Scott Meyers----通过35个编程实例，展示专家经验，行文有趣，深处浅出。\n* **C++编程思想（第2版）第1卷：标准C++导引**  \nBruce Eckel\n* **C++编程思想（第2版）第2卷：实用编程技术**  \nBruce Eckel\n* **C++程序设计**  \n谭浩强\n* **C++ 程序设计教程（第2版）**  \n钱能\n* **C++ Primer Plus（第五版）中文版**  \nStephen Prata\n\n> **小点评:**  \n>\n> * 广博如四库全书The c++ programming language、c++ Primer\n> * 深奥如山重水复Inside the c++ object model\n> * 程序库大全The c++ standard libray\n> * 工程经验之积累Effective c++、More Effective c++、Exceptional c++\n\n### Java\n* **java编程语言（第三版）**  \njava四大名著----James Gosling（java之父）\n* **java编程思想（第2版）**  \njava四大名著----Bruce Eckel\n* **java编程思想（第3版）**  \njava四大名著----------------Bruce Eckel\n* **java 2核心技术 卷I：基础知识（原书第7版）**  \njava四大名著-----Cay Horstmann\n* **java 2核心技术 卷II：高级特性（原书第7版）**  \njava四大名著-----Cay Horstmann\n* **Effective java中文版**  \njava四大名著--------Joshua Bloch\n* **精通Struts:基于MVC的java Web设计与开发**  \n孙卫琴\n* **精通Hibernate：java对象持久化技术详解**  \n孙卫琴\n* **Tomcat与java Web开发技术详解**  \n孙卫琴\n* **java与模式**  \n阎宏\n\n### 数据结构\n* **数据结构C++语言描述**  \nData Structures C++ ---- William Ford,William Topp -- 刘卫东 沈官林\n* **数据结构算法与应用-C++语言描述**  \nSartej Sahni 汪诗林 孙晓东等 ---- 机械工业出版社\n\n### 算法\n* **计算机程序设计艺术**  \nDonald.E.Knuth----------算法“倚天屠龙”双剑\n* **算法导论**  \nThomas H. Cormen--------算法“倚天屠龙”双剑\n* **离散数学及其应用**  \nKenneth H.Rosen\n* **具体数学—计算机科学基础**  \nDonald.E.Knuth\n\n### 网络\n* **计算机网络第四版中文版**  \n网络编程三剑客--------------Andrew S.Tanenbaum\n* **TCP/IP详解3卷本**  \nRichard Stevens----网络编程三剑客\n* **UNIX网络编程2卷本**  \nRichard Stevens----网络编程三剑客\n* **用TCP/IP进行网际互联**  \nDouglas E. Comer\n* **高级TCP/IP编程**  \nJon C. Snader\n* **C++网络编程**  \nDouglas Schmidt\n* **UNIX环境高级编程（第2版）**  \nRichard Stevens\n\n\n### Unix\n* **UNIX编程艺术**  \n* **UNIX环境高级编程（英文影印第2版）**  \nUNIX编程“圣经\n* **UNIX网络编程（卷1）：连网的APLS：套接字与XTI（第二版）（英文影印版）**  \n* **UNIX网络编程 第1卷：套接口API（第3版）**  \n* **UNIX网络编程 卷I 套接字联网API（英文版 第三版）**  \n* **UNIX网络编程 卷2：进程间通信（第2版）（英文影印版）**  \n* **UNIX网络编程（第2版）第1卷：套接口API和X/Open 传输接口API**  \n* **UNIX网络编程（第二版）第2卷：进程间通信**  \n* **UNIX编程环境**  \n* **UNIX系统编程**  \n* **UNIX环境高级编程**  \n* **Unix技术手册**  \n\n\n### Linux\n* **Linux内核设计与实现**  \n* **Linux内核完全注释**  \n* **LINUX内核分析及编程**  \n* **GNU/Linux 编程指南（第二版）**  \n* **Linux设备驱动程序（第三版）**  \n* **嵌入式设计及Linux驱动开发指南——基于ARM 9处理器**  \n* **Linux设备驱动程序 第三版（英文影印版）**  \n* **Linux内核设计与实现（第2版）**  \n* **Linux内核设计与实现（英文影印版）（第2版）**  \n* **Linux技术手册**  \n\n### 黑客技术\n* **应用密码学(协议算法与C源程序**  \nBruce Schneier\n* **网络信息安全的真相**  \nBruce Schneier\n* **黑客大曝光：网络安全机密与解决方案（第5版）**  \nSTUART MCCLURE\n* **软件加密技术内幕**  \n看雪学院\n* **加密与解密——软件保护技术与完全解决方案**  \n看雪学院\n* **加密与解密（第二版）**  \n段钢\n\n\n## 参考文献\n1. [文献1][ref_label]\n\n\n[ref_label]: http://siteurl\n","slug":"IT-books","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1q001yl73yf30t0nas","content":"<p>其实想写这篇文章的缘由是因为看了微信公众号菜鸟教程推荐的那篇<a href=\"https://mp.weixin.qq.com/s?__biz=MzA5NDIzNzY1OQ==&amp;mid=447566521&amp;idx=1&amp;sn=7f086ef930e81e9075eb332af26240d6&amp;scene=0#wechat_redirect\" target=\"_blank\" rel=\"external\">编程入门技巧大全</a>，对于它说的一点我非常赞同就是多看好书，多读经典，并对它推荐的经典书籍作了记录，以方便后面可以拜读。 <a id=\"more\"></a></p>\n<h2 id=\"什么叫好书\">什么叫好书</h2>\n<p>差书会误人子弟，不但浪费了时间和精力，更可怕的是他会打击人的自信心,会让人越来越怀疑自己的学习能力。而好书虽然好，但是数量却很少，特别是被大家公认很有价值的好书更是少之又少。历经多年时间考验和市场风雨的残酷洗礼而仅存的巨著，更是极其稀少。君不见，中国历史上的文学小说多如牛毛，但仅存的巨著也不过《三国演义》等四本。</p>\n<h2 id=\"编程语言\">编程语言</h2>\n<p>其实对于编程语言的选择并不是非常重要，纯属个人喜好。因为语言的存在说明有它存在的理由，最起码相对其他语言有优势，所以它才不会被时间所淘汰，当然它肯定同时有它的劣势，这也是毫无疑问的。而对于一个程序猿，只要把它当作一种工具好了，我们需要了解它的优缺点，才能根据不同的应用场景来选择比较适合的开发语言，这样才能立于不败之地。</p>\n<p>对于我而言，今后将重心放在C语言家族和Python这两种语言上。C语言家族是因为它够底层，基本上任何的事都可以干，而Python属于高级语言，它强大的库已经无所不能。至于其他像Java之类的，反正基本的语法都学过，如果要用，到时候熟悉一下就好了。</p>\n<h2 id=\"好书推荐\">好书推荐</h2>\n<p>这是我写这篇文章的关键。通常在某一个具体细分的技术领域，会自然而然地出现3-5本顶级著作，它们彼此相互配合，形成一个完整的体系。所以对于学习者，只需要认真研读这几本书，就足以登堂入室。下面我列出了它推荐的各个技术领域的“四书五经”。其中有斜体评论是我看过的书，好尴尬。</p>\n<h3 id=\"c\">C</h3>\n<ul>\n<li><strong>C程序设计语言（第2版·新版）</strong><br>\nBrian W.Kernighan“C语言之父” C语言“倚天屠龙双剑”</li>\n<li><strong>C Primer Plus中文版（第五版）</strong><br>\nC语言“倚天屠龙双剑” Stephen Prata</li>\n<li><strong>C程序设计（第三版）</strong><br>\n<em>这本书是由清华教授谭浩强老师写的，是我上C语言课程用的教材，讲的知识非常基础，但是又不会深入到细节里面。所以比较适合初学者。</em></li>\n<li><strong>C语言大全（第四版）</strong><br>\nHERBERT SCHILDT</li>\n<li><strong>C语言接口与实现：创建可重用软件的技术</strong><br>\nDAVID R.HANSON</li>\n<li><strong>C语言参考手册(原书第5版)</strong><br>\nSamuel P.Harbison</li>\n<li><strong>C程序设计教程</strong><br>\nH.M.Deitel/P.J.Deitel</li>\n<li><strong>C陷阱与缺陷</strong><br>\nAndrew Koenig</li>\n</ul>\n<h3 id=\"c-1\">C++</h3>\n<ul>\n<li><strong>C++程序设计语言（特别版）</strong><br>\nc++八大金刚—-Bjarne Stroustrup“C++之父”—-技术权威，用词深峻，思想深远，c++百科全书代表，圣经。</li>\n<li><strong>C++ Primer （第3版）中文版</strong><br>\nc++八大金刚—Stanley B.Lippman—-纵横书市十数年，c++最佳教本，c++百科全书代表。</li>\n<li><strong>C++ Primer（第4版）中文版</strong><br>\nc++八大金刚—Stanley B.Lippman</li>\n<li><strong>C++标准程序库—自修教程与参考手册</strong><br>\nc++八大金刚–Nicolai M.Josuttis—-c++标准库的百科全书</li>\n<li><strong>C++语言的设计和演化</strong><br>\nc++八大金刚—-Bjarne Stroustrup“C++之父”</li>\n<li><strong>深度探索C++对象模型</strong><br>\nc++八大金刚—-Stanley B.Lippman—-揭示c++底层，非常好，非常难。</li>\n<li><strong>Essential C++中文版</strong><br>\nc++八大金刚—Stanley B.Lippman—-旁枝暂略，主攻核心，轻薄短小，初学者</li>\n<li><strong>Effective C++中文版 2nd Edition</strong><br>\nc++八大金刚——Scott Meyers—-通过50个编程实例，展示专家经验，行文有趣，深处浅出。</li>\n<li><strong>More Effective C++中文版</strong><br>\nc++八大金刚——Scott Meyers—-通过35个编程实例，展示专家经验，行文有趣，深处浅出。</li>\n<li><strong>C++编程思想（第2版）第1卷：标准C++导引</strong><br>\nBruce Eckel</li>\n<li><strong>C++编程思想（第2版）第2卷：实用编程技术</strong><br>\nBruce Eckel</li>\n<li><strong>C++程序设计</strong><br>\n谭浩强</li>\n<li><strong>C++ 程序设计教程（第2版）</strong><br>\n钱能</li>\n<li><strong>C++ Primer Plus（第五版）中文版</strong><br>\nStephen Prata</li>\n</ul>\n<blockquote>\n<p><strong>小点评:</strong></p>\n<ul>\n<li>广博如四库全书The c++ programming language、c++ Primer</li>\n<li>深奥如山重水复Inside the c++ object model</li>\n<li>程序库大全The c++ standard libray</li>\n<li>工程经验之积累Effective c++、More Effective c++、Exceptional c++</li>\n</ul>\n</blockquote>\n<h3 id=\"java\">Java</h3>\n<ul>\n<li><strong>java编程语言（第三版）</strong><br>\njava四大名著—-James Gosling（java之父）</li>\n<li><strong>java编程思想（第2版）</strong><br>\njava四大名著—-Bruce Eckel</li>\n<li><strong>java编程思想（第3版）</strong><br>\njava四大名著—————-Bruce Eckel</li>\n<li><strong>java 2核心技术 卷I：基础知识（原书第7版）</strong><br>\njava四大名著—–Cay Horstmann</li>\n<li><strong>java 2核心技术 卷II：高级特性（原书第7版）</strong><br>\njava四大名著—–Cay Horstmann</li>\n<li><strong>Effective java中文版</strong><br>\njava四大名著——–Joshua Bloch</li>\n<li><strong>精通Struts:基于MVC的java Web设计与开发</strong><br>\n孙卫琴</li>\n<li><strong>精通Hibernate：java对象持久化技术详解</strong><br>\n孙卫琴</li>\n<li><strong>Tomcat与java Web开发技术详解</strong><br>\n孙卫琴</li>\n<li><strong>java与模式</strong><br>\n阎宏</li>\n</ul>\n<h3 id=\"数据结构\">数据结构</h3>\n<ul>\n<li><strong>数据结构C++语言描述</strong><br>\nData Structures C++ —- William Ford,William Topp – 刘卫东 沈官林</li>\n<li><strong>数据结构算法与应用-C++语言描述</strong><br>\nSartej Sahni 汪诗林 孙晓东等 —- 机械工业出版社</li>\n</ul>\n<h3 id=\"算法\">算法</h3>\n<ul>\n<li><strong>计算机程序设计艺术</strong><br>\nDonald.E.Knuth———-算法“倚天屠龙”双剑</li>\n<li><strong>算法导论</strong><br>\nThomas H. Cormen——–算法“倚天屠龙”双剑</li>\n<li><strong>离散数学及其应用</strong><br>\nKenneth H.Rosen</li>\n<li><strong>具体数学—计算机科学基础</strong><br>\nDonald.E.Knuth</li>\n</ul>\n<h3 id=\"网络\">网络</h3>\n<ul>\n<li><strong>计算机网络第四版中文版</strong><br>\n网络编程三剑客————–Andrew S.Tanenbaum</li>\n<li><strong>TCP/IP详解3卷本</strong><br>\nRichard Stevens—-网络编程三剑客</li>\n<li><strong>UNIX网络编程2卷本</strong><br>\nRichard Stevens—-网络编程三剑客</li>\n<li><strong>用TCP/IP进行网际互联</strong><br>\nDouglas E. Comer</li>\n<li><strong>高级TCP/IP编程</strong><br>\nJon C. Snader</li>\n<li><strong>C++网络编程</strong><br>\nDouglas Schmidt</li>\n<li><strong>UNIX环境高级编程（第2版）</strong><br>\nRichard Stevens</li>\n</ul>\n<h3 id=\"unix\">Unix</h3>\n<ul>\n<li><strong>UNIX编程艺术</strong><br>\n</li>\n<li><strong>UNIX环境高级编程（英文影印第2版）</strong><br>\nUNIX编程“圣经</li>\n<li><strong>UNIX网络编程（卷1）：连网的APLS：套接字与XTI（第二版）（英文影印版）</strong><br>\n</li>\n<li><strong>UNIX网络编程 第1卷：套接口API（第3版）</strong><br>\n</li>\n<li><strong>UNIX网络编程 卷I 套接字联网API（英文版 第三版）</strong><br>\n</li>\n<li><strong>UNIX网络编程 卷2：进程间通信（第2版）（英文影印版）</strong><br>\n</li>\n<li><strong>UNIX网络编程（第2版）第1卷：套接口API和X/Open 传输接口API</strong><br>\n</li>\n<li><strong>UNIX网络编程（第二版）第2卷：进程间通信</strong><br>\n</li>\n<li><strong>UNIX编程环境</strong><br>\n</li>\n<li><strong>UNIX系统编程</strong><br>\n</li>\n<li><strong>UNIX环境高级编程</strong><br>\n</li>\n<li><strong>Unix技术手册</strong></li>\n</ul>\n<h3 id=\"linux\">Linux</h3>\n<ul>\n<li><strong>Linux内核设计与实现</strong><br>\n</li>\n<li><strong>Linux内核完全注释</strong><br>\n</li>\n<li><strong>LINUX内核分析及编程</strong><br>\n</li>\n<li><strong>GNU/Linux 编程指南（第二版）</strong><br>\n</li>\n<li><strong>Linux设备驱动程序（第三版）</strong><br>\n</li>\n<li><strong>嵌入式设计及Linux驱动开发指南——基于ARM 9处理器</strong><br>\n</li>\n<li><strong>Linux设备驱动程序 第三版（英文影印版）</strong><br>\n</li>\n<li><strong>Linux内核设计与实现（第2版）</strong><br>\n</li>\n<li><strong>Linux内核设计与实现（英文影印版）（第2版）</strong><br>\n</li>\n<li><strong>Linux技术手册</strong></li>\n</ul>\n<h3 id=\"黑客技术\">黑客技术</h3>\n<ul>\n<li><strong>应用密码学(协议算法与C源程序</strong><br>\nBruce Schneier</li>\n<li><strong>网络信息安全的真相</strong><br>\nBruce Schneier</li>\n<li><strong>黑客大曝光：网络安全机密与解决方案（第5版）</strong><br>\nSTUART MCCLURE</li>\n<li><strong>软件加密技术内幕</strong><br>\n看雪学院</li>\n<li><strong>加密与解密——软件保护技术与完全解决方案</strong><br>\n看雪学院</li>\n<li><strong>加密与解密（第二版）</strong><br>\n段钢</li>\n</ul>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://siteurl\" target=\"_blank\" rel=\"external\">文献1</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>其实想写这篇文章的缘由是因为看了微信公众号菜鸟教程推荐的那篇<a href=\"https://mp.weixin.qq.com/s?__biz=MzA5NDIzNzY1OQ==&amp;mid=447566521&amp;idx=1&amp;sn=7f086ef930e81e9075eb332af26240d6&amp;scene=0#wechat_redirect\" target=\"_blank\" rel=\"external\">编程入门技巧大全</a>，对于它说的一点我非常赞同就是多看好书，多读经典，并对它推荐的经典书籍作了记录，以方便后面可以拜读。","more":"</p>\n<h2 id=\"什么叫好书\">什么叫好书</h2>\n<p>差书会误人子弟，不但浪费了时间和精力，更可怕的是他会打击人的自信心,会让人越来越怀疑自己的学习能力。而好书虽然好，但是数量却很少，特别是被大家公认很有价值的好书更是少之又少。历经多年时间考验和市场风雨的残酷洗礼而仅存的巨著，更是极其稀少。君不见，中国历史上的文学小说多如牛毛，但仅存的巨著也不过《三国演义》等四本。</p>\n<h2 id=\"编程语言\">编程语言</h2>\n<p>其实对于编程语言的选择并不是非常重要，纯属个人喜好。因为语言的存在说明有它存在的理由，最起码相对其他语言有优势，所以它才不会被时间所淘汰，当然它肯定同时有它的劣势，这也是毫无疑问的。而对于一个程序猿，只要把它当作一种工具好了，我们需要了解它的优缺点，才能根据不同的应用场景来选择比较适合的开发语言，这样才能立于不败之地。</p>\n<p>对于我而言，今后将重心放在C语言家族和Python这两种语言上。C语言家族是因为它够底层，基本上任何的事都可以干，而Python属于高级语言，它强大的库已经无所不能。至于其他像Java之类的，反正基本的语法都学过，如果要用，到时候熟悉一下就好了。</p>\n<h2 id=\"好书推荐\">好书推荐</h2>\n<p>这是我写这篇文章的关键。通常在某一个具体细分的技术领域，会自然而然地出现3-5本顶级著作，它们彼此相互配合，形成一个完整的体系。所以对于学习者，只需要认真研读这几本书，就足以登堂入室。下面我列出了它推荐的各个技术领域的“四书五经”。其中有斜体评论是我看过的书，好尴尬。</p>\n<h3 id=\"c\">C</h3>\n<ul>\n<li><strong>C程序设计语言（第2版·新版）</strong><br>\nBrian W.Kernighan“C语言之父” C语言“倚天屠龙双剑”</li>\n<li><strong>C Primer Plus中文版（第五版）</strong><br>\nC语言“倚天屠龙双剑” Stephen Prata</li>\n<li><strong>C程序设计（第三版）</strong><br>\n<em>这本书是由清华教授谭浩强老师写的，是我上C语言课程用的教材，讲的知识非常基础，但是又不会深入到细节里面。所以比较适合初学者。</em></li>\n<li><strong>C语言大全（第四版）</strong><br>\nHERBERT SCHILDT</li>\n<li><strong>C语言接口与实现：创建可重用软件的技术</strong><br>\nDAVID R.HANSON</li>\n<li><strong>C语言参考手册(原书第5版)</strong><br>\nSamuel P.Harbison</li>\n<li><strong>C程序设计教程</strong><br>\nH.M.Deitel/P.J.Deitel</li>\n<li><strong>C陷阱与缺陷</strong><br>\nAndrew Koenig</li>\n</ul>\n<h3 id=\"c-1\">C++</h3>\n<ul>\n<li><strong>C++程序设计语言（特别版）</strong><br>\nc++八大金刚—-Bjarne Stroustrup“C++之父”—-技术权威，用词深峻，思想深远，c++百科全书代表，圣经。</li>\n<li><strong>C++ Primer （第3版）中文版</strong><br>\nc++八大金刚—Stanley B.Lippman—-纵横书市十数年，c++最佳教本，c++百科全书代表。</li>\n<li><strong>C++ Primer（第4版）中文版</strong><br>\nc++八大金刚—Stanley B.Lippman</li>\n<li><strong>C++标准程序库—自修教程与参考手册</strong><br>\nc++八大金刚–Nicolai M.Josuttis—-c++标准库的百科全书</li>\n<li><strong>C++语言的设计和演化</strong><br>\nc++八大金刚—-Bjarne Stroustrup“C++之父”</li>\n<li><strong>深度探索C++对象模型</strong><br>\nc++八大金刚—-Stanley B.Lippman—-揭示c++底层，非常好，非常难。</li>\n<li><strong>Essential C++中文版</strong><br>\nc++八大金刚—Stanley B.Lippman—-旁枝暂略，主攻核心，轻薄短小，初学者</li>\n<li><strong>Effective C++中文版 2nd Edition</strong><br>\nc++八大金刚——Scott Meyers—-通过50个编程实例，展示专家经验，行文有趣，深处浅出。</li>\n<li><strong>More Effective C++中文版</strong><br>\nc++八大金刚——Scott Meyers—-通过35个编程实例，展示专家经验，行文有趣，深处浅出。</li>\n<li><strong>C++编程思想（第2版）第1卷：标准C++导引</strong><br>\nBruce Eckel</li>\n<li><strong>C++编程思想（第2版）第2卷：实用编程技术</strong><br>\nBruce Eckel</li>\n<li><strong>C++程序设计</strong><br>\n谭浩强</li>\n<li><strong>C++ 程序设计教程（第2版）</strong><br>\n钱能</li>\n<li><strong>C++ Primer Plus（第五版）中文版</strong><br>\nStephen Prata</li>\n</ul>\n<blockquote>\n<p><strong>小点评:</strong></p>\n<ul>\n<li>广博如四库全书The c++ programming language、c++ Primer</li>\n<li>深奥如山重水复Inside the c++ object model</li>\n<li>程序库大全The c++ standard libray</li>\n<li>工程经验之积累Effective c++、More Effective c++、Exceptional c++</li>\n</ul>\n</blockquote>\n<h3 id=\"java\">Java</h3>\n<ul>\n<li><strong>java编程语言（第三版）</strong><br>\njava四大名著—-James Gosling（java之父）</li>\n<li><strong>java编程思想（第2版）</strong><br>\njava四大名著—-Bruce Eckel</li>\n<li><strong>java编程思想（第3版）</strong><br>\njava四大名著—————-Bruce Eckel</li>\n<li><strong>java 2核心技术 卷I：基础知识（原书第7版）</strong><br>\njava四大名著—–Cay Horstmann</li>\n<li><strong>java 2核心技术 卷II：高级特性（原书第7版）</strong><br>\njava四大名著—–Cay Horstmann</li>\n<li><strong>Effective java中文版</strong><br>\njava四大名著——–Joshua Bloch</li>\n<li><strong>精通Struts:基于MVC的java Web设计与开发</strong><br>\n孙卫琴</li>\n<li><strong>精通Hibernate：java对象持久化技术详解</strong><br>\n孙卫琴</li>\n<li><strong>Tomcat与java Web开发技术详解</strong><br>\n孙卫琴</li>\n<li><strong>java与模式</strong><br>\n阎宏</li>\n</ul>\n<h3 id=\"数据结构\">数据结构</h3>\n<ul>\n<li><strong>数据结构C++语言描述</strong><br>\nData Structures C++ —- William Ford,William Topp – 刘卫东 沈官林</li>\n<li><strong>数据结构算法与应用-C++语言描述</strong><br>\nSartej Sahni 汪诗林 孙晓东等 —- 机械工业出版社</li>\n</ul>\n<h3 id=\"算法\">算法</h3>\n<ul>\n<li><strong>计算机程序设计艺术</strong><br>\nDonald.E.Knuth———-算法“倚天屠龙”双剑</li>\n<li><strong>算法导论</strong><br>\nThomas H. Cormen——–算法“倚天屠龙”双剑</li>\n<li><strong>离散数学及其应用</strong><br>\nKenneth H.Rosen</li>\n<li><strong>具体数学—计算机科学基础</strong><br>\nDonald.E.Knuth</li>\n</ul>\n<h3 id=\"网络\">网络</h3>\n<ul>\n<li><strong>计算机网络第四版中文版</strong><br>\n网络编程三剑客————–Andrew S.Tanenbaum</li>\n<li><strong>TCP/IP详解3卷本</strong><br>\nRichard Stevens—-网络编程三剑客</li>\n<li><strong>UNIX网络编程2卷本</strong><br>\nRichard Stevens—-网络编程三剑客</li>\n<li><strong>用TCP/IP进行网际互联</strong><br>\nDouglas E. Comer</li>\n<li><strong>高级TCP/IP编程</strong><br>\nJon C. Snader</li>\n<li><strong>C++网络编程</strong><br>\nDouglas Schmidt</li>\n<li><strong>UNIX环境高级编程（第2版）</strong><br>\nRichard Stevens</li>\n</ul>\n<h3 id=\"unix\">Unix</h3>\n<ul>\n<li><strong>UNIX编程艺术</strong><br>\n</li>\n<li><strong>UNIX环境高级编程（英文影印第2版）</strong><br>\nUNIX编程“圣经</li>\n<li><strong>UNIX网络编程（卷1）：连网的APLS：套接字与XTI（第二版）（英文影印版）</strong><br>\n</li>\n<li><strong>UNIX网络编程 第1卷：套接口API（第3版）</strong><br>\n</li>\n<li><strong>UNIX网络编程 卷I 套接字联网API（英文版 第三版）</strong><br>\n</li>\n<li><strong>UNIX网络编程 卷2：进程间通信（第2版）（英文影印版）</strong><br>\n</li>\n<li><strong>UNIX网络编程（第2版）第1卷：套接口API和X/Open 传输接口API</strong><br>\n</li>\n<li><strong>UNIX网络编程（第二版）第2卷：进程间通信</strong><br>\n</li>\n<li><strong>UNIX编程环境</strong><br>\n</li>\n<li><strong>UNIX系统编程</strong><br>\n</li>\n<li><strong>UNIX环境高级编程</strong><br>\n</li>\n<li><strong>Unix技术手册</strong></li>\n</ul>\n<h3 id=\"linux\">Linux</h3>\n<ul>\n<li><strong>Linux内核设计与实现</strong><br>\n</li>\n<li><strong>Linux内核完全注释</strong><br>\n</li>\n<li><strong>LINUX内核分析及编程</strong><br>\n</li>\n<li><strong>GNU/Linux 编程指南（第二版）</strong><br>\n</li>\n<li><strong>Linux设备驱动程序（第三版）</strong><br>\n</li>\n<li><strong>嵌入式设计及Linux驱动开发指南——基于ARM 9处理器</strong><br>\n</li>\n<li><strong>Linux设备驱动程序 第三版（英文影印版）</strong><br>\n</li>\n<li><strong>Linux内核设计与实现（第2版）</strong><br>\n</li>\n<li><strong>Linux内核设计与实现（英文影印版）（第2版）</strong><br>\n</li>\n<li><strong>Linux技术手册</strong></li>\n</ul>\n<h3 id=\"黑客技术\">黑客技术</h3>\n<ul>\n<li><strong>应用密码学(协议算法与C源程序</strong><br>\nBruce Schneier</li>\n<li><strong>网络信息安全的真相</strong><br>\nBruce Schneier</li>\n<li><strong>黑客大曝光：网络安全机密与解决方案（第5版）</strong><br>\nSTUART MCCLURE</li>\n<li><strong>软件加密技术内幕</strong><br>\n看雪学院</li>\n<li><strong>加密与解密——软件保护技术与完全解决方案</strong><br>\n看雪学院</li>\n<li><strong>加密与解密（第二版）</strong><br>\n段钢</li>\n</ul>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://siteurl\" target=\"_blank\" rel=\"external\">文献1</a></li>\n</ol>"},{"layout":"post","title":"从零开始搭建https服务器","comments":1,"date":"2017-01-24T13:03:12.000Z","_content":"写这篇文章的目的是为了开发微信小程序。因为它要使用wx.request发起https请求，而要进行https网络通信，必须先设置域名。所以需要搭建一个https服务器来存放微信小程序的应用数据。要从零开始搭建一个https的服务需要下面4个要素：域名，备案，云服务器，服务器配置。下面分别介绍着四要素的具体要求。\n<!-- more -->\n\n## 域名\n[域名][wiki-domain]（`Domain Name`）又叫网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。例如，www.haojunyu.com是一个域名，可以通过域名名称系统（`Domain Name System`）将该域名映射成对应的IP地址。该操作可以通过域名解析来实现。\n\n### 域名注册和解析\n域名注册前，可以通过[WHOIS域名查询][whois]来查询该域名是否被注册过。目前BAT都提供域名注册，如阿里的[万网],百度的[域名服务][baiduyuming]，腾讯的[Dnspod]。我的域名haojunyu.com是在阿里的万网注册的，之前注册域名的初衷是为了给github上面的个人博客作个性化的域名。并在其中的域名解析中作了设置，这里并不需要做太多的改动，只要将之前为个人博客添加的记录都暂停，并添加如下解析：记录类型为，主机记录为@，解析线路为默认，记录值为欲映射的IP。这样的话，当你在浏览器中输入haojunyu.com时，DNS会自动将其解析为映射的IP地址。\n\n## 备案\n这里的备案是针对像个人博客这类非经营性网站所做的备案。守法的网站对促进信息共享、文化繁荣和社会进步产生积极的作用，但有些不良的网站却传递色情，非法盈利的信息，所以备案的目的也就是为了方便网站的管理。\n\n目前网站域名的备案BAT都能提供，不过备案这个流程很长，大概要一个月，我的域名haojunyu.com是在百度云备案的，当时是先提交的资料（主要是身份证正反面照片），然后等百度快递来背景墙，再拍照片上传核实后才可以备案成功。\n\n## 云服务器\n服务器就是一台可以运行的电脑，可以是自己家里的电脑，也可以到BAT上买云服务。这里因为腾讯云上面有免费8天的试用，所以就试着在云服务上面搭建个https的服务，以方便微信小程序能成功发起request请求。如果试用体验还不错的话，可以续费（74元/月）。新建云主机时要选一个操作系统，鉴于对Ubutnu的熟悉以及服务器的需要，所以选择了Ubuntu Server 16.04.1 LTS 64的镜像做系统。当新建一个云主机后，百度云会提供一个对外的IP地址，这个IP地址就是域名解析中要填入的记录值。\n\n## 服务器配置\n服务器的配置主要有三步个，第一步是应用程序的布置，第二步是Nginx服务器的配置，第三步是http升级为https。前两步的配置是参考这篇博文[在Ubuntu上使用Nginx部署Flask应用][deploy-flask]，第三步是参考[腾讯云上Nginx证书安装][nginx-https]。\n### 应用程序\n考虑到微信小程序主要是用json的数据，所以就想服务器能够提供restful服务，又因为对python语言比较喜欢，所以就挑了python里的Flask这个轻量级的Web框架。服务器选择的是Nginx，而连接服务器和应用程序的是uWSGI。具体的安装步骤如下：\n1. 环境配置\n  ```bash\n    sudo apt-get update && sudo apt-get upgrade # 更新所有软件\n    sudo apt-get install build-essential  # 安装编译环境\n    sudo apt-get install  python python-dev python-setuptools # 安装python环境\n    sudo easy_install pip\n    sudo apt-get install nginx  # 安装Nginx\n    sudo apt-get install uwsgi uwsgi-plugin-python  # 安装uwsgi及其插件\n    sudo apt-get install supervisor # 安装进程管理软件\n  ```\n  > **TIPS:常用命令**\n  > 1. nginx服务启动|停止|重启\n  > ```bash\n      sudo /etc/init.d/nginx start|stop|restart\n    ```\n  > 2. sdf\n\n2. 应用配置\n  ```bash\n    sudo mkdir -p /var/www/flaskApp # 创建应用程序文件夹\n    sudo chown -R ubuntu：ubuntu /var/www/flaskApp # 更改应用程序文件夹所有权\n    sudo pip install virtualenv # 安装python虚拟环境\n    # 创建python虚拟环境\n    cd /var/www/flaskApp\n    virtualenv venv\n    . venv/bin/activate # 激活python虚拟环境venv\n    pip install flask flask-restful # 在虚拟环境中安装flask Web框架\n  ```\n  创建api.py代码\n  ```python\n  #!flask/bin/python\n  from flask import Flask, jsonify\n\n  app = Flask(__name__)\n\n  tasks = [\n      {\n          'id': 1,\n          'title': u'Buy groceries',\n          'description': u'Milk, Cheese, Pizza, Fruit, Tylenol',\n          'done': False\n      },\n      {\n          'id': 2,\n          'title': u'Learn Python',\n          'description': u'Need to find a good Python tutorial on the web',\n          'done': False\n      }\n  ]\n\n  @app.route('/todo/api/v1.0/tasks', methods=['GET'])\n  def get_tasks():\n      return jsonify({'tasks': tasks})\n\n  if __name__ == '__main__':\n      app.run(host='0.0.0.0', port=8080)\n  ```\n\n  执行脚本`python api.py`后可以通过浏览器来访问http://主机IP:8080/todo/api/v1.0/tasks，以此来获取tasks数据。\n\n### 服务器配置\n#### Nginx配置\n  1. 删除nginx默认配置文件\n  ``` bash\n    sudo rm /etc/nginx/sites-enabled/default\n  ```\n  2. 创建新的配置文件/var/www/flaskApp/config/flaskApp_nginx.conf\n  ```bash\n  server {\n    listen      80;\n    server_name www.haojunyu.com; #此时域名已经映射到主机IP\n    charset     utf-8;\n    client_max_body_size 75M;\n\n    location / { try_files $uri @yourapplication; }\n    location @yourapplication {\n        include uwsgi_params;\n        uwsgi_pass unix:/var/www/flaskApp/config/flaskApp_uwsgi.sock;\n    }\n  }\n  ```\n  3. 创建配置文件服务，重启服务\n  ```bash\n    sudo ln -s /var/www/flaskApp/config/nginx.conf /etc/nginx/conf.d/ #将应用文件夹里的配置文件链接到nginx配置文件处\n    sudo /etc/init.d/nginx restart  # 重启nginx\n  ```\n  4. 验证\n  现在通过浏览器来访问http://haojunyu.com/todo/api/v1.0/tasks，无法获取到数据，因为flaskApp_uwsgi.sock尚未生成，无法让uwsgi在Nginx和python应用程序之间构建一座桥。\n\n#### uWSGI配置\n  1. 创建新的配置文件/var/www/flaskApp/config/flaskApp_uwsgi.ini\n  ```bash\n  [uwsgi]\n  #application's base folder\n  base = /var/www/flaskApp\n\n  #python module to import\n  app = api\n  module = %(app)\n\n  home = %(base)/venv\n  pythonpath = %(base)\n  ## 使用virtualenvwrapper管理virtualenv后用下面的两个参数取代home和pythonpath\n  #chdir = %(base)\n  #virtualenvs = %HOME/.virtualenvs/flaskEnv\n\n  #socket file's location\n  socket = /var/www/flaskApp/%n.sock\n\n  #permissions for the socket file\n  chmod-socket    = 666\n\n  #the variable that holds a flask application inside the module imported at line #6\n  callable = app\n\n  #location of log files\n  logto = /var/log/uwsgi/%n.log\n  ```\n  2. 创建uWSGI日志文件夹，并更改文件所有权\n  ```bash\n  sudo mkdir -p /var/log/uwsgi # uWSGI日志文件夹\n  sudo chown -R ubuntu:ubuntu /var/log/uwsgi # 更改uWSGI日志文件夹所有权\n  uwsgi --ini /var/www/flaskApp/config/flaskApp_uwsgi.ini --plugin python & # 后台启动uwsgi\n  ```\n\n#### supervisor配置\nsupervisor是为了方便管理进程而存在的，因为每次开机后，都得重新执行`uwsgi --ini /var/www/flaskApp/config/flaskApp_uwsgi.ini`命令来启动uwsgi，这个很费神，因为你不可能永远记得清楚这么个应用，这么个配置。所以使用supervisor来管理，而我们只需要在开发这个应用时创建一个flaskApp_supervisor.conf配置文件，而重启机器后启动supervisor服务，即执行`sudo service supervisor start`。\n  1. 安装supervisor\n  ```bash\n  sudo apt install supervisor\n  ```\n  2. 创建配置文件：\n  ```bash\n  [program:flaskApp]\n  # 启动命令入口\n  command=/usr/local/bin/uwsgi --ini /var/www/flaskApp/flaskApp_uwsgi.ini\n  # 运行命令的用户名\n  user=ubuntu\n  autostart=true\n  autorestat=true\n  #日志地址\n  stdout_logfile=/var/log/supervisor/flaskApp_supervisor.log\n  ```\n  3. 创建配置文件副本并重启服务\n  ```bash\n  sudo ln -s /var/www/flaskApp/flaskApp_supervisor.conf /etc/supervisor/conf.d/\n  sudo service supervisor restart\n  ```\n\n### http升级https\n升级https需要证书的支持，这里BAT都提供这样的服务，都有相对应的配置安装说明。我这里是按照[腾讯云上Nginx证书安装][nginx-https],主要就是将申请的证书保存到config目录中，并将flaskApp_nginx.conf修改如下：\n```bash\nserver {\n  listen      443;\n  server_name www.haojunyu.com; #此时域名已经映射到主机IP\n\n  ssl on;\n  ssl_certificate /var/www/flaskApp/1_haojunyu.com_bundle.crt;\n  ssl_certificate_key /var/www/flaskApp/2_haojunyu.com.key;\n  ssl_session_timeout 5m;\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置\n  ssl_prefer_server_ciphers on;\n\n  location / { try_files $uri @yourapplication; }\n  location @yourapplication {\n      include uwsgi_params;\n      uwsgi_pass unix:/var/www/flaskApp/config/flaskApp_uwsgi.sock;\n  }\n}\n```\n\n\n## 参考文献\n1. [wiki-域名][wiki-domain]\n2. [whois域名查询][whois]\n3. [万网][wanwang]\n4. [百度域名服务][baiduyuming]\n5. [Dnspod][Dnspod]\n6. [在Ubuntu上使用Nginx部署Flask应用][deploy-flask]\n7. [腾讯云上Nginx证书安装][nginx-https]\n\n[wiki-domain]: https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D\n[whois]: https://who.is/\n[wanwang]: https://wanwang.aliyun.com/?spm=5176.8142029.388261.26.C75xLA\n[baiduyuming]： https://cloud.baidu.com/product/bcd.html\n[Dnspod]: https://dnspod.qcloud.com/?from=console\n[deploy-flask]: https://www.oschina.net/translate/serving-flask-with-nginx-on-ubuntu\n[nginx-https]: https://www.qcloud.com/document/product/400/4143#2.-nginx-.E8.AF.81.E4.B9.A6.E9.83.A8.E7.BD.B2\n","source":"_posts/2017-01-24-从零开始搭建https服务器.md","raw":"---\nlayout: post\ntitle: 从零开始搭建https服务器\ncategories:\n- TECHNOLOGY\ntags:\n- Cloud\n- Nginx\n- Python\npermalink: https-server\ncomments: true\ndate: 2017-01-24 21:03:12\n---\n写这篇文章的目的是为了开发微信小程序。因为它要使用wx.request发起https请求，而要进行https网络通信，必须先设置域名。所以需要搭建一个https服务器来存放微信小程序的应用数据。要从零开始搭建一个https的服务需要下面4个要素：域名，备案，云服务器，服务器配置。下面分别介绍着四要素的具体要求。\n<!-- more -->\n\n## 域名\n[域名][wiki-domain]（`Domain Name`）又叫网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。例如，www.haojunyu.com是一个域名，可以通过域名名称系统（`Domain Name System`）将该域名映射成对应的IP地址。该操作可以通过域名解析来实现。\n\n### 域名注册和解析\n域名注册前，可以通过[WHOIS域名查询][whois]来查询该域名是否被注册过。目前BAT都提供域名注册，如阿里的[万网],百度的[域名服务][baiduyuming]，腾讯的[Dnspod]。我的域名haojunyu.com是在阿里的万网注册的，之前注册域名的初衷是为了给github上面的个人博客作个性化的域名。并在其中的域名解析中作了设置，这里并不需要做太多的改动，只要将之前为个人博客添加的记录都暂停，并添加如下解析：记录类型为，主机记录为@，解析线路为默认，记录值为欲映射的IP。这样的话，当你在浏览器中输入haojunyu.com时，DNS会自动将其解析为映射的IP地址。\n\n## 备案\n这里的备案是针对像个人博客这类非经营性网站所做的备案。守法的网站对促进信息共享、文化繁荣和社会进步产生积极的作用，但有些不良的网站却传递色情，非法盈利的信息，所以备案的目的也就是为了方便网站的管理。\n\n目前网站域名的备案BAT都能提供，不过备案这个流程很长，大概要一个月，我的域名haojunyu.com是在百度云备案的，当时是先提交的资料（主要是身份证正反面照片），然后等百度快递来背景墙，再拍照片上传核实后才可以备案成功。\n\n## 云服务器\n服务器就是一台可以运行的电脑，可以是自己家里的电脑，也可以到BAT上买云服务。这里因为腾讯云上面有免费8天的试用，所以就试着在云服务上面搭建个https的服务，以方便微信小程序能成功发起request请求。如果试用体验还不错的话，可以续费（74元/月）。新建云主机时要选一个操作系统，鉴于对Ubutnu的熟悉以及服务器的需要，所以选择了Ubuntu Server 16.04.1 LTS 64的镜像做系统。当新建一个云主机后，百度云会提供一个对外的IP地址，这个IP地址就是域名解析中要填入的记录值。\n\n## 服务器配置\n服务器的配置主要有三步个，第一步是应用程序的布置，第二步是Nginx服务器的配置，第三步是http升级为https。前两步的配置是参考这篇博文[在Ubuntu上使用Nginx部署Flask应用][deploy-flask]，第三步是参考[腾讯云上Nginx证书安装][nginx-https]。\n### 应用程序\n考虑到微信小程序主要是用json的数据，所以就想服务器能够提供restful服务，又因为对python语言比较喜欢，所以就挑了python里的Flask这个轻量级的Web框架。服务器选择的是Nginx，而连接服务器和应用程序的是uWSGI。具体的安装步骤如下：\n1. 环境配置\n  ```bash\n    sudo apt-get update && sudo apt-get upgrade # 更新所有软件\n    sudo apt-get install build-essential  # 安装编译环境\n    sudo apt-get install  python python-dev python-setuptools # 安装python环境\n    sudo easy_install pip\n    sudo apt-get install nginx  # 安装Nginx\n    sudo apt-get install uwsgi uwsgi-plugin-python  # 安装uwsgi及其插件\n    sudo apt-get install supervisor # 安装进程管理软件\n  ```\n  > **TIPS:常用命令**\n  > 1. nginx服务启动|停止|重启\n  > ```bash\n      sudo /etc/init.d/nginx start|stop|restart\n    ```\n  > 2. sdf\n\n2. 应用配置\n  ```bash\n    sudo mkdir -p /var/www/flaskApp # 创建应用程序文件夹\n    sudo chown -R ubuntu：ubuntu /var/www/flaskApp # 更改应用程序文件夹所有权\n    sudo pip install virtualenv # 安装python虚拟环境\n    # 创建python虚拟环境\n    cd /var/www/flaskApp\n    virtualenv venv\n    . venv/bin/activate # 激活python虚拟环境venv\n    pip install flask flask-restful # 在虚拟环境中安装flask Web框架\n  ```\n  创建api.py代码\n  ```python\n  #!flask/bin/python\n  from flask import Flask, jsonify\n\n  app = Flask(__name__)\n\n  tasks = [\n      {\n          'id': 1,\n          'title': u'Buy groceries',\n          'description': u'Milk, Cheese, Pizza, Fruit, Tylenol',\n          'done': False\n      },\n      {\n          'id': 2,\n          'title': u'Learn Python',\n          'description': u'Need to find a good Python tutorial on the web',\n          'done': False\n      }\n  ]\n\n  @app.route('/todo/api/v1.0/tasks', methods=['GET'])\n  def get_tasks():\n      return jsonify({'tasks': tasks})\n\n  if __name__ == '__main__':\n      app.run(host='0.0.0.0', port=8080)\n  ```\n\n  执行脚本`python api.py`后可以通过浏览器来访问http://主机IP:8080/todo/api/v1.0/tasks，以此来获取tasks数据。\n\n### 服务器配置\n#### Nginx配置\n  1. 删除nginx默认配置文件\n  ``` bash\n    sudo rm /etc/nginx/sites-enabled/default\n  ```\n  2. 创建新的配置文件/var/www/flaskApp/config/flaskApp_nginx.conf\n  ```bash\n  server {\n    listen      80;\n    server_name www.haojunyu.com; #此时域名已经映射到主机IP\n    charset     utf-8;\n    client_max_body_size 75M;\n\n    location / { try_files $uri @yourapplication; }\n    location @yourapplication {\n        include uwsgi_params;\n        uwsgi_pass unix:/var/www/flaskApp/config/flaskApp_uwsgi.sock;\n    }\n  }\n  ```\n  3. 创建配置文件服务，重启服务\n  ```bash\n    sudo ln -s /var/www/flaskApp/config/nginx.conf /etc/nginx/conf.d/ #将应用文件夹里的配置文件链接到nginx配置文件处\n    sudo /etc/init.d/nginx restart  # 重启nginx\n  ```\n  4. 验证\n  现在通过浏览器来访问http://haojunyu.com/todo/api/v1.0/tasks，无法获取到数据，因为flaskApp_uwsgi.sock尚未生成，无法让uwsgi在Nginx和python应用程序之间构建一座桥。\n\n#### uWSGI配置\n  1. 创建新的配置文件/var/www/flaskApp/config/flaskApp_uwsgi.ini\n  ```bash\n  [uwsgi]\n  #application's base folder\n  base = /var/www/flaskApp\n\n  #python module to import\n  app = api\n  module = %(app)\n\n  home = %(base)/venv\n  pythonpath = %(base)\n  ## 使用virtualenvwrapper管理virtualenv后用下面的两个参数取代home和pythonpath\n  #chdir = %(base)\n  #virtualenvs = %HOME/.virtualenvs/flaskEnv\n\n  #socket file's location\n  socket = /var/www/flaskApp/%n.sock\n\n  #permissions for the socket file\n  chmod-socket    = 666\n\n  #the variable that holds a flask application inside the module imported at line #6\n  callable = app\n\n  #location of log files\n  logto = /var/log/uwsgi/%n.log\n  ```\n  2. 创建uWSGI日志文件夹，并更改文件所有权\n  ```bash\n  sudo mkdir -p /var/log/uwsgi # uWSGI日志文件夹\n  sudo chown -R ubuntu:ubuntu /var/log/uwsgi # 更改uWSGI日志文件夹所有权\n  uwsgi --ini /var/www/flaskApp/config/flaskApp_uwsgi.ini --plugin python & # 后台启动uwsgi\n  ```\n\n#### supervisor配置\nsupervisor是为了方便管理进程而存在的，因为每次开机后，都得重新执行`uwsgi --ini /var/www/flaskApp/config/flaskApp_uwsgi.ini`命令来启动uwsgi，这个很费神，因为你不可能永远记得清楚这么个应用，这么个配置。所以使用supervisor来管理，而我们只需要在开发这个应用时创建一个flaskApp_supervisor.conf配置文件，而重启机器后启动supervisor服务，即执行`sudo service supervisor start`。\n  1. 安装supervisor\n  ```bash\n  sudo apt install supervisor\n  ```\n  2. 创建配置文件：\n  ```bash\n  [program:flaskApp]\n  # 启动命令入口\n  command=/usr/local/bin/uwsgi --ini /var/www/flaskApp/flaskApp_uwsgi.ini\n  # 运行命令的用户名\n  user=ubuntu\n  autostart=true\n  autorestat=true\n  #日志地址\n  stdout_logfile=/var/log/supervisor/flaskApp_supervisor.log\n  ```\n  3. 创建配置文件副本并重启服务\n  ```bash\n  sudo ln -s /var/www/flaskApp/flaskApp_supervisor.conf /etc/supervisor/conf.d/\n  sudo service supervisor restart\n  ```\n\n### http升级https\n升级https需要证书的支持，这里BAT都提供这样的服务，都有相对应的配置安装说明。我这里是按照[腾讯云上Nginx证书安装][nginx-https],主要就是将申请的证书保存到config目录中，并将flaskApp_nginx.conf修改如下：\n```bash\nserver {\n  listen      443;\n  server_name www.haojunyu.com; #此时域名已经映射到主机IP\n\n  ssl on;\n  ssl_certificate /var/www/flaskApp/1_haojunyu.com_bundle.crt;\n  ssl_certificate_key /var/www/flaskApp/2_haojunyu.com.key;\n  ssl_session_timeout 5m;\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置\n  ssl_prefer_server_ciphers on;\n\n  location / { try_files $uri @yourapplication; }\n  location @yourapplication {\n      include uwsgi_params;\n      uwsgi_pass unix:/var/www/flaskApp/config/flaskApp_uwsgi.sock;\n  }\n}\n```\n\n\n## 参考文献\n1. [wiki-域名][wiki-domain]\n2. [whois域名查询][whois]\n3. [万网][wanwang]\n4. [百度域名服务][baiduyuming]\n5. [Dnspod][Dnspod]\n6. [在Ubuntu上使用Nginx部署Flask应用][deploy-flask]\n7. [腾讯云上Nginx证书安装][nginx-https]\n\n[wiki-domain]: https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D\n[whois]: https://who.is/\n[wanwang]: https://wanwang.aliyun.com/?spm=5176.8142029.388261.26.C75xLA\n[baiduyuming]： https://cloud.baidu.com/product/bcd.html\n[Dnspod]: https://dnspod.qcloud.com/?from=console\n[deploy-flask]: https://www.oschina.net/translate/serving-flask-with-nginx-on-ubuntu\n[nginx-https]: https://www.qcloud.com/document/product/400/4143#2.-nginx-.E8.AF.81.E4.B9.A6.E9.83.A8.E7.BD.B2\n","slug":"https-server","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1q001zl73yjmyqzfiw","content":"<p>写这篇文章的目的是为了开发微信小程序。因为它要使用wx.request发起https请求，而要进行https网络通信，必须先设置域名。所以需要搭建一个https服务器来存放微信小程序的应用数据。要从零开始搭建一个https的服务需要下面4个要素：域名，备案，云服务器，服务器配置。下面分别介绍着四要素的具体要求。 <a id=\"more\"></a></p>\n<h2 id=\"域名\">域名</h2>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D\" target=\"_blank\" rel=\"external\">域名</a>（<code>Domain Name</code>）又叫网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。例如，www.haojunyu.com是一个域名，可以通过域名名称系统（<code>Domain Name System</code>）将该域名映射成对应的IP地址。该操作可以通过域名解析来实现。</p>\n<h3 id=\"域名注册和解析\">域名注册和解析</h3>\n<p>域名注册前，可以通过<a href=\"https://who.is/\" target=\"_blank\" rel=\"external\">WHOIS域名查询</a>来查询该域名是否被注册过。目前BAT都提供域名注册，如阿里的[万网],百度的[域名服务][baiduyuming]，腾讯的[Dnspod]。我的域名haojunyu.com是在阿里的万网注册的，之前注册域名的初衷是为了给github上面的个人博客作个性化的域名。并在其中的域名解析中作了设置，这里并不需要做太多的改动，只要将之前为个人博客添加的记录都暂停，并添加如下解析：记录类型为，主机记录为@，解析线路为默认，记录值为欲映射的IP。这样的话，当你在浏览器中输入haojunyu.com时，DNS会自动将其解析为映射的IP地址。</p>\n<h2 id=\"备案\">备案</h2>\n<p>这里的备案是针对像个人博客这类非经营性网站所做的备案。守法的网站对促进信息共享、文化繁荣和社会进步产生积极的作用，但有些不良的网站却传递色情，非法盈利的信息，所以备案的目的也就是为了方便网站的管理。</p>\n<p>目前网站域名的备案BAT都能提供，不过备案这个流程很长，大概要一个月，我的域名haojunyu.com是在百度云备案的，当时是先提交的资料（主要是身份证正反面照片），然后等百度快递来背景墙，再拍照片上传核实后才可以备案成功。</p>\n<h2 id=\"云服务器\">云服务器</h2>\n<p>服务器就是一台可以运行的电脑，可以是自己家里的电脑，也可以到BAT上买云服务。这里因为腾讯云上面有免费8天的试用，所以就试着在云服务上面搭建个https的服务，以方便微信小程序能成功发起request请求。如果试用体验还不错的话，可以续费（74元/月）。新建云主机时要选一个操作系统，鉴于对Ubutnu的熟悉以及服务器的需要，所以选择了Ubuntu Server 16.04.1 LTS 64的镜像做系统。当新建一个云主机后，百度云会提供一个对外的IP地址，这个IP地址就是域名解析中要填入的记录值。</p>\n<h2 id=\"服务器配置\">服务器配置</h2>\n<p>服务器的配置主要有三步个，第一步是应用程序的布置，第二步是Nginx服务器的配置，第三步是http升级为https。前两步的配置是参考这篇博文[在Ubuntu上使用Nginx部署Flask应用][deploy-flask]，第三步是参考[腾讯云上Nginx证书安装][nginx-https]。 ### 应用程序 考虑到微信小程序主要是用json的数据，所以就想服务器能够提供restful服务，又因为对python语言比较喜欢，所以就挑了python里的Flask这个轻量级的Web框架。服务器选择的是Nginx，而连接服务器和应用程序的是uWSGI。具体的安装步骤如下： 1. 环境配置 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update &amp;&amp; sudo apt-get upgrade <span class=\"comment\"># 更新所有软件</span></div><div class=\"line\">sudo apt-get install build-essential  <span class=\"comment\"># 安装编译环境</span></div><div class=\"line\">sudo apt-get install  python python-dev python-setuptools <span class=\"comment\"># 安装python环境</span></div><div class=\"line\">sudo easy_install pip</div><div class=\"line\">sudo apt-get install nginx  <span class=\"comment\"># 安装Nginx</span></div><div class=\"line\">sudo apt-get install uwsgi uwsgi-plugin-python  <span class=\"comment\"># 安装uwsgi及其插件</span></div><div class=\"line\">sudo apt-get install supervisor <span class=\"comment\"># 安装进程管理软件</span></div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><strong>TIPS:常用命令</strong> 1. nginx服务启动|停止|重启 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo /etc/init.d/nginx start|stop|restart</div></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>sdf</li>\n</ol>\n</blockquote>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>应用配置 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo mkdir -p /var/www/flaskApp <span class=\"comment\"># 创建应用程序文件夹</span></div><div class=\"line\">sudo chown -R ubuntu：ubuntu /var/www/flaskApp <span class=\"comment\"># 更改应用程序文件夹所有权</span></div><div class=\"line\">sudo pip install virtualenv <span class=\"comment\"># 安装python虚拟环境</span></div><div class=\"line\"><span class=\"comment\"># 创建python虚拟环境</span></div><div class=\"line\"><span class=\"built_in\">cd</span> /var/www/flaskApp</div><div class=\"line\">virtualenv venv</div><div class=\"line\">. venv/bin/activate <span class=\"comment\"># 激活python虚拟环境venv</span></div><div class=\"line\">pip install flask flask-restful <span class=\"comment\"># 在虚拟环境中安装flask Web框架</span></div></pre></td></tr></table></figure></li>\n</ol>\n<p>创建api.py代码 <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!flask/bin/python</span></div><div class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, jsonify</div><div class=\"line\"></div><div class=\"line\">app = Flask(__name__)</div><div class=\"line\"></div><div class=\"line\">tasks = [</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">'id'</span>: <span class=\"number\">1</span>,</div><div class=\"line\">        <span class=\"string\">'title'</span>: <span class=\"string\">u'Buy groceries'</span>,</div><div class=\"line\">        <span class=\"string\">'description'</span>: <span class=\"string\">u'Milk, Cheese, Pizza, Fruit, Tylenol'</span>,</div><div class=\"line\">        <span class=\"string\">'done'</span>: <span class=\"keyword\">False</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">'id'</span>: <span class=\"number\">2</span>,</div><div class=\"line\">        <span class=\"string\">'title'</span>: <span class=\"string\">u'Learn Python'</span>,</div><div class=\"line\">        <span class=\"string\">'description'</span>: <span class=\"string\">u'Need to find a good Python tutorial on the web'</span>,</div><div class=\"line\">        <span class=\"string\">'done'</span>: <span class=\"keyword\">False</span></div><div class=\"line\">    &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@app.route('/todo/api/v1.0/tasks', methods=['GET'])</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_tasks</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> jsonify(&#123;<span class=\"string\">'tasks'</span>: tasks&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    app.run(host=<span class=\"string\">'0.0.0.0'</span>, port=<span class=\"number\">8080</span>)</div></pre></td></tr></table></figure></p>\n<p>执行脚本<code>python api.py</code>后可以通过浏览器来访问http://主机IP:8080/todo/api/v1.0/tasks，以此来获取tasks数据。</p>\n<h3 id=\"服务器配置-1\">服务器配置</h3>\n<h4 id=\"nginx配置\">Nginx配置</h4>\n<ol style=\"list-style-type: decimal\">\n<li><p>删除nginx默认配置文件 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo rm /etc/nginx/sites-enabled/default</div></pre></td></tr></table></figure></p></li>\n<li><p>创建新的配置文件/var/www/flaskApp/config/flaskApp_nginx.conf <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">  listen      80;</div><div class=\"line\">  server_name www.haojunyu.com; <span class=\"comment\">#此时域名已经映射到主机IP</span></div><div class=\"line\">  charset     utf-8;</div><div class=\"line\">  client_max_body_size 75M;</div><div class=\"line\"></div><div class=\"line\">  location / &#123; try_files <span class=\"variable\">$uri</span> @yourapplication; &#125;</div><div class=\"line\">  location @yourapplication &#123;</div><div class=\"line\">      include uwsgi_params;</div><div class=\"line\">      uwsgi_pass unix:/var/www/flaskApp/config/flaskApp_uwsgi.sock;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p></li>\n<li><p>创建配置文件服务，重启服务 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo ln <span class=\"_\">-s</span> /var/www/flaskApp/config/nginx.conf /etc/nginx/conf.d/ <span class=\"comment\">#将应用文件夹里的配置文件链接到nginx配置文件处</span></div><div class=\"line\">sudo /etc/init.d/nginx restart  <span class=\"comment\"># 重启nginx</span></div></pre></td></tr></table></figure></p></li>\n<li><p>验证 现在通过浏览器来访问http://haojunyu.com/todo/api/v1.0/tasks，无法获取到数据，因为flaskApp_uwsgi.sock尚未生成，无法让uwsgi在Nginx和python应用程序之间构建一座桥。</p></li>\n</ol>\n<h4 id=\"uwsgi配置\">uWSGI配置</h4>\n<ol style=\"list-style-type: decimal\">\n<li><p>创建新的配置文件/var/www/flaskApp/config/flaskApp_uwsgi.ini <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">[uwsgi]</div><div class=\"line\"><span class=\"comment\">#application's base folder</span></div><div class=\"line\">base = /var/www/flaskApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#python module to import</span></div><div class=\"line\">app = api</div><div class=\"line\">module = %(app)</div><div class=\"line\"></div><div class=\"line\">home = %(base)/venv</div><div class=\"line\">pythonpath = %(base)</div><div class=\"line\"><span class=\"comment\">## 使用virtualenvwrapper管理virtualenv后用下面的两个参数取代home和pythonpath</span></div><div class=\"line\"><span class=\"comment\">#chdir = %(base)</span></div><div class=\"line\"><span class=\"comment\">#virtualenvs = %HOME/.virtualenvs/flaskEnv</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#socket file's location</span></div><div class=\"line\">socket = /var/www/flaskApp/%n.sock</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#permissions for the socket file</span></div><div class=\"line\">chmod-socket    = 666</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#the variable that holds a flask application inside the module imported at line #6</span></div><div class=\"line\">callable = app</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#location of log files</span></div><div class=\"line\">logto = /var/<span class=\"built_in\">log</span>/uwsgi/%n.log</div></pre></td></tr></table></figure></p></li>\n<li><p>创建uWSGI日志文件夹，并更改文件所有权 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo mkdir -p /var/<span class=\"built_in\">log</span>/uwsgi <span class=\"comment\"># uWSGI日志文件夹</span></div><div class=\"line\">sudo chown -R ubuntu:ubuntu /var/<span class=\"built_in\">log</span>/uwsgi <span class=\"comment\"># 更改uWSGI日志文件夹所有权</span></div><div class=\"line\">uwsgi --ini /var/www/flaskApp/config/flaskApp_uwsgi.ini --plugin python &amp; <span class=\"comment\"># 后台启动uwsgi</span></div></pre></td></tr></table></figure></p></li>\n</ol>\n<h4 id=\"supervisor配置\">supervisor配置</h4>\n<p>supervisor是为了方便管理进程而存在的，因为每次开机后，都得重新执行<code>uwsgi --ini /var/www/flaskApp/config/flaskApp_uwsgi.ini</code>命令来启动uwsgi，这个很费神，因为你不可能永远记得清楚这么个应用，这么个配置。所以使用supervisor来管理，而我们只需要在开发这个应用时创建一个flaskApp_supervisor.conf配置文件，而重启机器后启动supervisor服务，即执行<code>sudo service supervisor start</code>。 1. 安装supervisor <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt install supervisor</div></pre></td></tr></table></figure></p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li><p>创建配置文件： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[program:flaskApp]</div><div class=\"line\"><span class=\"comment\"># 启动命令入口</span></div><div class=\"line\"><span class=\"built_in\">command</span>=/usr/<span class=\"built_in\">local</span>/bin/uwsgi --ini /var/www/flaskApp/flaskApp_uwsgi.ini</div><div class=\"line\"><span class=\"comment\"># 运行命令的用户名</span></div><div class=\"line\">user=ubuntu</div><div class=\"line\">autostart=<span class=\"literal\">true</span></div><div class=\"line\">autorestat=<span class=\"literal\">true</span></div><div class=\"line\"><span class=\"comment\">#日志地址</span></div><div class=\"line\">stdout_logfile=/var/<span class=\"built_in\">log</span>/supervisor/flaskApp_supervisor.log</div></pre></td></tr></table></figure></p></li>\n<li><p>创建配置文件副本并重启服务 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo ln <span class=\"_\">-s</span> /var/www/flaskApp/flaskApp_supervisor.conf /etc/supervisor/conf.d/</div><div class=\"line\">sudo service supervisor restart</div></pre></td></tr></table></figure></p></li>\n</ol>\n<h3 id=\"http升级https\">http升级https</h3>\n<p>升级https需要证书的支持，这里BAT都提供这样的服务，都有相对应的配置安装说明。我这里是按照[腾讯云上Nginx证书安装][nginx-https],主要就是将申请的证书保存到config目录中，并将flaskApp_nginx.conf修改如下： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">  listen      443;</div><div class=\"line\">  server_name www.haojunyu.com; <span class=\"comment\">#此时域名已经映射到主机IP</span></div><div class=\"line\"></div><div class=\"line\">  ssl on;</div><div class=\"line\">  ssl_certificate /var/www/flaskApp/1_haojunyu.com_bundle.crt;</div><div class=\"line\">  ssl_certificate_key /var/www/flaskApp/2_haojunyu.com.key;</div><div class=\"line\">  ssl_session_timeout 5m;</div><div class=\"line\">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; <span class=\"comment\">#按照这个协议配置</span></div><div class=\"line\">  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<span class=\"comment\">#按照这个套件配置</span></div><div class=\"line\">  ssl_prefer_server_ciphers on;</div><div class=\"line\"></div><div class=\"line\">  location / &#123; try_files <span class=\"variable\">$uri</span> @yourapplication; &#125;</div><div class=\"line\">  location @yourapplication &#123;</div><div class=\"line\">      include uwsgi_params;</div><div class=\"line\">      uwsgi_pass unix:/var/www/flaskApp/config/flaskApp_uwsgi.sock;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D\" target=\"_blank\" rel=\"external\">wiki-域名</a></li>\n<li><a href=\"https://who.is/\" target=\"_blank\" rel=\"external\">whois域名查询</a></li>\n<li><a href=\"https://wanwang.aliyun.com/?spm=5176.8142029.388261.26.C75xLA\" target=\"_blank\" rel=\"external\">万网</a></li>\n<li>[百度域名服务][baiduyuming]</li>\n<li>[Dnspod][Dnspod]</li>\n<li>[在Ubuntu上使用Nginx部署Flask应用][deploy-flask]</li>\n<li>[腾讯云上Nginx证书安装][nginx-https]</li>\n</ol>\n<p>[baiduyuming]： https://cloud.baidu.com/product/bcd.html [Dnspod]: https://dnspod.qcloud.com/?from=console [deploy-flask]: https://www.oschina.net/translate/serving-flask-with-nginx-on-ubuntu [nginx-https]: https://www.qcloud.com/document/product/400/4143#2.-nginx-.E8.AF.81.E4.B9.A6.E9.83.A8.E7.BD.B2</p>\n","site":{"data":{}},"excerpt":"<p>写这篇文章的目的是为了开发微信小程序。因为它要使用wx.request发起https请求，而要进行https网络通信，必须先设置域名。所以需要搭建一个https服务器来存放微信小程序的应用数据。要从零开始搭建一个https的服务需要下面4个要素：域名，备案，云服务器，服务器配置。下面分别介绍着四要素的具体要求。","more":"</p>\n<h2 id=\"域名\">域名</h2>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D\" target=\"_blank\" rel=\"external\">域名</a>（<code>Domain Name</code>）又叫网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。例如，www.haojunyu.com是一个域名，可以通过域名名称系统（<code>Domain Name System</code>）将该域名映射成对应的IP地址。该操作可以通过域名解析来实现。</p>\n<h3 id=\"域名注册和解析\">域名注册和解析</h3>\n<p>域名注册前，可以通过<a href=\"https://who.is/\" target=\"_blank\" rel=\"external\">WHOIS域名查询</a>来查询该域名是否被注册过。目前BAT都提供域名注册，如阿里的[万网],百度的[域名服务][baiduyuming]，腾讯的[Dnspod]。我的域名haojunyu.com是在阿里的万网注册的，之前注册域名的初衷是为了给github上面的个人博客作个性化的域名。并在其中的域名解析中作了设置，这里并不需要做太多的改动，只要将之前为个人博客添加的记录都暂停，并添加如下解析：记录类型为，主机记录为@，解析线路为默认，记录值为欲映射的IP。这样的话，当你在浏览器中输入haojunyu.com时，DNS会自动将其解析为映射的IP地址。</p>\n<h2 id=\"备案\">备案</h2>\n<p>这里的备案是针对像个人博客这类非经营性网站所做的备案。守法的网站对促进信息共享、文化繁荣和社会进步产生积极的作用，但有些不良的网站却传递色情，非法盈利的信息，所以备案的目的也就是为了方便网站的管理。</p>\n<p>目前网站域名的备案BAT都能提供，不过备案这个流程很长，大概要一个月，我的域名haojunyu.com是在百度云备案的，当时是先提交的资料（主要是身份证正反面照片），然后等百度快递来背景墙，再拍照片上传核实后才可以备案成功。</p>\n<h2 id=\"云服务器\">云服务器</h2>\n<p>服务器就是一台可以运行的电脑，可以是自己家里的电脑，也可以到BAT上买云服务。这里因为腾讯云上面有免费8天的试用，所以就试着在云服务上面搭建个https的服务，以方便微信小程序能成功发起request请求。如果试用体验还不错的话，可以续费（74元/月）。新建云主机时要选一个操作系统，鉴于对Ubutnu的熟悉以及服务器的需要，所以选择了Ubuntu Server 16.04.1 LTS 64的镜像做系统。当新建一个云主机后，百度云会提供一个对外的IP地址，这个IP地址就是域名解析中要填入的记录值。</p>\n<h2 id=\"服务器配置\">服务器配置</h2>\n<p>服务器的配置主要有三步个，第一步是应用程序的布置，第二步是Nginx服务器的配置，第三步是http升级为https。前两步的配置是参考这篇博文[在Ubuntu上使用Nginx部署Flask应用][deploy-flask]，第三步是参考[腾讯云上Nginx证书安装][nginx-https]。 ### 应用程序 考虑到微信小程序主要是用json的数据，所以就想服务器能够提供restful服务，又因为对python语言比较喜欢，所以就挑了python里的Flask这个轻量级的Web框架。服务器选择的是Nginx，而连接服务器和应用程序的是uWSGI。具体的安装步骤如下： 1. 环境配置 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update &amp;&amp; sudo apt-get upgrade <span class=\"comment\"># 更新所有软件</span></div><div class=\"line\">sudo apt-get install build-essential  <span class=\"comment\"># 安装编译环境</span></div><div class=\"line\">sudo apt-get install  python python-dev python-setuptools <span class=\"comment\"># 安装python环境</span></div><div class=\"line\">sudo easy_install pip</div><div class=\"line\">sudo apt-get install nginx  <span class=\"comment\"># 安装Nginx</span></div><div class=\"line\">sudo apt-get install uwsgi uwsgi-plugin-python  <span class=\"comment\"># 安装uwsgi及其插件</span></div><div class=\"line\">sudo apt-get install supervisor <span class=\"comment\"># 安装进程管理软件</span></div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><strong>TIPS:常用命令</strong> 1. nginx服务启动|停止|重启 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo /etc/init.d/nginx start|stop|restart</div></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>sdf</li>\n</ol>\n</blockquote>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>应用配置 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo mkdir -p /var/www/flaskApp <span class=\"comment\"># 创建应用程序文件夹</span></div><div class=\"line\">sudo chown -R ubuntu：ubuntu /var/www/flaskApp <span class=\"comment\"># 更改应用程序文件夹所有权</span></div><div class=\"line\">sudo pip install virtualenv <span class=\"comment\"># 安装python虚拟环境</span></div><div class=\"line\"><span class=\"comment\"># 创建python虚拟环境</span></div><div class=\"line\"><span class=\"built_in\">cd</span> /var/www/flaskApp</div><div class=\"line\">virtualenv venv</div><div class=\"line\">. venv/bin/activate <span class=\"comment\"># 激活python虚拟环境venv</span></div><div class=\"line\">pip install flask flask-restful <span class=\"comment\"># 在虚拟环境中安装flask Web框架</span></div></pre></td></tr></table></figure></li>\n</ol>\n<p>创建api.py代码 <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!flask/bin/python</span></div><div class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, jsonify</div><div class=\"line\"></div><div class=\"line\">app = Flask(__name__)</div><div class=\"line\"></div><div class=\"line\">tasks = [</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">'id'</span>: <span class=\"number\">1</span>,</div><div class=\"line\">        <span class=\"string\">'title'</span>: <span class=\"string\">u'Buy groceries'</span>,</div><div class=\"line\">        <span class=\"string\">'description'</span>: <span class=\"string\">u'Milk, Cheese, Pizza, Fruit, Tylenol'</span>,</div><div class=\"line\">        <span class=\"string\">'done'</span>: <span class=\"keyword\">False</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">'id'</span>: <span class=\"number\">2</span>,</div><div class=\"line\">        <span class=\"string\">'title'</span>: <span class=\"string\">u'Learn Python'</span>,</div><div class=\"line\">        <span class=\"string\">'description'</span>: <span class=\"string\">u'Need to find a good Python tutorial on the web'</span>,</div><div class=\"line\">        <span class=\"string\">'done'</span>: <span class=\"keyword\">False</span></div><div class=\"line\">    &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@app.route('/todo/api/v1.0/tasks', methods=['GET'])</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_tasks</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> jsonify(&#123;<span class=\"string\">'tasks'</span>: tasks&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    app.run(host=<span class=\"string\">'0.0.0.0'</span>, port=<span class=\"number\">8080</span>)</div></pre></td></tr></table></figure></p>\n<p>执行脚本<code>python api.py</code>后可以通过浏览器来访问http://主机IP:8080/todo/api/v1.0/tasks，以此来获取tasks数据。</p>\n<h3 id=\"服务器配置-1\">服务器配置</h3>\n<h4 id=\"nginx配置\">Nginx配置</h4>\n<ol style=\"list-style-type: decimal\">\n<li><p>删除nginx默认配置文件 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo rm /etc/nginx/sites-enabled/default</div></pre></td></tr></table></figure></p></li>\n<li><p>创建新的配置文件/var/www/flaskApp/config/flaskApp_nginx.conf <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">  listen      80;</div><div class=\"line\">  server_name www.haojunyu.com; <span class=\"comment\">#此时域名已经映射到主机IP</span></div><div class=\"line\">  charset     utf-8;</div><div class=\"line\">  client_max_body_size 75M;</div><div class=\"line\"></div><div class=\"line\">  location / &#123; try_files <span class=\"variable\">$uri</span> @yourapplication; &#125;</div><div class=\"line\">  location @yourapplication &#123;</div><div class=\"line\">      include uwsgi_params;</div><div class=\"line\">      uwsgi_pass unix:/var/www/flaskApp/config/flaskApp_uwsgi.sock;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p></li>\n<li><p>创建配置文件服务，重启服务 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo ln <span class=\"_\">-s</span> /var/www/flaskApp/config/nginx.conf /etc/nginx/conf.d/ <span class=\"comment\">#将应用文件夹里的配置文件链接到nginx配置文件处</span></div><div class=\"line\">sudo /etc/init.d/nginx restart  <span class=\"comment\"># 重启nginx</span></div></pre></td></tr></table></figure></p></li>\n<li><p>验证 现在通过浏览器来访问http://haojunyu.com/todo/api/v1.0/tasks，无法获取到数据，因为flaskApp_uwsgi.sock尚未生成，无法让uwsgi在Nginx和python应用程序之间构建一座桥。</p></li>\n</ol>\n<h4 id=\"uwsgi配置\">uWSGI配置</h4>\n<ol style=\"list-style-type: decimal\">\n<li><p>创建新的配置文件/var/www/flaskApp/config/flaskApp_uwsgi.ini <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">[uwsgi]</div><div class=\"line\"><span class=\"comment\">#application's base folder</span></div><div class=\"line\">base = /var/www/flaskApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#python module to import</span></div><div class=\"line\">app = api</div><div class=\"line\">module = %(app)</div><div class=\"line\"></div><div class=\"line\">home = %(base)/venv</div><div class=\"line\">pythonpath = %(base)</div><div class=\"line\"><span class=\"comment\">## 使用virtualenvwrapper管理virtualenv后用下面的两个参数取代home和pythonpath</span></div><div class=\"line\"><span class=\"comment\">#chdir = %(base)</span></div><div class=\"line\"><span class=\"comment\">#virtualenvs = %HOME/.virtualenvs/flaskEnv</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#socket file's location</span></div><div class=\"line\">socket = /var/www/flaskApp/%n.sock</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#permissions for the socket file</span></div><div class=\"line\">chmod-socket    = 666</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#the variable that holds a flask application inside the module imported at line #6</span></div><div class=\"line\">callable = app</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#location of log files</span></div><div class=\"line\">logto = /var/<span class=\"built_in\">log</span>/uwsgi/%n.log</div></pre></td></tr></table></figure></p></li>\n<li><p>创建uWSGI日志文件夹，并更改文件所有权 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo mkdir -p /var/<span class=\"built_in\">log</span>/uwsgi <span class=\"comment\"># uWSGI日志文件夹</span></div><div class=\"line\">sudo chown -R ubuntu:ubuntu /var/<span class=\"built_in\">log</span>/uwsgi <span class=\"comment\"># 更改uWSGI日志文件夹所有权</span></div><div class=\"line\">uwsgi --ini /var/www/flaskApp/config/flaskApp_uwsgi.ini --plugin python &amp; <span class=\"comment\"># 后台启动uwsgi</span></div></pre></td></tr></table></figure></p></li>\n</ol>\n<h4 id=\"supervisor配置\">supervisor配置</h4>\n<p>supervisor是为了方便管理进程而存在的，因为每次开机后，都得重新执行<code>uwsgi --ini /var/www/flaskApp/config/flaskApp_uwsgi.ini</code>命令来启动uwsgi，这个很费神，因为你不可能永远记得清楚这么个应用，这么个配置。所以使用supervisor来管理，而我们只需要在开发这个应用时创建一个flaskApp_supervisor.conf配置文件，而重启机器后启动supervisor服务，即执行<code>sudo service supervisor start</code>。 1. 安装supervisor <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt install supervisor</div></pre></td></tr></table></figure></p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li><p>创建配置文件： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[program:flaskApp]</div><div class=\"line\"><span class=\"comment\"># 启动命令入口</span></div><div class=\"line\"><span class=\"built_in\">command</span>=/usr/<span class=\"built_in\">local</span>/bin/uwsgi --ini /var/www/flaskApp/flaskApp_uwsgi.ini</div><div class=\"line\"><span class=\"comment\"># 运行命令的用户名</span></div><div class=\"line\">user=ubuntu</div><div class=\"line\">autostart=<span class=\"literal\">true</span></div><div class=\"line\">autorestat=<span class=\"literal\">true</span></div><div class=\"line\"><span class=\"comment\">#日志地址</span></div><div class=\"line\">stdout_logfile=/var/<span class=\"built_in\">log</span>/supervisor/flaskApp_supervisor.log</div></pre></td></tr></table></figure></p></li>\n<li><p>创建配置文件副本并重启服务 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo ln <span class=\"_\">-s</span> /var/www/flaskApp/flaskApp_supervisor.conf /etc/supervisor/conf.d/</div><div class=\"line\">sudo service supervisor restart</div></pre></td></tr></table></figure></p></li>\n</ol>\n<h3 id=\"http升级https\">http升级https</h3>\n<p>升级https需要证书的支持，这里BAT都提供这样的服务，都有相对应的配置安装说明。我这里是按照[腾讯云上Nginx证书安装][nginx-https],主要就是将申请的证书保存到config目录中，并将flaskApp_nginx.conf修改如下： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">  listen      443;</div><div class=\"line\">  server_name www.haojunyu.com; <span class=\"comment\">#此时域名已经映射到主机IP</span></div><div class=\"line\"></div><div class=\"line\">  ssl on;</div><div class=\"line\">  ssl_certificate /var/www/flaskApp/1_haojunyu.com_bundle.crt;</div><div class=\"line\">  ssl_certificate_key /var/www/flaskApp/2_haojunyu.com.key;</div><div class=\"line\">  ssl_session_timeout 5m;</div><div class=\"line\">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; <span class=\"comment\">#按照这个协议配置</span></div><div class=\"line\">  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<span class=\"comment\">#按照这个套件配置</span></div><div class=\"line\">  ssl_prefer_server_ciphers on;</div><div class=\"line\"></div><div class=\"line\">  location / &#123; try_files <span class=\"variable\">$uri</span> @yourapplication; &#125;</div><div class=\"line\">  location @yourapplication &#123;</div><div class=\"line\">      include uwsgi_params;</div><div class=\"line\">      uwsgi_pass unix:/var/www/flaskApp/config/flaskApp_uwsgi.sock;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D\" target=\"_blank\" rel=\"external\">wiki-域名</a></li>\n<li><a href=\"https://who.is/\" target=\"_blank\" rel=\"external\">whois域名查询</a></li>\n<li><a href=\"https://wanwang.aliyun.com/?spm=5176.8142029.388261.26.C75xLA\" target=\"_blank\" rel=\"external\">万网</a></li>\n<li>[百度域名服务][baiduyuming]</li>\n<li>[Dnspod][Dnspod]</li>\n<li>[在Ubuntu上使用Nginx部署Flask应用][deploy-flask]</li>\n<li>[腾讯云上Nginx证书安装][nginx-https]</li>\n</ol>\n<p>[baiduyuming]： https://cloud.baidu.com/product/bcd.html [Dnspod]: https://dnspod.qcloud.com/?from=console [deploy-flask]: https://www.oschina.net/translate/serving-flask-with-nginx-on-ubuntu [nginx-https]: https://www.qcloud.com/document/product/400/4143#2.-nginx-.E8.AF.81.E4.B9.A6.E9.83.A8.E7.BD.B2</p>"},{"layout":"post","title":"Nginx部署多应用","comments":1,"date":"2017-02-03T03:08:30.000Z","_content":"\n当拥有一个服务器后，发现有众多的应用想要部署在这个服务器上，而且想要为每个应用创建一个独有的二级域名，比如个人博客-blog.haojunyu.com,比如个人项目页面-pro.haojunyu.com等等，反正就是想要将自己所折腾的一切都放到这个服务器上，一方面算是给自己这么长时间在应用开发上的成果做个展示，另一方面是提醒自己不要再重复的造轮子，毕竟青春有限，还有很多其他的事情值得去尝试。这个以Nginx部署两个Python的Web框架Django和Flask为例。\n<!-- more -->\n\n在之前的博文中我们仿照[在Ubuntu上使用Nginx部署Flask应用][deploy-flask]在自己的服务器上成功部署了Flask应用，下面先在Ubuntu上使用Nginx部署Django应用，然后将二者合并在一起。\n\n## Django应用\n### 环境部署\n我们使用virtualenv(virtualenvwrapper来管理虚拟环境)来部署Django应用，部署流程如下：\n```bash\nmkvirtualenv djangoEnv  #在$HOME/.virtualenvs/目录下创建djangoEnv环境\npip install django\n# 后台使用mysql数据库\nsudo apt install mysql-server-5.x\nsudo apt install python-mysqldb\n```\n\n### 常用Django命令\n基本的Django应用命令如下：\n```bash\n# 创建项目\ndjango-amdin.py startproject djangoPro\n# 重构数据库\npython manage.py migrate\n# 启动应用\npython manage.py runserver 0.0.0.0:8090\n# 创建应用模块\npython manage.py startapp djangoApp\n```\n\n### Nginx配置\nDjango应用在Nginx服务上面的配置是参考的菜鸟教程上的[使用Nginx部署Django应用][nginx-django]。\n  1. uwsgi配置\n  和Flask应用一样，uwsgi是作为Django应用和Nginx服务器之间的桥梁的。配置如下：\n  ```bash\n  [uwsgi]\n  socket = 127.0.0.1:8090\n  master = true         //主进程\n  vhost = true          //多站模式\n  no-site = true        //多站模式时不设置入口模块和文件\n  # workers = 2           //子进程数\n  reload-mercy = 10     \n  vacuum = true         //退出、重启时清理文件\n  max-requests = 1000   \n  limit-as = 512\n  buffer-size = 30000\n  pidfile = /var/www/django/django_uwsgi.pid    //pid文件，用于下面的脚本启动、停止该进程\n  daemonize = /var/log/uwsgi/django_uwsgi.log\n  ```\n  2. Nginx配置\n  ```bash\n  server {\n    listen      443;\n    server_name django.haojunyu.com; #此时域名已经映射到主机IP\n\n    ssl on;\n    ssl_certificate /var/www/django/1_haojunyu.com_bundle.crt;\n    ssl_certificate_key /var/www/django/2_haojunyu.com.key;\n    ssl_session_timeout 5m;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置\n    ssl_prefer_server_ciphers on;\n\n    location / { try_files $uri @yourapplication; }\n    location @yourapplication {\n        include uwsgi_params;\n        uwsgi_pass 127.0.0.1:8090;  # 和uwsgi中socket配置的值一致\n        uwsgi_param UWSGI_SCRIPT djangoPro.wsgi;  # 入口文件，即wsgi.py相对于项目根目录的位置，这里.相当于一层目录\n        uwsgi_param UWSGI_CHDIR /djangoPro; # 项目根目录\n        index index.html index.htm;\n        client_max_body_size 35m;\n    }\n  }\n  ```\n  > **TIPS:**\n  > 1. 当我们使用`sudo server nginx restart`重启Nginx失败时，一定要善用`sudo nginx -t`命令来检测nginx.conf文件是否有问题。\n  > 2. 这里uwsgi充当服务器和应用之间的桥梁作用，当浏览器访问返回`Bad GatWay`时就得用`ps -aux | grep uwsgi`来检测uwsgi服务有没有启动\n\n\n## 合并多应用\n这里对于Nginx配置多个应用，建议将各个不同应用的Nginx配置文件放在/etc/nging/conf.d/目录下，有几个应用就创建几个配置文件，这样易于管理和配置。\n\n### 二级域名的使用\n对于不同的应用，显然是不能使用相同的域名的，所以这就有了通过二级域名来区分不同的应用，这里分别用django.haojunyu.com来表示django应用，用flask.haojunyu.com来表示flask应用。在Nginx的配置文件中server_name就是相应的二级域名，而在域名解析中添加两条A记录，主机记录和记录值分别是django及对应的IP地址和flask及对应的IP地址。\n\n\n\n## 参考文献\n1. [在Ubuntu上使用Nginx部署Flask应用][deploy-flask]\n1. [使用Nginx部署Django应用][nginx-django]\n\n[deploy-flask]: https://www.oschina.net/translate/serving-flask-with-nginx-on-ubuntu\n[nginx-django]: http://www.runoob.com/django/django-nginx-uwsgi.html:\n","source":"_posts/2017-02-03-Nginx部署多应用.md","raw":"---\nlayout: post\ntitle: Nginx部署多应用\ncategories:\n- TECHNOLOGY\ntags:\n- Nginx\n- Python\n- Django\n- Flask\npermalink: server-multi-apps\ncomments: true\ndate: 2017-02-03 11:08:30\n---\n\n当拥有一个服务器后，发现有众多的应用想要部署在这个服务器上，而且想要为每个应用创建一个独有的二级域名，比如个人博客-blog.haojunyu.com,比如个人项目页面-pro.haojunyu.com等等，反正就是想要将自己所折腾的一切都放到这个服务器上，一方面算是给自己这么长时间在应用开发上的成果做个展示，另一方面是提醒自己不要再重复的造轮子，毕竟青春有限，还有很多其他的事情值得去尝试。这个以Nginx部署两个Python的Web框架Django和Flask为例。\n<!-- more -->\n\n在之前的博文中我们仿照[在Ubuntu上使用Nginx部署Flask应用][deploy-flask]在自己的服务器上成功部署了Flask应用，下面先在Ubuntu上使用Nginx部署Django应用，然后将二者合并在一起。\n\n## Django应用\n### 环境部署\n我们使用virtualenv(virtualenvwrapper来管理虚拟环境)来部署Django应用，部署流程如下：\n```bash\nmkvirtualenv djangoEnv  #在$HOME/.virtualenvs/目录下创建djangoEnv环境\npip install django\n# 后台使用mysql数据库\nsudo apt install mysql-server-5.x\nsudo apt install python-mysqldb\n```\n\n### 常用Django命令\n基本的Django应用命令如下：\n```bash\n# 创建项目\ndjango-amdin.py startproject djangoPro\n# 重构数据库\npython manage.py migrate\n# 启动应用\npython manage.py runserver 0.0.0.0:8090\n# 创建应用模块\npython manage.py startapp djangoApp\n```\n\n### Nginx配置\nDjango应用在Nginx服务上面的配置是参考的菜鸟教程上的[使用Nginx部署Django应用][nginx-django]。\n  1. uwsgi配置\n  和Flask应用一样，uwsgi是作为Django应用和Nginx服务器之间的桥梁的。配置如下：\n  ```bash\n  [uwsgi]\n  socket = 127.0.0.1:8090\n  master = true         //主进程\n  vhost = true          //多站模式\n  no-site = true        //多站模式时不设置入口模块和文件\n  # workers = 2           //子进程数\n  reload-mercy = 10     \n  vacuum = true         //退出、重启时清理文件\n  max-requests = 1000   \n  limit-as = 512\n  buffer-size = 30000\n  pidfile = /var/www/django/django_uwsgi.pid    //pid文件，用于下面的脚本启动、停止该进程\n  daemonize = /var/log/uwsgi/django_uwsgi.log\n  ```\n  2. Nginx配置\n  ```bash\n  server {\n    listen      443;\n    server_name django.haojunyu.com; #此时域名已经映射到主机IP\n\n    ssl on;\n    ssl_certificate /var/www/django/1_haojunyu.com_bundle.crt;\n    ssl_certificate_key /var/www/django/2_haojunyu.com.key;\n    ssl_session_timeout 5m;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置\n    ssl_prefer_server_ciphers on;\n\n    location / { try_files $uri @yourapplication; }\n    location @yourapplication {\n        include uwsgi_params;\n        uwsgi_pass 127.0.0.1:8090;  # 和uwsgi中socket配置的值一致\n        uwsgi_param UWSGI_SCRIPT djangoPro.wsgi;  # 入口文件，即wsgi.py相对于项目根目录的位置，这里.相当于一层目录\n        uwsgi_param UWSGI_CHDIR /djangoPro; # 项目根目录\n        index index.html index.htm;\n        client_max_body_size 35m;\n    }\n  }\n  ```\n  > **TIPS:**\n  > 1. 当我们使用`sudo server nginx restart`重启Nginx失败时，一定要善用`sudo nginx -t`命令来检测nginx.conf文件是否有问题。\n  > 2. 这里uwsgi充当服务器和应用之间的桥梁作用，当浏览器访问返回`Bad GatWay`时就得用`ps -aux | grep uwsgi`来检测uwsgi服务有没有启动\n\n\n## 合并多应用\n这里对于Nginx配置多个应用，建议将各个不同应用的Nginx配置文件放在/etc/nging/conf.d/目录下，有几个应用就创建几个配置文件，这样易于管理和配置。\n\n### 二级域名的使用\n对于不同的应用，显然是不能使用相同的域名的，所以这就有了通过二级域名来区分不同的应用，这里分别用django.haojunyu.com来表示django应用，用flask.haojunyu.com来表示flask应用。在Nginx的配置文件中server_name就是相应的二级域名，而在域名解析中添加两条A记录，主机记录和记录值分别是django及对应的IP地址和flask及对应的IP地址。\n\n\n\n## 参考文献\n1. [在Ubuntu上使用Nginx部署Flask应用][deploy-flask]\n1. [使用Nginx部署Django应用][nginx-django]\n\n[deploy-flask]: https://www.oschina.net/translate/serving-flask-with-nginx-on-ubuntu\n[nginx-django]: http://www.runoob.com/django/django-nginx-uwsgi.html:\n","slug":"server-multi-apps","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1q0020l73y2j7ik520","content":"<p>当拥有一个服务器后，发现有众多的应用想要部署在这个服务器上，而且想要为每个应用创建一个独有的二级域名，比如个人博客-blog.haojunyu.com,比如个人项目页面-pro.haojunyu.com等等，反正就是想要将自己所折腾的一切都放到这个服务器上，一方面算是给自己这么长时间在应用开发上的成果做个展示，另一方面是提醒自己不要再重复的造轮子，毕竟青春有限，还有很多其他的事情值得去尝试。这个以Nginx部署两个Python的Web框架Django和Flask为例。 <a id=\"more\"></a></p>\n<p>在之前的博文中我们仿照<a href=\"https://www.oschina.net/translate/serving-flask-with-nginx-on-ubuntu\" target=\"_blank\" rel=\"external\">在Ubuntu上使用Nginx部署Flask应用</a>在自己的服务器上成功部署了Flask应用，下面先在Ubuntu上使用Nginx部署Django应用，然后将二者合并在一起。</p>\n<h2 id=\"django应用\">Django应用</h2>\n<h3 id=\"环境部署\">环境部署</h3>\n<p>我们使用virtualenv(virtualenvwrapper来管理虚拟环境)来部署Django应用，部署流程如下： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkvirtualenv djangoEnv  <span class=\"comment\">#在$HOME/.virtualenvs/目录下创建djangoEnv环境</span></div><div class=\"line\">pip install django</div><div class=\"line\"><span class=\"comment\"># 后台使用mysql数据库</span></div><div class=\"line\">sudo apt install mysql-server-5.x</div><div class=\"line\">sudo apt install python-mysqldb</div></pre></td></tr></table></figure></p>\n<h3 id=\"常用django命令\">常用Django命令</h3>\n<p>基本的Django应用命令如下： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 创建项目</span></div><div class=\"line\">django-amdin.py startproject djangoPro</div><div class=\"line\"><span class=\"comment\"># 重构数据库</span></div><div class=\"line\">python manage.py migrate</div><div class=\"line\"><span class=\"comment\"># 启动应用</span></div><div class=\"line\">python manage.py runserver 0.0.0.0:8090</div><div class=\"line\"><span class=\"comment\"># 创建应用模块</span></div><div class=\"line\">python manage.py startapp djangoApp</div></pre></td></tr></table></figure></p>\n<h3 id=\"nginx配置\">Nginx配置</h3>\n<p>Django应用在Nginx服务上面的配置是参考的菜鸟教程上的<a href=\"http://www.runoob.com/django/django-nginx-uwsgi.html:\" target=\"_blank\" rel=\"external\">使用Nginx部署Django应用</a>。 1. uwsgi配置 和Flask应用一样，uwsgi是作为Django应用和Nginx服务器之间的桥梁的。配置如下： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">[uwsgi]</div><div class=\"line\">socket = 127.0.0.1:8090</div><div class=\"line\">master = <span class=\"literal\">true</span>         //主进程</div><div class=\"line\">vhost = <span class=\"literal\">true</span>          //多站模式</div><div class=\"line\">no-site = <span class=\"literal\">true</span>        //多站模式时不设置入口模块和文件</div><div class=\"line\"><span class=\"comment\"># workers = 2           //子进程数</span></div><div class=\"line\">reload-mercy = 10     </div><div class=\"line\">vacuum = <span class=\"literal\">true</span>         //退出、重启时清理文件</div><div class=\"line\">max-requests = 1000   </div><div class=\"line\"><span class=\"built_in\">limit</span>-as = 512</div><div class=\"line\">buffer-size = 30000</div><div class=\"line\">pidfile = /var/www/django/django_uwsgi.pid    //pid文件，用于下面的脚本启动、停止该进程</div><div class=\"line\">daemonize = /var/<span class=\"built_in\">log</span>/uwsgi/django_uwsgi.log</div></pre></td></tr></table></figure></p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>Nginx配置 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">  listen      443;</div><div class=\"line\">  server_name django.haojunyu.com; <span class=\"comment\">#此时域名已经映射到主机IP</span></div><div class=\"line\"></div><div class=\"line\">  ssl on;</div><div class=\"line\">  ssl_certificate /var/www/django/1_haojunyu.com_bundle.crt;</div><div class=\"line\">  ssl_certificate_key /var/www/django/2_haojunyu.com.key;</div><div class=\"line\">  ssl_session_timeout 5m;</div><div class=\"line\">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; <span class=\"comment\">#按照这个协议配置</span></div><div class=\"line\">  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<span class=\"comment\">#按照这个套件配置</span></div><div class=\"line\">  ssl_prefer_server_ciphers on;</div><div class=\"line\"></div><div class=\"line\">  location / &#123; try_files <span class=\"variable\">$uri</span> @yourapplication; &#125;</div><div class=\"line\">  location @yourapplication &#123;</div><div class=\"line\">      include uwsgi_params;</div><div class=\"line\">      uwsgi_pass 127.0.0.1:8090;  <span class=\"comment\"># 和uwsgi中socket配置的值一致</span></div><div class=\"line\">      uwsgi_param UWSGI_SCRIPT djangoPro.wsgi;  <span class=\"comment\"># 入口文件，即wsgi.py相对于项目根目录的位置，这里.相当于一层目录</span></div><div class=\"line\">      uwsgi_param UWSGI_CHDIR /djangoPro; <span class=\"comment\"># 项目根目录</span></div><div class=\"line\">      index index.html index.htm;</div><div class=\"line\">      client_max_body_size 35m;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p><strong>TIPS:</strong> 1. 当我们使用<code>sudo server nginx restart</code>重启Nginx失败时，一定要善用<code>sudo nginx -t</code>命令来检测nginx.conf文件是否有问题。 2. 这里uwsgi充当服务器和应用之间的桥梁作用，当浏览器访问返回<code>Bad GatWay</code>时就得用<code>ps -aux | grep uwsgi</code>来检测uwsgi服务有没有启动</p>\n</blockquote>\n<h2 id=\"合并多应用\">合并多应用</h2>\n<p>这里对于Nginx配置多个应用，建议将各个不同应用的Nginx配置文件放在/etc/nging/conf.d/目录下，有几个应用就创建几个配置文件，这样易于管理和配置。</p>\n<h3 id=\"二级域名的使用\">二级域名的使用</h3>\n<p>对于不同的应用，显然是不能使用相同的域名的，所以这就有了通过二级域名来区分不同的应用，这里分别用django.haojunyu.com来表示django应用，用flask.haojunyu.com来表示flask应用。在Nginx的配置文件中server_name就是相应的二级域名，而在域名解析中添加两条A记录，主机记录和记录值分别是django及对应的IP地址和flask及对应的IP地址。</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://www.oschina.net/translate/serving-flask-with-nginx-on-ubuntu\" target=\"_blank\" rel=\"external\">在Ubuntu上使用Nginx部署Flask应用</a></li>\n<li><a href=\"http://www.runoob.com/django/django-nginx-uwsgi.html:\" target=\"_blank\" rel=\"external\">使用Nginx部署Django应用</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>当拥有一个服务器后，发现有众多的应用想要部署在这个服务器上，而且想要为每个应用创建一个独有的二级域名，比如个人博客-blog.haojunyu.com,比如个人项目页面-pro.haojunyu.com等等，反正就是想要将自己所折腾的一切都放到这个服务器上，一方面算是给自己这么长时间在应用开发上的成果做个展示，另一方面是提醒自己不要再重复的造轮子，毕竟青春有限，还有很多其他的事情值得去尝试。这个以Nginx部署两个Python的Web框架Django和Flask为例。","more":"</p>\n<p>在之前的博文中我们仿照<a href=\"https://www.oschina.net/translate/serving-flask-with-nginx-on-ubuntu\" target=\"_blank\" rel=\"external\">在Ubuntu上使用Nginx部署Flask应用</a>在自己的服务器上成功部署了Flask应用，下面先在Ubuntu上使用Nginx部署Django应用，然后将二者合并在一起。</p>\n<h2 id=\"django应用\">Django应用</h2>\n<h3 id=\"环境部署\">环境部署</h3>\n<p>我们使用virtualenv(virtualenvwrapper来管理虚拟环境)来部署Django应用，部署流程如下： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkvirtualenv djangoEnv  <span class=\"comment\">#在$HOME/.virtualenvs/目录下创建djangoEnv环境</span></div><div class=\"line\">pip install django</div><div class=\"line\"><span class=\"comment\"># 后台使用mysql数据库</span></div><div class=\"line\">sudo apt install mysql-server-5.x</div><div class=\"line\">sudo apt install python-mysqldb</div></pre></td></tr></table></figure></p>\n<h3 id=\"常用django命令\">常用Django命令</h3>\n<p>基本的Django应用命令如下： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 创建项目</span></div><div class=\"line\">django-amdin.py startproject djangoPro</div><div class=\"line\"><span class=\"comment\"># 重构数据库</span></div><div class=\"line\">python manage.py migrate</div><div class=\"line\"><span class=\"comment\"># 启动应用</span></div><div class=\"line\">python manage.py runserver 0.0.0.0:8090</div><div class=\"line\"><span class=\"comment\"># 创建应用模块</span></div><div class=\"line\">python manage.py startapp djangoApp</div></pre></td></tr></table></figure></p>\n<h3 id=\"nginx配置\">Nginx配置</h3>\n<p>Django应用在Nginx服务上面的配置是参考的菜鸟教程上的<a href=\"http://www.runoob.com/django/django-nginx-uwsgi.html:\" target=\"_blank\" rel=\"external\">使用Nginx部署Django应用</a>。 1. uwsgi配置 和Flask应用一样，uwsgi是作为Django应用和Nginx服务器之间的桥梁的。配置如下： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">[uwsgi]</div><div class=\"line\">socket = 127.0.0.1:8090</div><div class=\"line\">master = <span class=\"literal\">true</span>         //主进程</div><div class=\"line\">vhost = <span class=\"literal\">true</span>          //多站模式</div><div class=\"line\">no-site = <span class=\"literal\">true</span>        //多站模式时不设置入口模块和文件</div><div class=\"line\"><span class=\"comment\"># workers = 2           //子进程数</span></div><div class=\"line\">reload-mercy = 10     </div><div class=\"line\">vacuum = <span class=\"literal\">true</span>         //退出、重启时清理文件</div><div class=\"line\">max-requests = 1000   </div><div class=\"line\"><span class=\"built_in\">limit</span>-as = 512</div><div class=\"line\">buffer-size = 30000</div><div class=\"line\">pidfile = /var/www/django/django_uwsgi.pid    //pid文件，用于下面的脚本启动、停止该进程</div><div class=\"line\">daemonize = /var/<span class=\"built_in\">log</span>/uwsgi/django_uwsgi.log</div></pre></td></tr></table></figure></p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>Nginx配置 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">  listen      443;</div><div class=\"line\">  server_name django.haojunyu.com; <span class=\"comment\">#此时域名已经映射到主机IP</span></div><div class=\"line\"></div><div class=\"line\">  ssl on;</div><div class=\"line\">  ssl_certificate /var/www/django/1_haojunyu.com_bundle.crt;</div><div class=\"line\">  ssl_certificate_key /var/www/django/2_haojunyu.com.key;</div><div class=\"line\">  ssl_session_timeout 5m;</div><div class=\"line\">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; <span class=\"comment\">#按照这个协议配置</span></div><div class=\"line\">  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<span class=\"comment\">#按照这个套件配置</span></div><div class=\"line\">  ssl_prefer_server_ciphers on;</div><div class=\"line\"></div><div class=\"line\">  location / &#123; try_files <span class=\"variable\">$uri</span> @yourapplication; &#125;</div><div class=\"line\">  location @yourapplication &#123;</div><div class=\"line\">      include uwsgi_params;</div><div class=\"line\">      uwsgi_pass 127.0.0.1:8090;  <span class=\"comment\"># 和uwsgi中socket配置的值一致</span></div><div class=\"line\">      uwsgi_param UWSGI_SCRIPT djangoPro.wsgi;  <span class=\"comment\"># 入口文件，即wsgi.py相对于项目根目录的位置，这里.相当于一层目录</span></div><div class=\"line\">      uwsgi_param UWSGI_CHDIR /djangoPro; <span class=\"comment\"># 项目根目录</span></div><div class=\"line\">      index index.html index.htm;</div><div class=\"line\">      client_max_body_size 35m;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p><strong>TIPS:</strong> 1. 当我们使用<code>sudo server nginx restart</code>重启Nginx失败时，一定要善用<code>sudo nginx -t</code>命令来检测nginx.conf文件是否有问题。 2. 这里uwsgi充当服务器和应用之间的桥梁作用，当浏览器访问返回<code>Bad GatWay</code>时就得用<code>ps -aux | grep uwsgi</code>来检测uwsgi服务有没有启动</p>\n</blockquote>\n<h2 id=\"合并多应用\">合并多应用</h2>\n<p>这里对于Nginx配置多个应用，建议将各个不同应用的Nginx配置文件放在/etc/nging/conf.d/目录下，有几个应用就创建几个配置文件，这样易于管理和配置。</p>\n<h3 id=\"二级域名的使用\">二级域名的使用</h3>\n<p>对于不同的应用，显然是不能使用相同的域名的，所以这就有了通过二级域名来区分不同的应用，这里分别用django.haojunyu.com来表示django应用，用flask.haojunyu.com来表示flask应用。在Nginx的配置文件中server_name就是相应的二级域名，而在域名解析中添加两条A记录，主机记录和记录值分别是django及对应的IP地址和flask及对应的IP地址。</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://www.oschina.net/translate/serving-flask-with-nginx-on-ubuntu\" target=\"_blank\" rel=\"external\">在Ubuntu上使用Nginx部署Flask应用</a></li>\n<li><a href=\"http://www.runoob.com/django/django-nginx-uwsgi.html:\" target=\"_blank\" rel=\"external\">使用Nginx部署Django应用</a></li>\n</ol>"},{"layout":"post","title":"使用Python和Flask设计RESTFul接口","comments":1,"date":"2017-02-05T01:21:15.000Z","_content":"\nsdfasf\n<!-- more -->\n```bash\n# 安装Flask Flask-RESTful\npip install Flask Flask-RESTful\n# 安装关系型数据库mysql和python-mysqldb\nsudo apt install mysql-server-5.x python-mysqldb libmysqlclient-dev\n## libmysqlclient-dev是解决mysql_config无法找到问题的方案,这样才能顺利安装MySQL-python\neasy_install MySQL-python\n# 安装SQLAlchemy Flask-SQLAlchemy\npip install SQLAlchemy Flask-SQLAlchemy\n```\n","source":"_posts/2017-02-05-使用Python和Flask设计RESTFul接口.md","raw":"---\nlayout: post\ntitle: 使用Python和Flask设计RESTFul接口\ncategories:\n- TECHNOLOGY\ntags:\n- Flask\n- restful\n- Python\npermalink: design-restful\ncomments: true\ndate: 2017-02-05 09:21:15\n---\n\nsdfasf\n<!-- more -->\n```bash\n# 安装Flask Flask-RESTful\npip install Flask Flask-RESTful\n# 安装关系型数据库mysql和python-mysqldb\nsudo apt install mysql-server-5.x python-mysqldb libmysqlclient-dev\n## libmysqlclient-dev是解决mysql_config无法找到问题的方案,这样才能顺利安装MySQL-python\neasy_install MySQL-python\n# 安装SQLAlchemy Flask-SQLAlchemy\npip install SQLAlchemy Flask-SQLAlchemy\n```\n","slug":"design-restful","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1r0021l73yqroemt1o","content":"<p>sdfasf <a id=\"more\"></a> <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装Flask Flask-RESTful</span></div><div class=\"line\">pip install Flask Flask-RESTful</div><div class=\"line\"><span class=\"comment\"># 安装关系型数据库mysql和python-mysqldb</span></div><div class=\"line\">sudo apt install mysql-server-5.x python-mysqldb libmysqlclient-dev</div><div class=\"line\"><span class=\"comment\">## libmysqlclient-dev是解决mysql_config无法找到问题的方案,这样才能顺利安装MySQL-python</span></div><div class=\"line\">easy_install MySQL-python</div><div class=\"line\"><span class=\"comment\"># 安装SQLAlchemy Flask-SQLAlchemy</span></div><div class=\"line\">pip install SQLAlchemy Flask-SQLAlchemy</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>sdfasf","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 安装Flask Flask-RESTful</span></div><div class=\"line\">pip install Flask Flask-RESTful</div><div class=\"line\"><span class=\"comment\"># 安装关系型数据库mysql和python-mysqldb</span></div><div class=\"line\">sudo apt install mysql-server-5.x python-mysqldb libmysqlclient-dev</div><div class=\"line\"><span class=\"comment\">## libmysqlclient-dev是解决mysql_config无法找到问题的方案,这样才能顺利安装MySQL-python</span></div><div class=\"line\">easy_install MySQL-python</div><div class=\"line\"><span class=\"comment\"># 安装SQLAlchemy Flask-SQLAlchemy</span></div><div class=\"line\">pip install SQLAlchemy Flask-SQLAlchemy</div></pre></td></tr></table></figure></p>"},{"layout":"post","title":"ACM排序算法之快排","comments":1,"date":"2017-03-28T01:36:44.000Z","_content":"\ndescription\n<!-- more -->\n\ndetail\n\n## 参考文献\n1. [文献1][wx1]\n\n[wx1]: https://www.baidu.com\n","source":"_posts/2017-03-28-ACM排序算法之快排.md","raw":"---\nlayout: post\ntitle: ACM排序算法之快排\ncategories:\n  - TECHNOLOGY\ntags:\n  - ACM\n  - Algorithm\ncomments: true\ndate: 2017-03-28 09:36:44\npermalink: Explore-quickSort\n---\n\ndescription\n<!-- more -->\n\ndetail\n\n## 参考文献\n1. [文献1][wx1]\n\n[wx1]: https://www.baidu.com\n","slug":"Explore-quickSort","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1r0022l73ynlq66igf","content":"<p>description <a id=\"more\"></a></p>\n<p>detail</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"external\">文献1</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>description","more":"</p>\n<p>detail</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"external\">文献1</a></li>\n</ol>"},{"layout":"post","title":"活用python虚拟环境virtualenv","comments":1,"date":"2017-01-30T00:54:03.000Z","_content":"程序猿的开发历程是悠久的，但是开发技术的版本更新是日新月异的，所有这样的现象很常见：N年前开发的应用程序是基于Python2.7的，但是现在的Python版本已经到3.x了，而3.x对2.7的兼容性并不是100%的 ，所以问题来了--是不运行基于Python2.7的应用程序还是运行基于Python3.x的应用程序，而对于程序猿而言，2.7的开发程序是儿子，3.x的开发程序也是儿子哇，能使二者之间兼得的神器就是virtualenv。\n<!-- more -->\n\nvirtualenv是一个创建隔绝的Python环境的工具。它会创建一个包含所有必要的可执行文件的文件夹，用来使用Python工程所需要的包。换句话说，我们可以用virtualenv给各个项目创建各自的Python环境，各个的环境之间安装的包相互独立，互不影响。通过激活`avtive`相应的Python环境来使用相应的Python环境。这里为了方便管理不同的Python环境，我们使用virtualenvwrapper来对Python虚拟环境进行管理。\n\n## 安装和配置\nvirtualenv和virtualenvwrapper的安装很简单，一条命令即可：\n```bash\npip install virtualenv  # 安装virtualenv\npip install virtualenvwrapper # 安装virtualenvwrapper\n```\n\nvirtualenv是不需要配置的，它的使用直接是在项目文件夹里执行命令`virtualenv proEnv`，就会在当前项目目录下生成proEnv的目录，目录下会包含bin/，include/，lib/，local/这四个文件夹和一个pip-selfcheck.json文件。当该虚拟环境被激活后`source proEnv/bin/activate`，所有执行的pip安装程序都会安装在当前虚拟环境文件夹proEnv中。不过这样就导致下面的问题：\n1. 不方便管理--激活，消活`deactivate`，环境切换等\n2. 无法重用--存放在指定项目目录下\n而virtualenvwrapper能完美解决这些问题。\n\nvirtualenvwrapper的配置如下：\n```bash\n# 1.在~/.bashrc文件结尾添加下面\nsource $HOME/.local/bin/virtualenvwrapper.#!/bin/sh\n\n# 2. 重新加载配置\nsource $HOME/.bashrc\n```\n\n## 使用说明\n1. 创建环境\n```bash\n# 在$HOME/.virtualenvs/目录下创建项目python环境\nmkvirtualenv proEnv [-p python3.5]\n```\n2. 列举所有环境\n```bash\nlsvirtualenv\n```\n2. 切换环境\n```bash\nworkon proEnv\n```\n3. 退出环境\n```bash\ndeactivate\n```\n2. 删除环境\n```bash\nrevirtualenv proEnv\n```\n","source":"_posts/2017-01-30-活用python虚拟环境virtualenv.md","raw":"---\nlayout: post\ntitle: 活用python虚拟环境virtualenv\ncategories:\n- TECHNOLOGY\ntags:\n- Python\n- Web\npermalink: virtualenv\ncomments: true\ndate: 2017-01-30 08:54:03\n---\n程序猿的开发历程是悠久的，但是开发技术的版本更新是日新月异的，所有这样的现象很常见：N年前开发的应用程序是基于Python2.7的，但是现在的Python版本已经到3.x了，而3.x对2.7的兼容性并不是100%的 ，所以问题来了--是不运行基于Python2.7的应用程序还是运行基于Python3.x的应用程序，而对于程序猿而言，2.7的开发程序是儿子，3.x的开发程序也是儿子哇，能使二者之间兼得的神器就是virtualenv。\n<!-- more -->\n\nvirtualenv是一个创建隔绝的Python环境的工具。它会创建一个包含所有必要的可执行文件的文件夹，用来使用Python工程所需要的包。换句话说，我们可以用virtualenv给各个项目创建各自的Python环境，各个的环境之间安装的包相互独立，互不影响。通过激活`avtive`相应的Python环境来使用相应的Python环境。这里为了方便管理不同的Python环境，我们使用virtualenvwrapper来对Python虚拟环境进行管理。\n\n## 安装和配置\nvirtualenv和virtualenvwrapper的安装很简单，一条命令即可：\n```bash\npip install virtualenv  # 安装virtualenv\npip install virtualenvwrapper # 安装virtualenvwrapper\n```\n\nvirtualenv是不需要配置的，它的使用直接是在项目文件夹里执行命令`virtualenv proEnv`，就会在当前项目目录下生成proEnv的目录，目录下会包含bin/，include/，lib/，local/这四个文件夹和一个pip-selfcheck.json文件。当该虚拟环境被激活后`source proEnv/bin/activate`，所有执行的pip安装程序都会安装在当前虚拟环境文件夹proEnv中。不过这样就导致下面的问题：\n1. 不方便管理--激活，消活`deactivate`，环境切换等\n2. 无法重用--存放在指定项目目录下\n而virtualenvwrapper能完美解决这些问题。\n\nvirtualenvwrapper的配置如下：\n```bash\n# 1.在~/.bashrc文件结尾添加下面\nsource $HOME/.local/bin/virtualenvwrapper.#!/bin/sh\n\n# 2. 重新加载配置\nsource $HOME/.bashrc\n```\n\n## 使用说明\n1. 创建环境\n```bash\n# 在$HOME/.virtualenvs/目录下创建项目python环境\nmkvirtualenv proEnv [-p python3.5]\n```\n2. 列举所有环境\n```bash\nlsvirtualenv\n```\n2. 切换环境\n```bash\nworkon proEnv\n```\n3. 退出环境\n```bash\ndeactivate\n```\n2. 删除环境\n```bash\nrevirtualenv proEnv\n```\n","slug":"virtualenv","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1r0023l73yhf8us2sm","content":"<p>程序猿的开发历程是悠久的，但是开发技术的版本更新是日新月异的，所有这样的现象很常见：N年前开发的应用程序是基于Python2.7的，但是现在的Python版本已经到3.x了，而3.x对2.7的兼容性并不是100%的 ，所以问题来了–是不运行基于Python2.7的应用程序还是运行基于Python3.x的应用程序，而对于程序猿而言，2.7的开发程序是儿子，3.x的开发程序也是儿子哇，能使二者之间兼得的神器就是virtualenv。 <a id=\"more\"></a></p>\n<p>virtualenv是一个创建隔绝的Python环境的工具。它会创建一个包含所有必要的可执行文件的文件夹，用来使用Python工程所需要的包。换句话说，我们可以用virtualenv给各个项目创建各自的Python环境，各个的环境之间安装的包相互独立，互不影响。通过激活<code>avtive</code>相应的Python环境来使用相应的Python环境。这里为了方便管理不同的Python环境，我们使用virtualenvwrapper来对Python虚拟环境进行管理。</p>\n<h2 id=\"安装和配置\">安装和配置</h2>\n<p>virtualenv和virtualenvwrapper的安装很简单，一条命令即可： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install virtualenv  <span class=\"comment\"># 安装virtualenv</span></div><div class=\"line\">pip install virtualenvwrapper <span class=\"comment\"># 安装virtualenvwrapper</span></div></pre></td></tr></table></figure></p>\n<p>virtualenv是不需要配置的，它的使用直接是在项目文件夹里执行命令<code>virtualenv proEnv</code>，就会在当前项目目录下生成proEnv的目录，目录下会包含bin/，include/，lib/，local/这四个文件夹和一个pip-selfcheck.json文件。当该虚拟环境被激活后<code>source proEnv/bin/activate</code>，所有执行的pip安装程序都会安装在当前虚拟环境文件夹proEnv中。不过这样就导致下面的问题： 1. 不方便管理–激活，消活<code>deactivate</code>，环境切换等 2. 无法重用–存放在指定项目目录下 而virtualenvwrapper能完美解决这些问题。</p>\n<p>virtualenvwrapper的配置如下： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 1.在~/.bashrc文件结尾添加下面</span></div><div class=\"line\"><span class=\"built_in\">source</span> <span class=\"variable\">$HOME</span>/.local/bin/virtualenvwrapper.<span class=\"comment\">#!/bin/sh</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 2. 重新加载配置</span></div><div class=\"line\"><span class=\"built_in\">source</span> <span class=\"variable\">$HOME</span>/.bashrc</div></pre></td></tr></table></figure></p>\n<h2 id=\"使用说明\">使用说明</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>创建环境 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 在$HOME/.virtualenvs/目录下创建项目python环境</span></div><div class=\"line\">mkvirtualenv proEnv [-p python3.5]</div></pre></td></tr></table></figure></p></li>\n<li><p>列举所有环境 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lsvirtualenv</div></pre></td></tr></table></figure></p></li>\n<li><p>切换环境 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">workon proEnv</div></pre></td></tr></table></figure></p></li>\n<li><p>退出环境 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">deactivate</div></pre></td></tr></table></figure></p></li>\n<li><p>删除环境 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">revirtualenv proEnv</div></pre></td></tr></table></figure></p></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>程序猿的开发历程是悠久的，但是开发技术的版本更新是日新月异的，所有这样的现象很常见：N年前开发的应用程序是基于Python2.7的，但是现在的Python版本已经到3.x了，而3.x对2.7的兼容性并不是100%的 ，所以问题来了–是不运行基于Python2.7的应用程序还是运行基于Python3.x的应用程序，而对于程序猿而言，2.7的开发程序是儿子，3.x的开发程序也是儿子哇，能使二者之间兼得的神器就是virtualenv。","more":"</p>\n<p>virtualenv是一个创建隔绝的Python环境的工具。它会创建一个包含所有必要的可执行文件的文件夹，用来使用Python工程所需要的包。换句话说，我们可以用virtualenv给各个项目创建各自的Python环境，各个的环境之间安装的包相互独立，互不影响。通过激活<code>avtive</code>相应的Python环境来使用相应的Python环境。这里为了方便管理不同的Python环境，我们使用virtualenvwrapper来对Python虚拟环境进行管理。</p>\n<h2 id=\"安装和配置\">安装和配置</h2>\n<p>virtualenv和virtualenvwrapper的安装很简单，一条命令即可： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install virtualenv  <span class=\"comment\"># 安装virtualenv</span></div><div class=\"line\">pip install virtualenvwrapper <span class=\"comment\"># 安装virtualenvwrapper</span></div></pre></td></tr></table></figure></p>\n<p>virtualenv是不需要配置的，它的使用直接是在项目文件夹里执行命令<code>virtualenv proEnv</code>，就会在当前项目目录下生成proEnv的目录，目录下会包含bin/，include/，lib/，local/这四个文件夹和一个pip-selfcheck.json文件。当该虚拟环境被激活后<code>source proEnv/bin/activate</code>，所有执行的pip安装程序都会安装在当前虚拟环境文件夹proEnv中。不过这样就导致下面的问题： 1. 不方便管理–激活，消活<code>deactivate</code>，环境切换等 2. 无法重用–存放在指定项目目录下 而virtualenvwrapper能完美解决这些问题。</p>\n<p>virtualenvwrapper的配置如下： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 1.在~/.bashrc文件结尾添加下面</span></div><div class=\"line\"><span class=\"built_in\">source</span> <span class=\"variable\">$HOME</span>/.local/bin/virtualenvwrapper.<span class=\"comment\">#!/bin/sh</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 2. 重新加载配置</span></div><div class=\"line\"><span class=\"built_in\">source</span> <span class=\"variable\">$HOME</span>/.bashrc</div></pre></td></tr></table></figure></p>\n<h2 id=\"使用说明\">使用说明</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>创建环境 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 在$HOME/.virtualenvs/目录下创建项目python环境</span></div><div class=\"line\">mkvirtualenv proEnv [-p python3.5]</div></pre></td></tr></table></figure></p></li>\n<li><p>列举所有环境 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lsvirtualenv</div></pre></td></tr></table></figure></p></li>\n<li><p>切换环境 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">workon proEnv</div></pre></td></tr></table></figure></p></li>\n<li><p>退出环境 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">deactivate</div></pre></td></tr></table></figure></p></li>\n<li><p>删除环境 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">revirtualenv proEnv</div></pre></td></tr></table></figure></p></li>\n</ol>"},{"layout":"post","title":"高效排序之交换","comments":1,"date":"2017-04-14T02:29:51.000Z","_content":"\n在很多排序算法中都会使用到交换函数`Swap`，而且还是使用频率最高的函数，该函数的时间和空间复杂度完全可以决定整个排序算法的时间和空间复杂度，所以对于交换函数效率的研究还是非常重要的。而本文主要是根据贝尔实验室的JON L.BENTLEY和M.DOUGLAS McILROY发表的论文《[Engineering a Sort Function][EngiSortFunc]》。\n<!-- more -->\n\n## 理论准备\n### 字节序\n* 标题`title`\n\n\n## 程序实践\n### 计时函数选择\n要研究交换函数的效率，首先要有衡量效率的尺。这里就直接用函数运行的时间来比较实现相同功能的函数间的效率。而对于计时函数的选择我们分别对`time()`，`clock()`，`clock_gettime()`进行了试验，最终选择`clock()`函数作为计时函数。\n#### 函数`time`\n1. 定义\n```c\n#include<stdio.h>\ntime_t time(time_t *arg);\n```\n2. 功能\n获取当前日历时间（距离1970年1月1号00:00:00所经过的秒数），并返回到time_t对象中，如果arg是非空指针，则当前时间也会存储到*arg对象中。单位为秒。\n3. 注意点\n\t* time_t类型被宏定义为long int\n> **Tips:**\n> `time()`函数在[glibc-2.22源码][glibc-2.22]中实现的方式（sysdeps/unix/sysv/linux/time.c）是调用内核函数`INTERNAL_SYSCALL(time, err, 1, NULL)`实现的。\n\n#### 函数`clock`\n1. 定义\n```c \n#include<time.h>\nclock_t clock(void);\n```\n2.功能\n获取该程序从启动到本函数被调用所占用的额CPU时间，该时间是用户CPU时间和系统CPU时间之和。单位为微秒\n3. 注意点\n\t* clock_t类型被宏定义为long int\n\t* 在单核处理器上，实际时间大于CPU时间\n\t* 一般CLOCKS_PER_SEC=1000000，所以时间单位为微秒\n\n#### 函数`clock_gettime`\n1. 定义\n```c \n#include<time.h>\nint clock_gettime(clockid_t clk_id, struct timespec *tp);\n// timespec定义\nstruct timespec{\n\ttime_t tv_sec;     //秒\n\tlong int tv_nsec;  //纳秒\n}\n```\n2.功能\n通过clk_id来决定获取CPU时间[CLOCK_PROCESS_CPUTIME_ID]，实际运行时间[CLOCK_MONOTOTIC]等时间，单位为纳秒\n3. 注意点\n\t* clockid_t类型被宏定义为int\n\t* 虽然tv_nsec的单位是纳秒，但是基本后三位为0，所以精度还是微秒\n\n### 操作的耗时\n\n\n\n\n## 参考文献\n1. [Engineering a Sort Function][EngiSortFunc]\n1. [字节序][endianness]\n2. [字节序的类别][Types of endianness]\n2. [glibc-2.22源码][glibc-2.22]\n\n[EngiSortFunc]: http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf\n[endianness]: https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F\n[Types of endianness]: http://stackoverflow.com/questions/21449/types-of-endianness\n[glibc-2.22]: http://ftp.gnu.org/gnu/libc/glibc-2.22.tar.xz\n\n","source":"_posts/2017-04-14-高效排序之交换.md","raw":"---\nlayout: post\ntitle: 高效排序之交换\ncategories:\n  - TECHNOLOGY\ntags:\n  - Algorithm\n  - Research\ncomments: true\ndate: 2017-04-14 10:29:51\npermalink: Research-swap\n---\n\n在很多排序算法中都会使用到交换函数`Swap`，而且还是使用频率最高的函数，该函数的时间和空间复杂度完全可以决定整个排序算法的时间和空间复杂度，所以对于交换函数效率的研究还是非常重要的。而本文主要是根据贝尔实验室的JON L.BENTLEY和M.DOUGLAS McILROY发表的论文《[Engineering a Sort Function][EngiSortFunc]》。\n<!-- more -->\n\n## 理论准备\n### 字节序\n* 标题`title`\n\n\n## 程序实践\n### 计时函数选择\n要研究交换函数的效率，首先要有衡量效率的尺。这里就直接用函数运行的时间来比较实现相同功能的函数间的效率。而对于计时函数的选择我们分别对`time()`，`clock()`，`clock_gettime()`进行了试验，最终选择`clock()`函数作为计时函数。\n#### 函数`time`\n1. 定义\n```c\n#include<stdio.h>\ntime_t time(time_t *arg);\n```\n2. 功能\n获取当前日历时间（距离1970年1月1号00:00:00所经过的秒数），并返回到time_t对象中，如果arg是非空指针，则当前时间也会存储到*arg对象中。单位为秒。\n3. 注意点\n\t* time_t类型被宏定义为long int\n> **Tips:**\n> `time()`函数在[glibc-2.22源码][glibc-2.22]中实现的方式（sysdeps/unix/sysv/linux/time.c）是调用内核函数`INTERNAL_SYSCALL(time, err, 1, NULL)`实现的。\n\n#### 函数`clock`\n1. 定义\n```c \n#include<time.h>\nclock_t clock(void);\n```\n2.功能\n获取该程序从启动到本函数被调用所占用的额CPU时间，该时间是用户CPU时间和系统CPU时间之和。单位为微秒\n3. 注意点\n\t* clock_t类型被宏定义为long int\n\t* 在单核处理器上，实际时间大于CPU时间\n\t* 一般CLOCKS_PER_SEC=1000000，所以时间单位为微秒\n\n#### 函数`clock_gettime`\n1. 定义\n```c \n#include<time.h>\nint clock_gettime(clockid_t clk_id, struct timespec *tp);\n// timespec定义\nstruct timespec{\n\ttime_t tv_sec;     //秒\n\tlong int tv_nsec;  //纳秒\n}\n```\n2.功能\n通过clk_id来决定获取CPU时间[CLOCK_PROCESS_CPUTIME_ID]，实际运行时间[CLOCK_MONOTOTIC]等时间，单位为纳秒\n3. 注意点\n\t* clockid_t类型被宏定义为int\n\t* 虽然tv_nsec的单位是纳秒，但是基本后三位为0，所以精度还是微秒\n\n### 操作的耗时\n\n\n\n\n## 参考文献\n1. [Engineering a Sort Function][EngiSortFunc]\n1. [字节序][endianness]\n2. [字节序的类别][Types of endianness]\n2. [glibc-2.22源码][glibc-2.22]\n\n[EngiSortFunc]: http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf\n[endianness]: https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F\n[Types of endianness]: http://stackoverflow.com/questions/21449/types-of-endianness\n[glibc-2.22]: http://ftp.gnu.org/gnu/libc/glibc-2.22.tar.xz\n\n","slug":"Research-swap","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1s0024l73ygrinozsz","content":"<p>在很多排序算法中都会使用到交换函数<code>Swap</code>，而且还是使用频率最高的函数，该函数的时间和空间复杂度完全可以决定整个排序算法的时间和空间复杂度，所以对于交换函数效率的研究还是非常重要的。而本文主要是根据贝尔实验室的JON L.BENTLEY和M.DOUGLAS McILROY发表的论文《<a href=\"http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf\" target=\"_blank\" rel=\"external\">Engineering a Sort Function</a>》。 <a id=\"more\"></a></p>\n<h2 id=\"理论准备\">理论准备</h2>\n<h3 id=\"字节序\">字节序</h3>\n<ul>\n<li>标题<code>title</code></li>\n</ul>\n<h2 id=\"程序实践\">程序实践</h2>\n<h3 id=\"计时函数选择\">计时函数选择</h3>\n<p>要研究交换函数的效率，首先要有衡量效率的尺。这里就直接用函数运行的时间来比较实现相同功能的函数间的效率。而对于计时函数的选择我们分别对<code>time()</code>，<code>clock()</code>，<code>clock_gettime()</code>进行了试验，最终选择<code>clock()</code>函数作为计时函数。 #### 函数<code>time</code> 1. 定义 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">time_t</span> time(<span class=\"keyword\">time_t</span> *arg);</div></pre></td></tr></table></figure></p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>功能 获取当前日历时间（距离1970年1月1号00:00:00所经过的秒数），并返回到time_t对象中，如果arg是非空指针，则当前时间也会存储到*arg对象中。单位为秒。</li>\n<li>注意点\n<ul>\n<li>time_t类型被宏定义为long int &gt; <strong>Tips:</strong> &gt; <code>time()</code>函数在<a href=\"http://ftp.gnu.org/gnu/libc/glibc-2.22.tar.xz\" target=\"_blank\" rel=\"external\">glibc-2.22源码</a>中实现的方式（sysdeps/unix/sysv/linux/time.c）是调用内核函数<code>INTERNAL_SYSCALL(time, err, 1, NULL)</code>实现的。</li>\n</ul></li>\n</ol>\n<h4 id=\"函数clock\">函数<code>clock</code></h4>\n<ol style=\"list-style-type: decimal\">\n<li>定义 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;time.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">clock_t</span> clock(<span class=\"keyword\">void</span>);</div></pre></td></tr></table></figure></li>\n</ol>\n<p>2.功能 获取该程序从启动到本函数被调用所占用的额CPU时间，该时间是用户CPU时间和系统CPU时间之和。单位为微秒 3. 注意点 * clock_t类型被宏定义为long int * 在单核处理器上，实际时间大于CPU时间 * 一般CLOCKS_PER_SEC=1000000，所以时间单位为微秒</p>\n<h4 id=\"函数clock_gettime\">函数<code>clock_gettime</code></h4>\n<ol style=\"list-style-type: decimal\">\n<li>定义 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;time.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">clock_gettime</span><span class=\"params\">(<span class=\"keyword\">clockid_t</span> clk_id, <span class=\"keyword\">struct</span> timespec *tp)</span></span>;</div><div class=\"line\"><span class=\"comment\">// timespec定义</span></div><div class=\"line\"><span class=\"keyword\">struct</span> timespec&#123;</div><div class=\"line\">\t<span class=\"keyword\">time_t</span> tv_sec;     <span class=\"comment\">//秒</span></div><div class=\"line\">\t<span class=\"keyword\">long</span> <span class=\"keyword\">int</span> tv_nsec;  <span class=\"comment\">//纳秒</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ol>\n<p>2.功能 通过clk_id来决定获取CPU时间[CLOCK_PROCESS_CPUTIME_ID]，实际运行时间[CLOCK_MONOTOTIC]等时间，单位为纳秒 3. 注意点 * clockid_t类型被宏定义为int * 虽然tv_nsec的单位是纳秒，但是基本后三位为0，所以精度还是微秒</p>\n<h3 id=\"操作的耗时\">操作的耗时</h3>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf\" target=\"_blank\" rel=\"external\">Engineering a Sort Function</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F\" target=\"_blank\" rel=\"external\">字节序</a></li>\n<li><a href=\"http://stackoverflow.com/questions/21449/types-of-endianness\" target=\"_blank\" rel=\"external\">字节序的类别</a></li>\n<li><a href=\"http://ftp.gnu.org/gnu/libc/glibc-2.22.tar.xz\" target=\"_blank\" rel=\"external\">glibc-2.22源码</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在很多排序算法中都会使用到交换函数<code>Swap</code>，而且还是使用频率最高的函数，该函数的时间和空间复杂度完全可以决定整个排序算法的时间和空间复杂度，所以对于交换函数效率的研究还是非常重要的。而本文主要是根据贝尔实验室的JON L.BENTLEY和M.DOUGLAS McILROY发表的论文《<a href=\"http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf\" target=\"_blank\" rel=\"external\">Engineering a Sort Function</a>》。","more":"</p>\n<h2 id=\"理论准备\">理论准备</h2>\n<h3 id=\"字节序\">字节序</h3>\n<ul>\n<li>标题<code>title</code></li>\n</ul>\n<h2 id=\"程序实践\">程序实践</h2>\n<h3 id=\"计时函数选择\">计时函数选择</h3>\n<p>要研究交换函数的效率，首先要有衡量效率的尺。这里就直接用函数运行的时间来比较实现相同功能的函数间的效率。而对于计时函数的选择我们分别对<code>time()</code>，<code>clock()</code>，<code>clock_gettime()</code>进行了试验，最终选择<code>clock()</code>函数作为计时函数。 #### 函数<code>time</code> 1. 定义 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">time_t</span> time(<span class=\"keyword\">time_t</span> *arg);</div></pre></td></tr></table></figure></p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>功能 获取当前日历时间（距离1970年1月1号00:00:00所经过的秒数），并返回到time_t对象中，如果arg是非空指针，则当前时间也会存储到*arg对象中。单位为秒。</li>\n<li>注意点\n<ul>\n<li>time_t类型被宏定义为long int &gt; <strong>Tips:</strong> &gt; <code>time()</code>函数在<a href=\"http://ftp.gnu.org/gnu/libc/glibc-2.22.tar.xz\" target=\"_blank\" rel=\"external\">glibc-2.22源码</a>中实现的方式（sysdeps/unix/sysv/linux/time.c）是调用内核函数<code>INTERNAL_SYSCALL(time, err, 1, NULL)</code>实现的。</li>\n</ul></li>\n</ol>\n<h4 id=\"函数clock\">函数<code>clock</code></h4>\n<ol style=\"list-style-type: decimal\">\n<li>定义 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;time.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">clock_t</span> clock(<span class=\"keyword\">void</span>);</div></pre></td></tr></table></figure></li>\n</ol>\n<p>2.功能 获取该程序从启动到本函数被调用所占用的额CPU时间，该时间是用户CPU时间和系统CPU时间之和。单位为微秒 3. 注意点 * clock_t类型被宏定义为long int * 在单核处理器上，实际时间大于CPU时间 * 一般CLOCKS_PER_SEC=1000000，所以时间单位为微秒</p>\n<h4 id=\"函数clock_gettime\">函数<code>clock_gettime</code></h4>\n<ol style=\"list-style-type: decimal\">\n<li>定义 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;time.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">clock_gettime</span><span class=\"params\">(<span class=\"keyword\">clockid_t</span> clk_id, <span class=\"keyword\">struct</span> timespec *tp)</span></span>;</div><div class=\"line\"><span class=\"comment\">// timespec定义</span></div><div class=\"line\"><span class=\"keyword\">struct</span> timespec&#123;</div><div class=\"line\">\t<span class=\"keyword\">time_t</span> tv_sec;     <span class=\"comment\">//秒</span></div><div class=\"line\">\t<span class=\"keyword\">long</span> <span class=\"keyword\">int</span> tv_nsec;  <span class=\"comment\">//纳秒</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ol>\n<p>2.功能 通过clk_id来决定获取CPU时间[CLOCK_PROCESS_CPUTIME_ID]，实际运行时间[CLOCK_MONOTOTIC]等时间，单位为纳秒 3. 注意点 * clockid_t类型被宏定义为int * 虽然tv_nsec的单位是纳秒，但是基本后三位为0，所以精度还是微秒</p>\n<h3 id=\"操作的耗时\">操作的耗时</h3>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf\" target=\"_blank\" rel=\"external\">Engineering a Sort Function</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F\" target=\"_blank\" rel=\"external\">字节序</a></li>\n<li><a href=\"http://stackoverflow.com/questions/21449/types-of-endianness\" target=\"_blank\" rel=\"external\">字节序的类别</a></li>\n<li><a href=\"http://ftp.gnu.org/gnu/libc/glibc-2.22.tar.xz\" target=\"_blank\" rel=\"external\">glibc-2.22源码</a></li>\n</ol>"},{"layout":"post","title":"ACM解题报告之贪婪的礼物赠送者","comments":1,"date":"2017-03-25T03:30:33.000Z","_content":"本题属于杂项题，而解题的思路在于存储数据以及排序。本题使用了结构体来存储数据，并使用了快排排序算法和二叉排序树两种方法来解决排序的问题。这两种方法使得空间复杂度为$O(n)$，时间复杂度为$O(nlogn)$。\n<!-- more -->\n\n## 题目\n题目来自USACO的[Greedy Gift Givers][GreedyGiftGivers]，具体的英文说明见{% asset_link gift1.md.txt 附件%}，这里作一下简单的说明，就是有NP个人准备了一些钱来送礼物，他们会尽可能平方这些钱给收礼者。这些钱不会被分割为小数，而多出来的钱将会留在送礼者身上。第一行输入人数NP，下面NP行输入每个人的名字，接下来是NP组送礼的表示，第一行表示送礼人的名字，第二行表示送的金钱和送的人数n，后面是n个接受礼物的名字。\n\n## 思路\n本题要解决两个问题，一个是数据存储，一个是送礼过程中如何快速定位到送礼人和收礼人。\n1. 数据存储\n这里要存储的数据其实就是人名`char array`和礼物数`int`。这里考虑到后面定位查找，所以采用结构体`struct Person`来存储数据。\n```c\ntypedef strut Person{\n  char name[16];\n  int gifts;\n}Person;\n```\n\n2. 查找定位\n就现有的知识已知，查找最快的方法是随机存取和哈希算法，这两种方法的时间复杂度为$O(1)$，但本题因为要根据名称来查找定位，所以没有考虑这两种可能，再往上的时间复杂度是$O(logn)$，常见的方法有二分查找或二叉树查找。其中二分查找针对的对象是排序的数组，二叉树查找针对的对象是二叉排序树。下面就用上面两种方法来实现该问题。\n\n\n## 算法说明\n### 排序+二分查找\n这里排序查找的对象是结构体数组，由于排序的依据有名称和次序两个变量，所以思路里的结构体要添加order变量。\n```c\ntypedef struct Person{\n  char name[16];\n  int order;\n  int gifts;\n}Person;\n```\n\n对于排序算法和查找算法，我这里选择快速排序和二分查找算法，并且在c的stdlib库中有已经实现的qsort和bsearch方法来调用，不过需要我们实现比较函数来告诉这两个函数如何排列这些结构体。这里关于快速排序算法请参考{% post_link Explore-quickSort ACM排序算法之快排 %}，而关于二分查找算法请参考{% post_link ACM算法之二分查找法 ACM算法之二分查找法 %}。\n这里附上以名称name为依据的升序比较函数：\n```c\n#include<string.h>\n// @brief   按名称进行比较\n// @param   a   Person结构体\n//          b   Person结构体\n// @return  strcmp(a.name, b.name)\nint CompByName(const void *a, const void *b){\n  return strcmp(((Person *)a)->name, ((Person *)b)->name);\n}\n```\n附：{% asset_link gift1_sort.c gift1_sort.c完整代码 %}\n\n### 二叉排序树\n对于二叉树结构的节点必须得有两个子节点，所以结构体需要作一下修改：\n```c\ntypedef struct Node{\n  char name[16];\n  int gifts;\n  struct Person *left;\n  struct Person *right;\n}tNode;\n```\n\n对于二叉排序树的构建和查找，这里要分别实现，构建的过程就是一次插入节点的过程。而这个过程就需要按照左节点名称小于等于父节点名称小于等于右节点名称，所以我构建了一个递归插入函数，它输入当前树的根节点和要插入的新节点名称，并返回新节点插入后二叉树的根节点。至于二叉排序树的查找就通过递归纵向查找是否有该新节点。\n\n* 节点插入代码：\n```c\n// @brief   向二叉排序树插入节点\n// @param   root  二叉排序树的根节点指针\n//          str   插入的新节点名称\n// @return  二叉排序树的根节点\ntNode *InsertOrderTree(tNode *root, char *str){\n  int condi;\n\n  if(root == NULL){\n    // str为新节点\n    tNode *Node = (tNode *)malloc(sizeof(tNode));\n    if(Node == NULL)\n      // 无法申请节点空间，直接返回NULL\n      return NULL;\n    strcpy(Node->name, str);\n    Node->gifts = 0;\n    Node->left = NULL;\n    Node->right = NULL;\n    root = Node;\n  }else if((con\n  return root;\n}\n```\n\n* 查找二叉排序树节点\n```c\n// @brief   在二叉排序树中查找节点名为str的节点\n// @param   root  二叉排序树的根节点指针\n//          str   查找新节点的名称\n// @return  查找到的节点指针或NULL\ntNode *FindOrderTree(tNode *root, char *str){\n  int condi;\n\n  if(root == NULL){\n    return NULL;\n  }else if((condi = strcmp(str, root->name)) == 0){\n    // 该节点已经找到\n    return root;\n  }else if(condi < 0){\n    return FindOrderTree(root->left, str);\n  }else{\n    return FindOrderTree(root->right, str);\n  }\n}\n\n````\n\n附：{% asset_link gift1_tree.c gift1_tree.c完整代码 %}\n\n## 参考文献\n1. [Greedy Gift Givers][GreedyGiftGivers]\n\n[GreedyGiftGivers]: http://train.usaco.org/usacoprob2?a=F3aC6EQx1tA&S=gift1\n","source":"_posts/2017-03-25-ACM解题报告之贪婪的礼物赠送者.md","raw":"---\nlayout: post\ntitle: ACM解题报告之贪婪的礼物赠送者\ncategories:\n  - TECHNOLOGY\ntags:\n  - ACM\n  - USACO\n  - Report\ncomments: true\ndate: 2017-03-25 11:30:33\npermalink: greedy-gift-givers\n---\n本题属于杂项题，而解题的思路在于存储数据以及排序。本题使用了结构体来存储数据，并使用了快排排序算法和二叉排序树两种方法来解决排序的问题。这两种方法使得空间复杂度为$O(n)$，时间复杂度为$O(nlogn)$。\n<!-- more -->\n\n## 题目\n题目来自USACO的[Greedy Gift Givers][GreedyGiftGivers]，具体的英文说明见{% asset_link gift1.md.txt 附件%}，这里作一下简单的说明，就是有NP个人准备了一些钱来送礼物，他们会尽可能平方这些钱给收礼者。这些钱不会被分割为小数，而多出来的钱将会留在送礼者身上。第一行输入人数NP，下面NP行输入每个人的名字，接下来是NP组送礼的表示，第一行表示送礼人的名字，第二行表示送的金钱和送的人数n，后面是n个接受礼物的名字。\n\n## 思路\n本题要解决两个问题，一个是数据存储，一个是送礼过程中如何快速定位到送礼人和收礼人。\n1. 数据存储\n这里要存储的数据其实就是人名`char array`和礼物数`int`。这里考虑到后面定位查找，所以采用结构体`struct Person`来存储数据。\n```c\ntypedef strut Person{\n  char name[16];\n  int gifts;\n}Person;\n```\n\n2. 查找定位\n就现有的知识已知，查找最快的方法是随机存取和哈希算法，这两种方法的时间复杂度为$O(1)$，但本题因为要根据名称来查找定位，所以没有考虑这两种可能，再往上的时间复杂度是$O(logn)$，常见的方法有二分查找或二叉树查找。其中二分查找针对的对象是排序的数组，二叉树查找针对的对象是二叉排序树。下面就用上面两种方法来实现该问题。\n\n\n## 算法说明\n### 排序+二分查找\n这里排序查找的对象是结构体数组，由于排序的依据有名称和次序两个变量，所以思路里的结构体要添加order变量。\n```c\ntypedef struct Person{\n  char name[16];\n  int order;\n  int gifts;\n}Person;\n```\n\n对于排序算法和查找算法，我这里选择快速排序和二分查找算法，并且在c的stdlib库中有已经实现的qsort和bsearch方法来调用，不过需要我们实现比较函数来告诉这两个函数如何排列这些结构体。这里关于快速排序算法请参考{% post_link Explore-quickSort ACM排序算法之快排 %}，而关于二分查找算法请参考{% post_link ACM算法之二分查找法 ACM算法之二分查找法 %}。\n这里附上以名称name为依据的升序比较函数：\n```c\n#include<string.h>\n// @brief   按名称进行比较\n// @param   a   Person结构体\n//          b   Person结构体\n// @return  strcmp(a.name, b.name)\nint CompByName(const void *a, const void *b){\n  return strcmp(((Person *)a)->name, ((Person *)b)->name);\n}\n```\n附：{% asset_link gift1_sort.c gift1_sort.c完整代码 %}\n\n### 二叉排序树\n对于二叉树结构的节点必须得有两个子节点，所以结构体需要作一下修改：\n```c\ntypedef struct Node{\n  char name[16];\n  int gifts;\n  struct Person *left;\n  struct Person *right;\n}tNode;\n```\n\n对于二叉排序树的构建和查找，这里要分别实现，构建的过程就是一次插入节点的过程。而这个过程就需要按照左节点名称小于等于父节点名称小于等于右节点名称，所以我构建了一个递归插入函数，它输入当前树的根节点和要插入的新节点名称，并返回新节点插入后二叉树的根节点。至于二叉排序树的查找就通过递归纵向查找是否有该新节点。\n\n* 节点插入代码：\n```c\n// @brief   向二叉排序树插入节点\n// @param   root  二叉排序树的根节点指针\n//          str   插入的新节点名称\n// @return  二叉排序树的根节点\ntNode *InsertOrderTree(tNode *root, char *str){\n  int condi;\n\n  if(root == NULL){\n    // str为新节点\n    tNode *Node = (tNode *)malloc(sizeof(tNode));\n    if(Node == NULL)\n      // 无法申请节点空间，直接返回NULL\n      return NULL;\n    strcpy(Node->name, str);\n    Node->gifts = 0;\n    Node->left = NULL;\n    Node->right = NULL;\n    root = Node;\n  }else if((con\n  return root;\n}\n```\n\n* 查找二叉排序树节点\n```c\n// @brief   在二叉排序树中查找节点名为str的节点\n// @param   root  二叉排序树的根节点指针\n//          str   查找新节点的名称\n// @return  查找到的节点指针或NULL\ntNode *FindOrderTree(tNode *root, char *str){\n  int condi;\n\n  if(root == NULL){\n    return NULL;\n  }else if((condi = strcmp(str, root->name)) == 0){\n    // 该节点已经找到\n    return root;\n  }else if(condi < 0){\n    return FindOrderTree(root->left, str);\n  }else{\n    return FindOrderTree(root->right, str);\n  }\n}\n\n````\n\n附：{% asset_link gift1_tree.c gift1_tree.c完整代码 %}\n\n## 参考文献\n1. [Greedy Gift Givers][GreedyGiftGivers]\n\n[GreedyGiftGivers]: http://train.usaco.org/usacoprob2?a=F3aC6EQx1tA&S=gift1\n","slug":"greedy-gift-givers","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1s0025l73yf9o44zfc","content":"<p>本题属于杂项题，而解题的思路在于存储数据以及排序。本题使用了结构体来存储数据，并使用了快排排序算法和二叉排序树两种方法来解决排序的问题。这两种方法使得空间复杂度为<span class=\"math inline\">\\(O(n)\\)</span>，时间复杂度为<span class=\"math inline\">\\(O(nlogn)\\)</span>。 <a id=\"more\"></a></p>\n<h2 id=\"题目\">题目</h2>\n<p>题目来自USACO的<a href=\"http://train.usaco.org/usacoprob2?a=F3aC6EQx1tA&amp;S=gift1\" target=\"_blank\" rel=\"external\">Greedy Gift Givers</a>，具体的英文说明见<a href=\"/2017/03/25/greedy-gift-givers/gift1.md.txt\" title=\"附件\">附件</a>，这里作一下简单的说明，就是有NP个人准备了一些钱来送礼物，他们会尽可能平方这些钱给收礼者。这些钱不会被分割为小数，而多出来的钱将会留在送礼者身上。第一行输入人数NP，下面NP行输入每个人的名字，接下来是NP组送礼的表示，第一行表示送礼人的名字，第二行表示送的金钱和送的人数n，后面是n个接受礼物的名字。</p>\n<h2 id=\"思路\">思路</h2>\n<p>本题要解决两个问题，一个是数据存储，一个是送礼过程中如何快速定位到送礼人和收礼人。 1. 数据存储 这里要存储的数据其实就是人名<code>char array</code>和礼物数<code>int</code>。这里考虑到后面定位查找，所以采用结构体<code>struct Person</code>来存储数据。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> strut Person&#123;</div><div class=\"line\">  <span class=\"keyword\">char</span> name[<span class=\"number\">16</span>];</div><div class=\"line\">  <span class=\"keyword\">int</span> gifts;</div><div class=\"line\">&#125;Person;</div></pre></td></tr></table></figure></p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>查找定位 就现有的知识已知，查找最快的方法是随机存取和哈希算法，这两种方法的时间复杂度为<span class=\"math inline\">\\(O(1)\\)</span>，但本题因为要根据名称来查找定位，所以没有考虑这两种可能，再往上的时间复杂度是<span class=\"math inline\">\\(O(logn)\\)</span>，常见的方法有二分查找或二叉树查找。其中二分查找针对的对象是排序的数组，二叉树查找针对的对象是二叉排序树。下面就用上面两种方法来实现该问题。</li>\n</ol>\n<h2 id=\"算法说明\">算法说明</h2>\n<h3 id=\"排序二分查找\">排序+二分查找</h3>\n<p>这里排序查找的对象是结构体数组，由于排序的依据有名称和次序两个变量，所以思路里的结构体要添加order变量。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> Person&#123;</div><div class=\"line\">  <span class=\"keyword\">char</span> name[<span class=\"number\">16</span>];</div><div class=\"line\">  <span class=\"keyword\">int</span> order;</div><div class=\"line\">  <span class=\"keyword\">int</span> gifts;</div><div class=\"line\">&#125;Person;</div></pre></td></tr></table></figure></p>\n<p>对于排序算法和查找算法，我这里选择快速排序和二分查找算法，并且在c的stdlib库中有已经实现的qsort和bsearch方法来调用，不过需要我们实现比较函数来告诉这两个函数如何排列这些结构体。这里关于快速排序算法请参考<a href=\"/2017/03/28/Explore-quickSort/\" title=\"ACM排序算法之快排\">ACM排序算法之快排</a>，而关于二分查找算法请参考。 这里附上以名称name为依据的升序比较函数： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></div><div class=\"line\"><span class=\"comment\">// @brief   按名称进行比较</span></div><div class=\"line\"><span class=\"comment\">// @param   a   Person结构体</span></div><div class=\"line\"><span class=\"comment\">//          b   Person结构体</span></div><div class=\"line\"><span class=\"comment\">// @return  strcmp(a.name, b.name)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CompByName</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(((Person *)a)-&gt;name, ((Person *)b)-&gt;name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>附：<a href=\"/2017/03/25/greedy-gift-givers/gift1_sort.c\" title=\"gift1_sort.c完整代码\">gift1_sort.c完整代码</a></p>\n<h3 id=\"二叉排序树\">二叉排序树</h3>\n<p>对于二叉树结构的节点必须得有两个子节点，所以结构体需要作一下修改： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> Node&#123;</div><div class=\"line\">  <span class=\"keyword\">char</span> name[<span class=\"number\">16</span>];</div><div class=\"line\">  <span class=\"keyword\">int</span> gifts;</div><div class=\"line\">  <span class=\"keyword\">struct</span> Person *left;</div><div class=\"line\">  <span class=\"keyword\">struct</span> Person *right;</div><div class=\"line\">&#125;tNode;</div></pre></td></tr></table></figure></p>\n<p>对于二叉排序树的构建和查找，这里要分别实现，构建的过程就是一次插入节点的过程。而这个过程就需要按照左节点名称小于等于父节点名称小于等于右节点名称，所以我构建了一个递归插入函数，它输入当前树的根节点和要插入的新节点名称，并返回新节点插入后二叉树的根节点。至于二叉排序树的查找就通过递归纵向查找是否有该新节点。</p>\n<ul>\n<li><p>节点插入代码： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// @brief   向二叉排序树插入节点</span></div><div class=\"line\"><span class=\"comment\">// @param   root  二叉排序树的根节点指针</span></div><div class=\"line\"><span class=\"comment\">//          str   插入的新节点名称</span></div><div class=\"line\"><span class=\"comment\">// @return  二叉排序树的根节点</span></div><div class=\"line\"><span class=\"function\">tNode *<span class=\"title\">InsertOrderTree</span><span class=\"params\">(tNode *root, <span class=\"keyword\">char</span> *str)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> condi;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)&#123;</div><div class=\"line\">    <span class=\"comment\">// str为新节点</span></div><div class=\"line\">    tNode *Node = (tNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(tNode));</div><div class=\"line\">    <span class=\"keyword\">if</span>(Node == <span class=\"literal\">NULL</span>)</div><div class=\"line\">      <span class=\"comment\">// 无法申请节点空间，直接返回NULL</span></div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"built_in\">strcpy</span>(Node-&gt;name, str);</div><div class=\"line\">    Node-&gt;gifts = <span class=\"number\">0</span>;</div><div class=\"line\">    Node-&gt;left = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    Node-&gt;right = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    root = Node;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((con</div><div class=\"line\">  <span class=\"keyword\">return</span> root;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p></li>\n<li><p>查找二叉排序树节点 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// @brief   在二叉排序树中查找节点名为str的节点</span></div><div class=\"line\"><span class=\"comment\">// @param   root  二叉排序树的根节点指针</span></div><div class=\"line\"><span class=\"comment\">//          str   查找新节点的名称</span></div><div class=\"line\"><span class=\"comment\">// @return  查找到的节点指针或NULL</span></div><div class=\"line\"><span class=\"function\">tNode *<span class=\"title\">FindOrderTree</span><span class=\"params\">(tNode *root, <span class=\"keyword\">char</span> *str)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> condi;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((condi = <span class=\"built_in\">strcmp</span>(str, root-&gt;name)) == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">    <span class=\"comment\">// 该节点已经找到</span></div><div class=\"line\">    <span class=\"keyword\">return</span> root;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(condi &lt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> FindOrderTree(root-&gt;left, str);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> FindOrderTree(root-&gt;right, str);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">`</div></pre></td></tr></table></figure></p></li>\n</ul>\n<p>附：<a href=\"/2017/03/25/greedy-gift-givers/gift1_tree.c\" title=\"gift1_tree.c完整代码\">gift1_tree.c完整代码</a></p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://train.usaco.org/usacoprob2?a=F3aC6EQx1tA&amp;S=gift1\" target=\"_blank\" rel=\"external\">Greedy Gift Givers</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本题属于杂项题，而解题的思路在于存储数据以及排序。本题使用了结构体来存储数据，并使用了快排排序算法和二叉排序树两种方法来解决排序的问题。这两种方法使得空间复杂度为<span class=\"math inline\">\\(O(n)\\)</span>，时间复杂度为<span class=\"math inline\">\\(O(nlogn)\\)</span>。","more":"</p>\n<h2 id=\"题目\">题目</h2>\n<p>题目来自USACO的<a href=\"http://train.usaco.org/usacoprob2?a=F3aC6EQx1tA&amp;S=gift1\" target=\"_blank\" rel=\"external\">Greedy Gift Givers</a>，具体的英文说明见<a href=\"/2017/03/25/greedy-gift-givers/gift1.md.txt\" title=\"附件\">附件</a>，这里作一下简单的说明，就是有NP个人准备了一些钱来送礼物，他们会尽可能平方这些钱给收礼者。这些钱不会被分割为小数，而多出来的钱将会留在送礼者身上。第一行输入人数NP，下面NP行输入每个人的名字，接下来是NP组送礼的表示，第一行表示送礼人的名字，第二行表示送的金钱和送的人数n，后面是n个接受礼物的名字。</p>\n<h2 id=\"思路\">思路</h2>\n<p>本题要解决两个问题，一个是数据存储，一个是送礼过程中如何快速定位到送礼人和收礼人。 1. 数据存储 这里要存储的数据其实就是人名<code>char array</code>和礼物数<code>int</code>。这里考虑到后面定位查找，所以采用结构体<code>struct Person</code>来存储数据。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> strut Person&#123;</div><div class=\"line\">  <span class=\"keyword\">char</span> name[<span class=\"number\">16</span>];</div><div class=\"line\">  <span class=\"keyword\">int</span> gifts;</div><div class=\"line\">&#125;Person;</div></pre></td></tr></table></figure></p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>查找定位 就现有的知识已知，查找最快的方法是随机存取和哈希算法，这两种方法的时间复杂度为<span class=\"math inline\">\\(O(1)\\)</span>，但本题因为要根据名称来查找定位，所以没有考虑这两种可能，再往上的时间复杂度是<span class=\"math inline\">\\(O(logn)\\)</span>，常见的方法有二分查找或二叉树查找。其中二分查找针对的对象是排序的数组，二叉树查找针对的对象是二叉排序树。下面就用上面两种方法来实现该问题。</li>\n</ol>\n<h2 id=\"算法说明\">算法说明</h2>\n<h3 id=\"排序二分查找\">排序+二分查找</h3>\n<p>这里排序查找的对象是结构体数组，由于排序的依据有名称和次序两个变量，所以思路里的结构体要添加order变量。 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> Person&#123;</div><div class=\"line\">  <span class=\"keyword\">char</span> name[<span class=\"number\">16</span>];</div><div class=\"line\">  <span class=\"keyword\">int</span> order;</div><div class=\"line\">  <span class=\"keyword\">int</span> gifts;</div><div class=\"line\">&#125;Person;</div></pre></td></tr></table></figure></p>\n<p>对于排序算法和查找算法，我这里选择快速排序和二分查找算法，并且在c的stdlib库中有已经实现的qsort和bsearch方法来调用，不过需要我们实现比较函数来告诉这两个函数如何排列这些结构体。这里关于快速排序算法请参考<a href=\"/2017/03/28/Explore-quickSort/\" title=\"ACM排序算法之快排\">ACM排序算法之快排</a>，而关于二分查找算法请参考。 这里附上以名称name为依据的升序比较函数： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></div><div class=\"line\"><span class=\"comment\">// @brief   按名称进行比较</span></div><div class=\"line\"><span class=\"comment\">// @param   a   Person结构体</span></div><div class=\"line\"><span class=\"comment\">//          b   Person结构体</span></div><div class=\"line\"><span class=\"comment\">// @return  strcmp(a.name, b.name)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CompByName</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(((Person *)a)-&gt;name, ((Person *)b)-&gt;name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>附：<a href=\"/2017/03/25/greedy-gift-givers/gift1_sort.c\" title=\"gift1_sort.c完整代码\">gift1_sort.c完整代码</a></p>\n<h3 id=\"二叉排序树\">二叉排序树</h3>\n<p>对于二叉树结构的节点必须得有两个子节点，所以结构体需要作一下修改： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> Node&#123;</div><div class=\"line\">  <span class=\"keyword\">char</span> name[<span class=\"number\">16</span>];</div><div class=\"line\">  <span class=\"keyword\">int</span> gifts;</div><div class=\"line\">  <span class=\"keyword\">struct</span> Person *left;</div><div class=\"line\">  <span class=\"keyword\">struct</span> Person *right;</div><div class=\"line\">&#125;tNode;</div></pre></td></tr></table></figure></p>\n<p>对于二叉排序树的构建和查找，这里要分别实现，构建的过程就是一次插入节点的过程。而这个过程就需要按照左节点名称小于等于父节点名称小于等于右节点名称，所以我构建了一个递归插入函数，它输入当前树的根节点和要插入的新节点名称，并返回新节点插入后二叉树的根节点。至于二叉排序树的查找就通过递归纵向查找是否有该新节点。</p>\n<ul>\n<li><p>节点插入代码： <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// @brief   向二叉排序树插入节点</span></div><div class=\"line\"><span class=\"comment\">// @param   root  二叉排序树的根节点指针</span></div><div class=\"line\"><span class=\"comment\">//          str   插入的新节点名称</span></div><div class=\"line\"><span class=\"comment\">// @return  二叉排序树的根节点</span></div><div class=\"line\"><span class=\"function\">tNode *<span class=\"title\">InsertOrderTree</span><span class=\"params\">(tNode *root, <span class=\"keyword\">char</span> *str)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> condi;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)&#123;</div><div class=\"line\">    <span class=\"comment\">// str为新节点</span></div><div class=\"line\">    tNode *Node = (tNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(tNode));</div><div class=\"line\">    <span class=\"keyword\">if</span>(Node == <span class=\"literal\">NULL</span>)</div><div class=\"line\">      <span class=\"comment\">// 无法申请节点空间，直接返回NULL</span></div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"built_in\">strcpy</span>(Node-&gt;name, str);</div><div class=\"line\">    Node-&gt;gifts = <span class=\"number\">0</span>;</div><div class=\"line\">    Node-&gt;left = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    Node-&gt;right = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    root = Node;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((con</div><div class=\"line\">  <span class=\"keyword\">return</span> root;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p></li>\n<li><p>查找二叉排序树节点 <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// @brief   在二叉排序树中查找节点名为str的节点</span></div><div class=\"line\"><span class=\"comment\">// @param   root  二叉排序树的根节点指针</span></div><div class=\"line\"><span class=\"comment\">//          str   查找新节点的名称</span></div><div class=\"line\"><span class=\"comment\">// @return  查找到的节点指针或NULL</span></div><div class=\"line\"><span class=\"function\">tNode *<span class=\"title\">FindOrderTree</span><span class=\"params\">(tNode *root, <span class=\"keyword\">char</span> *str)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> condi;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((condi = <span class=\"built_in\">strcmp</span>(str, root-&gt;name)) == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">    <span class=\"comment\">// 该节点已经找到</span></div><div class=\"line\">    <span class=\"keyword\">return</span> root;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(condi &lt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> FindOrderTree(root-&gt;left, str);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> FindOrderTree(root-&gt;right, str);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">`</div></pre></td></tr></table></figure></p></li>\n</ul>\n<p>附：<a href=\"/2017/03/25/greedy-gift-givers/gift1_tree.c\" title=\"gift1_tree.c完整代码\">gift1_tree.c完整代码</a></p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"http://train.usaco.org/usacoprob2?a=F3aC6EQx1tA&amp;S=gift1\" target=\"_blank\" rel=\"external\">Greedy Gift Givers</a></li>\n</ol>"},{"layout":"post","title":"自搭服务器之网络配置","comments":1,"date":"2017-05-02T15:00:57.000Z","_content":"\ndescription\n<!-- more -->\n\n## ssh\n1. ssh配置\n在~/.ssh/config配置文件中添加服务器别名，以便以`ssh server`登录服务器\n```sh\nHost server\n  HostName 192.168.0.66\n  port 22\n  user hjy\n  IdentityFile ~/.ssh/server #设置远程服务器对应的私钥\n```\n2. 公钥登录服务器\n```sh\n# 生成ssh公私钥(密钥类型为rsa，生成的文件名为server和server.pub，注释为haojunyu2012@gmail.com)\nssh-keygen -t rsa -f server -c \"haojunyu2012@gmail.com\"\n# 拷贝本地公钥server.pub到远程主机authorized_keys中\nssh-copy-id -i server.pub hjy@192.168.0.100\n```\n保证/etc/ssh/sshd_config中三个选项打开\n```sh\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n```\n重启ssh服务\n```sh\nsudo\n```\n\n## 参考文献\n1. [文献1][wx1]\n2. [SSH原理与运用（一）：远程登录][ssh_remote_login]\n\n[wx1]: https://www.baidu.com\n[ssh_remote_login]: http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\n","source":"_posts/2017-05-02-自搭服务器之网络配置.md","raw":"---\nlayout: post\ntitle: 自搭服务器之网络配置\ncategories:\n  - category\ntags:\n  - tag\ncomments: true\ndate: 2017-05-02 23:00:57\npermalink:\n---\n\ndescription\n<!-- more -->\n\n## ssh\n1. ssh配置\n在~/.ssh/config配置文件中添加服务器别名，以便以`ssh server`登录服务器\n```sh\nHost server\n  HostName 192.168.0.66\n  port 22\n  user hjy\n  IdentityFile ~/.ssh/server #设置远程服务器对应的私钥\n```\n2. 公钥登录服务器\n```sh\n# 生成ssh公私钥(密钥类型为rsa，生成的文件名为server和server.pub，注释为haojunyu2012@gmail.com)\nssh-keygen -t rsa -f server -c \"haojunyu2012@gmail.com\"\n# 拷贝本地公钥server.pub到远程主机authorized_keys中\nssh-copy-id -i server.pub hjy@192.168.0.100\n```\n保证/etc/ssh/sshd_config中三个选项打开\n```sh\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n```\n重启ssh服务\n```sh\nsudo\n```\n\n## 参考文献\n1. [文献1][wx1]\n2. [SSH原理与运用（一）：远程登录][ssh_remote_login]\n\n[wx1]: https://www.baidu.com\n[ssh_remote_login]: http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\n","slug":"自搭服务器之网络配置","published":1,"updated":"2017-06-05T14:22:28.000Z","photos":[],"link":"","_id":"cj3kb1j1s0026l73yye8m2he2","content":"<p>description <a id=\"more\"></a></p>\n<h2 id=\"ssh\">ssh</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>ssh配置 在~/.ssh/config配置文件中添加服务器别名，以便以<code>ssh server</code>登录服务器 <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Host server</div><div class=\"line\">  HostName 192.168.0.66</div><div class=\"line\">  port 22</div><div class=\"line\">  user hjy</div><div class=\"line\">  IdentityFile ~/.ssh/server <span class=\"comment\">#设置远程服务器对应的私钥</span></div></pre></td></tr></table></figure></p></li>\n<li><p>公钥登录服务器 <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 生成ssh公私钥(密钥类型为rsa，生成的文件名为server和server.pub，注释为haojunyu2012@gmail.com)</span></div><div class=\"line\">ssh-keygen -t rsa <span class=\"_\">-f</span> server -c <span class=\"string\">\"haojunyu2012@gmail.com\"</span></div><div class=\"line\"><span class=\"comment\"># 拷贝本地公钥server.pub到远程主机authorized_keys中</span></div><div class=\"line\">ssh-copy-id -i server.pub hjy@192.168.0.100</div></pre></td></tr></table></figure></p></li>\n</ol>\n<p>保证/etc/ssh/sshd_config中三个选项打开 <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">RSAAuthentication yes</div><div class=\"line\">PubkeyAuthentication yes</div><div class=\"line\">AuthorizedKeysFile .ssh/authorized_keys</div></pre></td></tr></table></figure></p>\n<p>重启ssh服务 <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo</div></pre></td></tr></table></figure></p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"external\">文献1</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\" target=\"_blank\" rel=\"external\">SSH原理与运用（一）：远程登录</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>description","more":"</p>\n<h2 id=\"ssh\">ssh</h2>\n<ol style=\"list-style-type: decimal\">\n<li><p>ssh配置 在~/.ssh/config配置文件中添加服务器别名，以便以<code>ssh server</code>登录服务器 <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Host server</div><div class=\"line\">  HostName 192.168.0.66</div><div class=\"line\">  port 22</div><div class=\"line\">  user hjy</div><div class=\"line\">  IdentityFile ~/.ssh/server <span class=\"comment\">#设置远程服务器对应的私钥</span></div></pre></td></tr></table></figure></p></li>\n<li><p>公钥登录服务器 <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 生成ssh公私钥(密钥类型为rsa，生成的文件名为server和server.pub，注释为haojunyu2012@gmail.com)</span></div><div class=\"line\">ssh-keygen -t rsa <span class=\"_\">-f</span> server -c <span class=\"string\">\"haojunyu2012@gmail.com\"</span></div><div class=\"line\"><span class=\"comment\"># 拷贝本地公钥server.pub到远程主机authorized_keys中</span></div><div class=\"line\">ssh-copy-id -i server.pub hjy@192.168.0.100</div></pre></td></tr></table></figure></p></li>\n</ol>\n<p>保证/etc/ssh/sshd_config中三个选项打开 <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">RSAAuthentication yes</div><div class=\"line\">PubkeyAuthentication yes</div><div class=\"line\">AuthorizedKeysFile .ssh/authorized_keys</div></pre></td></tr></table></figure></p>\n<p>重启ssh服务 <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo</div></pre></td></tr></table></figure></p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ol style=\"list-style-type: decimal\">\n<li><a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"external\">文献1</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\" target=\"_blank\" rel=\"external\">SSH原理与运用（一）：远程登录</a></li>\n</ol>"}],"PostAsset":[{"_id":"source/_drafts/2017-03-21-C程序编程四步走/hello.c","slug":"hello.c","post":"cj3kb1j0o0008l73yjtb8sq1w","modified":0,"renderable":0},{"_id":"source/_drafts/2017-03-21-C程序编程四步走/hello.i","slug":"hello.i","post":"cj3kb1j0o0008l73yjtb8sq1w","modified":0,"renderable":0},{"_id":"source/_drafts/2017-03-21-C程序编程四步走/hello.s","slug":"hello.s","post":"cj3kb1j0o0008l73yjtb8sq1w","modified":0,"renderable":0},{"_id":"source/_posts/2015-07-23-ACM解题报告之最大约数个数/hiho_divisors.cpp.txt","slug":"hiho_divisors.cpp.txt","post":"cj3kb1j1f0019l73yq16h9mvl","modified":0,"renderable":0},{"_id":"source/_posts/2015-07-23-ACM解题报告之最大约数个数/hiho_divisors_depart.cpp.txt","slug":"hiho_divisors_depart.cpp.txt","post":"cj3kb1j1f0019l73yq16h9mvl","modified":0,"renderable":0},{"_id":"source/_posts/2015-07-23-ACM解题报告之最大约数个数/hiho_divisors_travel.cpp.txt","slug":"hiho_divisors_travel.cpp.txt","post":"cj3kb1j1f0019l73yq16h9mvl","modified":0,"renderable":0},{"_id":"source/_posts/2017-03-25-ACM解题报告之贪婪的礼物赠送者/gift1.md.txt","slug":"gift1.md.txt","post":"cj3kb1j1s0025l73yf9o44zfc","modified":0,"renderable":0},{"_id":"source/_posts/2017-03-25-ACM解题报告之贪婪的礼物赠送者/gift1_sort.c","slug":"gift1_sort.c","post":"cj3kb1j1s0025l73yf9o44zfc","modified":0,"renderable":0},{"_id":"source/_posts/2017-03-25-ACM解题报告之贪婪的礼物赠送者/gift1_tree.c","slug":"gift1_tree.c","post":"cj3kb1j1s0025l73yf9o44zfc","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cj3kb1j090000l73y8r8g3yh2","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j60008rl73y9k1nb0k4"},{"post_id":"cj3kb1j0d0001l73yveqqgfeu","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j60008tl73yxsb19gbl"},{"post_id":"cj3kb1j0e0002l73yw0xrvvgv","category_id":"cj3kb1j2y002bl73yqf9o55fa","_id":"cj3kb1j60008vl73yohlynsjf"},{"post_id":"cj3kb1j0g0003l73yfd3bud71","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j60008xl73y1cez40qz"},{"post_id":"cj3kb1j0g0004l73yg7zwwwe5","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j60008zl73yal00xgkv"},{"post_id":"cj3kb1j0i0005l73yh176v40r","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j600091l73y3h7uhtlu"},{"post_id":"cj3kb1j0j0006l73ybtfghnyu","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j600093l73y6qoi5p5o"},{"post_id":"cj3kb1j0k0007l73y7y12gd8y","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j600095l73yx03v4hq7"},{"post_id":"cj3kb1j0o0008l73yjtb8sq1w","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j600097l73yaxvjq6bg"},{"post_id":"cj3kb1j0p0009l73ytnr2c1z2","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j600099l73y2cfbmtcs"},{"post_id":"cj3kb1j0q000al73y6ooz9408","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j60009bl73y5tna6475"},{"post_id":"cj3kb1j0r000bl73y36re4cst","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j60009dl73y75hspl60"},{"post_id":"cj3kb1j0r000cl73yt664j7za","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j60009fl73ygo015sbw"},{"post_id":"cj3kb1j0s000dl73y1hxym7od","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j60009hl73yw1itdzhk"},{"post_id":"cj3kb1j0s000el73yuyqmu2c2","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j60009jl73y45bsi6ap"},{"post_id":"cj3kb1j0t000fl73yozr9a4gr","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j60009ll73yxxpmh5y8"},{"post_id":"cj3kb1j0t000gl73yn97yt65c","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j60009nl73y8zl2ayzq"},{"post_id":"cj3kb1j0u000hl73yqf30qcmy","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j61009pl73y2zjy8g3q"},{"post_id":"cj3kb1j0u000il73yun67yae1","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j61009rl73y47l5opd8"},{"post_id":"cj3kb1j0u000jl73y6h218src","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j61009tl73yu8fk55so"},{"post_id":"cj3kb1j0v000kl73yg9tu3pmz","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j61009vl73ypufaftux"},{"post_id":"cj3kb1j0v000ll73yd35d505j","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j61009xl73yarrfmvqz"},{"post_id":"cj3kb1j0w000ml73y5o6b2g5t","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j61009zl73yaf4pm42d"},{"post_id":"cj3kb1j0x000nl73yl1kwefl3","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6100a1l73yfx8wtjfi"},{"post_id":"cj3kb1j0y000ol73ym9rq6was","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6100a3l73ylkhcsnpv"},{"post_id":"cj3kb1j0z000pl73yn9igz76h","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6100a5l73y0tb0sdta"},{"post_id":"cj3kb1j10000ql73y0x5ito78","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6100a7l73ylzkqcqtt"},{"post_id":"cj3kb1j12000rl73y72wb4pkf","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6100a9l73y4fom1thf"},{"post_id":"cj3kb1j13000sl73yjhgal45b","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6100abl73ydwsv6obf"},{"post_id":"cj3kb1j13000tl73y3kqfthco","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200adl73ycyktf3k2"},{"post_id":"cj3kb1j14000ul73yapbp9l6o","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200afl73yjws89y97"},{"post_id":"cj3kb1j14000vl73y9ocds9sq","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200ahl73yizscbe8m"},{"post_id":"cj3kb1j16000wl73yvq9xqodo","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200ajl73y5y0ohd4d"},{"post_id":"cj3kb1j18000xl73ytwln3sq3","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200all73y3rm38wmd"},{"post_id":"cj3kb1j18000yl73y606x3i7q","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200anl73y8dp9uh57"},{"post_id":"cj3kb1j19000zl73ysdkbqfks","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200apl73ypfti6m9o"},{"post_id":"cj3kb1j190010l73ybd73fl7r","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200arl73y3hc3xmy8"},{"post_id":"cj3kb1j1a0011l73y9larlp7u","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200atl73yrtig1t66"},{"post_id":"cj3kb1j1a0012l73yp3qyzcjp","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200avl73yifr3g86c"},{"post_id":"cj3kb1j1b0013l73ydwfvuqkq","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200axl73ye4siqo4m"},{"post_id":"cj3kb1j1c0014l73yu3ott1p7","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200azl73yucym0jyb"},{"post_id":"cj3kb1j1d0015l73yll777kaq","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200b1l73ygl7w3x7l"},{"post_id":"cj3kb1j1d0016l73y8zt76jmx","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200b3l73ym1wyuwir"},{"post_id":"cj3kb1j1e0017l73yhruv5f0p","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200b5l73y216m7b0m"},{"post_id":"cj3kb1j1f0018l73yuldp58gh","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200b7l73y2yd8qo9c"},{"post_id":"cj3kb1j1f0019l73yq16h9mvl","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200b9l73y0nz5mf9w"},{"post_id":"cj3kb1j1g001al73y2xfqiwbn","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6200bbl73yemaaljhs"},{"post_id":"cj3kb1j1g001bl73yxjbqukwh","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300bdl73yjgg5fya1"},{"post_id":"cj3kb1j1g001cl73yjeqqjyqt","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300bfl73yfdr6h0tm"},{"post_id":"cj3kb1j1h001dl73yrmq61ozo","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300bhl73yd5h0td6x"},{"post_id":"cj3kb1j1h001el73ynji20pun","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300bjl73yyifald7v"},{"post_id":"cj3kb1j1i001fl73ylgtike89","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300bll73yvp2tv2ql"},{"post_id":"cj3kb1j1i001gl73ykwbm9bn9","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300bnl73yt8x9fq7j"},{"post_id":"cj3kb1j1i001hl73ybchf9tef","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300bpl73yp5n02a0y"},{"post_id":"cj3kb1j1j001il73y3wcjizwq","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300brl73yoje54vd9"},{"post_id":"cj3kb1j1j001jl73yfvj5q872","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300btl73ynjr9xt54"},{"post_id":"cj3kb1j1k001kl73ymk75zmrt","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300bvl73y8k8rshpt"},{"post_id":"cj3kb1j1k001ll73y649a59wc","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300bxl73y64if7vfj"},{"post_id":"cj3kb1j1l001ml73yl2wu0tux","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300bzl73yln6embhv"},{"post_id":"cj3kb1j1l001nl73y6laxi1bh","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300c1l73yhotaa8j4"},{"post_id":"cj3kb1j1m001ol73yhlkfy00r","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300c3l73yxvrscanb"},{"post_id":"cj3kb1j1m001pl73yic29veyu","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300c5l73y7kzu52tj"},{"post_id":"cj3kb1j1m001ql73y6g8d1jvx","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300c7l73yaezigju4"},{"post_id":"cj3kb1j1n001rl73yc38o0d1j","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6300c9l73y8pkv9aie"},{"post_id":"cj3kb1j1n001sl73y1j0mdfsh","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6400cbl73y36y9wcuj"},{"post_id":"cj3kb1j1n001tl73ygtvwxv65","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6400cdl73yuyjua1vh"},{"post_id":"cj3kb1j1o001ul73y4m23nvnv","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6400cfl73ypejl2wqb"},{"post_id":"cj3kb1j1p001vl73yf2f7nq1z","category_id":"cj3kb1j2y002bl73yqf9o55fa","_id":"cj3kb1j6400chl73yksaqmycu"},{"post_id":"cj3kb1j1p001wl73y3z9bv010","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6400cjl73yg71tbjyb"},{"post_id":"cj3kb1j1q001xl73y5h2id8ug","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6400cll73ys0apzmk2"},{"post_id":"cj3kb1j1q001yl73yf30t0nas","category_id":"cj3kb1j4h0061l73yl5mllsx2","_id":"cj3kb1j6400cnl73y0s3xi58d"},{"post_id":"cj3kb1j1q001zl73yjmyqzfiw","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6400cpl73yg0aov08h"},{"post_id":"cj3kb1j1q0020l73y2j7ik520","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6400crl73ydy09umub"},{"post_id":"cj3kb1j1r0021l73yqroemt1o","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6400ctl73ym313n1wj"},{"post_id":"cj3kb1j1r0022l73ynlq66igf","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6500cvl73y924914c4"},{"post_id":"cj3kb1j1r0023l73yhf8us2sm","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6500cxl73yoxokfuyr"},{"post_id":"cj3kb1j1s0024l73ygrinozsz","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6500czl73yhje0ejbz"},{"post_id":"cj3kb1j1s0025l73yf9o44zfc","category_id":"cj3kb1j2h0027l73yt1k74jbx","_id":"cj3kb1j6500d1l73yt46bfqyg"},{"post_id":"cj3kb1j1s0026l73yye8m2he2","category_id":"cj3kb1j4n006gl73y7luv8ol4","_id":"cj3kb1j6500d3l73yoymfng65"}],"PostTag":[{"post_id":"cj3kb1j090000l73y8r8g3yh2","tag_id":"cj3kb1j2t0028l73y3ermvdky","_id":"cj3kb1j60008ql73y2e6tqbqr"},{"post_id":"cj3kb1j0d0001l73yveqqgfeu","tag_id":"cj3kb1j2w002al73y4gs75qio","_id":"cj3kb1j60008sl73yym8f9awe"},{"post_id":"cj3kb1j0d0001l73yveqqgfeu","tag_id":"cj3kb1j2y002cl73y6lhdfrnq","_id":"cj3kb1j60008ul73yl9nmvsl8"},{"post_id":"cj3kb1j0e0002l73yw0xrvvgv","tag_id":"cj3kb1j2z002el73yi8txomsb","_id":"cj3kb1j60008wl73yhzjdnoeb"},{"post_id":"cj3kb1j0g0003l73yfd3bud71","tag_id":"cj3kb1j2z002gl73yy2anqt1q","_id":"cj3kb1j60008yl73y3omx3txn"},{"post_id":"cj3kb1j0g0003l73yfd3bud71","tag_id":"cj3kb1j30002il73yd36p57xe","_id":"cj3kb1j600090l73y6ijxxnns"},{"post_id":"cj3kb1j0g0004l73yg7zwwwe5","tag_id":"cj3kb1j30002kl73yw5k8rqqn","_id":"cj3kb1j600092l73y3zxfqsty"},{"post_id":"cj3kb1j0g0004l73yg7zwwwe5","tag_id":"cj3kb1j31002ml73yay7txjq2","_id":"cj3kb1j600094l73yig526n4n"},{"post_id":"cj3kb1j0i0005l73yh176v40r","tag_id":"cj3kb1j31002ol73ywlqv2bih","_id":"cj3kb1j600096l73yxzoq651k"},{"post_id":"cj3kb1j0i0005l73yh176v40r","tag_id":"cj3kb1j2z002gl73yy2anqt1q","_id":"cj3kb1j600098l73y056t6yn4"},{"post_id":"cj3kb1j0i0005l73yh176v40r","tag_id":"cj3kb1j32002sl73yj0jdnmtg","_id":"cj3kb1j60009al73yz4tmdv1e"},{"post_id":"cj3kb1j0j0006l73ybtfghnyu","tag_id":"cj3kb1j2t0028l73y3ermvdky","_id":"cj3kb1j60009cl73y12dsuobd"},{"post_id":"cj3kb1j0k0007l73y7y12gd8y","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j60009el73ypqcc0fbv"},{"post_id":"cj3kb1j0k0007l73y7y12gd8y","tag_id":"cj3kb1j34002zl73yqibr30qn","_id":"cj3kb1j60009gl73yv3b4lbjn"},{"post_id":"cj3kb1j0o0008l73yjtb8sq1w","tag_id":"cj3kb1j2z002gl73yy2anqt1q","_id":"cj3kb1j60009il73y2cdvnsyi"},{"post_id":"cj3kb1j0o0008l73yjtb8sq1w","tag_id":"cj3kb1j350033l73y00woe3va","_id":"cj3kb1j60009kl73ytd01m4ht"},{"post_id":"cj3kb1j0o0008l73yjtb8sq1w","tag_id":"cj3kb1j360035l73yiw5qse1n","_id":"cj3kb1j60009ml73ymn3yppcb"},{"post_id":"cj3kb1j0o0008l73yjtb8sq1w","tag_id":"cj3kb1j370037l73ybo8tcx9y","_id":"cj3kb1j61009ol73yfk2d9yfl"},{"post_id":"cj3kb1j0o0008l73yjtb8sq1w","tag_id":"cj3kb1j380039l73yydnl164b","_id":"cj3kb1j61009ql73ybxdm4jf6"},{"post_id":"cj3kb1j0p0009l73ytnr2c1z2","tag_id":"cj3kb1j39003bl73ytk4xs54i","_id":"cj3kb1j61009sl73ytojondt3"},{"post_id":"cj3kb1j0q000al73y6ooz9408","tag_id":"cj3kb1j39003bl73ytk4xs54i","_id":"cj3kb1j61009ul73yzku7ugru"},{"post_id":"cj3kb1j0r000bl73y36re4cst","tag_id":"cj3kb1j39003bl73ytk4xs54i","_id":"cj3kb1j61009wl73y4nfwar5p"},{"post_id":"cj3kb1j0r000cl73yt664j7za","tag_id":"cj3kb1j39003bl73ytk4xs54i","_id":"cj3kb1j61009yl73yse5f2n6l"},{"post_id":"cj3kb1j0s000dl73y1hxym7od","tag_id":"cj3kb1j39003bl73ytk4xs54i","_id":"cj3kb1j6100a0l73y3uu8uy4y"},{"post_id":"cj3kb1j0s000el73yuyqmu2c2","tag_id":"cj3kb1j39003bl73ytk4xs54i","_id":"cj3kb1j6100a2l73ylfeodq3s"},{"post_id":"cj3kb1j0t000fl73yozr9a4gr","tag_id":"cj3kb1j39003bl73ytk4xs54i","_id":"cj3kb1j6100a4l73y8acfpue7"},{"post_id":"cj3kb1j0t000gl73yn97yt65c","tag_id":"cj3kb1j39003bl73ytk4xs54i","_id":"cj3kb1j6100a6l73yp6fjurjo"},{"post_id":"cj3kb1j0u000hl73yqf30qcmy","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6100a8l73ye6psycbi"},{"post_id":"cj3kb1j0u000il73yun67yae1","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6100aal73yjvp9pgqk"},{"post_id":"cj3kb1j0u000jl73y6h218src","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6200acl73y4bl75vpl"},{"post_id":"cj3kb1j0v000kl73yg9tu3pmz","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6200ael73yli89dkh1"},{"post_id":"cj3kb1j0v000ll73yd35d505j","tag_id":"cj3kb1j3l0040l73y1fkl8kzy","_id":"cj3kb1j6200agl73y5uxd3ki9"},{"post_id":"cj3kb1j0v000ll73yd35d505j","tag_id":"cj3kb1j3l0042l73yoow1eyp7","_id":"cj3kb1j6200ail73y5d2baaxq"},{"post_id":"cj3kb1j0w000ml73y5o6b2g5t","tag_id":"cj3kb1j3l0040l73y1fkl8kzy","_id":"cj3kb1j6200akl73youfzir6s"},{"post_id":"cj3kb1j0w000ml73y5o6b2g5t","tag_id":"cj3kb1j3l0042l73yoow1eyp7","_id":"cj3kb1j6200aml73ye0ubjufq"},{"post_id":"cj3kb1j0x000nl73yl1kwefl3","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6200aol73yrvgjzou3"},{"post_id":"cj3kb1j0x000nl73yl1kwefl3","tag_id":"cj3kb1j3o004al73ynnij1i3l","_id":"cj3kb1j6200aql73ywef7lzgz"},{"post_id":"cj3kb1j0y000ol73ym9rq6was","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6200asl73y10q67s7e"},{"post_id":"cj3kb1j0y000ol73ym9rq6was","tag_id":"cj3kb1j3o004al73ynnij1i3l","_id":"cj3kb1j6200aul73yk6kgmxlo"},{"post_id":"cj3kb1j0z000pl73yn9igz76h","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6200awl73yal0v4ro0"},{"post_id":"cj3kb1j0z000pl73yn9igz76h","tag_id":"cj3kb1j3o004al73ynnij1i3l","_id":"cj3kb1j6200ayl73yjyp2e5aw"},{"post_id":"cj3kb1j10000ql73y0x5ito78","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6200b0l73ynzdhdifj"},{"post_id":"cj3kb1j10000ql73y0x5ito78","tag_id":"cj3kb1j3o004al73ynnij1i3l","_id":"cj3kb1j6200b2l73yk7sb6pel"},{"post_id":"cj3kb1j12000rl73y72wb4pkf","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6200b4l73yj3pyzxv9"},{"post_id":"cj3kb1j12000rl73y72wb4pkf","tag_id":"cj3kb1j3o004al73ynnij1i3l","_id":"cj3kb1j6200b6l73y7e88kvxb"},{"post_id":"cj3kb1j13000sl73yjhgal45b","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6200b8l73y9ekhxs6p"},{"post_id":"cj3kb1j13000sl73yjhgal45b","tag_id":"cj3kb1j3o004al73ynnij1i3l","_id":"cj3kb1j6200bal73y3kbeyybm"},{"post_id":"cj3kb1j13000tl73y3kqfthco","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6300bcl73ypvpey440"},{"post_id":"cj3kb1j13000tl73y3kqfthco","tag_id":"cj3kb1j3o004al73ynnij1i3l","_id":"cj3kb1j6300bel73ym7m6ykpv"},{"post_id":"cj3kb1j14000ul73yapbp9l6o","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j6300bgl73yx18c493q"},{"post_id":"cj3kb1j14000ul73yapbp9l6o","tag_id":"cj3kb1j34002zl73yqibr30qn","_id":"cj3kb1j6300bil73yv3l8lh29"},{"post_id":"cj3kb1j14000vl73y9ocds9sq","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6300bkl73yfw04c6r5"},{"post_id":"cj3kb1j14000vl73y9ocds9sq","tag_id":"cj3kb1j3o004al73ynnij1i3l","_id":"cj3kb1j6300bml73ynjaw3dqd"},{"post_id":"cj3kb1j16000wl73yvq9xqodo","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6300bol73y7ttrc7xf"},{"post_id":"cj3kb1j16000wl73yvq9xqodo","tag_id":"cj3kb1j3o004al73ynnij1i3l","_id":"cj3kb1j6300bql73yfhne70ku"},{"post_id":"cj3kb1j18000xl73ytwln3sq3","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j6300bsl73yhxd2a1am"},{"post_id":"cj3kb1j18000xl73ytwln3sq3","tag_id":"cj3kb1j34002zl73yqibr30qn","_id":"cj3kb1j6300bul73yjaplida7"},{"post_id":"cj3kb1j18000yl73y606x3i7q","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6300bwl73yvk3hukea"},{"post_id":"cj3kb1j19000zl73ysdkbqfks","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6300byl73yqns5xmnw"},{"post_id":"cj3kb1j190010l73ybd73fl7r","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6300c0l73y9nwxbaph"},{"post_id":"cj3kb1j1a0011l73y9larlp7u","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6300c2l73yphqrplu9"},{"post_id":"cj3kb1j1a0012l73yp3qyzcjp","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j6300c4l73yt8dol3h3"},{"post_id":"cj3kb1j1a0012l73yp3qyzcjp","tag_id":"cj3kb1j46005ql73yv6t6nhgh","_id":"cj3kb1j6300c6l73y5n9y5ena"},{"post_id":"cj3kb1j1b0013l73ydwfvuqkq","tag_id":"cj3kb1j47005sl73y91kehhz7","_id":"cj3kb1j6300c8l73yiq1ma07d"},{"post_id":"cj3kb1j1b0013l73ydwfvuqkq","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j6400cal73yeh57jvb8"},{"post_id":"cj3kb1j1c0014l73yu3ott1p7","tag_id":"cj3kb1j4e005wl73yi4u1ozxl","_id":"cj3kb1j6400ccl73ypl6m0buj"},{"post_id":"cj3kb1j1d0015l73yll777kaq","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6400cel73yvkz2753p"},{"post_id":"cj3kb1j1d0016l73y8zt76jmx","tag_id":"cj3kb1j3l0040l73y1fkl8kzy","_id":"cj3kb1j6400cgl73yu88ihdy1"},{"post_id":"cj3kb1j1d0016l73y8zt76jmx","tag_id":"cj3kb1j4i0062l73yezayk6mt","_id":"cj3kb1j6400cil73yjtz3yl36"},{"post_id":"cj3kb1j1e0017l73yhruv5f0p","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6400ckl73yhas2zlh4"},{"post_id":"cj3kb1j1f0018l73yuldp58gh","tag_id":"cj3kb1j3l0040l73y1fkl8kzy","_id":"cj3kb1j6400cml73yu6p5owp5"},{"post_id":"cj3kb1j1f0018l73yuldp58gh","tag_id":"cj3kb1j4i0062l73yezayk6mt","_id":"cj3kb1j6400col73ymg760si3"},{"post_id":"cj3kb1j1f0019l73yq16h9mvl","tag_id":"cj3kb1j3l0040l73y1fkl8kzy","_id":"cj3kb1j6400cql73ybnm1o56p"},{"post_id":"cj3kb1j1f0019l73yq16h9mvl","tag_id":"cj3kb1j4m006cl73yau9362qn","_id":"cj3kb1j6400csl73ymuzi5ni8"},{"post_id":"cj3kb1j1f0019l73yq16h9mvl","tag_id":"cj3kb1j4m006fl73y5zu15xsd","_id":"cj3kb1j6400cul73ya8onn576"},{"post_id":"cj3kb1j1g001al73y2xfqiwbn","tag_id":"cj3kb1j3l0040l73y1fkl8kzy","_id":"cj3kb1j6500cwl73y86x6dga8"},{"post_id":"cj3kb1j1g001al73y2xfqiwbn","tag_id":"cj3kb1j4i0062l73yezayk6mt","_id":"cj3kb1j6500cyl73y2q8cct3f"},{"post_id":"cj3kb1j1g001bl73yxjbqukwh","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j6500d0l73y0epbx4i4"},{"post_id":"cj3kb1j1g001bl73yxjbqukwh","tag_id":"cj3kb1j46005ql73yv6t6nhgh","_id":"cj3kb1j6500d2l73yg5irqrfr"},{"post_id":"cj3kb1j1g001cl73yjeqqjyqt","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j6600d4l73yz8qmhm1h"},{"post_id":"cj3kb1j1g001cl73yjeqqjyqt","tag_id":"cj3kb1j46005ql73yv6t6nhgh","_id":"cj3kb1j6600d5l73ytqq5vt3t"},{"post_id":"cj3kb1j1h001dl73yrmq61ozo","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j6600d6l73y1bd70k5e"},{"post_id":"cj3kb1j1h001dl73yrmq61ozo","tag_id":"cj3kb1j34002zl73yqibr30qn","_id":"cj3kb1j6600d7l73y5b012hjm"},{"post_id":"cj3kb1j1h001el73ynji20pun","tag_id":"cj3kb1j2z002gl73yy2anqt1q","_id":"cj3kb1j6600d8l73y8e41yaap"},{"post_id":"cj3kb1j1h001el73ynji20pun","tag_id":"cj3kb1j3l0042l73yoow1eyp7","_id":"cj3kb1j6600d9l73yj5xngb1y"},{"post_id":"cj3kb1j1i001fl73ylgtike89","tag_id":"cj3kb1j30002kl73yw5k8rqqn","_id":"cj3kb1j6600dal73ynxd6zarx"},{"post_id":"cj3kb1j1i001fl73ylgtike89","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j6600dbl73yifwt27wo"},{"post_id":"cj3kb1j1i001gl73ykwbm9bn9","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j6600dcl73yzveu2kmh"},{"post_id":"cj3kb1j1i001gl73ykwbm9bn9","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6600ddl73y2z7mdc9c"},{"post_id":"cj3kb1j1i001hl73ybchf9tef","tag_id":"cj3kb1j3l0040l73y1fkl8kzy","_id":"cj3kb1j6600del73yrtny9qwt"},{"post_id":"cj3kb1j1i001hl73ybchf9tef","tag_id":"cj3kb1j4m006cl73yau9362qn","_id":"cj3kb1j6600dfl73yrvmqltwl"},{"post_id":"cj3kb1j1i001hl73ybchf9tef","tag_id":"cj3kb1j4m006fl73y5zu15xsd","_id":"cj3kb1j6600dgl73yd0x71f8w"},{"post_id":"cj3kb1j1j001il73y3wcjizwq","tag_id":"cj3kb1j3l0040l73y1fkl8kzy","_id":"cj3kb1j6600dhl73yacu1uufw"},{"post_id":"cj3kb1j1j001il73y3wcjizwq","tag_id":"cj3kb1j4w006zl73y2jvb1ub1","_id":"cj3kb1j6600dil73yqycs8wvc"},{"post_id":"cj3kb1j1j001il73y3wcjizwq","tag_id":"cj3kb1j4m006fl73y5zu15xsd","_id":"cj3kb1j6600djl73yoxb3pcos"},{"post_id":"cj3kb1j1j001jl73yfvj5q872","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j6600dkl73yh5nhea2n"},{"post_id":"cj3kb1j1j001jl73yfvj5q872","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6600dll73ygm6hn2wq"},{"post_id":"cj3kb1j1k001kl73ymk75zmrt","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j6600dml73yiaw29b2o"},{"post_id":"cj3kb1j1k001kl73ymk75zmrt","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6600dnl73ymahcmigi"},{"post_id":"cj3kb1j1k001ll73y649a59wc","tag_id":"cj3kb1j33002xl73y4lqfvv81","_id":"cj3kb1j6600dol73y8uxsq41w"},{"post_id":"cj3kb1j1k001ll73y649a59wc","tag_id":"cj3kb1j3h003rl73y58ddli6y","_id":"cj3kb1j6600dpl73y2vb9lx1s"},{"post_id":"cj3kb1j1l001ml73yl2wu0tux","tag_id":"cj3kb1j2z002gl73yy2anqt1q","_id":"cj3kb1j6600dql73ydylszp2h"},{"post_id":"cj3kb1j1l001ml73yl2wu0tux","tag_id":"cj3kb1j3l0042l73yoow1eyp7","_id":"cj3kb1j6600drl73yxllxaw1i"},{"post_id":"cj3kb1j1l001nl73y6laxi1bh","tag_id":"cj3kb1j2z002gl73yy2anqt1q","_id":"cj3kb1j6600dsl73ywrm5pk6e"},{"post_id":"cj3kb1j1l001nl73y6laxi1bh","tag_id":"cj3kb1j4z007al73y4oyzwszs","_id":"cj3kb1j6600dtl73ypopgmwhf"},{"post_id":"cj3kb1j1m001ol73yhlkfy00r","tag_id":"cj3kb1j2z002gl73yy2anqt1q","_id":"cj3kb1j6600dul73ytqdns0hc"},{"post_id":"cj3kb1j1m001ol73yhlkfy00r","tag_id":"cj3kb1j32002sl73yj0jdnmtg","_id":"cj3kb1j6600dvl73ywqdv0cs7"},{"post_id":"cj3kb1j1m001ol73yhlkfy00r","tag_id":"cj3kb1j3l0042l73yoow1eyp7","_id":"cj3kb1j6600dwl73yy96mdguk"},{"post_id":"cj3kb1j1m001pl73yic29veyu","tag_id":"cj3kb1j30002kl73yw5k8rqqn","_id":"cj3kb1j6600dxl73yrneecsgt"},{"post_id":"cj3kb1j1m001pl73yic29veyu","tag_id":"cj3kb1j31002ml73yay7txjq2","_id":"cj3kb1j6600dyl73yjxcm6pyz"},{"post_id":"cj3kb1j1m001ql73y6g8d1jvx","tag_id":"cj3kb1j51007gl73yyf6bcyj2","_id":"cj3kb1j6600dzl73ywqpmkdbe"},{"post_id":"cj3kb1j1m001ql73y6g8d1jvx","tag_id":"cj3kb1j4i0062l73yezayk6mt","_id":"cj3kb1j6600e0l73yo4bgen7i"},{"post_id":"cj3kb1j1n001rl73yc38o0d1j","tag_id":"cj3kb1j2z002gl73yy2anqt1q","_id":"cj3kb1j6700e1l73yvb5xmqhx"},{"post_id":"cj3kb1j1n001rl73yc38o0d1j","tag_id":"cj3kb1j3l0042l73yoow1eyp7","_id":"cj3kb1j6700e2l73ygm40nem7"},{"post_id":"cj3kb1j1n001sl73y1j0mdfsh","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6700e3l73yhj7vmgu2"},{"post_id":"cj3kb1j1n001sl73y1j0mdfsh","tag_id":"cj3kb1j51007gl73yyf6bcyj2","_id":"cj3kb1j6700e4l73y2vxjz58l"},{"post_id":"cj3kb1j1n001sl73y1j0mdfsh","tag_id":"cj3kb1j52007ml73yd7z07w7h","_id":"cj3kb1j6700e5l73yk9ejerhk"},{"post_id":"cj3kb1j1n001tl73ygtvwxv65","tag_id":"cj3kb1j52007nl73yg7k2rpxw","_id":"cj3kb1j6700e6l73yc5tgzh2e"},{"post_id":"cj3kb1j1n001tl73ygtvwxv65","tag_id":"cj3kb1j53007ol73yqss3ygcu","_id":"cj3kb1j6700e7l73yuzze8g00"},{"post_id":"cj3kb1j1o001ul73y4m23nvnv","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6700e8l73yux5cnw8d"},{"post_id":"cj3kb1j1o001ul73y4m23nvnv","tag_id":"cj3kb1j51007gl73yyf6bcyj2","_id":"cj3kb1j6700e9l73y7cp038hd"},{"post_id":"cj3kb1j1o001ul73y4m23nvnv","tag_id":"cj3kb1j54007rl73ysa1zn52h","_id":"cj3kb1j6700eal73yxaakxu6c"},{"post_id":"cj3kb1j1p001vl73yf2f7nq1z","tag_id":"cj3kb1j52007nl73yg7k2rpxw","_id":"cj3kb1j6700ebl73yvp1fwqq1"},{"post_id":"cj3kb1j1p001wl73y3z9bv010","tag_id":"cj3kb1j52007nl73yg7k2rpxw","_id":"cj3kb1j6700ecl73yakfzybpy"},{"post_id":"cj3kb1j1p001wl73y3z9bv010","tag_id":"cj3kb1j2y002cl73y6lhdfrnq","_id":"cj3kb1j6700edl73y0981ip7f"},{"post_id":"cj3kb1j1p001wl73y3z9bv010","tag_id":"cj3kb1j2w002al73y4gs75qio","_id":"cj3kb1j6700eel73ye9midqoi"},{"post_id":"cj3kb1j1q001xl73y5h2id8ug","tag_id":"cj3kb1j52007nl73yg7k2rpxw","_id":"cj3kb1j6700efl73ydiay8ftp"},{"post_id":"cj3kb1j1q001xl73y5h2id8ug","tag_id":"cj3kb1j34002zl73yqibr30qn","_id":"cj3kb1j6700egl73y028czxht"},{"post_id":"cj3kb1j1q001yl73yf30t0nas","tag_id":"cj3kb1j3l0042l73yoow1eyp7","_id":"cj3kb1j6700ehl73yshbemkxi"},{"post_id":"cj3kb1j1q001yl73yf30t0nas","tag_id":"cj3kb1j2z002gl73yy2anqt1q","_id":"cj3kb1j6700eil73yyorwyqfq"},{"post_id":"cj3kb1j1q001yl73yf30t0nas","tag_id":"cj3kb1j32002sl73yj0jdnmtg","_id":"cj3kb1j6700ejl73yamr055t0"},{"post_id":"cj3kb1j1q001yl73yf30t0nas","tag_id":"cj3kb1j590081l73yk9b8r0rz","_id":"cj3kb1j6700ekl73yb3npsx3v"},{"post_id":"cj3kb1j1q001yl73yf30t0nas","tag_id":"cj3kb1j4i0062l73yezayk6mt","_id":"cj3kb1j6700ell73ybdkui11s"},{"post_id":"cj3kb1j1q001yl73yf30t0nas","tag_id":"cj3kb1j5a0083l73yemxiclrl","_id":"cj3kb1j6700eml73y31h3hym0"},{"post_id":"cj3kb1j1q001yl73yf30t0nas","tag_id":"cj3kb1j31002ol73ywlqv2bih","_id":"cj3kb1j6700enl73yuna2zzej"},{"post_id":"cj3kb1j1q001yl73yf30t0nas","tag_id":"cj3kb1j5a0085l73yedka6w0h","_id":"cj3kb1j6700eol73y6evww503"},{"post_id":"cj3kb1j1q001zl73yjmyqzfiw","tag_id":"cj3kb1j5a0086l73y242g1isp","_id":"cj3kb1j6700epl73ya1q9cobk"},{"post_id":"cj3kb1j1q001zl73yjmyqzfiw","tag_id":"cj3kb1j5b0087l73yar2hrnoh","_id":"cj3kb1j6700eql73y3tnxgj35"},{"post_id":"cj3kb1j1q001zl73yjmyqzfiw","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6700erl73ymdpydl1p"},{"post_id":"cj3kb1j1q0020l73y2j7ik520","tag_id":"cj3kb1j5b0087l73yar2hrnoh","_id":"cj3kb1j6700esl73ydg7vaw23"},{"post_id":"cj3kb1j1q0020l73y2j7ik520","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6700etl73yl23tlyly"},{"post_id":"cj3kb1j1q0020l73y2j7ik520","tag_id":"cj3kb1j5c008bl73y7wxh0v6s","_id":"cj3kb1j6700eul73yv64ljkjy"},{"post_id":"cj3kb1j1q0020l73y2j7ik520","tag_id":"cj3kb1j5c008cl73y792rwgd5","_id":"cj3kb1j6700evl73yueox1mjf"},{"post_id":"cj3kb1j1r0021l73yqroemt1o","tag_id":"cj3kb1j5c008cl73y792rwgd5","_id":"cj3kb1j6700ewl73yiof8kssx"},{"post_id":"cj3kb1j1r0021l73yqroemt1o","tag_id":"cj3kb1j5c008el73ytbzynvar","_id":"cj3kb1j6700exl73yn7vahmgp"},{"post_id":"cj3kb1j1r0021l73yqroemt1o","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6700eyl73ygg78e5ux"},{"post_id":"cj3kb1j1r0022l73ynlq66igf","tag_id":"cj3kb1j3l0040l73y1fkl8kzy","_id":"cj3kb1j6700ezl73y7i8qudhg"},{"post_id":"cj3kb1j1r0022l73ynlq66igf","tag_id":"cj3kb1j4i0062l73yezayk6mt","_id":"cj3kb1j6700f0l73y5gn6tidw"},{"post_id":"cj3kb1j1r0023l73yhf8us2sm","tag_id":"cj3kb1j3n0048l73yf6yjtkb6","_id":"cj3kb1j6700f1l73ykdtti0f7"},{"post_id":"cj3kb1j1r0023l73yhf8us2sm","tag_id":"cj3kb1j5f008jl73yqz7mcnzd","_id":"cj3kb1j6800f2l73yf8zxhs43"},{"post_id":"cj3kb1j1s0024l73ygrinozsz","tag_id":"cj3kb1j4i0062l73yezayk6mt","_id":"cj3kb1j6800f3l73y8ble7jhl"},{"post_id":"cj3kb1j1s0024l73ygrinozsz","tag_id":"cj3kb1j5f008ll73yexinfzhm","_id":"cj3kb1j6800f4l73y5rg2md9s"},{"post_id":"cj3kb1j1s0025l73yf9o44zfc","tag_id":"cj3kb1j3l0040l73y1fkl8kzy","_id":"cj3kb1j6800f5l73yrqgq2pvt"},{"post_id":"cj3kb1j1s0025l73yf9o44zfc","tag_id":"cj3kb1j5g008nl73y8ovwfvkh","_id":"cj3kb1j6800f6l73yjihtcacd"},{"post_id":"cj3kb1j1s0025l73yf9o44zfc","tag_id":"cj3kb1j4m006fl73y5zu15xsd","_id":"cj3kb1j6800f7l73yclallnd6"},{"post_id":"cj3kb1j1s0026l73yye8m2he2","tag_id":"cj3kb1j5g008pl73y2mmafzgu","_id":"cj3kb1j6800f8l73yzmv5rpyf"}],"Tag":[{"name":"Gimp","_id":"cj3kb1j2t0028l73y3ermvdky"},{"name":"Blog","_id":"cj3kb1j2w002al73y4gs75qio"},{"name":"Hexo","_id":"cj3kb1j2y002cl73y6lhdfrnq"},{"name":"Travel","_id":"cj3kb1j2z002el73yi8txomsb"},{"name":"C","_id":"cj3kb1j2z002gl73yy2anqt1q"},{"name":"Memory","_id":"cj3kb1j30002il73yd36p57xe"},{"name":"Vim","_id":"cj3kb1j30002kl73yw5k8rqqn"},{"name":"Plugin","_id":"cj3kb1j31002ml73yay7txjq2"},{"name":"OS","_id":"cj3kb1j31002ol73ywlqv2bih"},{"name":"C++","_id":"cj3kb1j32002sl73yj0jdnmtg"},{"name":"Ubuntu","_id":"cj3kb1j33002xl73y4lqfvv81"},{"name":"Software","_id":"cj3kb1j34002zl73yqibr30qn"},{"name":"GCC","_id":"cj3kb1j350033l73y00woe3va"},{"name":"Compile","_id":"cj3kb1j360035l73yiw5qse1n"},{"name":"Assemble","_id":"cj3kb1j370037l73ybo8tcx9y"},{"name":"Link","_id":"cj3kb1j380039l73yydnl164b"},{"name":"Batch","_id":"cj3kb1j39003bl73ytk4xs54i"},{"name":"Shell","_id":"cj3kb1j3h003rl73y58ddli6y"},{"name":"ACM","_id":"cj3kb1j3l0040l73y1fkl8kzy"},{"name":"Coding","_id":"cj3kb1j3l0042l73yoow1eyp7"},{"name":"Python","_id":"cj3kb1j3n0048l73yf6yjtkb6"},{"name":"Google","_id":"cj3kb1j3o004al73ynnij1i3l"},{"name":"OPS","_id":"cj3kb1j46005ql73yv6t6nhgh"},{"name":"Git","_id":"cj3kb1j47005sl73y91kehhz7"},{"name":"Markdown","_id":"cj3kb1j4e005wl73yi4u1ozxl"},{"name":"Algorithm","_id":"cj3kb1j4i0062l73yezayk6mt"},{"name":"HiHoCoder","_id":"cj3kb1j4m006cl73yau9362qn"},{"name":"Report","_id":"cj3kb1j4m006fl73y5zu15xsd"},{"name":"LeetCode","_id":"cj3kb1j4w006zl73y2jvb1ub1"},{"name":"Interview","_id":"cj3kb1j4z007al73y4oyzwszs"},{"name":"ML","_id":"cj3kb1j51007gl73yyf6bcyj2"},{"name":"Numpy","_id":"cj3kb1j52007ml73yd7z07w7h"},{"name":"Mac","_id":"cj3kb1j52007nl73yg7k2rpxw"},{"name":"OSX","_id":"cj3kb1j53007ol73yqss3ygcu"},{"name":"Plt","_id":"cj3kb1j54007rl73ysa1zn52h"},{"name":"Java","_id":"cj3kb1j590081l73yk9b8r0rz"},{"name":"Network","_id":"cj3kb1j5a0083l73yemxiclrl"},{"name":"Linux","_id":"cj3kb1j5a0085l73yedka6w0h"},{"name":"Cloud","_id":"cj3kb1j5a0086l73y242g1isp"},{"name":"Nginx","_id":"cj3kb1j5b0087l73yar2hrnoh"},{"name":"Django","_id":"cj3kb1j5c008bl73y7wxh0v6s"},{"name":"Flask","_id":"cj3kb1j5c008cl73y792rwgd5"},{"name":"restful","_id":"cj3kb1j5c008el73ytbzynvar"},{"name":"Web","_id":"cj3kb1j5f008jl73yqz7mcnzd"},{"name":"Research","_id":"cj3kb1j5f008ll73yexinfzhm"},{"name":"USACO","_id":"cj3kb1j5g008nl73y8ovwfvkh"},{"name":"tag","_id":"cj3kb1j5g008pl73y2mmafzgu"}]}}